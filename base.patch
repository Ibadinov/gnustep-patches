diff --git a/.gitignore b/.gitignore
new file mode 100644
index 0000000..b03a3c5
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1,2 @@
+*.xcodeproj/*
+!*.xcodeproj/*.pbxproj
diff --git a/ChangeLog b/ChangeLog
index ad55995..fb46f81 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -586,12 +586,131 @@
         was annoying when they were called on NSMutableCharacterSet.
         It seems they finally changed to returning id, so we can do the same.
 
+2012-10-12  Marat Ibadinov <ibadinov@me.com>
+
+        * Headers/GNUstepBase/GSVersionMacros.h
+        * Source/GSPrivate.h
+        Commented (visibility("internal")) out of declarations of functions
+        defined in "Additions" subproject. Can't explain in detail, but this
+        doesn't work well with dyld.
+        
 2012-10-12  Richard Frith-Macdonald <rfm@gnu.org>
 
         * Headers/GNUstepBase/NSDebug+GNUstepBase.h:
         Fix format of logs produced by two of the three method macros ...
         a bug spotted by Fred.
 
+2012-10-11  Marat Ibadinov <ibadinov@me.com>
+
+        * Headers/Foundation/NSString.h
+        * Source/GSString.m
+        * Source/NSProcessInfo.m
+        Constant strings work on OSX again.
+        
+2012-10-11  Marat Ibadinov <ibadinov@me.com>
+
+        * Headers/Foundation/NSArray.h
+        * Headers/Foundation/NSAutoreleasePool.h
+        * Headers/Foundation/NSBundle.h
+        * Headers/Foundation/NSCoder.h
+        * Headers/Foundation/NSComparisonPredicate.h
+        * Headers/Foundation/NSCompoundPredicate.h
+        * Headers/Foundation/NSConnection.h
+        * Headers/Foundation/NSData.h
+        * Headers/Foundation/NSDate.h
+        * Headers/Foundation/NSDictionary.h
+        * Headers/Foundation/NSError.h
+        * Headers/Foundation/NSException.h
+        * Headers/Foundation/NSExpression.h
+        * Headers/Foundation/NSHTTPCookie.h
+        * Headers/Foundation/NSHTTPCookieStorage.h
+        * Headers/Foundation/NSIndexPath.h
+        * Headers/Foundation/NSIndexSet.h
+        * Headers/Foundation/NSInvocation.h
+        * Headers/Foundation/NSKeyValueObserving.h
+        * Headers/Foundation/NSLock.h
+        * Headers/Foundation/NSNetServices.h
+        * Headers/Foundation/NSObjCRuntime.h
+        * Headers/Foundation/NSOperation.h
+        * Headers/Foundation/NSPathUtilities.h
+        * Headers/Foundation/NSPointerArray.h
+        * Headers/Foundation/NSPointerFunctions.h
+        * Headers/Foundation/NSPredicate.h
+        * Headers/Foundation/NSProcessInfo.h
+        * Headers/Foundation/NSPropertyList.h
+        * Headers/Foundation/NSScanner.h
+        * Headers/Foundation/NSSet.h
+        * Headers/Foundation/NSSortDescriptor.h
+        * Headers/Foundation/NSSpellServer.h
+        * Headers/Foundation/NSStream.h
+        * Headers/Foundation/NSString.h
+        * Headers/Foundation/NSThread.h
+        * Headers/Foundation/NSTimeZone.h
+        * Headers/Foundation/NSTimer.h
+        * Headers/Foundation/NSURL.h
+        * Headers/Foundation/NSURLCache.h
+        * Headers/Foundation/NSURLConnection.h
+        * Headers/Foundation/NSURLCredential.h
+        * Headers/Foundation/NSURLCredentialStorage.h
+        * Headers/Foundation/NSURLDownload.h
+        * Headers/Foundation/NSURLError.h
+        * Headers/Foundation/NSURLProtectionSpace.h
+        * Headers/Foundation/NSURLProtocol.h
+        * Headers/Foundation/NSURLRequest.h
+        * Headers/Foundation/NSURLResponse.h
+        * Headers/Foundation/NSValueTransformer.h
+        * Headers/Foundation/NSXMLElement.h
+        * Headers/Foundation/NSXMLParser.h
+        * Headers/GNUstepBase/GSVersionMacros.h
+        * Source/NSNetServices.m
+        Replaced hard-coded API versions with version macros. Commented out 
+        those of them I don't know how to define symbolically (e.g. 11501) and
+        labeled comments "FIXDEF!". This was necessary because of version-number
+        mismatch between OSX and GNUstep. Also made some OSX-related fixes in
+        GSVersionMacros.h.
+
+2012-10-11  Marat Ibadinov <ibadinov@me.com>
+
+        * Source/Additions/NSObject+GNUstepBase.m
+        * Source/GSBlocks.m
+        * Source/GSInvocation.h
+        * Source/NSKeyValueMutableSet.m
+        * Source/NSKeyedUnarchiver.m
+        * Source/NSNotificationCenter.m
+        * Source/objc-load.m
+        Introduced some "fixes" necessary to compile on OSX.
+        Currently GSPrivateLoadModule() is no-op when using non-fragile ABI.
+
+2012-10-11  Marat Ibadinov <ibadinov@me.com>
+
+        * Headers/GNUstepBase/GSObjCRuntime.h
+        * Source/Additions/GSObjCRuntime.m
+        * Source/NSArchiver.m
+        * Source/NSCoder.m
+        * Source/NSConnection.m
+        * Source/NSData.m
+        * Source/NSMethodSignature.m
+        * Source/NSObjCRuntime.m
+        * Source/NSObject.m
+        * Source/NSPortCoder.m
+        * Source/NSProxy.m
+        * Source/NSUnarchiver.m
+        * Source/cifframe.m
+        Reimplemented type demangling from scratch using single sequential 
+        parser that emits events for it's delegate. Emulated legacy API using
+        it. Made some fixes necessary to work on OSX. Corrected copy-paste
+        error in ChangeLog.
+
+2012-10-11  Marat Ibadinov <ibadinov@me.com>
+
+        * config/config.constant-string-class.m:
+        * configure.ac:
+        * configure:
+        Detects constant string support on Apple's compilers.
+        No unnecessary whining about uncaught exception handler.
+        Undefines __strong and __weak before redefinition.
+        Still does not detect MDNS correctly.
+
 2012-10-03  Richard Frith-Macdonald <rfm@gnu.org>
 
         * Source/GSFormat.m: for C-string formatting, avoid reading to the
diff --git a/Headers/Foundation/MISSING b/Headers/Foundation/MISSING
new file mode 100644
index 0000000..5c4ac7b
--- /dev/null
+++ b/Headers/Foundation/MISSING
@@ -0,0 +1,1023 @@
+Missing macros:
+	NS_ENUM
+	NS_OPTIONS
+	NS_AVAILABLE
+	NS_RETURNS_INNER_POINTER
+	NS_ENUM_AVAILABLE
+	NS_BLOCKS_AVAILABLE
+	NS_CLASS_AVAILABLE
+	NS_AVAILABLE_MAC
+	NS_ENUM_AVAILABLE_IOS
+	NS_DEPRECATED
+	NS_UNAVAILABLE
+	NS_AUTOMATED_REFCOUNT_WEAK_UNAVAILABLE
+	NS_AVAILABLE_IOS
+
+Missing headers:
+	<NSAppleEventDescriptor.h>
+	<NSAppleEventManager.h>
+	<NSAppleScript.h>
+	<NSByteCountFormatter.h>
+	<NSFileCoordinator.h>
+	<NSFilePresenter.h>
+	<NSFileVersion.h>
+	<NSFileWrapper.h>
+	<NSHFSFileTypes.h>
+	<NSLinguisticTagger.h>
+	<NSObjectScripting.h>
+	<NSOrderedSet.h>
+	<NSOrthography.h>
+	<NSScriptClassDescription.h>
+	<NSScriptCoercionHandler.h>
+	<NSScriptCommand.h>
+	<NSScriptCommandDescription.h>
+	<NSScriptExecutionContext.h>
+	<NSScriptKeyValueCoding.h>
+	<NSScriptObjectSpecifiers.h>
+	<NSScriptStandardSuiteCommands.h>
+	<NSScriptSuiteRegistry.h>>
+	<NSUbiquitousKeyValueStore.h>
+	<NSUserNotification.h>
+	<NSUserScriptTask.h>
+	<NSUUID.h>
+	<NSXPCConnection.h>
+-------------------------------------------------------------
+Foundation:
+	<NSOrderedSet.h>
+	<NSOrthography.h>
+	<NSPort.h>
+	<NSPropertyList.h>
+	<NSRegularExpression.h>
+	<NSTextCheckingResult.h>
+	<NSByteCountFormatter.h>
+	<NSFileCoordinator.h>
+	<NSFilePresenter.h>
+	<NSFileVersion.h>
+	<NSFileWrapper.h>
+	<NSLinguisticTagger.h>
+	<NSUbiquitousKeyValueStore.h>
+	<NSUUID.h>
+	<NSAppleEventDescriptor.h>
+	<NSAppleEventManager.h>
+	<NSAppleScript.h>
+	<NSHFSFileTypes.h>
+	<NSObjectScripting.h>
+	<NSScriptClassDescription.h>
+	<NSScriptCoercionHandler.h>
+	<NSScriptCommand.h>
+	<NSScriptCommandDescription.h>
+	<NSScriptExecutionContext.h>
+	<NSScriptKeyValueCoding.h>
+	<NSScriptObjectSpecifiers.h>
+	<NSScriptStandardSuiteCommands.h>
+	<NSScriptSuiteRegistry.h>
+	<NSUserNotification.h>
+	<NSUserScriptTask.h>
+	<NSXPCConnection.h>
+-------------------------------------------------------------
+FoundationErrors:
+	NSFileWriteFileExistsError
+	NSFileWriteVolumeReadOnlyError
+	NSFeatureUnsupportedError
+	NSPropertyListReadCorruptError
+    NSPropertyListReadUnknownVersionError
+    NSPropertyListReadStreamError
+    NSPropertyListWriteStreamError
+    NSPropertyListErrorMinimum
+    NSPropertyListErrorMaximum
+    NSXPCConnectionInterrupted
+    NSXPCConnectionInvalid
+    NSXPCConnectionReplyInvalid
+    NSXPCConnectionErrorMinimum
+    NSXPCConnectionErrorMaximum
+-------------------------------------------------------------
+NSArchiver:
+	- encodeRootObject:
+	- encodeConditionalObject:
+-------------------------------------------------------------
+NSAttributedString:
+	NSAttributedStringEnumerationReverse
+  	NSAttributedStringEnumerationLongestEffectiveRangeNotRequired
+
+  	- enumerateAttributesInRange:options:usingBlock:
+	- enumerateAttribute:inRange:options:usingBlock:
+-------------------------------------------------------------
+NSBundle:
+	- bundleURL
+	- resourceURL
+	- executableURL
+	- URLForAuxiliaryExecutable:
+	- privateFrameworksURL
+	- sharedFrameworksURL
+	- sharedSupportURL
+	- builtInPlugInsURL
+	- appStoreReceiptURL
+	- pathForAuxiliaryExecutable:
+	- privateFrameworksPath
+	- sharedFrameworksPath
+	- sharedSupportPath
+	+ URLsForResourcesWithExtension:subdirectory:inBundleWithURL:
+	- URLsForResourcesWithExtension:subdirectory:
+	- URLsForResourcesWithExtension:subdirectory:localization:
+
+	/** Not implemented */ (GNUstep comment)
+	- executableArchitectures;
+-------------------------------------------------------------
+NSByteOrder:
+	NSSwappedFloat — incompatible declaration
+	NSSwappedDouble — incompatible declaration
+-------------------------------------------------------------
+NSCalendar:
+	NSWeekOfMonthCalendarUnit
+	NSWeekOfYearCalendarUnit
+	NSYearForWeekOfYearCalendarUnit
+    NSCalendarCalendarUnit
+    NSTimeZoneCalendarUnit
+
+    - weekOfMonth
+	- weekOfYear
+	- yearForWeekOfYear
+	- isLeapMonth
+	- setWeekOfMonth:
+	- setWeekOfYear:
+	- setYearForWeekOfYear:
+	- setLeapMonth:
+	- date
+-------------------------------------------------------------
+NSCharacterSet:
+	NSOpenStepUnicodeReservedBase
+-------------------------------------------------------------
+NSCoder:
+	- requiresSecureCoding
+	- decodeObjectOfClass:forKey:
+	- decodeObjectOfClasses:forKey:
+	- decodePropertyListForKey:
+	- allowedClasses
+	- encodeNXObject:
+	- decodeNXObject:
+-------------------------------------------------------------
+NSComparisonPredicate:
+	NSNormalizedPredicateOption
+-------------------------------------------------------------
+NSConnection:
+	<NSDate.h>
+
+	- dispatchWithComponents:
+	- connection:shouldMakeNewConnection:
+	- createConversationForConnection:
+	- connection:handleRequest:
+	- invocation
+	- connection
+	- conversation
+	- replyWithException
+-------------------------------------------------------------
+NSData:
+	NSDataReadingMappedIfSafe
+    NSDataReadingUncached
+    NSDataReadingMappedAlways
+    NSDataWritingAtomic
+    NSDataWritingWithoutOverwriting
+    NSDataWritingFileProtectionNone
+    NSDataWritingFileProtectionComplete
+    NSDataWritingFileProtectionCompleteUnlessOpen
+    NSDataWritingFileProtectionCompleteUntilFirstUserAuthentication
+    NSDataWritingFileProtectionMask
+    NSDataSearchBackwards
+    NSDataSearchAnchored
+
+    - rangeOfData:options:range:
+    + dataWithContentsOfFile:options:error:
+	+ dataWithContentsOfURL:options:error:
+	- initWithContentsOfFile:options:error:
+	- initWithContentsOfURL:options:error:
+
+	@inteface NSPurgeableData
+-------------------------------------------------------------
+NSDate:
+	NSSystemClockDidChangeNotification
+-------------------------------------------------------------
+NSDebug:
+	<NSAutoreleasePool.h>
+
+	NSObjectAutoreleasedEvent
+	NSObjectExtraRefIncrementedEvent
+	NSObjectExtraRefDecrementedEvent
+	NSObjectInternalRefIncrementedEvent
+	NSObjectInternalRefDecrementedEvent
+	
+	NSDebugEnabled
+	NSKeepAllocationStatistics
+
+	NSIsFreedObject()
+	NSRecordAllocationEvent()
+
+	@interface NSAutoreleasePool (NSAutoreleasePoolDebugging)
+-------------------------------------------------------------
+NSDecimal:
+	NSDecimal — incompatible declaration
+-------------------------------------------------------------
+NSDecimalNumber:
+	<NSScanner.h>
+
+	NSDecimalNumberExactnessException
+	NSDecimalNumberOverflowException
+	NSDecimalNumberUnderflowException
+	NSDecimalNumberDivideByZeroException
+
+	@interface NSScanner (NSDecimalNumberScanning)
+-------------------------------------------------------------
+NSDictionary:
+	- keysSortedByValueUsingComparator:
+	- keysSortedByValueWithOptions:usingComparator:
+	+ dictionaryWithObjects:forKeys:(const id <NSCopying> [])keys count:
+	- initWithObjects:forKeys:(const id <NSCopying> [])keys count:
+
+	@interface NSDictionary (NSSharedKeySetDictionary)
+	@interface NSMutableDictionary (NSSharedKeySetDictionary)
+-------------------------------------------------------------
+NSDistributedNotificationCenter:
+	NSNotificationDeliverImmediately
+    NSNotificationPostToAllSessions
+
+	- postNotificationName:object:userInfo:options:
+-------------------------------------------------------------
+NSError:
+	NSHelpAnchorErrorKey
+
+	- helpAnchor
+-------------------------------------------------------------
+NSException:
+	@class NSAssertionHandler
+-------------------------------------------------------------
+NSExpression:
+	@class NSPredicate
+
+	NSUnionSetExpressionType
+    NSIntersectSetExpressionType
+    NSMinusSetExpressionType
+    NSSubqueryExpressionType
+    NSAggregateExpressionType
+
+    + expressionWithFormat:argumentArray:
+	+ expressionWithFormat:
+	+ expressionWithFormat:arguments:
+	+ expressionForAggregate:
+	+ expressionForUnionSet:with:
+	+ expressionForIntersectSet:with
+	+ expressionForMinusSet:with:
+	+ expressionForSubquery:usingIteratorVariable:predicate:
+	+ expressionForFunction:selectorName:arguments:
+	+ expressionForBlock:arguments:	
+	- collection
+	- predicate
+	- leftExpression
+	- rightExpression
+	- expressionBlock
+-------------------------------------------------------------
+NSFileHandler:
+	<NSArray.h>
+
+	@class NSError
+
+	+ fileHandleForReadingFromURL:error:
+	+ fileHandleForWritingToURL:error:
+	+ fileHandleForUpdatingURL:error:
+
+	@property (copy) void (^readabilityHandler)(NSFileHandle *)
+	@property (copy) void (^writeabilityHandler)(NSFileHandle *)
+-------------------------------------------------------------
+NSFileManager:
+	<NSPathUtilities.h>
+
+	NSUbiquityIdentityDidChangeNotification
+
+	@protocol NSFileManagerDelegate
+
+	typedef NSVolumeEnumerationOptions
+	typedef NSDirectoryEnumerationOptions
+	typedef NSFileManagerItemReplacementOptions
+
+	- mountedVolumeURLsIncludingResourceValuesForKeys:options:
+	- contentsOfDirectoryAtURL:includingPropertiesForKeys:options:error:
+	- URLsForDirectory:inDomains:
+	- URLForDirectory:inDomain:appropriateForURL:create:error:
+	- createDirectoryAtURL:withIntermediateDirectories:attributes:error:
+	- createSymbolicLinkAtURL:withDestinationURL:error:
+	- setDelegate:
+	- delegate
+	- setAttributes:ofItemAtPath:error:
+	- subpathsOfDirectoryAtPath:error:
+	- attributesOfFileSystemForPath:error:
+	- createSymbolicLinkAtPath:withDestinationPath:error:
+	- destinationOfSymbolicLinkAtPath:error:
+	- linkItemAtPath:toPath:error:
+	- copyItemAtURL:toURL:error:
+	- moveItemAtURL:toURL:error:
+	- linkItemAtURL:toURL:error:
+	- removeItemAtURL:error:
+	- trashItemAtURL:resultingItemURL:error:
+	- enumeratorAtURL:includingPropertiesForKeys:options:errorHandler:
+	- (__strong const char *)fileSystemRepresentationWithPath:
+	- replaceItemAtURL:withItemAtURL:backupItemName:options:resultingItemURL:error:
+	- setUbiquitous:itemAtURL:destinationURL:error:
+	- isUbiquitousItemAtURL:
+	- startDownloadingUbiquitousItemAtURL:error:
+	- evictUbiquitousItemAtURL:error:
+	- URLForUbiquityContainerIdentifier:
+	- URLForPublishingUbiquitousItemAtURL:expirationDate:error:
+	- ubiquityIdentityToken
+	- level
+	- skipDescendants //not skipDescendents (sic!)
+
+	@protocol NSFileManagerDelegate <NSObject>
+
+	NSFileBusy
+	NSFileProtectionKey
+	NSFileProtectionNone
+	NSFileProtectionComplete
+	NSFileProtectionCompleteUnlessOpen
+	NSFileProtectionCompleteUntilFirstUserAuthentication 
+-------------------------------------------------------------
+NSGeometry:
+	<AvailabilityMacros.h>
+	<Foundation/NSValue.h>
+	<Foundation/NSCoder.h>
+
+	incompatible NSRectEdge
+	NSAlignmentOptions
+
+	@class NSString
+
+	NSRectFromCGRect()
+	NSRectToCGRect()
+	NSPointFromCGPoint()
+	NSPointToCGPoint()
+	NSSizeFromCGSize()
+	NSSizeToCGSize()
+	NSIntegralRectWithOptions()
+
+	@interface NSValue (NSValueGeometryExtensions)
+	@interface NSCoder (NSGeometryCoding)
+	@interface NSCoder (NSGeometryKeyedCoding)
+-------------------------------------------------------------
+NSHashTable:
+	incompatible NSHashEnumerator
+
+	NSOwnedObjectIdentityHashCallBacks
+-------------------------------------------------------------
+NSHost:
+	@class NSMutableArray
+
+	- localizedName
+-------------------------------------------------------------
+NSHTTPCookie:
+	@class NSHTTPCookieInternal;
+
+	- isHTTPOnly
+-------------------------------------------------------------
+NSHTTPCookieStorage:
+	@class NSHTTPCookieStorageInternal
+
+	- sortedCookiesUsingDescriptors:
+-------------------------------------------------------------
+NSIndexSet:
+	- indexPassingTest:
+	- indexWithOptions:passingTest:
+	- indexInRange:options:passingTest
+	- indexesPassingTest:
+	- indexesWithOptions:passingTest:
+	- indexesInRange:options:passingTest:
+	- enumerateRangesUsingBlock:
+	- enumerateRangesWithOptions:usingBlock:
+	- enumerateRangesInRange:options:usingBlock:
+-------------------------------------------------------------
+NSInvocation:
+	<stdbool.h>
+
+	enum _NSObjCValueType
+	typedef struct NSObjCValue
+-------------------------------------------------------------
+NSKeyedArchiver:
+	<NSGeometry.h>
+
+	+ classFallbacksForKeyedArchiver
+-------------------------------------------------------------
+NSKeyValueCoding:
+	<NSArray.h>
+	<NSDictionary.h>
+	<NSOrderedSet.h>
+	<NSSet.h>
+
+	NSAverageKeyValueOperator
+	NSCountKeyValueOperator
+	NSDistinctUnionOfArraysKeyValueOperator
+	NSDistinctUnionOfObjectsKeyValueOperator
+	NSDistinctUnionOfSetsKeyValueOperator
+	NSMaximumKeyValueOperator
+	NSMinimumKeyValueOperator
+	NSSumKeyValueOperator
+	NSUnionOfArraysKeyValueOperator
+	NSUnionOfObjectsKeyValueOperator
+	NSUnionOfSetsKeyValueOperator
+
+	- mutableOrderedSetValueForKey:
+	- mutableOrderedSetValueForKeyPath:
+
+	@interface NSArray(NSKeyValueCoding)
+	@interface NSDictionary(NSKeyValueCoding)
+	@interface NSMutableDictionary(NSKeyValueCoding)
+	@interface NSOrderedSet(NSKeyValueCoding)
+	@interface NSSet(NSKeyValueCoding)
+	@interface NSObject(NSDeprecatedKeyValueCoding)
+-------------------------------------------------------------
+NSKeyValueObserving:
+	<NSSet.h>
+
+	- removeObserver:forKeyPath:context:
+	- removeObserver:fromObjectsAtIndexes:forKeyPath:context:
+	+ keyPathsForValuesAffectingValueForKey:
+-------------------------------------------------------------
+NSLocale:
+	@class NSDictionary
+-------------------------------------------------------------
+NSMapTable:
+	@class NSArray, NSDictionary, NSMapTable
+
+	incompatible NSMapEnumerator
+
+	NSFreeMapTable()
+	NSResetMapTable()
+	NSCompareMapTables()
+	*NSCopyMapTableWithZone()
+	NSMapMember()
+	*NSMapGet()
+	NSMapInsert()
+	NSMapInsertKnownAbsent()
+	*NSMapInsertIfAbsent()
+	NSMapRemove()
+	NSEnumerateMapTable()
+	NSNextMapEnumeratorPair()
+	NSEndMapTableEnumeration()
+	NSCountMapTable()
+	*NSStringFromMapTable()
+	*NSAllMapTableKeys()
+	*NSAllMapTableValues()
+-------------------------------------------------------------
+NSMetadata:
+	@class NSArray, NSMetadataItem, NSMetadataQueryAttributeValueTuple, NSMetadataQueryResultGroup
+
+	NSMetadataQueryResultContentRelevanceAttribute
+	NSMetadataItemIsUbiquitousKey
+	NSMetadataUbiquitousItemHasUnresolvedConflictsKey
+	NSMetadataUbiquitousItemIsDownloadedKey
+	NSMetadataUbiquitousItemIsDownloadingKey
+	NSMetadataUbiquitousItemIsUploadedKey
+	NSMetadataUbiquitousItemIsUploadingKey
+	NSMetadataUbiquitousItemPercentDownloadedKey
+	NSMetadataUbiquitousItemPercentUploadedKey
+-------------------------------------------------------------
+NSNetServices:
+	<NSDate.h>
+
+	@class NSArray, NSData, NSDictionary, NSString
+-------------------------------------------------------------
+NSNotification:
+	@class NSOperationQueue
+
+	- addObserverForName:queue:usingBlock:
+-------------------------------------------------------------
+NSNumberFormatter:
+	@class NSMutableDictionary
+-------------------------------------------------------------
+NSObjCRuntime:
+	#include <TargetConditionals.h>
+	#include <AvailabilityMacros.h>
+	#include <Availability.h>
+-------------------------------------------------------------
+NSObject:
+	@class NSEnumerator
+
+	- debugDescription
+
+	@protocol NSSecureCoding <NSCoding>
+
+	- allowsWeakReference
+	- retainWeakReference
+-------------------------------------------------------------
+NSOperation:
+	@class NSArray, NSSet
+
+	@interface NSBlockOperation : NSOperation
+	@interface NSInvocationOperation : NSOperation
+
+	NSInvocationOperationVoidResultException
+	NSInvocationOperationCancelledException
+
+	- addOperationWithBlock:
+-------------------------------------------------------------
+NSPathUtilities:
+	(interfaces reside in NSString.h and NSArray.h)
+
+	typedef NS_ENUM(NSUInteger, NSSearchPathDirectory)
+-------------------------------------------------------------
+NSPointerFunctions:
+	#include <Foundation/NSPointerFunctionsPriv.h>
+-------------------------------------------------------------
+NSPort:
+	@class NSData
+	@protocol NSPortDelegate, NSMachPortDelegate
+
+	- scheduleInRunLoop:forMode:
+	- removeFromRunLoop:forMode:
+
+	NSMachPortDeallocateNone
+	NSMachPortDeallocateSendRight
+	NSMachPortDeallocateReceiveRight
+
+	+ portWithMachPort:options:
+	- initWithMachPort:options:
+
+	@interface NSSocketPort : NSPort
+-------------------------------------------------------------
+NSPortNameServer:
+	- portForName:host:
+	- registerPort:name:
+	- servicePortWithName:
+
+	- portForName:host:nameServerPortNumber:
+	- registerPort:name:nameServerPortNumber:
+	- setDefaultNameServerPortNumber:
+	- defaultNameServerPortNumber
+-------------------------------------------------------------
+NSPredicate:
+	+ predicateWithBlock:
+	- evaluateWithObject:substitutionVariables:
+-------------------------------------------------------------
+NSProcessInfo:
+	@class NSString
+
+	- disableSuddenTermination
+	- enableSuddenTermination
+	- disableAutomaticTermination:
+	- enableAutomaticTermination:
+	-  setAutomaticTerminationSupportEnabled:
+	-  automaticTerminationSupportEnabled
+-------------------------------------------------------------
+NSPropertyList:
+	@class NSError
+-------------------------------------------------------------
+NSProxy:
+	@class NSMethodSignature, NSInvocation
+
+	- finalize
+	- debugDescription
+	- allowsWeakReference
+	- retainWeakReference
+-------------------------------------------------------------
+NSRange:
+	<Foundation/NSValue.h>
+	<NSObjCRuntime.h>
+
+	@class NSString
+
+	@inteface NSValue (NSValueRangeException)
+-------------------------------------------------------------
+NSRegularExpression:
+	<NSString.h>
+	<NSTextCheckingResult.h>
+
+	@class NSArray
+
+	+ escapedPatternForString:
+	+ escapedTemplateForString:
+
+	@interface NSDataDetector : NSRegularExpression
+-------------------------------------------------------------
+NSRunLoop:
+	<NSDate.h>
+
+	NSRunLoopCommonModes
+
+	+ mainRunLoop
+	- getCFRunLoop
+
+	@interface NSObject (NSDelayedPerforming)
+-------------------------------------------------------------
+NSScanner:
+	@class NSString
+-------------------------------------------------------------
+NSScriptWhoseTests:
+	@class NSArray, NSScriptObjectSpecifier, NSString
+
+	typedef NSTestComparisonOperation
+
+	@interface NSScriptWhoseTest : NSObject
+	@interface NSLogicalTest : NSScriptWhoseTest
+	@interface NSSpecifierTest : NSScriptWhoseTest
+	@interface NSObject (NSScriptingComparisonMethods)
+-------------------------------------------------------------
+NSSortDescriptor:
+	<NSSet.h>
+
+	+ sortDescriptorWithKey:ascending:comparator:
+	- initWithKey:ascending:comparator:
+	- comparator
+-------------------------------------------------------------
+NSSpellServer:
+	<NSTextCheckingResult.h>
+
+	@class NSArray, NSOrthography
+
+	- spellServer:checkString:offset:types:options:orthography:wordCount:
+	- spellServer:recordResponse:toCorrection:forWord:language:
+-------------------------------------------------------------
+NSStream:
+	- initWithURL:
+	+ inputStreamWithURL:
+	- initWithURL:append:
+	+ outputStreamWithURL:append:
+
+	NSStreamNetworkServiceType
+	NSStreamNetworkServiceTypeVoIP
+	NSStreamNetworkServiceTypeVideo
+	NSStreamNetworkServiceTypeBackground
+	NSStreamNetworkServiceTypeVoice
+-------------------------------------------------------------
+NSString:
+	NSParseErrorException
+	NSCharacterConversionException
+	NSStringEnumerationOptions
+
+	- localizedStandardCompare:
+	- uppercaseStringWithLocale:
+	- lowercaseStringWithLocale:
+	- capitalizedStringWithLocale:
+	- enumerateSubstringsInRange:options:usingBlock:
+	- enumerateLinesUsingBlock:
+	- getBytes:maxLength:usedLength:encoding:options:range:remainingRange:
+	- decomposedStringWithCanonicalMapping
+	- precomposedStringWithCanonicalMapping
+	- decomposedStringWithCompatibilityMapping
+	- precomposedStringWithCompatibilityMapping
+	- stringByFoldingWithOptions:locale:
+
+	- (__strong const char *)cStringUsingEncoding:(NSStringEncoding)encoding NS_RETURNS_INNER_POINTER;
+	- (__strong const char *)UTF8String NS_RETURNS_INNER_POINTER;
+-------------------------------------------------------------
+NSTask:
+	- init
+	- terminationReason
+
+	@property (copy) void (^terminationHandler)(NSTask *)
+-------------------------------------------------------------
+NSTextCheckingResult:
+	<NSRange.h>
+	<NSDate.h>
+
+	typedef NSTextCheckingType
+	typedef NSTextCheckingTypes
+
+	NSTextCheckingNameKey
+	NSTextCheckingJobTitleKey
+	NSTextCheckingOrganizationKey
+	NSTextCheckingStreetKey
+	NSTextCheckingCityKey
+	NSTextCheckingStateKey
+	NSTextCheckingZIPKey
+	NSTextCheckingCountryKey
+	NSTextCheckingPhoneKey
+	NSTextCheckingAirlineKey
+	NSTextCheckingFlightKey
+
+	@interface NSTextCheckingResult (NSTextCheckingResultCreation)
+-------------------------------------------------------------
+NSThread:
+	<NSDate.h>
+
+	+ (BOOL)setThreadPriority:
+	- threadPriority NS_AVAILABLE(10_6, 4_0);
+	- setThreadPriority:
+	+ callStackSymbols
+
+	NSDidBecomeSingleThreadedNotification
+-------------------------------------------------------------
+NSTimeZone:
+	<NSDate.h>
+
+	@class NSData
+
+	+ setAbbreviationDictionary:
+	+ timeZoneDataVersion
+	- description
+
+	NSTimeZoneNameStyleGeneric
+	NSTimeZoneNameStyleShortGeneric
+-------------------------------------------------------------
+NSUndoManager:
+	#include <stdint.h>
+
+	@class NSString
+
+	- setActionIsDiscardable:
+
+	NSUndoManagerGroupIsDiscardableKey
+
+	- undoActionIsDiscardable
+	- redoActionIsDiscardable
+
+	NSUndoManagerDidCloseUndoGroupNotification
+-------------------------------------------------------------
+NSURL:
+	<NSString.h>
+
+	@class NSData, NSDictionary
+
+	+ fileURLWithPath:isDirectory:
+	- isFileReferenceURL
+	- fileReferenceURL
+	- filePathURL
+	- getResourceValue:forKey:error:
+	- resourceValuesForKeys:error:
+	- setResourceValue:forKey:error:
+	- setResourceValues:error:
+
+	NSURLKeysOfUnsetValuesKey
+
+	NSURLNameKey
+	NSURLLocalizedNameKey
+	NSURLIsRegularFileKey
+	NSURLIsDirectoryKey
+	NSURLIsSymbolicLinkKey
+	NSURLIsVolumeKey
+	NSURLIsPackageKey
+	NSURLIsSystemImmutableKey
+	NSURLIsUserImmutableKey
+	NSURLIsHiddenKey
+	NSURLHasHiddenExtensionKey
+	NSURLCreationDateKey
+	NSURLContentAccessDateKey
+	NSURLContentModificationDateKey
+	NSURLAttributeModificationDateKey
+	NSURLLinkCountKey
+	NSURLParentDirectoryURLKey
+	NSURLVolumeURLKey
+	NSURLTypeIdentifierKey
+	NSURLLocalizedTypeDescriptionKey
+	NSURLLabelNumberKey
+	NSURLLabelColorKey
+	NSURLLocalizedLabelKey
+	NSURLEffectiveIconKey
+	NSURLCustomIconKey
+	NSURLFileResourceIdentifierKey
+	NSURLVolumeIdentifierKey
+	NSURLPreferredIOBlockSizeKey
+	NSURLIsReadableKey
+	NSURLIsWritableKey
+	NSURLIsExecutableKey
+	NSURLFileSecurityKey
+	NSURLIsExcludedFromBackupKey
+	NSURLPathKey
+	NSURLIsMountTriggerKey
+	NSURLFileResourceTypeKey
+
+	NSURLFileResourceTypeNamedPipe
+	NSURLFileResourceTypeCharacterSpecial
+	NSURLFileResourceTypeDirectory
+	NSURLFileResourceTypeBlockSpecial
+	NSURLFileResourceTypeRegular
+	NSURLFileResourceTypeSymbolicLink
+	NSURLFileResourceTypeSocket
+	NSURLFileResourceTypeUnknown
+
+	NSURLFileSizeKey
+	NSURLFileAllocatedSizeKey
+	NSURLTotalFileSizeKey
+	NSURLTotalFileAllocatedSizeKey
+	NSURLIsAliasFileKey
+
+	NSURLVolumeLocalizedFormatDescriptionKey
+	NSURLVolumeTotalCapacityKey
+	NSURLVolumeAvailableCapacityKey
+	NSURLVolumeResourceCountKey
+	NSURLVolumeSupportsPersistentIDsKey
+	NSURLVolumeSupportsSymbolicLinksKey
+	NSURLVolumeSupportsHardLinksKey
+	NSURLVolumeSupportsJournalingKey
+	NSURLVolumeIsJournalingKey
+	NSURLVolumeSupportsSparseFilesKey
+	NSURLVolumeSupportsZeroRunsKey
+	NSURLVolumeSupportsCaseSensitiveNamesKey
+	NSURLVolumeSupportsCasePreservedNamesKey
+	NSURLVolumeSupportsRootDirectoryDatesKey
+	NSURLVolumeSupportsVolumeSizesKey
+	NSURLVolumeSupportsRenamingKey
+	NSURLVolumeSupportsAdvisoryFileLockingKey
+	NSURLVolumeSupportsExtendedSecurityKey
+	NSURLVolumeIsBrowsableKey
+	NSURLVolumeMaximumFileSizeKey
+	NSURLVolumeIsEjectableKey
+	NSURLVolumeIsRemovableKey
+	NSURLVolumeIsInternalKey
+	NSURLVolumeIsAutomountedKey
+	NSURLVolumeIsLocalKey
+	NSURLVolumeIsReadOnlyKey
+	NSURLVolumeCreationDateKey
+	NSURLVolumeURLForRemountingKey
+	NSURLVolumeUUIDStringKey
+	NSURLVolumeNameKey
+	NSURLVolumeLocalizedNameKey
+
+	NSURLIsUbiquitousItemKey
+	NSURLUbiquitousItemHasUnresolvedConflictsKey
+	NSURLUbiquitousItemIsDownloadedKey
+	NSURLUbiquitousItemIsDownloadingKey
+	NSURLUbiquitousItemIsUploadedKey
+	NSURLUbiquitousItemIsUploadingKey
+	NSURLUbiquitousItemPercentDownloadedKey
+	NSURLUbiquitousItemPercentUploadedKey
+
+	typedef NSURLBookmarkCreationOptions
+	typedef NSURLBookmarkResolutionOptions
+	typedef NSURLBookmarkFileCreationOptions
+
+	- bookmarkDataWithOptions:includingResourceValuesForKeys:relativeToURL:error:
+	- initByResolvingBookmarkData:options:relativeToURL:bookmarkDataIsStale:error:
+	+ URLByResolvingBookmarkData:options:relativeToURL:bookmarkDataIsStale:error:
+	+ resourceValuesForKeys:fromBookmarkData:
+	+ writeBookmarkData:toURL:options:error:
+	+ bookmarkDataWithContentsOfURL:error:
+	- startAccessingSecurityScopedResource
+	- stopAccessingSecurityScopedResource
+	- stringByAddingPercentEscapesUsingEncoding:
+	- stringByReplacingPercentEscapesUsingEncoding:
+	- URLByAppendingPathComponent:isDirectory:
+-------------------------------------------------------------
+NSURLAuthenticationChallenge:
+	- performDefaultHandlingForAuthenticationChallenge:
+	- rejectProtectionSpaceAndContinueWithChallenge:
+
+	@class NSURLAuthenticationChallengeInternal	
+-------------------------------------------------------------
+NSURLCache:
+	@class NSCachedURLResponseInternal
+	@class NSURLCacheInternal
+-------------------------------------------------------------
+NSURLConnection:
+	@class NSArray, NSURL, NSURLConnectionInternal, NSRunLoop, NSInputStream, NSURLProtectionSpace, NSOperationQueue
+	@protocol NSURLConnectionDelegate
+	@protocol NSURLConnectionDownloadDelegate
+
+	- originalRequest
+	- currentRequest
+	- scheduleInRunLoop:forMode:
+	- unscheduleFromRunLoop:forMode:
+	- setDelegateQueue:
+	+ sendAsynchronousRequest:queue:completionHandler:
+-------------------------------------------------------------
+NSURLCredential:
+	<Security/Security.h>
+
+	@class NSArray, NSURLCredentialInternal
+
+	@interface NSURLCredential(NSClientCertificate)
+	@interface NSURLCredential(NSServerTrust)
+-------------------------------------------------------------
+NSURLCredentialStorage:
+	@class NSURLCredentialStorageInternal
+-------------------------------------------------------------
+NSURLDownload:
+	@class NSURLDownloadInternal, NSURLProtectionSpace
+	@protocol NSURLDownloadDelegate
+
+	@protocol NSURLDownloadDelegate <NSObject> (incomplete)
+-------------------------------------------------------------
+NSURLError:
+	NSURLErrorFailingURLErrorKey 
+	NSURLErrorFailingURLStringErrorKey
+	NSURLErrorFailingURLPeerTrustErrorKey
+	NSURLErrorCannotDecodeRawData
+    NSURLErrorCannotDecodeContentData
+    NSURLErrorCannotParseResponse
+    NSURLErrorDataLengthExceedsMaximum
+	NSURLErrorClientCertificateRequired
+	NSURLErrorDownloadDecodingFailedToComplete
+	NSURLErrorInternationalRoamingOff
+	NSURLErrorCallIsActive
+	NSURLErrorDataNotAllowed
+	NSURLErrorRequestBodyStreamExhausted
+-------------------------------------------------------------
+NSURLHandle:
+	NSHTTPPropertyHTTPProxy
+	NSFTPPropertyUserLoginKey
+	NSFTPPropertyUserPasswordKey
+	NSFTPPropertyActiveTransferModeKey
+	NSFTPPropertyFileOffsetKey
+	NSFTPPropertyFTPProxy
+
+	- expectedResourceDataSize
+-------------------------------------------------------------
+NSURLProtectionSpace:
+	<Security/Security.h>
+
+	@class NSArray, NSURLProtectionSpaceInternal
+
+	NSURLProtectionSpaceHTTP
+	NSURLProtectionSpaceHTTPS
+	NSURLProtectionSpaceFTP
+	NSURLAuthenticationMethodNTLM
+	NSURLAuthenticationMethodNegotiate
+	NSURLAuthenticationMethodClientCertificate
+	NSURLAuthenticationMethodServerTrust
+
+	- distinguishedNames
+	- serverTrust
+-------------------------------------------------------------
+NSURLProtocol:
+	@class NSURLProtocolInternal
+
+	+ removePropertyForKey:inRequest:
+-------------------------------------------------------------
+NSURLRequest:
+	<Foundation/NSDate.h>
+
+	@class NSURLRequestInternal
+
+	typedef NSUInteger NSURLRequestCachePolicy
+	typedef NSUInteger NSURLRequestNetworkServiceType
+
+	- networkServiceType
+	- allowsCellularAccess
+	- setNetworkServiceType:
+	- setAllowsCellularAccess:
+	- HTTPShouldUsePipelining
+	- setHTTPShouldUsePipelining:
+-------------------------------------------------------------
+NSURLResponse:
+	@class NSURLRequest, NSURLResponseInternal, NSHTTPURLResponseInternal
+-------------------------------------------------------------
+NSUserDefaults:
+	@class NSURL
+
+	- URLForKey:
+	- setURL:forKey:
+	- objectIsForcedForKey:
+	- objectIsForcedForKey:inDomain:
+
+	NSPositiveCurrencyFormatString
+	NSNegativeCurrencyFormatString
+-------------------------------------------------------------
+NSValue:
+	@class NSDictionary
+-------------------------------------------------------------
+NSValueTransformer:
+	NSKeyedUnarchiveFromDataTransformerName
+-------------------------------------------------------------
+NSXMLDocument:
+	@class NSXMLDocument, NSDictionary, NSArray
+-------------------------------------------------------------
+NSXMLNode:
+	- description
+-------------------------------------------------------------
+NSXMLNodeOptions:
+	NSXMLNodeLoadExternalEntitiesAlways
+    NSXMLNodeLoadExternalEntitiesSameOriginOnly
+    NSXMLNodeLoadExternalEntitiesNever
+-------------------------------------------------------------
+NSXMLParser:
+	@class NSInputStream
+
+	- initWithStream:
+	- parseError
+-------------------------------------------------------------
+NSZone:
+	typedef struct _NSZone NSZone
+-------------------------------------------------------------
+Good headers:
+	<NSAffineTransform.h>
+	<NSArray.h>
+	<NSAutoreleasePool.h>
+	<NSCache.h>
+	<NSCalendarDate.h>
+	<NSClassDescription.h>
+	<NSCompoundPredicate.h>
+	<NSDateFormatter.h>
+	<NSDistantObject.h>
+	<NSDistributedLock.h>
+	<NSEnumerator.h>
+	<NSFormatter.h>
+	<NSGarbageCollector.h>
+	<NSIndexPath.h>
+	<NSJSONSerialization.h>
+	<NSLock.h>
+	<NSMethodSignature.h>
+	<NSNotificationQueue.h>
+	<NSNull.h>
+	<NSPointerArray.h>
+	<NSPortCoder.h>
+	<NSPortMessage>
+	<NSProtocolChecker.h>
+	<NSSet.h>
+	<NSTimer.h>
+	<NSXMLDTD.h>
+	<NSXMLDTDNode.h>
+	<NSXMLElement.h>
\ No newline at end of file
diff --git a/Headers/Foundation/NSArchiver.h b/Headers/Foundation/NSArchiver.h
index e642a0f..8874088 100644
--- a/Headers/Foundation/NSArchiver.h
+++ b/Headers/Foundation/NSArchiver.h
@@ -66,7 +66,7 @@ extern "C" {
   unsigned	_xRefC;		/* Counter for cross-reference.	*/
   unsigned	_xRefO;		/* Counter for cross-reference.	*/
   unsigned	_xRefP;		/* Counter for cross-reference.	*/
-  unsigned	_startPos;	/* Where in data we started.	*/
+  NSUInteger _startPos;	/* Where in data we started.	*/
   BOOL		_encodingRoot;
   BOOL		_initialPass;
 #endif
@@ -149,11 +149,11 @@ extern "C" {
  *	methods rather than those in the NSMutableData object.
  */
 - (BOOL) directDataAccess;
-- (void) serializeHeaderAt: (unsigned)positionInData
+- (void) serializeHeaderAt: (NSUInteger)positionInData
 		   version: (unsigned)systemVersion
-		   classes: (unsigned)classCount
-		   objects: (unsigned)objectCount
-		  pointers: (unsigned)pointerCount;
+		   classes: (NSUInteger)classCount
+		   objects: (NSUInteger)objectCount
+		  pointers: (NSUInteger)pointerCount;
 @end
 #endif
 
@@ -167,7 +167,7 @@ extern "C" {
   Class			dataClass;	/* What sort of data is it?	*/
   id			src;		/* Deserialization source.	*/
   IMP			desImp;		/* Method to deserialize with.	*/
-  void			(*tagImp)(id, SEL, unsigned char*, unsigned*,unsigned*);
+  void			(*tagImp)(id, SEL, unsigned char*, unsigned*,NSUInteger*);
   IMP			dValImp;	/* Method to decode data with.	*/
 #ifndef	_IN_NSUNARCHIVER_M
 #define	GSIArray	void*
@@ -178,7 +178,7 @@ extern "C" {
 #ifndef	_IN_NSUNARCHIVER_M
 #undef	GSIArray
 #endif
-  unsigned		cursor;		/* Position in data buffer.	*/
+  NSUInteger		cursor;		/* Position in data buffer.	*/
   unsigned		version;	/* Version of archiver used.	*/
   NSZone		*zone;		/* Zone for allocating objs.	*/
   NSMutableDictionary	*objDict;	/* Class information store.	*/
@@ -225,16 +225,16 @@ extern "C" {
 #if OS_API_VERSION(GS_API_NONE,GS_API_NONE) && GS_API_VERSION(1,GS_API_LATEST)
 @interface	NSUnarchiver (GNUstep)
 
-- (unsigned) cursor;
+- (NSUInteger) cursor;
 - (void) resetUnarchiverWithData: (NSData*)anObject
-			 atIndex: (unsigned)pos;
+			 atIndex: (NSUInteger)pos;
 
 - (BOOL) directDataAccess;
-- (void) deserializeHeaderAt: (unsigned*)pos
+- (void) deserializeHeaderAt: (NSUInteger*)pos
 		     version: (unsigned*)v
-		     classes: (unsigned*)c
-		     objects: (unsigned*)o
-		    pointers: (unsigned*)p;
+		     classes: (NSUInteger*)c
+		     objects: (NSUInteger*)o
+		    pointers: (NSUInteger*)p;
 @end
 #endif
 
diff --git a/Headers/Foundation/NSArray.h b/Headers/Foundation/NSArray.h
index 22575ac..b653661 100644
--- a/Headers/Foundation/NSArray.h
+++ b/Headers/Foundation/NSArray.h
@@ -39,7 +39,7 @@ extern "C" {
 @class NSURL;
 @class NSIndexSet;
 
-#if OS_API_VERSION(100600, GS_API_LATEST)
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_6, GS_API_LATEST)
 enum
 {
   NSBinarySearchingFirstEqual = (1UL << 8), /** Specifies that the binary
@@ -112,7 +112,7 @@ typedef NSUInteger NSBinarySearchingOptions;
  */
 - (id) objectAtIndex: (NSUInteger)index;
 
-#if OS_API_VERSION(100400, GS_API_LATEST)
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_4, GS_API_LATEST)
 - (NSArray *) objectsAtIndexes: (NSIndexSet *)indexes;
 #endif
 
@@ -154,7 +154,7 @@ typedef NSUInteger NSBinarySearchingOptions;
 - (id) valueForKey: (NSString*)key;
 #endif
 
-#if OS_API_VERSION(100600, GS_API_LATEST)
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_6, GS_API_LATEST)
 
 DEFINE_BLOCK_TYPE(GSEnumeratorBlock, void, id, NSUInteger, BOOL*);
 DEFINE_BLOCK_TYPE(GSPredicateBlock, BOOL, id, NSUInteger, BOOL*);
@@ -314,7 +314,7 @@ DEFINE_BLOCK_TYPE(GSPredicateBlock, BOOL, id, NSUInteger, BOOL*);
  * The object is retained by the array.
  */
 - (void) insertObject: (id)anObject atIndex: (NSUInteger)index;
-#if OS_API_VERSION(100400, GS_API_LATEST)
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_4, GS_API_LATEST)
 - (void) insertObjects: (NSArray *)objects atIndexes: (NSIndexSet *)indexes;
 #endif
 
@@ -335,7 +335,7 @@ DEFINE_BLOCK_TYPE(GSPredicateBlock, BOOL, id, NSUInteger, BOOL*);
 - (void) replaceObjectAtIndex: (NSUInteger)index
 		   withObject: (id)anObject;
 
-#if OS_API_VERSION(100400, GS_API_LATEST)
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_4, GS_API_LATEST)
 - (void) replaceObjectsAtIndexes: (NSIndexSet *)indexes
                      withObjects: (NSArray *)objects;
 #endif
@@ -365,7 +365,7 @@ DEFINE_BLOCK_TYPE(GSPredicateBlock, BOOL, id, NSUInteger, BOOL*);
 - (void) sortUsingSelector: (SEL)comparator;
 
 
-#if OS_API_VERSION(100600, GS_API_LATEST)
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_6, GS_API_LATEST)
 /**
  * Sorts the array using the specified comparator block.
  */
diff --git a/Headers/Foundation/NSAutoreleasePool.h b/Headers/Foundation/NSAutoreleasePool.h
index 5a8784a..f2422fe 100644
--- a/Headers/Foundation/NSAutoreleasePool.h
+++ b/Headers/Foundation/NSAutoreleasePool.h
@@ -231,7 +231,7 @@ NS_AUTOMATED_REFCOUNT_UNAVAILABLE
  */
 - (id) autorelease;
 
-#if OS_API_VERSION(100400, GS_API_LATEST)
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_4, GS_API_LATEST)
 /**
  * Intended to trigger a garbage collection run (if needed) when called in
  * a garbage collected environment.<br />
@@ -262,7 +262,7 @@ NS_AUTOMATED_REFCOUNT_UNAVAILABLE
  *   used for debugging purposes.
  * </p>
  */
-+ (unsigned) autoreleaseCountForObject: (id)anObject;
++ (NSUInteger) autoreleaseCountForObject: (id)anObject;
 
 /** 
  * Return the currently active autorelease pool.
@@ -312,7 +312,7 @@ NS_AUTOMATED_REFCOUNT_UNAVAILABLE
 /**
  * Return the number of objects in this pool.
  */
-- (unsigned) autoreleaseCount;
+- (NSUInteger) autoreleaseCount;
 
 /**
  * Empties the current pool by releasing all the autoreleased objects
diff --git a/Headers/Foundation/NSBundle.h b/Headers/Foundation/NSBundle.h
index dea83fe..216e2bc 100644
--- a/Headers/Foundation/NSBundle.h
+++ b/Headers/Foundation/NSBundle.h
@@ -42,7 +42,7 @@ extern "C" {
 @class NSMutableArray;
 @class NSMutableDictionary;
 
-#if OS_API_VERSION(100500,GS_API_LATEST) 
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_5,GS_API_LATEST) 
 enum {
   NSBundleExecutableArchitectureI386      = 0x00000007,
   NSBundleExecutableArchitecturePPC       = 0x00000012,
@@ -184,7 +184,7 @@ GS_EXPORT NSString* const NSLoadedClasses;
  * not readable, return nil.  If you want the main bundle of an
  * application or a tool, it's better if you use +mainBundle.  */
 + (NSBundle*) bundleWithPath: (NSString*)path;
-#if OS_API_VERSION(100600,GS_API_LATEST) 
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_6,GS_API_LATEST) 
 + (NSBundle*) bundleWithURL: (NSURL*)url;
 #endif
 
@@ -207,7 +207,7 @@ GS_EXPORT NSString* const NSLoadedClasses;
 		  inDirectory: (NSString*)bundlePath
 		  withVersion: (int)version;
 
-#if OS_API_VERSION(100600,GS_API_LATEST) 
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_6,GS_API_LATEST) 
 + (NSURL*) URLForResource: (NSString*)name
             withExtension: (NSString*)extension
              subdirectory: (NSString*)subpath
@@ -236,7 +236,7 @@ GS_EXPORT NSString* const NSLoadedClasses;
  */
 - (id) initWithPath: (NSString*)path;
 
-#if OS_API_VERSION(100600,GS_API_LATEST) 
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_6,GS_API_LATEST) 
 - (id) initWithURL: (NSURL*)url;
 #endif
 
@@ -313,7 +313,7 @@ GS_EXPORT NSString* const NSLoadedClasses;
 - (NSString*) pathForResource: (NSString*)name
 		       ofType: (NSString*)extension;
 
-#if OS_API_VERSION(100600,GS_API_LATEST) 
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_6,GS_API_LATEST) 
 - (NSURL*) URLForResource: (NSString*)name
             withExtension: (NSString*)extension;
 - (NSURL*) URLForResource: (NSString*)name
@@ -369,7 +369,7 @@ GS_EXPORT NSString* const NSLoadedClasses;
 + (NSArray *) preferredLocalizationsFromArray: (NSArray *)localizationsArray 
 			       forPreferences: (NSArray *)preferencesArray;
 
-#if OS_API_VERSION(100200,GS_API_LATEST) 
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_2,GS_API_LATEST) 
 /**
  * Returns a boolean indicating whether code for the bundle has been loaded.
  */
@@ -400,7 +400,7 @@ GS_EXPORT NSString* const NSLoadedClasses;
 /** Returns the info property list associated with the bundle. */
 - (NSDictionary*) infoDictionary;
 
-#if OS_API_VERSION(100200,GS_API_LATEST) 
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_2,GS_API_LATEST) 
 /** Returns a localized info property list based on the preferred
  *  localization or the most appropriate localization if the preferred
  *  one cannot be found.
@@ -432,7 +432,7 @@ GS_EXPORT NSString* const NSLoadedClasses;
  */
 - (BOOL) load;
 
-#if OS_API_VERSION(100200,GS_API_LATEST) 
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_2,GS_API_LATEST) 
 /** * Not implemented
  */
 - (BOOL) unload;
@@ -442,7 +442,7 @@ GS_EXPORT NSString* const NSLoadedClasses;
 - (NSString *) executablePath;
 #endif
 
-#if OS_API_VERSION(100500,GS_API_LATEST) 
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_5,GS_API_LATEST) 
 /** Not implemented */
 - (NSArray *) executableArchitectures;
 /** Not implemented */
@@ -500,8 +500,8 @@ GS_EXPORT NSString* const NSLoadedClasses;
 
 /** Find a resource in the "Library" directory. */
 + (NSString*) pathForLibraryResource: (NSString*)name
-			      ofType: (NSString*)extension
-			 inDirectory: (NSString*)bundlePath;
+                              ofType: (NSString*)extension
+                         inDirectory: (NSString*)bundlePath;
 
 @end
 
diff --git a/Headers/Foundation/NSCalendar.h b/Headers/Foundation/NSCalendar.h
index 5663750..734833a 100644
--- a/Headers/Foundation/NSCalendar.h
+++ b/Headers/Foundation/NSCalendar.h
@@ -81,20 +81,6 @@ enum
 {
 @private
   void  *_NSDateComponentsInternal;
-/* FIXME ... remove dummy fields at next binary incompatible release
- */
-  void  *_dummy1;
-  void  *_dummy2;
-  void  *_dummy3;
-  void  *_dummy4;
-  void  *_dummy5;
-  void  *_dummy6;
-  void  *_dummy7;
-  void  *_dummy8;
-  void  *_dummy9;
-  void  *_dummy10;
-  void  *_dummy11;
-  void  *_dummy12;
 }
 
 - (NSInteger) day;
@@ -180,11 +166,6 @@ enum
 {
 @private
   void  *_NSCalendarInternal;
-/* FIXME ... remove dummy fields at next binary incompatible release
- */
-  void  *_dummy1;
-  void  *_dummy2;
-  void  *_dummy3;
 }
 
 + (id) currentCalendar;
diff --git a/Headers/Foundation/NSCoder.h b/Headers/Foundation/NSCoder.h
index f14518e..05102e1 100644
--- a/Headers/Foundation/NSCoder.h
+++ b/Headers/Foundation/NSCoder.h
@@ -353,7 +353,7 @@ extern "C" {
 - (void) encodeObject: (id)anObject forKey: (NSString*)aKey;
 #endif
 
-#if OS_API_VERSION(100500, GS_API_LATEST)
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_5, GS_API_LATEST)
 /** <override-subclass />
  * Encodes an NSInteger and associates the encoded value with key.
  */
diff --git a/Headers/Foundation/NSComparisonPredicate.h b/Headers/Foundation/NSComparisonPredicate.h
index 737abe5..525a222 100644
--- a/Headers/Foundation/NSComparisonPredicate.h
+++ b/Headers/Foundation/NSComparisonPredicate.h
@@ -26,7 +26,7 @@
 #define __NSComparisonPredicate_h_GNUSTEP_BASE_INCLUDE
 #import	<GNUstepBase/GSVersionMacros.h>
 
-#if	OS_API_VERSION(100400, GS_API_LATEST)
+#if	OS_API_VERSION(MAC_OS_X_VERSION_10_4, GS_API_LATEST)
 
 #import	<Foundation/NSExpression.h>
 #import	<Foundation/NSPredicate.h>
@@ -62,7 +62,7 @@ typedef enum _NSPredicateOperatorType
   NSEndsWithPredicateOperatorType,
   NSInPredicateOperatorType,
   NSCustomSelectorPredicateOperatorType
-#if OS_API_VERSION(100500,GS_API_LATEST) 
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_5,GS_API_LATEST) 
   ,
   NSContainsPredicateOperatorType = 99,
   NSBetweenPredicateOperatorType
diff --git a/Headers/Foundation/NSCompoundPredicate.h b/Headers/Foundation/NSCompoundPredicate.h
index b750b74..cdd2c1e 100644
--- a/Headers/Foundation/NSCompoundPredicate.h
+++ b/Headers/Foundation/NSCompoundPredicate.h
@@ -26,7 +26,7 @@
 #define __NSCompoundPredicate_h_GNUSTEP_BASE_INCLUDE
 #import	<GNUstepBase/GSVersionMacros.h>
 
-#if	OS_API_VERSION(100400, GS_API_LATEST)
+#if	OS_API_VERSION(MAC_OS_X_VERSION_10_4, GS_API_LATEST)
 
 #import	<Foundation/NSPredicate.h>
 
diff --git a/Headers/Foundation/NSConnection.h b/Headers/Foundation/NSConnection.h
index af3f745..52371b7 100644
--- a/Headers/Foundation/NSConnection.h
+++ b/Headers/Foundation/NSConnection.h
@@ -119,7 +119,7 @@ GS_NSConnection_IVARS;
 + (NSDistantObject*) rootProxyForConnectionWithRegisteredName: (NSString*)n
   host: (NSString*)h usingNameServer: (NSPortNameServer*)s;
 
-#if OS_API_VERSION(100500,GS_API_LATEST) 
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_5,GS_API_LATEST) 
 + (id) serviceConnectionWithName: (NSString *)name
                       rootObject: (id)root;
 + (id) serviceConnectionWithName: (NSString *)name
@@ -237,9 +237,6 @@ GS_NSConnection_IVARS;
  - (BOOL) connection: (NSConnection*)parent
   shouldMakeNewConnection: (NSConnection*)newConnection;
 
-- (NSConnection*) connection: (NSConnection*)ancestorConn
-		  didConnect: (NSConnection*)newConn;
-
 /**
  * An old fashioned synonym for -connection:shouldMakeNewConnection: -
  * don't use this.
diff --git a/Headers/Foundation/NSData.h b/Headers/Foundation/NSData.h
index 627bb15..611c6e1 100644
--- a/Headers/Foundation/NSData.h
+++ b/Headers/Foundation/NSData.h
@@ -39,7 +39,7 @@ extern "C" {
 @class	NSURL;
 #endif
 
-#if OS_API_VERSION(100400,GS_API_LATEST) 
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_4,GS_API_LATEST) 
 enum {
   NSMappedRead = 1,
   NSUncachedRead = 2
@@ -124,24 +124,24 @@ enum {
 
 // Deserializing Data
 
-- (unsigned int) deserializeAlignedBytesLengthAtCursor: (unsigned int*)cursor;
+- (unsigned int) deserializeAlignedBytesLengthAtCursor: (NSUInteger*)cursor;
 - (void) deserializeBytes: (void*)buffer
-		   length: (unsigned int)bytes
-		 atCursor: (unsigned int*)cursor;
+		   length: (NSUInteger)bytes
+		 atCursor: (NSUInteger*)cursor;
 - (void) deserializeDataAt: (void*)data
 		ofObjCType: (const char*)type
-		  atCursor: (unsigned int*)cursor
+		  atCursor: (NSUInteger*)cursor
 		   context: (id <NSObjCTypeSerializationCallBack>)callback;
-- (int) deserializeIntAtCursor: (unsigned int*)cursor;
-- (int) deserializeIntAtIndex: (unsigned int)index;
+- (int) deserializeIntAtCursor: (NSUInteger*)cursor;
+- (int) deserializeIntAtIndex: (NSUInteger)index;
 - (void) deserializeInts: (int*)intBuffer
-		   count: (unsigned int)numInts
-		atCursor: (unsigned int*)cursor;
+		   count: (NSUInteger)numInts
+		atCursor: (NSUInteger*)cursor;
 - (void) deserializeInts: (int*)intBuffer
-		   count: (unsigned int)numInts
-		 atIndex: (unsigned int)index;
+		   count: (NSUInteger)numInts
+		 atIndex: (NSUInteger)index;
 
-#if OS_API_VERSION(100400,GS_API_LATEST) 
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_4,GS_API_LATEST) 
 /**
  * <p>Writes a copy of the data encapsulated by the receiver to a file
  * at path.  If the NSAtomicWrite option is set, this writes to a
@@ -248,7 +248,7 @@ enum {
  */
 - (void) deserializeTypeTag: (unsigned char*)tag
 		andCrossRef: (unsigned int*)ref
-		   atCursor: (unsigned int*)cursor;
+		   atCursor: (NSUInteger*)cursor;
 @end
 #endif
 
@@ -285,18 +285,18 @@ enum {
 
 // Serializing Data
 
-- (void) serializeAlignedBytesLength: (unsigned int)length;
+- (void) serializeAlignedBytesLength: (NSUInteger)length;
 - (void) serializeDataAt: (const void*)data
 	      ofObjCType: (const char*)type
 		 context: (id <NSObjCTypeSerializationCallBack>)callback;
 - (void) serializeInt: (int)value;
 - (void) serializeInt: (int)value
-	      atIndex: (unsigned int)index;
+	      atIndex: (NSUInteger)index;
 - (void) serializeInts: (int*)intBuffer
-		 count: (unsigned int)numInts;
+		 count: (NSUInteger)numInts;
 - (void) serializeInts: (int*)intBuffer
-		 count: (unsigned int)numInts
-	       atIndex: (unsigned int)index;
+		 count: (NSUInteger)numInts
+	       atIndex: (NSUInteger)index;
 
 @end
 
diff --git a/Headers/Foundation/NSDate.h b/Headers/Foundation/NSDate.h
index 723ee4e..379efcb 100644
--- a/Headers/Foundation/NSDate.h
+++ b/Headers/Foundation/NSDate.h
@@ -66,17 +66,29 @@ GS_EXPORT const NSTimeInterval NSTimeIntervalSince1970;
 
 + (id) date;
 + (id) dateWithString: (NSString*)description;
+
 + (id) dateWithTimeIntervalSinceNow: (NSTimeInterval)seconds;
-+ (id) dateWithTimeIntervalSince1970: (NSTimeInterval)seconds;
++ (id) dateWithTimeInterval: (NSTimeInterval)seconds sinceDate: (NSDate *)date;
 + (id) dateWithTimeIntervalSinceReferenceDate: (NSTimeInterval)seconds;
++ (id) dateWithTimeIntervalSince1970: (NSTimeInterval)seconds;
+
 + (id) distantFuture;
 + (id) distantPast;
 
+- (id) init;
 - (id) initWithString: (NSString*)description;
-- (id) initWithTimeInterval: (NSTimeInterval)secsToBeAdded
-		  sinceDate: (NSDate*)anotherDate;
-- (id) initWithTimeIntervalSinceNow: (NSTimeInterval)secsToBeAdded;
-- (id) initWithTimeIntervalSinceReferenceDate: (NSTimeInterval)secs;
+
+- (id) initWithTimeInterval: (NSTimeInterval)seconds 
+                  sinceDate: (NSDate *)refDate;
+- (id) initWithTimeIntervalSinceNow: (NSTimeInterval)seconds;
+- (id) initWithTimeIntervalSinceReferenceDate: (NSTimeInterval)seconds;
+
+#if OS_API_VERSION(GS_API_MACOSX, GS_API_LATEST)
++ (id) dateWithNaturalLanguageString: (NSString *)string;
++ (id) dateWithNaturalLanguageString: (NSString *)string
+                              locale: (id)localeDictionary;
+- (id) initWithTimeIntervalSince1970: (NSTimeInterval)seconds;
+#endif
 
 // Converting to NSCalendar
 
@@ -106,7 +118,7 @@ GS_EXPORT const NSTimeInterval NSTimeIntervalSince1970;
 - (BOOL) isEqualToDate: (NSDate*)other;
 - (NSDate*) laterDate: (NSDate*)otherDate;
 
-#if OS_API_VERSION(100600,GS_API_LATEST)
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_6,GS_API_LATEST)
 /**
  * Returns an autoreleased NSDate instance whose value is offset from
  * that of the receiver by the specified interval.
@@ -114,13 +126,6 @@ GS_EXPORT const NSTimeInterval NSTimeIntervalSince1970;
 - (id) dateByAddingTimeInterval: (NSTimeInterval)ti;
 #endif
 
-#if OS_API_VERSION(GS_API_MACOSX, GS_API_LATEST)
-+ (id) dateWithNaturalLanguageString: (NSString*)string;
-+ (id) dateWithNaturalLanguageString: (NSString*)string
-                              locale: (NSDictionary*)locale;
-- (id) initWithTimeIntervalSince1970: (NSTimeInterval)seconds;
-#endif
-
 @end
 
 #if	defined(__cplusplus)
diff --git a/Headers/Foundation/NSDictionary.h b/Headers/Foundation/NSDictionary.h
index 8a00dd3..2aab8f1 100644
--- a/Headers/Foundation/NSDictionary.h
+++ b/Headers/Foundation/NSDictionary.h
@@ -59,7 +59,7 @@ extern "C" {
 - (NSString*) descriptionWithLocale: (id)locale
 			     indent: (NSUInteger)level;
 
-#if OS_API_VERSION(100600, GS_API_LATEST)
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_6, GS_API_LATEST)
 DEFINE_BLOCK_TYPE(GSKeysAndObjectsEnumeratorBlock, void, id, id, BOOL*);
 - (void) enumerateKeysAndObjectsUsingBlock:
   (GSKeysAndObjectsEnumeratorBlock)aBlock;
@@ -87,7 +87,7 @@ DEFINE_BLOCK_TYPE(GSKeysAndObjectsEnumeratorBlock, void, id, id, BOOL*);
 
 - (NSEnumerator*) keyEnumerator;				// Primitive
 
-#if OS_API_VERSION(100600, GS_API_LATEST)
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_6, GS_API_LATEST)
 DEFINE_BLOCK_TYPE(GSKeysAndObjectsPredicateBlock, BOOL, id, id, BOOL*);
 - (NSSet*) keysOfEntriesPassingTest: (GSKeysAndObjectsPredicateBlock)aPredicate;
 - (NSSet*) keysOfEntriesWithOptions: (NSEnumerationOptions)opts
diff --git a/Headers/Foundation/NSError.h b/Headers/Foundation/NSError.h
index 0216d1c..2a12d0b 100644
--- a/Headers/Foundation/NSError.h
+++ b/Headers/Foundation/NSError.h
@@ -30,7 +30,7 @@
 
 #import	<Foundation/NSObject.h>
 
-#if	OS_API_VERSION(100300,GS_API_LATEST)
+#if	OS_API_VERSION(MAC_OS_X_VERSION_10_3,GS_API_LATEST)
 
 #if	defined(__cplusplus)
 extern "C" {
@@ -50,7 +50,7 @@ GS_EXPORT NSString* const NSLocalizedDescriptionKey;
  */
 GS_EXPORT NSString* const NSUnderlyingErrorKey;
 
-#if	OS_API_VERSION(100400,GS_API_LATEST)
+#if	OS_API_VERSION(MAC_OS_X_VERSION_10_4,GS_API_LATEST)
 /**
  * This key can be used to store the file path of a resource involved
  * in the error (eg unreadable file).
@@ -98,7 +98,7 @@ GS_EXPORT NSString* const NSOSStatusErrorDomain;
  * Domain for system and system library errors.
  */
 GS_EXPORT NSString* const NSPOSIXErrorDomain;
-#if	OS_API_VERSION(100400,GS_API_LATEST)
+#if	OS_API_VERSION(MAC_OS_X_VERSION_10_4,GS_API_LATEST)
 /**
  * Domain for Foundation and AppKit (base and gui) errors.
  */
@@ -117,7 +117,7 @@ GS_EXPORT NSString* const NSCocoaErrorDomain;
 {
 #if	GS_EXPOSE(NSError)
 @private
-  int		_code;
+  NSInteger		_code;
   NSString	*_domain;
   NSDictionary	*_userInfo;
 #endif
@@ -167,7 +167,7 @@ GS_EXPORT NSString* const NSCocoaErrorDomain;
  */
 - (NSString *) localizedDescription;
 
-#if	OS_API_VERSION(100400,GS_API_LATEST)
+#if	OS_API_VERSION(MAC_OS_X_VERSION_10_4,GS_API_LATEST)
 /**
  * Return a human readable explanation of the reason for the error
  * (if known).  This should normally be a more discursive explanation
diff --git a/Headers/Foundation/NSErrorRecoveryAttempting.h b/Headers/Foundation/NSErrorRecoveryAttempting.h
index 60c6d2c..b4828e1 100644
--- a/Headers/Foundation/NSErrorRecoveryAttempting.h
+++ b/Headers/Foundation/NSErrorRecoveryAttempting.h
@@ -41,9 +41,9 @@ extern "C" {
 @interface NSObject (NSErrorRecoveryAttempting)
 
 - (BOOL) attemptRecoveryFromError: (NSError*)error
-                      optionIndex: (unsigned int)recoveryOptionIndex;
+                      optionIndex: (NSUInteger)recoveryOptionIndex;
 - (void) attemptRecoveryFromError: (NSError*)error
-                      optionIndex: (unsigned int)recoveryOptionIndex
+                      optionIndex: (NSUInteger)recoveryOptionIndex
                          delegate: (id)delegate
                didRecoverSelector: (SEL)didRecoverSelector
                       contextInfo: (void*)contextInfo;
diff --git a/Headers/Foundation/NSException.h b/Headers/Foundation/NSException.h
index 9370603..2675800 100644
--- a/Headers/Foundation/NSException.h
+++ b/Headers/Foundation/NSException.h
@@ -123,8 +123,7 @@ extern "C" {
  * format string and any additional arguments. The exception is then
  * <em>raised</em> using the -raise method.
  */
-+ (void) raise: (NSString*)name
-	format: (NSString*)format,...;
++ (void)raise:(NSString *)name format:(NSString *)format, ... NS_FORMAT_FUNCTION(2,3);
 
 /**
  * Creates an exception with a name and a reason string using the
@@ -132,11 +131,9 @@ extern "C" {
  * argument list argList. The exception is then <em>raised</em>
  * using the -raise method.
  */
-+ (void) raise: (NSString*)name
-	format: (NSString*)format
-     arguments: (va_list)argList;
++ (void)raise:(NSString *)name format:(NSString *)format arguments:(va_list)argList NS_FORMAT_FUNCTION(2,0);
 
-#if OS_API_VERSION(100500,GS_API_LATEST) && GS_API_VERSION( 11501,GS_API_LATEST)
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_5,GS_API_LATEST) // FIXDEF! && GS_API_VERSION( 11501,GS_API_LATEST)
 /** Returns an array of the call stack return addresses at the point when
  * the exception was raised.  Re-raising the exception does not change
  * this value.
@@ -144,7 +141,7 @@ extern "C" {
 - (NSArray*) callStackReturnAddresses;
 #endif
 
-#if OS_API_VERSION(100600,GS_API_LATEST) && GS_API_VERSION( 11903,GS_API_LATEST)
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_6,GS_API_LATEST) // FIXDEF! && GS_API_VERSION( 11903,GS_API_LATEST)
 /**
  * Returns an array of the symbolic names of the call stack return addresses.  
  * Note that, on some platforms, symbols are only exported in
@@ -288,7 +285,7 @@ typedef void NSUncaughtExceptionHandler(NSException *exception);
  *  calling NSSetUncaughtExceptionHandler().
  */
 GS_EXPORT NSUncaughtExceptionHandler *
-NSGetUncaughtExceptionHandler();
+NSGetUncaughtExceptionHandler(void);
 
 /**
  *  <p>Sets the exception handler called when an exception is generated and
@@ -397,32 +394,36 @@ GS_EXPORT void _NSRemoveHandler( NSHandler *handler );
 
 @end
 extern NSString *const NSAssertionHandlerKey;
+    
+#if !defined (__GNUC__)
+#  define __builtin_expect(expression, value) expression
+#endif
 
 #ifdef	NS_BLOCK_ASSERTIONS
 #define _NSAssertArgs(condition, desc, args...)		
 #define _NSCAssertArgs(condition, desc, args...)	
 #else
-#define _NSAssertArgs(condition, desc, args...)			\
-    do {							\
-	if (!(condition)) {					\
-	    [[NSAssertionHandler currentHandler] 		\
-	    	handleFailureInMethod: _cmd 			\
-		object: self 					\
-		file: [NSString stringWithUTF8String: __FILE__] 	\
-		lineNumber: __LINE__ 				\
-		description: (desc) , ## args]; 			\
-	}							\
+#define _NSAssertArgs(condition, desc, args...)             \
+    do {                                                    \
+	if (__builtin_expect(!(condition), NO)) {               \
+	    [[NSAssertionHandler currentHandler]                \
+	    	handleFailureInMethod: _cmd                     \
+		object: self                                        \
+		file: [NSString stringWithUTF8String: __FILE__]     \
+		lineNumber: __LINE__                                \
+		description: (desc) , ## args];                     \
+	}                                                       \
     } while(0)
 
-#define _NSCAssertArgs(condition, desc, args...)		\
-    do {							\
-	if (!(condition)) {					\
-	    [[NSAssertionHandler currentHandler] 		\
-	    handleFailureInFunction: [NSString stringWithUTF8String: __PRETTY_FUNCTION__] 				\
-	    file: [NSString stringWithUTF8String: __FILE__] 		\
-	    lineNumber: __LINE__ 				\
-	    description: (desc) , ## args]; 			\
-	}							\
+#define _NSCAssertArgs(condition, desc, args...)                                        \
+    do {                                                                                \
+	if (__builtin_expect(!(condition), NO)) {                                           \
+	    [[NSAssertionHandler currentHandler]                                            \
+	    handleFailureInFunction: [NSString stringWithUTF8String: __PRETTY_FUNCTION__]   \
+	    file: [NSString stringWithUTF8String: __FILE__]                                 \
+	    lineNumber: __LINE__                                                            \
+	    description: (desc) , ## args];                                                 \
+	}                                                                                   \
     } while(0)
 #endif
 
diff --git a/Headers/Foundation/NSExpression.h b/Headers/Foundation/NSExpression.h
index 34cdc58..09f993c 100644
--- a/Headers/Foundation/NSExpression.h
+++ b/Headers/Foundation/NSExpression.h
@@ -26,7 +26,7 @@
 #define __NSExpression_h_GNUSTEP_BASE_INCLUDE
 #import	<GNUstepBase/GSVersionMacros.h>
 
-#if	OS_API_VERSION(100400, GS_API_LATEST)
+#if	OS_API_VERSION(MAC_OS_X_VERSION_10_4, GS_API_LATEST)
 
 #import	<Foundation/NSObject.h>
 
diff --git a/Headers/Foundation/NSFileHandle.h b/Headers/Foundation/NSFileHandle.h
index e49fe14..281311d 100644
--- a/Headers/Foundation/NSFileHandle.h
+++ b/Headers/Foundation/NSFileHandle.h
@@ -184,22 +184,25 @@ GS_EXPORT NSString * const NSFileHandleOperationException;
 // GNUstep class extensions
 
 @interface NSFileHandle (GNUstepExtensions)
+
 + (id) fileHandleAsServerAtAddress: (NSString*)address
-			   service: (NSString*)service
-			  protocol: (NSString*)protocol;
+                           service: (NSString*)service
+                          protocol: (NSString*)protocol;
 + (id) fileHandleAsClientAtAddress: (NSString*)address
-			   service: (NSString*)service
-			  protocol: (NSString*)protocol;
+                           service: (NSString*)service
+                          protocol: (NSString*)protocol;
+
 + (id) fileHandleAsClientInBackgroundAtAddress: (NSString*)address
-				       service: (NSString*)service
-				      protocol: (NSString*)protocol;
+                                       service: (NSString*)service
+                                      protocol: (NSString*)protocol;
 + (id) fileHandleAsClientInBackgroundAtAddress: (NSString*)address
-				       service: (NSString*)service
-				      protocol: (NSString*)protocol
-				      forModes: (NSArray*)modes;
-- (void) readDataInBackgroundAndNotifyLength: (unsigned)len;
-- (void) readDataInBackgroundAndNotifyLength: (unsigned)len
-				    forModes: (NSArray*)modes;
+                                       service: (NSString*)service
+                                      protocol: (NSString*)protocol
+                                      forModes: (NSArray*)modes;
+
+- (void) readDataInBackgroundAndNotifyLength: (NSUInteger)len;
+- (void) readDataInBackgroundAndNotifyLength: (NSUInteger)len
+                                    forModes: (NSArray*)modes;
 - (BOOL) readInProgress;
 - (NSString*) socketAddress;
 - (NSString*) socketLocalAddress;
@@ -210,6 +213,7 @@ GS_EXPORT NSString * const NSFileHandleOperationException;
 - (void) writeInBackgroundAndNotify: (NSData*)item forModes: (NSArray*)modes;
 - (void) writeInBackgroundAndNotify: (NSData*)item;
 - (BOOL) writeInProgress;
+
 @end
 
 /**
diff --git a/Headers/Foundation/NSHTTPCookie.h b/Headers/Foundation/NSHTTPCookie.h
index 31377e1..d81154d 100644
--- a/Headers/Foundation/NSHTTPCookie.h
+++ b/Headers/Foundation/NSHTTPCookie.h
@@ -26,7 +26,7 @@
 #define __NSHTTPCookie_h_GNUSTEP_BASE_INCLUDE
 #import	<GNUstepBase/GSVersionMacros.h>
 
-#if OS_API_VERSION(100200,GS_API_LATEST) && GS_API_VERSION( 11300,GS_API_LATEST)
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_2,GS_API_LATEST) // FIXDEF! && GS_API_VERSION( 11300,GS_API_LATEST)
 
 #import	<Foundation/NSObject.h>
 
diff --git a/Headers/Foundation/NSHTTPCookieStorage.h b/Headers/Foundation/NSHTTPCookieStorage.h
index 9b8c757..4df73f5 100644
--- a/Headers/Foundation/NSHTTPCookieStorage.h
+++ b/Headers/Foundation/NSHTTPCookieStorage.h
@@ -26,7 +26,7 @@
 #define __NSHTTPCookieStorage_h_GNUSTEP_BASE_INCLUDE
 #import	<GNUstepBase/GSVersionMacros.h>
 
-#if OS_API_VERSION(100200,GS_API_LATEST) && GS_API_VERSION( 11300,GS_API_LATEST)
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_2,GS_API_LATEST) // FIXDEF! && GS_API_VERSION( 11300,GS_API_LATEST)
 
 #import	<Foundation/NSObject.h>
 
diff --git a/Headers/Foundation/NSIndexPath.h b/Headers/Foundation/NSIndexPath.h
index 1b22ab9..c5984be 100644
--- a/Headers/Foundation/NSIndexPath.h
+++ b/Headers/Foundation/NSIndexPath.h
@@ -35,7 +35,7 @@
 extern "C" {
 #endif
 
-#if OS_API_VERSION(100400,GS_API_LATEST) && GS_API_VERSION( 10200,GS_API_LATEST)
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_4,GS_API_LATEST) // FIXDEF! && GS_API_VERSION( 10200,GS_API_LATEST)
 
 /**
  * Instances of this class represent a series of indexes into a hierarchy
diff --git a/Headers/Foundation/NSIndexSet.h b/Headers/Foundation/NSIndexSet.h
index 51e7432..9ec5187 100644
--- a/Headers/Foundation/NSIndexSet.h
+++ b/Headers/Foundation/NSIndexSet.h
@@ -90,14 +90,14 @@ extern "C" {
  */
 - (NSUInteger) count;
 
-#if OS_API_VERSION(100500,GS_API_LATEST)
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_5,GS_API_LATEST)
 /** Not implemented
  * Returns the number of indexes set within the specified range.
  */
 - (NSUInteger) countOfIndexesInRange: (NSRange)range;
 #endif
 
-#if OS_API_VERSION(100600,GS_API_LATEST)
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_6,GS_API_LATEST)
 DEFINE_BLOCK_TYPE(GSIndexSetEnumerationBlock, void, NSUInteger, BOOL*);
 - (void)enumerateIndexesInRange: (NSRange)range
                         options: (NSEnumerationOptions)opts
diff --git a/Headers/Foundation/NSInvocation.h b/Headers/Foundation/NSInvocation.h
index 6a828db..b60f24a 100644
--- a/Headers/Foundation/NSInvocation.h
+++ b/Headers/Foundation/NSInvocation.h
@@ -26,9 +26,17 @@
 #ifndef __NSInvocation_h_GNUSTEP_BASE_INCLUDE
 #define __NSInvocation_h_GNUSTEP_BASE_INCLUDE
 #import	<GNUstepBase/GSVersionMacros.h>
-
 #import	<Foundation/NSMethodSignature.h>
 
+#if defined (NeXT_RUNTIME)
+# import <Foundation/NSArray.h>
+  typedef struct NSArgumentInfo
+  {
+    uint32_t offset;
+    uint32_t size;
+  } ArgumentInfo; // FIXME!
+#endif
+
 #if	defined(__cplusplus)
 extern "C" {
 #endif
@@ -36,29 +44,52 @@ extern "C" {
 @interface NSInvocation : NSObject
 {
 #if	GS_EXPOSE(NSInvocation)
+#if !defined (NeXT_RUNTIME)
 @public
   NSMethodSignature	*_sig;
-  void                  *_cframe;
-  void			*_retval;
-  id			_target;
-  SEL			_selector;
-  unsigned int		_numArgs;
-  void			*_info;
-  BOOL			_argsRetained;
-  BOOL                  _targetRetained;
-  BOOL			_validReturn;
-  BOOL			_sendToSuper;
-  void			*_retptr;
-#endif
-#if     GS_NONFRAGILE
+  void              *_cframe;
+  void              *_retval;
+  id                _target;
+  SEL               _selector;
+  unsigned int      _numArgs;
+  void              *_info;
+  BOOL              _argsRetained;
+  BOOL              _targetRetained;
+  BOOL              _validReturn;
+  BOOL              _sendToSuper;
+  void              *_retptr;
+#if GS_NONFRAGILE
 #else
   /* Pointer to private additional data used to avoid breaking ABI
    * when we don't have the non-fragile ABI available.
    * Use this mechanism rather than changing the instance variable
    * layout (see Source/GSInternal.h for details).
    */
-  @private id _internal GS_UNUSED_IVAR;
+@private id _internal GS_UNUSED_IVAR;
 #endif
+#else
+  void                *imp;
+  void                *arguments;
+  ArgumentInfo        *argumentInfo;
+  void                *result;
+  
+  uint32_t            stackSize;
+  uint32_t            resultSize;
+  /* 32bit instead of 8bit makes assembly a bit simpler */
+  uint32_t            resultStorage;
+  
+  uint8_t             argumentCount;
+  BOOL                retainArguments;
+  BOOL                ownResultBuffer;
+  BOOL                sendToSuper;
+  
+  NSMethodSignature   *signature;
+  NSMutableArray      *pool;
+  
+  uint32_t            retainedArguments;
+  BOOL                retainTarget;
+#endif /* NeXT_RUNTIME */
+#endif /* GS_EXPOSE */
 }
 
 /*
@@ -86,7 +117,7 @@ extern "C" {
 - (BOOL) argumentsRetained;
 - (void) retainArguments;
 
-#if OS_API_VERSION(GS_API_NONE,GS_API_NONE) && GS_API_VERSION( 11101,GS_API_LATEST)
+#if OS_API_VERSION(GS_API_NONE,GS_API_NONE) // FIXDEF! && GS_API_VERSION( 11101,GS_API_LATEST)
 - (BOOL) targetRetained;
 - (void) retainArgumentsIncludingTarget: (BOOL)retainTargetFlag;
 #endif
@@ -109,7 +140,7 @@ extern "C" {
 /**
  * Returns the status of the flag set by -setSendsToSuper:
  */
-- (BOOL) sendsToSuper;
+- (BOOL)sendsToSuper;
 /**
  * Sets the flag to tell the invocation that it should actually invoke a
  * method in the superclass of the target rather than the method of the
@@ -117,7 +148,18 @@ extern "C" {
  * This extension permits an invocation to act like a regular method
  * call sent to <em>super</em> in the method of a class.
  */
-- (void) setSendsToSuper: (BOOL)flag;
+- (void)setSendsToSuper:(BOOL)flag;
+
+- (id)initWithMethodSignature:(NSMethodSignature *)aSignature;
+- (BOOL)encodeWithDistantCoder:(NSCoder *)coder passPointers:(BOOL)passp;
+
+#if defined (NeXT_RUNTIME)
++ (NSInvocation *)invocationWithMethodSignature:(NSMethodSignature *)signature
+                                      arguments:(void *)arguments;
+- (void)setImplementation:(IMP)imp;
+- (void)returnResult;
+#endif
+
 @end
 #endif
 
diff --git a/Headers/Foundation/NSKeyValueObserving.h b/Headers/Foundation/NSKeyValueObserving.h
index 53ce854..10ac2e9 100644
--- a/Headers/Foundation/NSKeyValueObserving.h
+++ b/Headers/Foundation/NSKeyValueObserving.h
@@ -26,7 +26,7 @@
 #define __NSKeyValueObserving_h_GNUSTEP_BASE_INCLUDE
 #import	<GNUstepBase/GSVersionMacros.h>
 
-#if OS_API_VERSION(100300,GS_API_LATEST) && GS_API_VERSION( 10200,GS_API_LATEST)
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_3,GS_API_LATEST) // FIXDEF! && GS_API_VERSION( 10200,GS_API_LATEST)
 
 #import	<Foundation/NSObject.h>
 #import	<Foundation/NSArray.h>
@@ -42,7 +42,7 @@ extern "C" {
 enum {
   NSKeyValueObservingOptionNew = 1,
   NSKeyValueObservingOptionOld = 2
-#if OS_API_VERSION(100500,GS_API_LATEST)
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_5,GS_API_LATEST)
 ,  NSKeyValueObservingOptionInitial = 4,
   NSKeyValueObservingOptionPrior = 8
 #endif
@@ -69,7 +69,7 @@ GS_EXPORT NSString *const NSKeyValueChangeIndexesKey;
 GS_EXPORT NSString *const NSKeyValueChangeKindKey;
 GS_EXPORT NSString *const NSKeyValueChangeNewKey;
 GS_EXPORT NSString *const NSKeyValueChangeOldKey;
-#if OS_API_VERSION(100500,GS_API_LATEST)
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_5,GS_API_LATEST)
 GS_EXPORT NSString *const NSKeyValueChangeNotificationIsPriorKey;
 #endif
 
@@ -130,13 +130,10 @@ GS_EXPORT NSString *const NSKeyValueChangeNotificationIsPriorKey;
 
 @interface NSObject (NSKeyValueObserverRegistration)
 
-- (void) addObserver: (NSObject*)anObserver
-	  forKeyPath: (NSString*)aPath
-	     options: (NSKeyValueObservingOptions)options
-	     context: (void*)aContext;
+- (void)addObserver:(NSObject*)anObserver forKeyPath:(NSString*)aPath options:(NSKeyValueObservingOptions)options context:(void*)aContext;
 
-- (void) removeObserver: (NSObject*)anObserver
-	     forKeyPath: (NSString*)aPath;
+- (void)removeObserver:(NSObject *)anObserver forKeyPath:(NSString *)keyPath;
+- (void)removeObserver:(NSObject *)anObserver forKeyPath:(NSString *)keyPath context:(void *)context;
 
 @end
 
@@ -180,7 +177,7 @@ GS_EXPORT NSString *const NSKeyValueChangeNotificationIsPriorKey;
     valuesAtIndexes: (NSIndexSet*)indexes
 	     forKey: (NSString*)aKey;
 
-#if OS_API_VERSION(100400,GS_API_LATEST)
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_4,GS_API_LATEST)
 
 /** <override-dummy />
  */
@@ -209,29 +206,30 @@ GS_EXPORT NSString *const NSKeyValueChangeNotificationIsPriorKey;
  * class receive messages to change the value for the key.<br />
  * The default implementation returns YES.
  */
-+ (BOOL) automaticallyNotifiesObserversForKey: (NSString*)aKey;
++ (BOOL)automaticallyNotifiesObserversForKey:(NSString *)aKey;
 
-/**
- * Tells the observing system that when NSKeyValueObserverNotification
- * protocol messages are sent for any key in the triggerKeys array,
- * they should also be sent for dependentKey.
- */
-+ (void) setKeys: (NSArray*)triggerKeys
-triggerChangeNotificationsForDependentKey: (NSString*)dependentKey;
++ (NSSet *)keyPathsForValuesAffectingValueForKey:(NSString *)aKey;
 
 /**
  * Returns a reference to the observation information for the receiver
  * as stored using the -setObservationInfo: method.<br />
  * The default implementation returns information from a global table.
  */
-- (void*) observationInfo;
+- (void*)observationInfo;
 
 /**
  * Stores observation information for the receiver.  By default this is
  * done in a global table, but classes may implement storage in an instance
  * variable or some other scheme (for improved performance).
  */
-- (void) setObservationInfo: (void*)observationInfo;
+- (void)setObservationInfo:(void *)observationInfo;
+
+/**
+ * Tells the observing system that when NSKeyValueObserverNotification
+ * protocol messages are sent for any key in the triggerKeys array,
+ * they should also be sent for dependentKey.
+ */
++ (void)setKeys:(NSArray *)triggerKeys triggerChangeNotificationsForDependentKey:(NSString *)dependentKey;
 
 @end
 
diff --git a/Headers/Foundation/NSKeyedArchiver.h b/Headers/Foundation/NSKeyedArchiver.h
index a026a06..ed972b5 100644
--- a/Headers/Foundation/NSKeyedArchiver.h
+++ b/Headers/Foundation/NSKeyedArchiver.h
@@ -409,6 +409,13 @@ extern "C" {
 - (id) _decodePropertyListForKey: (NSString*)aKey;
 @end
 
+/* Dirty hack and should be removed */
+@interface NSKeyedUnarchiver (GNUstepGUI)
+/**
+ * This method is used by GSNibLoading
+ */
+- (BOOL)replaceObject:(id)anObject withObject:(id)newObject;
+@end
 
 /* Exceptions */
 GS_EXPORT NSString * const NSInvalidArchiveOperationException;
diff --git a/Headers/Foundation/NSLock.h b/Headers/Foundation/NSLock.h
index 4c3cd01..f3843dc 100644
--- a/Headers/Foundation/NSLock.h
+++ b/Headers/Foundation/NSLock.h
@@ -98,7 +98,7 @@ extern "C" {
  */
 - (void) unlock;
 
-#if OS_API_VERSION(100500,GS_API_LATEST) 
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_5,GS_API_LATEST) 
 /** Return the name of the receiver or nil of none has been set.
  */
 - (NSString*) name;
@@ -168,7 +168,7 @@ extern "C" {
 #if	GS_EXPOSE(NSConditionLock)
 @private
   NSCondition *_condition;
-  int   _condition_value;
+  NSInteger   _condition_value;
   NSString      *_name;
 #endif
 }
@@ -236,7 +236,7 @@ extern "C" {
  */
 - (void) unlock;
 
-#if OS_API_VERSION(100500,GS_API_LATEST) 
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_5,GS_API_LATEST) 
 /** Return the name of the receiver or nil of none has been set.
  */
 - (NSString*) name;
@@ -286,7 +286,7 @@ extern "C" {
  */
 - (void) unlock;
 
-#if OS_API_VERSION(100500,GS_API_LATEST) 
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_5,GS_API_LATEST) 
 /** Return the name of the receiver or nil of none has been set.
  */
 - (NSString*) name;
diff --git a/Headers/Foundation/NSNetServices.h b/Headers/Foundation/NSNetServices.h
index 5739be2..ce9b624 100644
--- a/Headers/Foundation/NSNetServices.h
+++ b/Headers/Foundation/NSNetServices.h
@@ -337,7 +337,7 @@ GS_EXPORT NSString * const NSNetServicesErrorDomain;
  * </p>
  */
 
-@interface NSNetService : NSObject
+@interface NSNetService : NSObject <NSNetServiceDelegate>
 {
 #if	GS_EXPOSE(NSNetService)
   id		_delegate;
@@ -362,7 +362,7 @@ GS_EXPORT NSString * const NSNetServicesErrorDomain;
 - (void) scheduleInRunLoop: (NSRunLoop *) aRunLoop
                    forMode: (NSString *) mode;
 
-#if OS_API_VERSION(100500,GS_API_LATEST) 
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_5,GS_API_LATEST) 
 - (NSInteger) port;
 
 - (void) publishWithOptions: (NSNetServiceOptions)options;
@@ -423,7 +423,7 @@ GS_EXPORT NSString * const NSNetServicesErrorDomain;
  * </p>
  */
 
-@interface NSNetServiceBrowser : NSObject
+@interface NSNetServiceBrowser : NSObject<NSNetServiceBrowserDelegate>
 {
 #if	GS_EXPOSE(NSNetServiceBrowser)
   id		_delegate;
diff --git a/Headers/Foundation/NSObjCRuntime.h b/Headers/Foundation/NSObjCRuntime.h
index a63f38c..8ed7c8f 100644
--- a/Headers/Foundation/NSObjCRuntime.h
+++ b/Headers/Foundation/NSObjCRuntime.h
@@ -30,149 +30,252 @@
 #define __NSObjCRuntime_h_GNUSTEP_BASE_INCLUDE
 
 #ifdef __cplusplus
-#ifndef __STDC_LIMIT_MACROS
-#define __STDC_LIMIT_MACROS 1
-#endif
+#  ifndef __STDC_LIMIT_MACROS
+#    define __STDC_LIMIT_MACROS 1
+#  endif
 #endif
 
-#include <stdarg.h>
-#include <stdint.h>
-#include <limits.h>
-#include <float.h>
+/* ToDo: remove this hack and supply TargetConditionals.h for other platofrms */
+#if !defined (TARGET_OS_WIN32)
+#  if defined (GNUSTEP_WITH_DLL)
+#    define TARGET_OS_WIN32 1
+#  else
+#    define TARGET_OS_WIN32 0
+#  endif
+#endif
 
-#import	<GNUstepBase/GSVersionMacros.h>
-#import	<GNUstepBase/GSConfig.h>
-#import	<GNUstepBase/GSBlocks.h>
+/* ToDo: remove this hack and specify NSBUILDINGFOUNDATION when building */
+#if !defined (NSBUILDINGFOUNDATION)
+#  if defined (BUILD_libgnustep_base_DLL)
+#    define NSBUILDINGFOUNDATION 1
+#  else
+#    define NSBUILDINGFOUNDATION 0
+#  endif
+#endif
 
-/* These typedefs must be in place before GSObjCRuntime.h is imported.
- */
+#if defined(__cplusplus)
+#  define FOUNDATION_EXTERN extern "C"
+#else
+#  define FOUNDATION_EXTERN extern
+#endif
 
-#if     !defined(NSINTEGER_DEFINED)
-typedef	intptr_t	NSInteger;
-typedef	uintptr_t	NSUInteger;
-#	define NSIntegerMax  INTPTR_MAX
-#	define NSIntegerMin  INTPTR_MIN
-#	define NSUIntegerMax UINTPTR_MAX
-#endif /* !defined(NSINTEGER_DEFINED) */
-
-#if     !defined(CGFLOAT_DEFINED)
-#if     GS_SIZEOF_VOIDP == 8
-#define CGFLOAT_IS_DBL  1
-typedef double          CGFloat;
-#define CGFLOAT_MIN	DBL_MIN
-#define CGFLOAT_MAX	DBL_MAX
+#if TARGET_OS_WIN32
+#  if defined(NSBUILDINGFOUNDATION)
+#    define FOUNDATION_EXPORT FOUNDATION_EXTERN __declspec(dllexport)
+#  else
+#    define FOUNDATION_EXPORT FOUNDATION_EXTERN __declspec(dllimport)
+#  endif
+#  define FOUNDATION_IMPORT FOUNDATION_EXTERN __declspec(dllimport)
 #else
-typedef float           CGFloat;
-#define CGFLOAT_MIN	FLT_MIN
-#define CGFLOAT_MAX	FLT_MAX
+#  define FOUNDATION_EXPORT FOUNDATION_EXTERN
+#  define FOUNDATION_IMPORT FOUNDATION_EXTERN
+#endif
+
+#if !defined (FOUNDATION_STATIC_INLINE)
+#  define FOUNDATION_STATIC_INLINE static __inline__
+#endif
+
+#if !defined (FOUNDATION_EXTERN_INLINE)
+#  define FOUNDATION_EXTERN_INLINE extern __inline__
+#endif
+
+#if !defined(NS_FORMAT_FUNCTION)
+#  if defined (__GNUC__) && (__GNUC__ * 10 + __GNUC_MINOR__ >= 42)
+#    define NS_FORMAT_FUNCTION(F,A) __attribute__((format(__NSString__, F, A)))
+#  else
+#    define NS_FORMAT_FUNCTION(F,A)
+#  endif
+#endif
+
+#if !defined(NS_FORMAT_ARGUMENT)
+#  if defined (__GNUC__) && (__GNUC__ * 10 + __GNUC_MINOR__ >= 42)
+#    define NS_FORMAT_ARGUMENT(A) __attribute__ ((format_arg(A)))
+#  else
+#    define NS_FORMAT_ARGUMENT(A)
+#  endif
+#endif
+
+#ifndef __has_feature
+#  define __has_feature(x) 0
+#endif
+
+#ifndef NS_RETURNS_RETAINED
+#  if __has_feature(attribute_ns_returns_retained)
+#    define NS_RETURNS_RETAINED __attribute__((ns_returns_retained))
+#  else
+#    define NS_RETURNS_RETAINED
+#  endif
+#endif
+
+#ifndef NS_RETURNS_NOT_RETAINED
+#  if __has_feature(attribute_ns_returns_not_retained)
+#    define NS_RETURNS_NOT_RETAINED __attribute__((ns_returns_not_retained))
+#  else
+#    define NS_RETURNS_NOT_RETAINED
+#  endif
+#endif
+
+#ifndef NS_CONSUMED
+#  if __has_feature(attribute_ns_consumed)
+#    define NS_CONSUMED __attribute__((ns_consumed))
+#  else
+#    define NS_CONSUMED
+#  endif
+#endif
+
+#ifndef NS_CONSUMES_SELF
+#  if __has_feature(attribute_ns_consumes_self)
+#    define NS_CONSUMES_SELF __attribute__((ns_consumes_self))
+#  else
+#    define NS_CONSUMES_SELF
+#  endif
+#endif
+
+#if !defined(NS_INLINE)
+#  if defined(__GNUC__)
+#    define NS_INLINE static __inline__ __attribute__((always_inline))
+#  elif defined(__cplusplus) || defined(__MWERKS__)
+#    define NS_INLINE static inline
+#  elif defined(_MSC_VER)
+#    define NS_INLINE static __inline
+#  else
+#    define NS_INLINE inline
+#  endif
 #endif
-#endif /* !defined(CGFLOAT_DEFINED) */
 
-#define NSINTEGER_DEFINED 1
-#define CGFLOAT_DEFINED 1
 #ifndef NS_AUTOMATED_REFCOUNT_UNAVAILABLE
 #  if __has_feature(objc_arc)
-#    define NS_AUTOMATED_REFCOUNT_UNAVAILABLE \
-      __attribute__((unavailable("Not available with automatic reference counting")))
+#    define NS_AUTOMATED_REFCOUNT_UNAVAILABLE __attribute__((unavailable("Not available with automatic reference counting")))
 #  else
 #    define NS_AUTOMATED_REFCOUNT_UNAVAILABLE
 #  endif
 #endif
 
+#if defined (__clang__)
+#  define NS_REQUIRES_NIL_TERMINATION __attribute__((sentinel))
+#else
+#  define NS_REQUIRES_NIL_TERMINATION
+#endif
 
-#if	defined(__cplusplus)
-extern "C" {
+#import <objc/objc.h>
+#include <stdarg.h>
+#include <stdint.h>
+#include <limits.h>
+#include <float.h>
+
+FOUNDATION_EXPORT double NSFoundationVersionNumber;
+
+#if !defined(NSINTEGER_DEFINED)
+typedef	intptr_t	NSInteger;
+typedef	uintptr_t	NSUInteger;
 #endif
 
+#if !defined(NSINTEGER_DEFINED)
+#  define NSIntegerMax  INTPTR_MAX
+#  define NSIntegerMin  INTPTR_MIN
+#  define NSUIntegerMax UINTPTR_MAX
+#  define NSINTEGER_DEFINED 1
+#endif 
+
+#import	<GNUstepBase/GSVersionMacros.h>
+#import	<GNUstepBase/GSConfig.h>
+#import	<GNUstepBase/GSBlocks.h>
+
+#if !defined(CGFLOAT_DEFINED)
+#  if GS_SIZEOF_VOIDP == 8
+#    define CGFLOAT_IS_DBL 1
+typedef double CGFloat;
+#    define CGFLOAT_MIN DBL_MIN
+#    define CGFLOAT_MAX DBL_MAX
+#  else
+typedef float CGFloat;
+#    define CGFLOAT_MIN FLT_MIN
+#    define CGFLOAT_MAX FLT_MAX
+#  endif
+#  define CGFLOAT_DEFINED 1
+#endif /* CGFLOAT_DEFINED */
+
 enum
 {
-  NSEnumerationConcurrent = (1UL << 0), /** Specifies that the enumeration
-   * is concurrency-safe.  Note that this does not mean that it will be
-   * carried out in a concurrent manner, only that it can be.
-   */
-
-  NSEnumerationReverse = (1UL << 1) /** Specifies that the enumeration should
-   * happen in the opposite of the natural order of the collection.
-   */
+    /**
+     * Specifies that the enumeration
+     * is concurrency-safe.  Note that this does not mean that it will be
+     * carried out in a concurrent manner, only that it can be.
+     */
+    NSEnumerationConcurrent = (1UL << 0), 
+    /**
+     * Specifies that the enumeration should
+     * happen in the opposite of the natural order of the collection.
+     */
+    NSEnumerationReverse = (1UL << 1) 
 };
-
-/** Bitfield used to specify options to control enumeration over collections.
+/**
+ * Bitfield used to specify options to control enumeration over collections.
  */
 typedef NSUInteger NSEnumerationOptions;
 
 enum
 {
-    NSSortConcurrent = (1UL << 0), /** Specifies that the sort
+    /** 
+     * Specifies that the sort
      * is concurrency-safe.  Note that this does not mean that it will be
      * carried out in a concurrent manner, only that it can be.
      */
-    NSSortStable = (1UL << 4), /** Specifies that the sort should keep
+    NSSortConcurrent = (1UL << 0),
+    /**
+     * Specifies that the sort should keep
      * equal objects in the same order in the collection.
      */
+    NSSortStable = (1UL << 4), 
 };
-
-/** Bitfield used to specify options to control the sorting of collections.
+/** 
+ * Bitfield used to specify options to control the sorting of collections.
  */
 typedef NSUInteger NSSortOptions;
 
-#import <GNUstepBase/GSObjCRuntime.h>
-
-#if OS_API_VERSION(100500,GS_API_LATEST)
-GS_EXPORT NSString	*NSStringFromProtocol(Protocol *aProtocol);
-GS_EXPORT Protocol	*NSProtocolFromString(NSString *aProtocolName);
-#endif
-GS_EXPORT SEL		NSSelectorFromString(NSString *aSelectorName);
-GS_EXPORT NSString	*NSStringFromSelector(SEL aSelector);
-GS_EXPORT SEL		NSSelectorFromString(NSString *aSelectorName);
-GS_EXPORT Class		NSClassFromString(NSString *aClassName);
-GS_EXPORT NSString	*NSStringFromClass(Class aClass);
-GS_EXPORT const char	*NSGetSizeAndAlignment(const char *typePtr,
-  NSUInteger *sizep, NSUInteger *alignp);
-
-#if OS_API_VERSION(GS_API_NONE, GS_API_NONE)
-/* Logging */
-/**
- *  OpenStep spec states that log messages go to stderr, but just in case
- *  someone wants them to go somewhere else, they can implement a function
- *  like this and assign a pointer to it to _NSLog_printf_handler.
- */
-typedef void NSLog_printf_handler (NSString* message);
-GS_EXPORT NSLog_printf_handler	*_NSLog_printf_handler;
-GS_EXPORT int	_NSLogDescriptor;
-@class NSRecursiveLock;
-GS_EXPORT NSRecursiveLock	*GSLogLock(void);
-#endif
-
-GS_EXPORT void			NSLog (NSString *format, ...);
-GS_EXPORT void			NSLogv (NSString *format, va_list args);
+@class Protocol, NSString;
 
-#ifndef YES
-#define YES		1
-#endif
-#ifndef NO
-#define NO		0
-#endif
-#ifndef nil
-#define nil		0
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_5, GS_API_LATEST)
+FOUNDATION_EXPORT NSString *NSStringFromProtocol(Protocol *aProtocol);
+FOUNDATION_EXPORT Protocol *NSProtocolFromString(NSString *aProtocolName);
 #endif
+    
+FOUNDATION_EXPORT SEL       NSSelectorFromString(NSString *aSelectorName);
+FOUNDATION_EXPORT NSString  *NSStringFromSelector(SEL aSelector);
+    
+FOUNDATION_EXPORT Class     NSClassFromString(NSString *aClassName);
+FOUNDATION_EXPORT NSString  *NSStringFromClass(Class aClass);
+    
+FOUNDATION_EXPORT const char *NSGetSizeAndAlignment(const char *typePtr, NSUInteger *sizep, NSUInteger *alignp);
+
+FOUNDATION_EXPORT void NSLog(NSString *format, ...) NS_FORMAT_FUNCTION(1,2);
+FOUNDATION_EXPORT void NSLogv(NSString *format, va_list args) NS_FORMAT_FUNCTION(1,0);
 
 /**
  * Contains values <code>NSOrderedSame</code>, <code>NSOrderedAscending</code>
  * <code>NSOrderedDescending</code>, for left hand side equals, less than, or
  * greater than right hand side.
  */
-typedef enum _NSComparisonResult
+enum _NSComparisonResult
 {
-  NSOrderedAscending = -1, NSOrderedSame, NSOrderedDescending
-}
-NSComparisonResult;
+    NSOrderedAscending = -1, NSOrderedSame, NSOrderedDescending
+};
+typedef NSInteger NSComparisonResult;
 
 enum {NSNotFound = NSIntegerMax};
 
 DEFINE_BLOCK_TYPE(NSComparator, NSComparisonResult, id, id);
 
-#if	defined(__cplusplus)
-}
+#if !defined (YES)
+#  define YES (BOOL)1
+#endif
+
+#if !defined (NO)
+#  define NO (BOOL)0
+#endif
+
+#if !defined (nil)
+#  define nil 0
 #endif
 
-#endif /* __NSObjCRuntime_h_GNUSTEP_BASE_INCLUDE */
+#endif /* __NSObjCRuntime_h_GNUSTEP_BASE_INCLUDE */
\ No newline at end of file
diff --git a/Headers/Foundation/NSObject.h b/Headers/Foundation/NSObject.h
index 9ec4854..eccd73d 100644
--- a/Headers/Foundation/NSObject.h
+++ b/Headers/Foundation/NSObject.h
@@ -28,7 +28,6 @@
 #define __NSObject_h_GNUSTEP_BASE_INCLUDE
 
 #import	<Foundation/NSObjCRuntime.h>
-#import <objc/objc.h>
 #import	<Foundation/NSZone.h>
 
 #ifndef	GS_WITH_GC
diff --git a/Headers/Foundation/NSOperation.h b/Headers/Foundation/NSOperation.h
index ca47f08..24e47fa 100644
--- a/Headers/Foundation/NSOperation.h
+++ b/Headers/Foundation/NSOperation.h
@@ -28,13 +28,13 @@
 #define __NSOperation_h_GNUSTEP_BASE_INCLUDE
 
 #import <Foundation/NSObject.h>
-#if OS_API_VERSION(100500, GS_API_LATEST)
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_5, GS_API_LATEST)
 
 #if	defined(__cplusplus)
 extern "C" {
 #endif
 
-#if OS_API_VERSION(100600, GS_API_LATEST)
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_6, GS_API_LATEST)
 #import <GNUstepBase/GSBlocks.h>
 DEFINE_BLOCK_TYPE_NO_ARGS(GSOperationCompletionBlock, void);
 #endif
@@ -82,7 +82,7 @@ typedef NSInteger NSOperationQueuePriority;
  */
 - (void) cancel;
 
-#if OS_API_VERSION(100600, GS_API_LATEST)
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_6, GS_API_LATEST)
 /**
  * Returns the block that will be executed after the operation finishes.
  */
@@ -147,7 +147,7 @@ typedef NSInteger NSOperationQueuePriority;
  */
 - (void) removeDependency: (NSOperation *)op;
 
-#if OS_API_VERSION(100600, GS_API_LATEST)
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_6, GS_API_LATEST)
 /**
  * Sets the block that will be executed when the operation has finished.
  */
@@ -160,7 +160,7 @@ typedef NSInteger NSOperationQueuePriority;
  */
 - (void) setQueuePriority: (NSOperationQueuePriority)priority;
 
-#if OS_API_VERSION(100600, GS_API_LATEST)
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_6, GS_API_LATEST)
 /** Sets the thread priority to be used while executing then -main method.
  * The priority change is implemented in the -start method, so if you are
  * replacing -start you are responsible for managing this.<br />
@@ -184,7 +184,7 @@ typedef NSInteger NSOperationQueuePriority;
  */
 - (void) start;
 
-#if OS_API_VERSION(100600, GS_API_LATEST)
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_6, GS_API_LATEST)
 /** Returns the thread priority to be used executing the -main method.
  * The default is 0.5
  */
@@ -219,7 +219,7 @@ enum {
 @private id _internal;
 #endif
 }
-#if OS_API_VERSION(100600, GS_API_LATEST)
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_6, GS_API_LATEST)
 /** If called from within the -main method of an operation which is
  * currently being executed by a queue, this returns the queue instance
  * in use.
@@ -235,7 +235,7 @@ enum {
  */
 - (void) addOperation: (NSOperation *)op;
 
-#if OS_API_VERSION(100600, GS_API_LATEST)
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_6, GS_API_LATEST)
 /** Adds multiple operations to the receiver and (optionally) waits for
  * all the operations in the queue to finish.
  */
@@ -257,7 +257,7 @@ enum {
  */
 - (NSInteger) maxConcurrentOperationCount;
 
-#if OS_API_VERSION(100600, GS_API_LATEST)
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_6, GS_API_LATEST)
 /** Return the name of this operation queue.
  */
 - (NSString*) name;
@@ -278,7 +278,7 @@ enum {
  */
 - (void) setMaxConcurrentOperationCount: (NSInteger)cnt;
 
-#if OS_API_VERSION(100600, GS_API_LATEST)
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_6, GS_API_LATEST)
 /** Sets the name for this operation queue.
  */
 - (void) setName: (NSString*)s;
diff --git a/Headers/Foundation/NSPathUtilities.h b/Headers/Foundation/NSPathUtilities.h
index 103195a..5673018 100644
--- a/Headers/Foundation/NSPathUtilities.h
+++ b/Headers/Foundation/NSPathUtilities.h
@@ -27,7 +27,8 @@
 #ifndef __NSPathUtilities_h_GNUSTEP_BASE_INCLUDE
 #define __NSPathUtilities_h_GNUSTEP_BASE_INCLUDE
 #import	<GNUstepBase/GSVersionMacros.h>
-#import	<Foundation/NSObjCRuntime.h>
+#import	<Foundation/NSString.h>
+#import	<Foundation/NSArray.h>
 
 #if	defined(__cplusplus)
 extern "C" {
@@ -116,18 +117,18 @@ enum
   NSDeveloperDirectory,			/** Developer */
   NSUserDirectory,			/** user home directories */
   NSDocumentationDirectory,		/** Documentation */
-#if OS_API_VERSION(100200, GS_API_LATEST)
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_2, GS_API_LATEST)
   NSDocumentDirectory,			/** Documents */
 #endif
-#if OS_API_VERSION(100300, GS_API_LATEST)
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_3, GS_API_LATEST)
   NSCoreServicesDirectory,		/** CoreServices */
 #endif
-#if OS_API_VERSION(100400, GS_API_LATEST)
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_4, GS_API_LATEST)
   NSDesktopDirectory = 12,		/** location of users desktop */
   NSCachesDirectory = 13,		/** location of users cache files */
   NSApplicationSupportDirectory = 14,	/** location of app support files */
 #endif
-#if OS_API_VERSION(100500, GS_API_LATEST)
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_5, GS_API_LATEST)
   NSDownloadsDirectory = 15,	        /** location of downloaded files */
 #endif
 
diff --git a/Headers/Foundation/NSPointerArray.h b/Headers/Foundation/NSPointerArray.h
index 8d87bf6..af5bca9 100644
--- a/Headers/Foundation/NSPointerArray.h
+++ b/Headers/Foundation/NSPointerArray.h
@@ -30,7 +30,7 @@
 #import <Foundation/NSArray.h>
 #import <Foundation/NSPointerFunctions.h>
 
-#if OS_API_VERSION(100500, GS_API_LATEST)
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_5, GS_API_LATEST)
 
 #if	defined(__cplusplus)
 extern "C" {
diff --git a/Headers/Foundation/NSPointerFunctions.h b/Headers/Foundation/NSPointerFunctions.h
index 5ce2d1f..ba0db2b 100644
--- a/Headers/Foundation/NSPointerFunctions.h
+++ b/Headers/Foundation/NSPointerFunctions.h
@@ -28,7 +28,7 @@
 
 #import	<Foundation/NSObject.h>
 
-#if OS_API_VERSION(100500, GS_API_LATEST)
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_5, GS_API_LATEST)
 
 #if	defined(__cplusplus)
 extern "C" {
diff --git a/Headers/Foundation/NSPortCoder.h b/Headers/Foundation/NSPortCoder.h
index f9d8844..abf6a06 100644
--- a/Headers/Foundation/NSPortCoder.h
+++ b/Headers/Foundation/NSPortCoder.h
@@ -78,7 +78,7 @@ extern "C" {
 // Decoding
   id			_src;		/* Deserialization source.	*/
   IMP			_dDesImp;	/* Method to deserialize with.	*/
-  void			(*_dTagImp)(id,SEL,unsigned char*,unsigned*,unsigned*);
+  void			(*_dTagImp)(id,SEL,unsigned char*,unsigned*,NSUInteger*);
   IMP			_dValImp;	/* Method to decode data with.	*/
 #ifndef	_IN_PORT_CODER_M
 #define	GSIArray	void*
@@ -90,7 +90,7 @@ extern "C" {
 #undef	GSIArray
 #endif
   NSMutableDictionary	*_cInfo;	/* Class version information.	*/
-  unsigned		_cursor;	/* Position in data buffer.	*/
+  NSUInteger		_cursor;	/* Position in data buffer.	*/
   unsigned		_version;	/* Version of archiver used.	*/
   NSZone		*_zone;		/* Zone for allocating objs.	*/
 #endif
diff --git a/Headers/Foundation/NSPredicate.h b/Headers/Foundation/NSPredicate.h
index 7e94e08..2c4527e 100644
--- a/Headers/Foundation/NSPredicate.h
+++ b/Headers/Foundation/NSPredicate.h
@@ -26,7 +26,7 @@
 #define __NSPredicate_h_GNUSTEP_BASE_INCLUDE
 #import	<GNUstepBase/GSVersionMacros.h>
 
-#if	OS_API_VERSION(100400, GS_API_LATEST)
+#if	OS_API_VERSION(MAC_OS_X_VERSION_10_4, GS_API_LATEST)
 
 #import	<Foundation/NSObject.h>
 #import	<Foundation/NSArray.h>
diff --git a/Headers/Foundation/NSProcessInfo.h b/Headers/Foundation/NSProcessInfo.h
index 7e44c4a..fd20a97 100644
--- a/Headers/Foundation/NSProcessInfo.h
+++ b/Headers/Foundation/NSProcessInfo.h
@@ -166,7 +166,7 @@ enum {
  * Returns a human readable version string for the current operating system
  * version.
  */
-#if OS_API_VERSION(100200,GS_API_LATEST)
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_2,GS_API_LATEST)
 - (NSString *) operatingSystemVersionString;
 #endif
 
@@ -189,7 +189,7 @@ enum {
  */
 - (void) setProcessName: (NSString*)newName;
 
-#if OS_API_VERSION(100500,GS_API_LATEST) 
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_5,GS_API_LATEST) 
 /** Not implemented */
 - (NSUInteger) processorCount;
 /** Not implemented */
diff --git a/Headers/Foundation/NSPropertyList.h b/Headers/Foundation/NSPropertyList.h
index 2441356..83bcb9f 100644
--- a/Headers/Foundation/NSPropertyList.h
+++ b/Headers/Foundation/NSPropertyList.h
@@ -65,7 +65,7 @@ enum {
   NSPropertyListGNUstepBinaryFormat
 };
 
-#if OS_API_VERSION(100600,GS_API_LATEST)
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_6,GS_API_LATEST)
 typedef NSUInteger NSPropertyListWriteOptions;
 typedef NSUInteger NSPropertyListReadOptions;
 @class NSError;
@@ -261,7 +261,7 @@ typedef NSUInteger NSPropertyListFormat;
 		     format: (NSPropertyListFormat*)aFormat
 	   errorDescription: (NSString**)anErrorString;
 
-#if OS_API_VERSION(100600,GS_API_LATEST)
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_6,GS_API_LATEST)
 + (NSData *) dataWithPropertyList: (id)aPropertyList
                            format: (NSPropertyListFormat)aFormat
                           options: (NSPropertyListWriteOptions)anOption
diff --git a/Headers/Foundation/NSProxy.h b/Headers/Foundation/NSProxy.h
index 92de37b..bdc6349 100644
--- a/Headers/Foundation/NSProxy.h
+++ b/Headers/Foundation/NSProxy.h
@@ -36,13 +36,6 @@ GS_ROOT_CLASS @interface NSProxy <NSObject>
 {
 @public
     Class	isa;
-#if !(GS_NONFRAGILE == 1)
-@private
-	/**
-	 * Legacy compatibility ivar.  Remove in the next ABI-breaking release.
-	 */
-    NSUInteger	_retain_count;
-#endif
 }
 
 + (id) alloc;
@@ -55,6 +48,7 @@ GS_ROOT_CLASS @interface NSProxy <NSObject>
 /** <override-dummy />
  */
 + (void) load;
++ (void) initialize;
 /** <override-dummy />
  */
 + (oneway void) release;
diff --git a/Headers/Foundation/NSRange.h b/Headers/Foundation/NSRange.h
index 882984e..39bd8f2 100644
--- a/Headers/Foundation/NSRange.h
+++ b/Headers/Foundation/NSRange.h
@@ -35,7 +35,6 @@ extern "C" {
 #endif
 
 @class NSException;
-@class NXConstantString;
 
 /**** Type, Constant, and Macro Definitions **********************************/
 
diff --git a/Headers/Foundation/NSScanner.h b/Headers/Foundation/NSScanner.h
index d642900..a3b61dd 100644
--- a/Headers/Foundation/NSScanner.h
+++ b/Headers/Foundation/NSScanner.h
@@ -110,7 +110,7 @@ extern "C" {
 #if OS_API_VERSION(GS_API_MACOSX, GS_API_LATEST)
 - (BOOL) scanDecimal: (NSDecimal*)value;
 #endif
-#if OS_API_VERSION(100500, GS_API_LATEST)
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_5, GS_API_LATEST)
 /** Not implemented */
 - (BOOL) scanHexDouble: (double *)result;
 /** Not implemented */
diff --git a/Headers/Foundation/NSSerialization.h b/Headers/Foundation/NSSerialization.h
index 44d04a6..c8adc96 100644
--- a/Headers/Foundation/NSSerialization.h
+++ b/Headers/Foundation/NSSerialization.h
@@ -51,7 +51,7 @@ extern "C" {
 - (void) deserializeObjectAt: (id*)object
 		  ofObjCType: (const char *)type
 		    fromData: (NSData*)data
-		    atCursor: (unsigned*)cursor;
+		    atCursor: (NSUInteger*)cursor;
 
 /**
  *  Encode the given object of given type into data, using a string not a
@@ -139,7 +139,7 @@ extern "C" {
  *  +propertyListFromData:mutabilityOption:format:errorDescription:].</em>
  */
 + (id) deserializePropertyListFromData: (NSData*)data
-			      atCursor: (unsigned int*)cursor
+			      atCursor: (NSUInteger*)cursor
 		     mutableContainers: (BOOL)flag;
 
 /**
@@ -162,8 +162,8 @@ extern "C" {
  *  +propertyListFromData:mutabilityOption:format:errorDescription:].</em>
  */
 + (id) deserializePropertyListLazilyFromData: (NSData*)data
-				    atCursor: (unsigned*)cursor
-				      length: (unsigned)length
+				    atCursor: (NSUInteger*)cursor
+				      length: (NSUInteger)length
 			   mutableContainers: (BOOL)flag;
 
 @end
diff --git a/Headers/Foundation/NSSet.h b/Headers/Foundation/NSSet.h
index 51ba07e..12844aa 100644
--- a/Headers/Foundation/NSSet.h
+++ b/Headers/Foundation/NSSet.h
@@ -80,7 +80,7 @@ extern "C" {
 - (id) member: (id)anObject;
 - (NSEnumerator*) objectEnumerator;
 
-#if OS_API_VERSION(100600, GS_API_LATEST)
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_6, GS_API_LATEST)
 
 DEFINE_BLOCK_TYPE(GSSetEnumeratorBlock, void, id, BOOL*);
 DEFINE_BLOCK_TYPE(GSSetFilterBlock, BOOL, id, BOOL*);
@@ -113,7 +113,7 @@ DEFINE_BLOCK_TYPE(GSSetFilterBlock, BOOL, id, BOOL*);
 
 #endif
 
-#if OS_API_VERSION(100500,GS_API_LATEST) 
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_5,GS_API_LATEST) 
 - (NSSet *) setByAddingObject: (id)anObject;
 - (NSSet *) setByAddingObjectsFromSet: (NSSet *)other;
 - (NSSet *) setByAddingObjectsFromArray: (NSArray *)other;
diff --git a/Headers/Foundation/NSSortDescriptor.h b/Headers/Foundation/NSSortDescriptor.h
index fffd612..8c99b8f 100644
--- a/Headers/Foundation/NSSortDescriptor.h
+++ b/Headers/Foundation/NSSortDescriptor.h
@@ -26,7 +26,7 @@
 #define __NSSortDescriptor_h_GNUSTEP_BASE_INCLUDE
 #import	<GNUstepBase/GSVersionMacros.h>
 
-#if OS_API_VERSION(100300,GS_API_LATEST)
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_3,GS_API_LATEST)
 
 #import	<Foundation/NSObject.h>
 #import	<Foundation/NSArray.h>
@@ -52,7 +52,8 @@ extern "C" {
 #endif
 #if     GS_NONFRAGILE
 #else
-  /* Pointer to private additional data used to avoid breaking ABI
+  /* 
+   * Pointer to private additional data used to avoid breaking ABI
    * when we don't have the non-fragile ABI available.
    * Use this mechanism rather than changing the instance variable
    * layout (see Source/GSInternal.h for details).
@@ -61,26 +62,14 @@ extern "C" {
 #endif
 }
 
-/** Returns a flag indicating whether the sort descriptor sorts objects
- * in ascending order (YES) or descending order (NO).
- */
-- (BOOL) ascending;
-
-/** Returns the result of comparing object1 to object2 using the property
- * whose key is defined in the receiver and using the selector of the
- * receiver.  If the receiver performs a descending order sort, the
- * result of this comparison is the opposite of that prroduced by
- * applying the selector.
- */
-- (NSComparisonResult) compareObject: (id)object1 toObject: (id)object2;
-
-/** Initialises the receiver for comparisons using the 'compare:' selector
+/**
+ * Initialises the receiver for comparisons using the 'compare:' selector
  * and the specified key and ordering.
  */
 - (id) initWithKey: (NSString *)key
-	 ascending: (BOOL)ascending;
+         ascending: (BOOL)ascending;
 
-/** <init />
+/** 
  * Initialises the receiver to perform comparisons in the specified order
  * using selector to compar the property key of each object.
  */
@@ -88,18 +77,45 @@ extern "C" {
          ascending: (BOOL)ascending
           selector: (SEL)selector;
 
-/** Returns the key used to obtain the property on which comparisons are based.
+
++ (id) sortDescriptorWithKey: (NSString *)key
+                   ascending: (BOOL)ascending;
+
++ (id) sortDescriptorWithKey: (NSString *)key
+                   ascending: (BOOL)ascending
+                    selector: (SEL)selector;
+
+/** 
+ * Returns a flag indicating whether the sort descriptor sorts objects
+ * in ascending order (YES) or descending order (NO).
+ */
+- (BOOL) ascending;
+
+/** 
+ * Returns the key used to obtain the property on which comparisons are based.
  */
 - (NSString *) key;
 
-/** Returns the selector used to compare the properties of objects.
+/**
+ * Returns the selector used to compare the properties of objects.
  */
 - (SEL) selector;
 
-/** Returns a copy of the receiver which compares and sorts in reversed
+/** 
+ * Returns the result of comparing object1 to object2 using the property
+ * whose key is defined in the receiver and using the selector of the
+ * receiver.  If the receiver performs a descending order sort, the
+ * result of this comparison is the opposite of that prroduced by
+ * applying the selector.
+ */
+- (NSComparisonResult) compareObject: (id)object1 toObject: (id)object2;
+
+/** 
+ * Returns a copy of the receiver which compares and sorts in reversed
  * order.
  */
 - (id) reversedSortDescriptor;
+
 @end
 
 @interface NSArray (NSSortDescriptorSorting)
diff --git a/Headers/Foundation/NSSpellServer.h b/Headers/Foundation/NSSpellServer.h
index 3568a86..302c563 100644
--- a/Headers/Foundation/NSSpellServer.h
+++ b/Headers/Foundation/NSSpellServer.h
@@ -47,7 +47,7 @@ extern "C" {
 @class NSMutableArray;
 @class NSMutableDictionary;
 
-#if OS_API_VERSION(100500,GS_API_LATEST) 
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_5,GS_API_LATEST) 
 GS_EXPORT NSString *const NSGrammarCorrections;
 GS_EXPORT NSString *const NSGrammarRange;
 GS_EXPORT NSString *const NSGrammarUserDescription;
@@ -143,7 +143,7 @@ findMisspelledWordInString: (NSString *)stringToCheck
        didForgetWord: (NSString *)word
           inLanguage: (NSString *)language;
 
-#if OS_API_VERSION(100300,GS_API_LATEST) 
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_3,GS_API_LATEST) 
 /** Not implemented */
 - (NSArray *) spellServer: (NSSpellServer *)sender
   suggestCompletionsForPartialWordRange: (NSRange)range
@@ -151,7 +151,7 @@ findMisspelledWordInString: (NSString *)stringToCheck
   language: (NSString *)language;
 #endif
 
-#if OS_API_VERSION(100500,GS_API_LATEST) 
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_5,GS_API_LATEST) 
 /** Not implemented */
 - (NSRange) spellServer: (NSSpellServer *)sender
   checkGrammarInString: (NSString *)stringToCheck
diff --git a/Headers/Foundation/NSStream.h b/Headers/Foundation/NSStream.h
index 0b49413..4581115 100644
--- a/Headers/Foundation/NSStream.h
+++ b/Headers/Foundation/NSStream.h
@@ -25,7 +25,7 @@
 #define __NSStream_h_GNUSTEP_BASE_INCLUDE
 #import	<GNUstepBase/GSVersionMacros.h>
 
-#if OS_API_VERSION(100400,GS_API_LATEST) && GS_API_VERSION( 10200,GS_API_LATEST)
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_4,GS_API_LATEST) // FIXDEF! && GS_API_VERSION( 10200,GS_API_LATEST)
 
 #import	<Foundation/NSObject.h>
 
diff --git a/Headers/Foundation/NSString.h b/Headers/Foundation/NSString.h
index 5097d4e..2a8e45b 100644
--- a/Headers/Foundation/NSString.h
+++ b/Headers/Foundation/NSString.h
@@ -68,6 +68,7 @@
 #ifndef __NSString_h_GNUSTEP_BASE_INCLUDE
 #define __NSString_h_GNUSTEP_BASE_INCLUDE
 #import	<GNUstepBase/GSVersionMacros.h>
+#import <GNUstepBase/GSObjCRuntime.h>
 
 #import	<Foundation/NSObject.h>
 #import	<Foundation/NSRange.h>
@@ -81,7 +82,7 @@ extern "C" {
  */
 typedef uint16_t unichar;
 
-#if OS_API_VERSION(100500,GS_API_LATEST) 
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_5,GS_API_LATEST) 
 #define NSMaximumStringLength   (INT_MAX-1)
 #endif
 
@@ -104,13 +105,13 @@ enum
   NSBackwardsSearch = 4,
   NSAnchoredSearch = 8,
   NSNumericSearch = 64	/* MacOS-X 10.2 */
-#if OS_API_VERSION(100500,GS_API_LATEST) 
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_5,GS_API_LATEST) 
  ,
  NSDiacriticInsensitiveSearch = 128,
  NSWidthInsensitiveSearch = 256,
  NSForcedOrderingSearch = 512
 #endif
-#if OS_API_VERSION(100700,GS_API_LATEST) 
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_7,GS_API_LATEST) 
  ,
  /**
   * Treats the search string as a regular expression.  This option may be
@@ -196,7 +197,7 @@ typedef enum _NSStringEncoding
   NSBIG5StringEncoding,			// Traditional chinese
   NSKoreanEUCStringEncoding		// Korean
 
-#if OS_API_VERSION(100400,GS_API_LATEST) 
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_4,GS_API_LATEST) 
   ,
   NSUTF16BigEndianStringEncoding = 0x90000100,
   NSUTF16LittleEndianStringEncoding = 0x94000100,
@@ -210,7 +211,7 @@ enum {
   NSOpenStepUnicodeReservedBase = 0xF400
 };
 
-#if OS_API_VERSION(100400,GS_API_LATEST) 
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_4,GS_API_LATEST) 
 enum {
   NSStringEncodingConversionAllowLossy = 1,
   NSStringEncodingConversionExternalRepresentation = 2
@@ -262,24 +263,30 @@ typedef NSUInteger NSStringEncodingConversionOptions;
  *   that of the receiver which returned them.
  * </p>
  */
-@interface NSString :NSObject <NSCoding, NSCopying, NSMutableCopying>
-
-+ (id) string;
-+ (id) stringWithCharacters: (const unichar*)chars
-		     length: (NSUInteger)length;
-#if OS_API_VERSION(100400,GS_API_LATEST) && GS_API_VERSION( 10200,GS_API_LATEST)
-+ (id) stringWithCString: (const char*)byteString
-		encoding: (NSStringEncoding)encoding;
+@interface NSString : NSObject <NSCopying, NSMutableCopying, NSCoding>
+
+/* NSString primitive (funnel) methods. A minimal subclass of NSString just needs to implement these, although we also recommend getCharacters:range:. See below for the other methods.
+ */
+- (NSUInteger)length;			
+- (unichar)characterAtIndex:(NSUInteger)index;
+
+@end
+
+@interface NSString (NSStringExtensionMethods)
+
++ (id)string;
++ (id)stringWithCharacters:(const unichar *)chars length:(NSUInteger)length;
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_4,GS_API_LATEST) // FIXDEF! && GS_API_VERSION( 10200,GS_API_LATEST)
++ (id)stringWithCString:(const char *)byteString encoding:(NSStringEncoding)encoding;
 #endif
-+ (id) stringWithCString: (const char*)byteString
-		  length: (NSUInteger)length;
-+ (id) stringWithCString: (const char*)byteString;
-+ (id) stringWithFormat: (NSString*)format,...;
-+ (id) stringWithContentsOfFile:(NSString *)path;
++ (id)stringWithCString:(const char *)byteString length:(NSUInteger)length;
++ (id)stringWithCString:(const char *)byteString;
++ (id)stringWithFormat:(NSString *)format, ... NS_FORMAT_FUNCTION(1,2);
++ (id)stringWithContentsOfFile:(NSString *)path;
 
 // Initializing Newly Allocated Strings
 - (id) init;
-#if OS_API_VERSION(100400,GS_API_LATEST) && GS_API_VERSION( 10200,GS_API_LATEST)
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_4,GS_API_LATEST) // FIXDEF! && GS_API_VERSION( 10200,GS_API_LATEST)
 - (id) initWithBytes: (const void*)bytes
 	      length: (NSUInteger)length
 	    encoding: (NSStringEncoding)encoding;
@@ -288,7 +295,7 @@ typedef NSUInteger NSStringEncodingConversionOptions;
 		  encoding: (NSStringEncoding)encoding 
 	      freeWhenDone: (BOOL)flag;
 #endif
-#if OS_API_VERSION(100400,GS_API_LATEST)
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_4,GS_API_LATEST)
 + (id) stringWithContentsOfFile: (NSString*)path
                    usedEncoding: (NSStringEncoding*)enc
                           error: (NSError**)error;
@@ -322,7 +329,7 @@ typedef NSUInteger NSStringEncodingConversionOptions;
 	   encoding: (NSStringEncoding)enc
 	      error: (NSError**)error;
 #endif
-#if OS_API_VERSION(100500,GS_API_LATEST)
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_5,GS_API_LATEST)
 - (NSString*)stringByReplacingOccurrencesOfString: (NSString*)replace
                                        withString: (NSString*)by
                                           options: (NSStringCompareOptions)opts
@@ -332,24 +339,20 @@ typedef NSUInteger NSStringEncodingConversionOptions;
 - (NSString*) stringByReplacingCharactersInRange: (NSRange)aRange 
                                       withString: (NSString*)by;
 #endif
-- (id) initWithCharactersNoCopy: (unichar*)chars
-			 length: (NSUInteger)length
-		   freeWhenDone: (BOOL)flag;
-- (id) initWithCharacters: (const unichar*)chars
-		   length: (NSUInteger)length;
-- (id) initWithCStringNoCopy: (char*)byteString
-		      length: (NSUInteger)length
-	        freeWhenDone: (BOOL)flag;
-- (id) initWithCString: (const char*)byteString
-	        length: (NSUInteger)length;
-- (id) initWithCString: (const char*)byteString;
-- (id) initWithString: (NSString*)string;
-- (id) initWithFormat: (NSString*)format, ...;
-- (id) initWithFormat: (NSString*)format
-	    arguments: (va_list)argList;
-- (id) initWithData: (NSData*)data
-	   encoding: (NSStringEncoding)encoding;
-- (id) initWithContentsOfFile: (NSString*)path;
+
+- (id)initWithCharactersNoCopy:(unichar *)chars length:(NSUInteger)length freeWhenDone:(BOOL)flag;
+- (id)initWithCharacters:(const unichar *)chars length:(NSUInteger)length;
+
+- (id)initWithCStringNoCopy:(char *)byteString length:(NSUInteger)length freeWhenDone:(BOOL)flag;
+- (id)initWithCString:(const char *)byteString length:(NSUInteger)length;
+- (id)initWithCString:(const char *)byteString;
+
+- (id)initWithString:(NSString *)string;
+- (id)initWithFormat:(NSString *)format, ... NS_FORMAT_FUNCTION(1,2);
+- (id)initWithFormat:(NSString *)format arguments:(va_list)argList NS_FORMAT_FUNCTION(1,0);
+
+- (id)initWithData:(NSData *)data encoding:(NSStringEncoding)encoding;
+- (id)initWithContentsOfFile:(NSString *)path;
 
 // Getting a String's Length
 - (NSUInteger) length;
@@ -361,13 +364,13 @@ typedef NSUInteger NSStringEncodingConversionOptions;
 		 range: (NSRange)aRange;
 
 // Combining Strings
-- (NSString*) stringByAppendingFormat: (NSString*)format,...;
-- (NSString*) stringByAppendingString: (NSString*)aString;
+- (NSString *)stringByAppendingFormat:(NSString *)format, ... NS_FORMAT_FUNCTION(1,2);
+- (NSString *)stringByAppendingString:(NSString *)aString;
 
 // Dividing Strings into Substrings
-- (NSArray*) componentsSeparatedByString: (NSString*)separator;
-- (NSString*) substringFromIndex: (NSUInteger)index;
-- (NSString*) substringToIndex: (NSUInteger)index;
+- (NSArray *)componentsSeparatedByString:(NSString *)separator;
+- (NSString *)substringFromIndex:(NSUInteger)index;
+- (NSString *)substringToIndex:(NSUInteger)index;
 
 // Finding Ranges of Characters and Substrings
 - (NSRange) rangeOfCharacterFromSet: (NSCharacterSet*)aSet;
@@ -416,7 +419,7 @@ typedef NSUInteger NSStringEncodingConversionOptions;
 - (const char*) cString;
 #if OS_API_VERSION(GS_API_MACOSX, GS_API_LATEST)
 
-#if OS_API_VERSION(100400,GS_API_LATEST) && GS_API_VERSION( 10200,GS_API_LATEST)
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_4,GS_API_LATEST) // FIXDEF! && GS_API_VERSION( 10200,GS_API_LATEST)
 - (const char*) cStringUsingEncoding: (NSStringEncoding)encoding;
 - (BOOL) getCString: (char*)buffer
 	  maxLength: (NSUInteger)maxLength
@@ -681,7 +684,7 @@ typedef NSUInteger NSStringEncodingConversionOptions;
 
 
 // for methods working with decomposed strings
-- (int) _baseLength;
+- (NSUInteger) _baseLength;
 
 #if OS_API_VERSION(GS_API_MACOSX, GS_API_LATEST)
 /**
@@ -722,20 +725,19 @@ typedef NSUInteger NSStringEncodingConversionOptions;
  * Returns an array of strings made by appending the values in paths
  * to the receiver.
  */
-- (NSArray*) stringsByAppendingPaths: (NSArray*)paths;
-
-+ (NSString*) localizedStringWithFormat: (NSString*)format, ...;
-
-+ (id) stringWithString: (NSString*)aString;
-+ (id) stringWithContentsOfURL: (NSURL*)url;
-+ (id) stringWithUTF8String: (const char*)bytes;
-- (id) initWithFormat: (NSString*)format
-	       locale: (NSDictionary*)locale, ...;
-- (id) initWithFormat: (NSString*)format
-	       locale: (NSDictionary*)locale
-	    arguments: (va_list)argList;
-- (id) initWithUTF8String: (const char *)bytes;
-- (id) initWithContentsOfURL: (NSURL*)url;
+- (NSArray*)stringsByAppendingPaths:(NSArray*)paths;
+
++ (NSString*)localizedStringWithFormat:(NSString*)format, ... NS_FORMAT_FUNCTION(1,2);
+
++ (id)stringWithString: (NSString*)aString;
++ (id)stringWithContentsOfURL: (NSURL*)url;
++ (id)stringWithUTF8String: (const char*)bytes;
+
+- (id)initWithFormat:(NSString*)format locale:(NSDictionary*)locale, ... NS_FORMAT_FUNCTION(1,3);
+- (id)initWithFormat:(NSString*)format locale:(NSDictionary*)locale arguments:(va_list)argList NS_FORMAT_FUNCTION(1,0);
+- (id)initWithUTF8String:(const char *)bytes;
+- (id)initWithContentsOfURL:(NSURL*)url;
+
 - (NSString*) substringWithRange: (NSRange)aRange;
 - (NSComparisonResult) caseInsensitiveCompare: (NSString*)aString;
 - (NSComparisonResult) compare: (NSString*)string 
@@ -765,7 +767,7 @@ typedef NSUInteger NSStringEncodingConversionOptions;
 - (const char *)UTF8String;
 #endif
 
-#if OS_API_VERSION(100300,GS_API_LATEST) 
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_3,GS_API_LATEST) 
 /** Not implemented */
 - (void) getParagraphStart: (NSUInteger *)startIndex
                        end: (NSUInteger *)parEndIndex
@@ -775,7 +777,7 @@ typedef NSUInteger NSStringEncodingConversionOptions;
  - (NSRange) paragraphRangeForRange: (NSRange)range;
 #endif
 
-#if OS_API_VERSION(100500,GS_API_LATEST) 
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_5,GS_API_LATEST) 
 /**
  * Returns YES when scanning the receiver's text from left to right
  * finds an initial digit in the range 1-9 or a letter in the set
@@ -807,36 +809,37 @@ typedef NSUInteger NSStringEncodingConversionOptions;
 @interface NSMutableString : NSString
 
 // Creating Temporary Strings
-+ (id) string;
-+ (id) stringWithCharacters: (const unichar*)characters
-		     length: (NSUInteger)length;
-+ (id) stringWithCString: (const char*)byteString
-		  length: (NSUInteger)length;
-+ (id) stringWithCString: (const char*)byteString;
-+ (id) stringWithFormat: (NSString*)format,...;
-+ (id) stringWithContentsOfFile: (NSString*)path;
-+ (NSMutableString*) stringWithCapacity: (NSUInteger)capacity;
++ (id)string;
++ (id)stringWithCharacters:(const unichar *)characters length:(NSUInteger)length;
++ (id)stringWithCString:(const char *)byteString length:(NSUInteger)length;
++ (id)stringWithCString:(const char *)byteString;
++ (id)stringWithFormat:(NSString *)format, ... NS_FORMAT_FUNCTION(1,2);
++ (id)stringWithContentsOfFile:(NSString *)path;
+
++ (NSMutableString *)stringWithCapacity:(NSUInteger)capacity;
 
 // Initializing Newly Allocated Strings
 - (id) initWithCapacity: (NSUInteger)capacity;
 
 // Modify A String
-- (void) appendFormat: (NSString*)format, ...;
-- (void) appendString: (NSString*)aString;
-- (void) deleteCharactersInRange: (NSRange)range;
-- (void) insertString: (NSString*)aString atIndex: (NSUInteger)loc;
-- (void) replaceCharactersInRange: (NSRange)range 
-		       withString: (NSString*)aString;
-- (NSUInteger) replaceOccurrencesOfString: (NSString*)replace
-				 withString: (NSString*)by
-				    options: (NSUInteger)opts
-				      range: (NSRange)searchRange;
-- (void) setString: (NSString*)aString;
+- (void)appendFormat:(NSString *)format, ... NS_FORMAT_FUNCTION(1,2);
+- (void)appendString:(NSString *)aString;
+
+- (void)deleteCharactersInRange:(NSRange)range;
+- (void)insertString:(NSString *)aString atIndex:(NSUInteger)loc;
+
+- (void)replaceCharactersInRange:(NSRange)range withString:(NSString *)aString;
+- (NSUInteger)replaceOccurrencesOfString:(NSString *)replace 
+                              withString:(NSString *)by
+                                 options:(NSUInteger)opts
+                                   range:(NSRange)searchRange;
+
+- (void)setString:(NSString *)aString;
 
 @end
 
 /**
- * <p>The NXConstantString class is used to hold constant 8-bit character
+ * <p>The NSSimpleCString class is used to hold constant 8-bit character
  * string objects produced by the compiler where it sees @"..." in the
  * source.  The compiler generates the instances of this class - which
  * has three instance variables -</p>
@@ -846,12 +849,7 @@ typedef NSUInteger NSStringEncodingConversionOptions;
  * <item>the length of the string</item>
  * </list>
  * <p>In older versions of the compiler, the isa variable is always set to
- * the NXConstantString class.  In newer versions a compiler option was
- * added for GNUstep, to permit the isa variable to be set to another
- * class, and GNUstep uses this to avoid conflicts with the default
- * implementation of NXConstantString in the ObjC runtime library (the
- * preprocessor is used to change all occurrences of NXConstantString
- * in the source code to NSConstantString).</p>
+ * the NXConstantString class.</p>
  * <p>Since GNUstep will generally use the GNUstep extension to the
  * compiler, you should never refer to the constant string class by
  * name, but should use the [NSString+constantStringClass] method to
@@ -859,19 +857,68 @@ typedef NSUInteger NSStringEncodingConversionOptions;
  * What follows is a dummy declaration of the class to keep the compiler
  * happy.
  */
-@interface NXConstantString : NSString
-{
-@public
-  const char * const nxcsptr;
-  const unsigned int nxcslen;
+@interface NSSimpleCString : NSString {
+}
+/* Overrides retain, release etc. */
+@end
+
+/*
+ * If build on other systems or on OSX with:
+ * -fno-constant-cfstrings -fconstant-string-class=NSConstantString
+ */
+
+@interface NSConstantString : NSSimpleCString {
+@package
+    const char * const bytes;
+    const unsigned int numBytes;
+#if __LP64__
+    int padding;
+#endif
+}
+@end
+    
+@interface NXConstantString : NSConstantString {
 }
 @end
 
-#ifdef NeXT_RUNTIME
-/** For internal use with NeXT runtime;
-    needed, until Apple Radar 2870817 is fixed. */
-extern struct objc_class _NSConstantStringClassReference;
+@interface NSCFConstantString : NSSimpleCString {
+@package
+    int32_t flags;
+#if __LP64__
+    int32_t padding;
+#endif
+    const char * const bytes;
+    const unsigned int numBytes;
+#if __LP64__
+    int padding2;
 #endif
+}
+@end
+
+/*
+ * -fno-constant-cfstrings & -fconstant-string-class support
+ */
+#if __APPLE__ /* __OBJC2__ may be undefined with GNUstep's runtime */
+#if __OBJC2__
+    extern Class _NSConstantStringClassReference;
+#else
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
+    extern struct objc_class _NSConstantStringClassReference;
+#pragma GCC diagnostic pop
+#endif /* __OBJC2__ */
+#endif /* __APPLE__ */
+
+/*
+ * -fconstant-cfstrings support
+ * constant CFString's isa points to it
+ */
+#if __LP64__
+    extern int __CFConstantStringClassReference[24];
+#else
+    extern int __CFConstantStringClassReference[12];
+#endif
+
 
 #if	defined(__cplusplus)
 }
diff --git a/Headers/Foundation/NSThread.h b/Headers/Foundation/NSThread.h
index bf6bde0..31b62d1 100644
--- a/Headers/Foundation/NSThread.h
+++ b/Headers/Foundation/NSThread.h
@@ -128,14 +128,12 @@ extern "C" {
 
 - (NSMutableDictionary*) threadDictionary;
 
-#if OS_API_VERSION(MAC_OS_X_VERSION_10_2,GS_API_LATEST) \
-  && GS_API_VERSION( 10200,GS_API_LATEST)
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_2,GS_API_LATEST) // FIXDEF! && GS_API_VERSION( 10200,GS_API_LATEST)
 + (void) setThreadPriority: (double)pri;
 + (double) threadPriority;
 #endif
 
-#if OS_API_VERSION(MAC_OS_X_VERSION_10_5,GS_API_LATEST) \
-  && GS_API_VERSION( 11501,GS_API_LATEST)
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_5,GS_API_LATEST) // FIXDEF! && GS_API_VERSION( 11501,GS_API_LATEST)
 
 /** Returns an array of the call stack return addresses.
  */
diff --git a/Headers/Foundation/NSTimeZone.h b/Headers/Foundation/NSTimeZone.h
index 23c7cf7..0cdef62 100644
--- a/Headers/Foundation/NSTimeZone.h
+++ b/Headers/Foundation/NSTimeZone.h
@@ -35,7 +35,7 @@ extern "C" {
 @class  NSLocale;
 @class	NSString;
 
-#if OS_API_VERSION(100500,GS_API_LATEST) 
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_5,GS_API_LATEST) 
 enum {
   NSTimeZoneNameStyleStandard,
   NSTimeZoneNameStyleShortStandard,
@@ -87,7 +87,7 @@ GS_EXPORT NSString * const NSSystemTimeZoneDidChangeNotification;
 - (NSInteger) secondsFromGMTForDate: (NSDate*)aDate;
 #endif
 
-#if OS_API_VERSION(100500,GS_API_LATEST) 
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_5,GS_API_LATEST) 
 - (NSTimeInterval) daylightSavingTimeOffsetForDate: (NSDate *)aDate;
 /** Not implemented */
 - (NSDate *) nextDaylightSavingTimeTransitionAfterDate: (NSDate *)aDate;
diff --git a/Headers/Foundation/NSTimer.h b/Headers/Foundation/NSTimer.h
index aa02050..1ee7f68 100644
--- a/Headers/Foundation/NSTimer.h
+++ b/Headers/Foundation/NSTimer.h
@@ -92,7 +92,7 @@ extern "C" {
 - (NSTimeInterval) timeInterval;
 #endif
 
-#if	OS_API_VERSION(100200, GS_API_LATEST)
+#if	OS_API_VERSION(MAC_OS_X_VERSION_10_2, GS_API_LATEST)
 - (id) initWithFireDate: (NSDate*)fd
 	       interval: (NSTimeInterval)ti
 		 target: (id)object
diff --git a/Headers/Foundation/NSURL.h b/Headers/Foundation/NSURL.h
index 9c366b3..4525b45 100644
--- a/Headers/Foundation/NSURL.h
+++ b/Headers/Foundation/NSURL.h
@@ -70,7 +70,7 @@ GS_EXPORT NSString* const NSURLFileScheme;
  */
 + (id) fileURLWithPath: (NSString*)aPath;
 
-#if OS_API_VERSION(100600,GS_API_LATEST) 
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_6,GS_API_LATEST) 
 /** Creates a file URL using a path built from components.
  */
 + (NSURL*) fileURLWithPathComponents: (NSArray*)components;
@@ -104,7 +104,7 @@ GS_EXPORT NSString* const NSURLFileScheme;
  */
 - (id) initFileURLWithPath: (NSString*)aPath;
 
-#if OS_API_VERSION(100500,GS_API_LATEST) 
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_5,GS_API_LATEST) 
 /**
  * Initialise as a file URL with the specified path (which must
  * be a valid path on the local filesystem).<br />
@@ -166,7 +166,7 @@ GS_EXPORT NSString* const NSURLFileScheme;
  */
 - (NSURL*) baseURL;
 
-#if OS_API_VERSION(100600,GS_API_LATEST) 
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_6,GS_API_LATEST) 
 /** Attempts to load from the specified URL and provides an error
  * response if the data is unrachable.<br />
  * Returns YES on success, NO on failure.
@@ -197,7 +197,7 @@ GS_EXPORT NSString* const NSURLFileScheme;
  */
 - (BOOL) isFileURL;
 
-#if OS_API_VERSION(100600,GS_API_LATEST) 
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_6,GS_API_LATEST) 
 /** Returns the last (rightmost) path component of the receiver.
  */
 - (NSString*) lastPathComponent;
@@ -260,7 +260,7 @@ GS_EXPORT NSString* const NSURLFileScheme;
  */
 - (NSString*) path;
 
-#if OS_API_VERSION(100600,GS_API_LATEST) 
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_6,GS_API_LATEST) 
 /** Returns thepath components of the receiver.<br />
  * See [NSString-pathComponents].
  */
@@ -346,7 +346,7 @@ GS_EXPORT NSString* const NSURLFileScheme;
  */
 - (NSURL*) standardizedURL;
 
-#if OS_API_VERSION(100600,GS_API_LATEST) 
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_6,GS_API_LATEST) 
 /** Returns a URL formed by adding a path component to the path of the
  * receiver.<br />
  * See [NSString-stringByAppendingPathComponent:].
diff --git a/Headers/Foundation/NSURLCache.h b/Headers/Foundation/NSURLCache.h
index 5554d35..73c0316 100644
--- a/Headers/Foundation/NSURLCache.h
+++ b/Headers/Foundation/NSURLCache.h
@@ -26,7 +26,7 @@
 #define __NSURLCache_h_GNUSTEP_BASE_INCLUDE
 #import	<GNUstepBase/GSVersionMacros.h>
 
-#if OS_API_VERSION(100200,GS_API_LATEST) && GS_API_VERSION( 11300,GS_API_LATEST)
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_2,GS_API_LATEST) // FIXDEF! && GS_API_VERSION( 11300,GS_API_LATEST)
 
 #import	<Foundation/NSObject.h>
 
diff --git a/Headers/Foundation/NSURLConnection.h b/Headers/Foundation/NSURLConnection.h
index 35bc816..39fdda0 100644
--- a/Headers/Foundation/NSURLConnection.h
+++ b/Headers/Foundation/NSURLConnection.h
@@ -26,7 +26,7 @@
 #define __NSURLConnection_h_GNUSTEP_BASE_INCLUDE
 #import	<GNUstepBase/GSVersionMacros.h>
 
-#if OS_API_VERSION(100200,GS_API_LATEST) && GS_API_VERSION( 11300,GS_API_LATEST)
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_2,GS_API_LATEST) // FIXDEF! && GS_API_VERSION( 11300,GS_API_LATEST)
 
 #import	<Foundation/NSObject.h>
 
@@ -43,8 +43,7 @@ extern "C" {
 
 /**
  */
-@interface NSURLConnection : NSObject
-{
+@interface NSURLConnection : NSObject {
 #if	GS_EXPOSE(NSURLConnection)
   void *_NSURLConnectionInternal;
 #endif
@@ -57,19 +56,13 @@ extern "C" {
  * changes to the request or changes to the registered protocols
  * etc.
  */
-+ (BOOL) canHandleRequest: (NSURLRequest *)request;
++ (BOOL)canHandleRequest:(NSURLRequest *)request;
 
 /**
  * Allocates and returns the autoreleased instance which it initialises
  * using the -initWithRequest:delegate: method.
  */
-+ (NSURLConnection *) connectionWithRequest: (NSURLRequest *)request
-				   delegate: (id)delegate;
-
-/**
- * Cancel the asynchronous load in progress (if any) for this connection.
- */
-- (void) cancel;
++ (NSURLConnection *)connectionWithRequest:(NSURLRequest *)request delegate:(id)delegate;
 
 /** <init />
  * Initialises the receiver with the specified request (performing
@@ -84,7 +77,16 @@ extern "C" {
  * This method breaks with convention and retains the delegate object,
  * releasing it when the connection finished loading, fails, or is cancelled.
  */
-- (id) initWithRequest: (NSURLRequest *)request delegate: (id)delegate;
+- (id)initWithRequest:(NSURLRequest *)request delegate:(id)delegate;
+
+- (id)initWithRequest:(NSURLRequest *)request delegate:(id)delegate startImmediately:(BOOL)startImmediately;
+
+- (void)start;
+
+/**
+ * Cancel the asynchronous load in progress (if any) for this connection.
+ */
+- (void)cancel;
 
 @end
 
diff --git a/Headers/Foundation/NSURLCredential.h b/Headers/Foundation/NSURLCredential.h
index c531fc6..3a2964b 100644
--- a/Headers/Foundation/NSURLCredential.h
+++ b/Headers/Foundation/NSURLCredential.h
@@ -26,7 +26,7 @@
 #define __NSURLCredential_h_GNUSTEP_BASE_INCLUDE
 #import	<GNUstepBase/GSVersionMacros.h>
 
-#if OS_API_VERSION(100200,GS_API_LATEST) && GS_API_VERSION( 11300,GS_API_LATEST)
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_2,GS_API_LATEST) // FIXDEF! && GS_API_VERSION( 11300,GS_API_LATEST)
 
 #import	<Foundation/NSObject.h>
 
diff --git a/Headers/Foundation/NSURLCredentialStorage.h b/Headers/Foundation/NSURLCredentialStorage.h
index 7d1b132..4a9aae2 100644
--- a/Headers/Foundation/NSURLCredentialStorage.h
+++ b/Headers/Foundation/NSURLCredentialStorage.h
@@ -26,7 +26,7 @@
 #define __NSURLCredentialStorage_h_GNUSTEP_BASE_INCLUDE
 #import	<GNUstepBase/GSVersionMacros.h>
 
-#if OS_API_VERSION(100200,GS_API_LATEST) && GS_API_VERSION( 11300,GS_API_LATEST)
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_2,GS_API_LATEST) // FIXDEF! && GS_API_VERSION( 11300,GS_API_LATEST)
 
 #import	<Foundation/NSObject.h>
 
diff --git a/Headers/Foundation/NSURLDownload.h b/Headers/Foundation/NSURLDownload.h
index 47b90b8..34e8bc5 100644
--- a/Headers/Foundation/NSURLDownload.h
+++ b/Headers/Foundation/NSURLDownload.h
@@ -26,7 +26,7 @@
 #define __NSURLDownload_h_GNUSTEP_BASE_INCLUDE
 #import	<GNUstepBase/GSVersionMacros.h>
 
-#if OS_API_VERSION(100200,GS_API_LATEST) && GS_API_VERSION( 11300,GS_API_LATEST)
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_2,GS_API_LATEST) // FIXDEF! && GS_API_VERSION( 11300,GS_API_LATEST)
 
 #import	<Foundation/NSObject.h>
 
diff --git a/Headers/Foundation/NSURLError.h b/Headers/Foundation/NSURLError.h
index 500ee0d..d23c2d7 100644
--- a/Headers/Foundation/NSURLError.h
+++ b/Headers/Foundation/NSURLError.h
@@ -26,7 +26,7 @@
 #define __NSURLError_h_GNUSTEP_BASE_INCLUDE
 #import	<GNUstepBase/GSVersionMacros.h>
 
-#if OS_API_VERSION(100200,GS_API_LATEST) && GS_API_VERSION( 11300,GS_API_LATEST)
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_2,GS_API_LATEST) // FIXDEF! && GS_API_VERSION( 11300,GS_API_LATEST)
 
 #import	<Foundation/NSObject.h>
 
diff --git a/Headers/Foundation/NSURLProtectionSpace.h b/Headers/Foundation/NSURLProtectionSpace.h
index ea81507..1f5a296 100644
--- a/Headers/Foundation/NSURLProtectionSpace.h
+++ b/Headers/Foundation/NSURLProtectionSpace.h
@@ -26,7 +26,7 @@
 #define __NSURLProtectionSpace_h_GNUSTEP_BASE_INCLUDE
 #import	<GNUstepBase/GSVersionMacros.h>
 
-#if OS_API_VERSION(100200,GS_API_LATEST) && GS_API_VERSION( 11300,GS_API_LATEST)
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_2,GS_API_LATEST) // FIXDEF! && GS_API_VERSION( 11300,GS_API_LATEST)
 
 #import	<Foundation/NSObject.h>
 
diff --git a/Headers/Foundation/NSURLProtocol.h b/Headers/Foundation/NSURLProtocol.h
index ae9bfcc..fab5057 100644
--- a/Headers/Foundation/NSURLProtocol.h
+++ b/Headers/Foundation/NSURLProtocol.h
@@ -26,7 +26,7 @@
 #define __NSURLProtocol_h_GNUSTEP_BASE_INCLUDE
 #import	<GNUstepBase/GSVersionMacros.h>
 
-#if OS_API_VERSION(100200,GS_API_LATEST) && GS_API_VERSION( 11300,GS_API_LATEST)
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_2,GS_API_LATEST) // FIXDEF! && GS_API_VERSION( 11300,GS_API_LATEST)
 
 #import	<Foundation/NSObject.h>
 
diff --git a/Headers/Foundation/NSURLRequest.h b/Headers/Foundation/NSURLRequest.h
index fa43dcb..3ce36b6 100644
--- a/Headers/Foundation/NSURLRequest.h
+++ b/Headers/Foundation/NSURLRequest.h
@@ -26,7 +26,7 @@
 #define __NSURLRequest_h_GNUSTEP_BASE_INCLUDE
 #import	<GNUstepBase/GSVersionMacros.h>
 
-#if OS_API_VERSION(100200,GS_API_LATEST) && GS_API_VERSION( 11300,GS_API_LATEST)
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_2,GS_API_LATEST) // FIXDEF! && GS_API_VERSION( 11300,GS_API_LATEST)
 
 #import	<Foundation/NSObject.h>
 
@@ -193,7 +193,7 @@ typedef NSUInteger NSURLRequestCachePolicy;
  */
 - (NSData *) HTTPBody;
 
-#if OS_API_VERSION(100400,GS_API_LATEST)
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_4,GS_API_LATEST)
 /**
  * Returns the currently set stream (if any) to be used to provide data
  * to send as the request body.<br />
@@ -242,7 +242,7 @@ typedef NSUInteger NSURLRequestCachePolicy;
  */
 - (void) setAllHTTPHeaderFields: (NSDictionary *)headerFields;
 
-#if OS_API_VERSION(100400,GS_API_LATEST)
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_4,GS_API_LATEST)
 /**
  * Sets the request body to be the contents of the given stream.<br />
  * The stream should be unopened when it is set, and the load process
diff --git a/Headers/Foundation/NSURLResponse.h b/Headers/Foundation/NSURLResponse.h
index 0d20c5c..f81719d 100644
--- a/Headers/Foundation/NSURLResponse.h
+++ b/Headers/Foundation/NSURLResponse.h
@@ -26,7 +26,7 @@
 #define __NSURLResponse_h_GNUSTEP_BASE_INCLUDE
 #import	<GNUstepBase/GSVersionMacros.h>
 
-#if OS_API_VERSION(100200,GS_API_LATEST)
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_2,GS_API_LATEST)
 
 #import	<Foundation/NSObject.h>
 
@@ -67,7 +67,7 @@ extern "C" {
   expectedContentLength: (NSInteger)length
   textEncodingName: (NSString *)name;
 
-#if OS_API_VERSION(100700,GS_API_LATEST)
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_7,GS_API_LATEST)
 /**
  * Initialises the receiver with the URL, statusCode, HTTPVersion, and
  * headerFields provided.
diff --git a/Headers/Foundation/NSUndoManager.h b/Headers/Foundation/NSUndoManager.h
index 256f9c5..74bdb0d 100644
--- a/Headers/Foundation/NSUndoManager.h
+++ b/Headers/Foundation/NSUndoManager.h
@@ -95,8 +95,8 @@ GS_EXPORT NSString* const NSUndoManagerWillUndoChangeNotification;
   BOOL			_isUndoing;
   BOOL			_groupsByEvent;
   BOOL			_runLoopGroupingPending;
-  unsigned		_disableCount;
-  unsigned		_levelsOfUndo;
+  NSUInteger		_disableCount;
+  NSUInteger		_levelsOfUndo;
 #endif
 #if     GS_NONFRAGILE
 #else
diff --git a/Headers/Foundation/NSValueTransformer.h b/Headers/Foundation/NSValueTransformer.h
index f8f6b30..118f1fc 100644
--- a/Headers/Foundation/NSValueTransformer.h
+++ b/Headers/Foundation/NSValueTransformer.h
@@ -27,7 +27,7 @@
 #define __NSValueTransformer_h_GNUSTEP_BASE_INCLUDE
 #import	<GNUstepBase/GSVersionMacros.h>
 
-#if OS_API_VERSION(100300,GS_API_LATEST) && GS_API_VERSION( 10200,GS_API_LATEST)
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_3,GS_API_LATEST) // FIXDEF! && GS_API_VERSION( 10200,GS_API_LATEST)
 
 #import	<Foundation/NSObject.h>
 
diff --git a/Headers/Foundation/NSXMLElement.h b/Headers/Foundation/NSXMLElement.h
index 0fd0f9c..9caddb4 100644
--- a/Headers/Foundation/NSXMLElement.h
+++ b/Headers/Foundation/NSXMLElement.h
@@ -104,7 +104,7 @@ extern "C" {
  */
 - (void) setAttributesAsDictionary: (NSDictionary*)attributes;
 
-#if OS_API_VERSION(100700, GS_API_LATEST)
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_7, GS_API_LATEST)
 /**
  * Sets attributes from the supplied dictionary.
  */
diff --git a/Headers/Foundation/NSXMLParser.h b/Headers/Foundation/NSXMLParser.h
index 9496c44..df862a7 100644
--- a/Headers/Foundation/NSXMLParser.h
+++ b/Headers/Foundation/NSXMLParser.h
@@ -28,7 +28,7 @@
 #define __NSXMLParser_h_GNUSTEP_BASE_INCLUDE
 #import	<GNUstepBase/GSVersionMacros.h>
 
-#if OS_API_VERSION(100300, GS_API_LATEST)
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_3, GS_API_LATEST)
 
 #import	<Foundation/NSObject.h>
 
diff --git a/Headers/GNUstepBase/GCObject.h b/Headers/GNUstepBase/GCObject.h
index 69af1c9..ccaeaac 100644
--- a/Headers/GNUstepBase/GCObject.h
+++ b/Headers/GNUstepBase/GCObject.h
@@ -86,7 +86,7 @@ typedef struct {
   gcInfo	gc;
   id		*_contents;	// C array of content objects
   BOOL		*_isGCObject;	// Is content object collectable?
-  unsigned int	_count;		// Number of content objects.
+  NSUInteger	_count;		// Number of content objects.
 }
 @end
 
@@ -96,8 +96,8 @@ typedef struct {
   gcInfo	gc;
   id		*_contents;
   BOOL		*_isGCObject;
-  unsigned	_count;
-  unsigned	_maxCount;	// Maximum number of content objects.
+  NSUInteger	_count;
+  NSUInteger	_maxCount;	// Maximum number of content objects.
 }
 @end
 
diff --git a/Headers/GNUstepBase/GNUstep.h b/Headers/GNUstepBase/GNUstep.h
index bed739e..c9d8910 100644
--- a/Headers/GNUstepBase/GNUstep.h
+++ b/Headers/GNUstepBase/GNUstep.h
@@ -137,7 +137,8 @@ id __object = (object); (__object != nil) ? [__object autorelease] : nil; })
  */
 #define	ASSIGN(object,value)	({\
   id __object = object; \
-  object = [(value) retain]; \
+  id __value = value; \
+  object = [__value retain]; \
   [__object release]; \
 })
 #endif
@@ -150,7 +151,8 @@ id __object = (object); (__object != nil) ? [__object autorelease] : nil; })
  */
 #define	ASSIGNCOPY(object,value)	({\
   id __object = object; \
-  object = [(value) copy];\
+  id __value = value; \
+  object = [__value copy];\
   [__object release]; \
 })
 #endif
@@ -341,19 +343,16 @@ id __object = (object); (__object != nil) ? [__object autorelease] : nil; })
  * extends beyond [0,size]. Size must be an unsigned integer (NSUInteger).
  */
 #define GS_RANGE_CHECK(RANGE, SIZE) \
-  if (RANGE.location > (NSUInteger)SIZE \
-    || RANGE.length > ((NSUInteger)SIZE - RANGE.location)) \
-    [NSException raise: NSRangeException format: @"in %s, range { %"\
-      PRIuPTR", %"PRIuPTR" } extends beyond size (%"PRIuPTR")", \
-      GSNameFromSelector(_cmd), RANGE.location, RANGE.length, (NSUInteger)SIZE]
-
-/** Checks whether INDEX is strictly less than OVER (within C array space).
- * INDEX and OVER must be unsigned integers (NSUInteger).
- */
+  if (RANGE.location > SIZE || RANGE.length > (SIZE - RANGE.location)) \
+    [NSException raise: NSRangeException \
+                 format: @"in %s, range { %"PRIuPTR", %"PRIuPTR" } extends beyond size (%"PRIuPTR")", \
+		 GSNameFromSelector(_cmd), RANGE.location, RANGE.length, (NSUInteger)SIZE]
+
+/** Checks whether INDEX is strictly less than OVER (within C array space). */
 #define CHECK_INDEX_RANGE_ERROR(INDEX, OVER) \
 if ((NSUInteger)INDEX >= (NSUInteger)OVER) \
   [NSException raise: NSRangeException \
-    format: @"in %s, index %"PRIuPTR" is out of range", \
-    GSNameFromSelector(_cmd), (NSUInteger)INDEX]
+              format: @"in %s, index %"PRIuPTR" is out of range", \
+              GSNameFromSelector(_cmd), (NSUInteger)INDEX]
 
 #endif /* __GNUSTEP_GNUSTEP_H_INCLUDED_ */
diff --git a/Headers/GNUstepBase/GSConfig.h.in b/Headers/GNUstepBase/GSConfig.h.in
index 6808861..1e0f87f 100644
--- a/Headers/GNUstepBase/GSConfig.h.in
+++ b/Headers/GNUstepBase/GSConfig.h.in
@@ -177,11 +177,6 @@ typedef	gsuaddr gsaddr;
 #endif
 
 /*
- * Define to say if we use NXConstantString or NSConstantString
- */
-#define NXConstantString	@NX_CONST_STRING_CLASS@
-
-/*
  * Ensure some standard types are defined.
  */
 @INCLUDE_STDINT@
@@ -237,7 +232,7 @@ typedef	struct {
 #define GS_USE_LIBDISPATCH @HAVE_LIBDISPATCH@
 #define GS_HAVE_OBJC_ROOT_CLASS_ATTR @GS_HAVE_OBJC_ROOT_CLASS_ATTR@
 
-#if     defined(__WIN32__) || defined(_WIN32) || defined(__MS_WIN32__)
+#if defined(__WIN32__) || defined(_WIN32) || defined(__MS_WIN32__)
 #  if	!defined(__WIN32__)
 #    define __WIN32__
 #  endif
@@ -395,6 +390,8 @@ typedef	struct {
 #endif
 
 #if !__has_feature(objc_arc)
+#  undef __strong /* This macros may be defined by clang already */
+#  undef __weak   /* and it displays loads of warnings. Make it silent. */
 #  if __OBJC_GC__
 #    define __strong __attribute__((objc_gc(strong)))
 #    define __weak __attribute__((objc_gc(weak)))
diff --git a/Headers/GNUstepBase/GSIArray.h b/Headers/GNUstepBase/GSIArray.h
index 716d1ac..c6d8310 100644
--- a/Headers/GNUstepBase/GSIArray.h
+++ b/Headers/GNUstepBase/GSIArray.h
@@ -164,9 +164,9 @@ extern "C" {
 
 struct	_GSIArray {
   GSIArrayItem	*ptr;
-  unsigned	count;
-  unsigned	cap;
-  unsigned	old;
+  NSUInteger	count;
+  NSUInteger	cap;
+  NSUInteger	old;
   NSZone	*zone;
 #ifdef	GSI_ARRAY_EXTRA
   GSI_ARRAY_EXTRA	extra;
@@ -175,13 +175,13 @@ struct	_GSIArray {
 typedef	struct	_GSIArray	GSIArray_t;
 typedef	struct	_GSIArray	*GSIArray;
 
-static INLINE unsigned
+static INLINE NSUInteger
 GSIArrayCapacity(GSIArray array)
 {
   return array->cap;
 }
 
-static INLINE unsigned
+static INLINE NSUInteger
 GSIArrayCount(GSIArray array)
 {
   return array->count;
@@ -190,8 +190,8 @@ GSIArrayCount(GSIArray array)
 static INLINE void
 GSIArrayGrow(GSIArray array)
 {
-  unsigned int	next;
-  unsigned int	size;
+  NSUInteger	next;
+  NSUInteger	size;
   GSIArrayItem	*tmp;
 
   if (array->old == 0)
@@ -237,9 +237,9 @@ GSIArrayGrow(GSIArray array)
 }
 
 static INLINE void
-GSIArrayGrowTo(GSIArray array, unsigned next)
+GSIArrayGrowTo(GSIArray array, NSUInteger next)
 {
-  unsigned int	size;
+  NSUInteger	size;
   GSIArrayItem	*tmp;
 
   if (next < array->count)
@@ -281,9 +281,9 @@ GSIArrayGrowTo(GSIArray array, unsigned next)
 }
 
 static INLINE void
-GSIArrayInsertItem(GSIArray array, GSIArrayItem item, unsigned index)
+GSIArrayInsertItem(GSIArray array, GSIArrayItem item, NSUInteger index)
 {
-  unsigned int	i;
+  NSUInteger	i;
 
   GSI_ARRAY_CHECK;
   GSI_ARRAY_RETAIN(array, item);
@@ -300,9 +300,9 @@ GSIArrayInsertItem(GSIArray array, GSIArrayItem item, unsigned index)
 }
 
 static INLINE void
-GSIArrayInsertItemNoRetain(GSIArray array, GSIArrayItem item, unsigned index)
+GSIArrayInsertItemNoRetain(GSIArray array, GSIArrayItem item, NSUInteger index)
 {
-  unsigned int	i;
+  NSUInteger	i;
 
   GSI_ARRAY_CHECK;
   if (array->count == array->cap)
@@ -349,13 +349,13 @@ GSIArrayAddItemNoRetain(GSIArray array, GSIArrayItem item)
  *      added is 'less than' the item in the array, NSOrderedDescending
  *      if it is greater, and NSOrderedSame if it is equal.
  */
-static INLINE unsigned
+static INLINE NSUInteger
 GSIArraySearch(GSIArray array, GSIArrayItem item, 
   NSComparisonResult (*sorter)(GSIArrayItem, GSIArrayItem))
 {
-  unsigned int	upper = array->count;
-  unsigned int	lower = 0;
-  unsigned int	index;
+  NSUInteger	upper = array->count;
+  NSUInteger	lower = 0;
+  NSUInteger	index;
 
   /*
    *	Binary search for an item equal to the one to be inserted.
@@ -382,11 +382,11 @@ GSIArraySearch(GSIArray array, GSIArrayItem item,
   return index;
 }
 
-static INLINE unsigned
+static INLINE NSUInteger
 GSIArrayInsertionPosition(GSIArray array, GSIArrayItem item, 
   NSComparisonResult (*sorter)(GSIArrayItem, GSIArrayItem))
 {
-  unsigned int	index;
+  NSUInteger	index;
 
   index = GSIArraySearch(array,item,sorter);
   /*
@@ -409,7 +409,7 @@ static INLINE void
 GSIArrayCheckSort(GSIArray array, 
   NSComparisonResult (*sorter)(GSIArrayItem, GSIArrayItem))
 {
-  unsigned int	i;
+  NSUInteger	i;
 
   for (i = 1; i < array->count; i++)
     {
@@ -425,7 +425,7 @@ static INLINE void
 GSIArrayInsertSorted(GSIArray array, GSIArrayItem item, 
   NSComparisonResult (*sorter)(GSIArrayItem, GSIArrayItem))
 {
-  unsigned int	index;
+  NSUInteger	index;
 
 #ifdef	GSI_ARRAY_CHECKS
   GSIArrayCheckSort(array, sorter);
@@ -441,7 +441,7 @@ static INLINE void
 GSIArrayInsertSortedNoRetain(GSIArray array, GSIArrayItem item,
   NSComparisonResult (*sorter)(GSIArrayItem, GSIArrayItem))
 {
-  unsigned int	index;
+  NSUInteger	index;
 
 #ifdef	GSI_ARRAY_CHECKS
   GSIArrayCheckSort(array, sorter);
@@ -454,7 +454,7 @@ GSIArrayInsertSortedNoRetain(GSIArray array, GSIArrayItem item,
 }
 
 static INLINE void
-GSIArrayRemoveItemAtIndex(GSIArray array, unsigned index)
+GSIArrayRemoveItemAtIndex(GSIArray array, NSUInteger index)
 {
 #if	defined(GSI_ARRAY_NO_RELEASE)
 # ifdef	GSI_ARRAY_CHECKS
@@ -498,7 +498,7 @@ GSIArrayRemoveLastItem(GSIArray array)
 }
 
 static INLINE void
-GSIArrayRemoveItemAtIndexNoRelease(GSIArray array, unsigned index)
+GSIArrayRemoveItemAtIndexNoRelease(GSIArray array, NSUInteger index)
 {
 #ifdef	GSI_ARRAY_CHECKS
   NSCAssert(index < array->count, NSInvalidArgumentException);
@@ -512,7 +512,7 @@ GSIArrayRemoveItemAtIndexNoRelease(GSIArray array, unsigned index)
 }
 
 static INLINE void
-GSIArraySetItemAtIndex(GSIArray array, GSIArrayItem item, unsigned index)
+GSIArraySetItemAtIndex(GSIArray array, GSIArrayItem item, NSUInteger index)
 {
 #if	defined(GSI_ARRAY_NO_RELEASE)
 # ifdef	GSI_ARRAY_CHECKS
@@ -543,7 +543,7 @@ GSIArrayItems(GSIArray array)
 }
 
 static INLINE GSIArrayItem
-GSIArrayItemAtIndex(GSIArray array, unsigned index)
+GSIArrayItemAtIndex(GSIArray array, NSUInteger index)
 {
 #ifdef	GSI_ARRAY_CHECKS
   NSCAssert(index < array->count, NSInvalidArgumentException);
@@ -580,7 +580,7 @@ GSIArrayClear(GSIArray array)
 }
 
 static INLINE void
-GSIArrayRemoveItemsFromIndex(GSIArray array, unsigned index)
+GSIArrayRemoveItemsFromIndex(GSIArray array, NSUInteger index)
 {
   if (index < array->count)
     {
@@ -620,9 +620,9 @@ GSIArrayEmpty(GSIArray array)
 }
 
 static INLINE GSIArray
-GSIArrayInitWithZoneAndCapacity(GSIArray array, NSZone *zone, size_t capacity)
+GSIArrayInitWithZoneAndCapacity(GSIArray array, NSZone *zone, NSUInteger capacity)
 {
-  unsigned int	size;
+  NSUInteger	size;
 
   array->zone = zone;
   array->count = 0;
@@ -642,7 +642,7 @@ GSIArrayInitWithZoneAndCapacity(GSIArray array, NSZone *zone, size_t capacity)
 
 static INLINE GSIArray
 GSIArrayInitWithZoneAndStaticCapacity(GSIArray array, NSZone *zone,
-    size_t capacity, GSIArrayItem *buffer)
+    NSUInteger capacity, GSIArrayItem *buffer)
 {
   array->zone = zone;
   array->count = 0;
@@ -655,7 +655,7 @@ GSIArrayInitWithZoneAndStaticCapacity(GSIArray array, NSZone *zone,
 static INLINE GSIArray
 GSIArrayCopyWithZone(GSIArray array, NSZone *zone)
 {
-  unsigned int i;
+  NSUInteger i;
   GSIArray new;
 
 #if	GS_WITH_GC
diff --git a/Headers/GNUstepBase/GSIMap.h b/Headers/GNUstepBase/GSIMap.h
index 92a0c99..fd67e7f 100644
--- a/Headers/GNUstepBase/GSIMap.h
+++ b/Headers/GNUstepBase/GSIMap.h
@@ -390,7 +390,7 @@ typedef struct _GSIMapEnumerator GSIMapEnumerator_t;
 typedef GSIMapEnumerator_t	*GSIMapEnumerator;
 
 static INLINE GSIMapBucket
-GSIMapPickBucket(unsigned hash, GSIMapBucket buckets, uintptr_t bucketCount)
+GSIMapPickBucket(NSUInteger hash, GSIMapBucket buckets, uintptr_t bucketCount)
 {
   return buckets + hash % bucketCount;
 }
@@ -561,7 +561,7 @@ GSIMapRemangleBuckets(GSIMapTable map,
 }
 
 static INLINE void
-GSIMapMoreNodes(GSIMapTable map, unsigned required)
+GSIMapMoreNodes(GSIMapTable map, NSUInteger required)
 {
   GSIMapNode	*newArray;
 
@@ -1057,25 +1057,7 @@ GSIMapCountByEnumeratingWithStateObjectsCount(GSIMapTable map,
 }
 
 #if	GSI_MAP_HAS_VALUE
-static INLINE GSIMapNode
-GSIMapAddPairNoRetain(GSIMapTable map, GSIMapKey key, GSIMapVal value)
-{
-  GSIMapNode	node = map->freeNodes;
-
-  if (node == 0)
-    {
-      GSIMapMoreNodes(map, map->nodeCount < map->increment ? 0: map->increment);
-      node = map->freeNodes;
-    }
-  map->freeNodes = node->nextInBucket;
-  GSI_MAP_WRITE_KEY(map, &node->key, key);
-  GSI_MAP_WRITE_VAL(map, &node->value, value);
-  node->nextInBucket = 0;
-  GSIMapRightSizeMap(map, map->nodeCount);
-  GSIMapAddNodeToMap(map, node);
-  return node;
-}
-
+    
 static INLINE GSIMapNode
 GSIMapAddPair(GSIMapTable map, GSIMapKey key, GSIMapVal value)
 {
@@ -1097,23 +1079,6 @@ GSIMapAddPair(GSIMapTable map, GSIMapKey key, GSIMapVal value)
   return node;
 }
 #else
-static INLINE GSIMapNode
-GSIMapAddKeyNoRetain(GSIMapTable map, GSIMapKey key)
-{
-  GSIMapNode	node = map->freeNodes;
-
-  if (node == 0)
-    {
-      GSIMapMoreNodes(map, map->nodeCount < map->increment ? 0: map->increment);
-      node = map->freeNodes;
-    }
-  map->freeNodes = node->nextInBucket;
-  GSI_MAP_WRITE_KEY(map, &node->key, key);
-  node->nextInBucket = 0;
-  GSIMapRightSizeMap(map, map->nodeCount);
-  GSIMapAddNodeToMap(map, node);
-  return node;
-}
 
 static INLINE GSIMapNode
 GSIMapAddKey(GSIMapTable map, GSIMapKey key)
diff --git a/Headers/GNUstepBase/GSMime.h b/Headers/GNUstepBase/GSMime.h
index 8e91529..869abbd 100644
--- a/Headers/GNUstepBase/GSMime.h
+++ b/Headers/GNUstepBase/GSMime.h
@@ -208,13 +208,13 @@ extern "C" {
 #if	GS_EXPOSE(GSMimeParser)
   NSMutableData		*data;
   unsigned char		*bytes;
-  unsigned		dataEnd;
-  unsigned		sectionStart;
-  unsigned		lineStart;
-  unsigned		lineEnd;
-  unsigned		input;
-  unsigned		expect;
-  unsigned		rawBodyLength;
+  NSUInteger		dataEnd;
+  NSUInteger		sectionStart;
+  NSUInteger		lineStart;
+  NSUInteger		lineEnd;
+  NSUInteger		input;
+  NSUInteger		expect;
+  NSUInteger		rawBodyLength;
   struct {
     unsigned int	inBody:1;
     unsigned int	isHttp:1;
diff --git a/Headers/GNUstepBase/GSObjCRuntime.h b/Headers/GNUstepBase/GSObjCRuntime.h
index ae783dd..58a31ae 100644
--- a/Headers/GNUstepBase/GSObjCRuntime.h
+++ b/Headers/GNUstepBase/GSObjCRuntime.h
@@ -30,106 +30,162 @@
 #ifndef __GSObjCRuntime_h_GNUSTEP_BASE_INCLUDE
 #define __GSObjCRuntime_h_GNUSTEP_BASE_INCLUDE
 
+#import <Foundation/NSObjCRuntime.h>
 #import <GNUstepBase/GSVersionMacros.h>
 #import <GNUstepBase/GSConfig.h>
 
 #include <stdio.h>
 
-#if NeXT_RUNTIME
- #include <objc/objc.h>
- #include <objc/objc-class.h>
- #include <objc/objc-runtime.h>
- #ifndef _C_ATOM
-  #define _C_ATOM '%'
- #endif
- #define _F_CONST    0x01
- #define _F_IN       0x01
- #define _F_OUT      0x02
- #define _F_INOUT    0x03
- #define _F_BYCOPY   0x04
- #define _F_ONEWAY   0x08
- #define _C_CONST    'r'
- #define _C_IN       'n'
- #define _C_INOUT    'N'
- #define _C_OUT      'o'
- #define _C_BYCOPY   'O'
- #define _C_ONEWAY   'V'
-#else				/* GNU Objective C Runtime */
- #include <objc/objc.h>
- #if defined (__GNU_LIBOBJC__)
-  #include <objc/runtime.h>
- #else
-  #include <objc/objc-api.h>
-  #include <objc/encoding.h>
- #endif
+#if defined (__APPLE__) && !defined (NeXT_RUNTIME)
+# define NeXT_RUNTIME
 #endif
 
+#import <GNUstepBase/GSTypeEncoding.h>
+
+#if defined(NeXT_RUNTIME)
+#  include <objc/objc.h>
+#  include <objc/objc-class.h>
+#  include <objc/objc-runtime.h>
+#
+#  ifndef _C_ATOM
+#    define _C_ATOM '%'
+#  endif
+#else /* GNU Objective C Runtime */
+#  include <objc/objc.h>
+#
+#  if defined (__GNU_LIBOBJC__)
+#    include <objc/runtime.h>
+#  else
+#    include <objc/objc-api.h>
+#    include <objc/encoding.h>
+#  endif
+#endif
+
+#if OBJC2RUNTIME
+#  /* We have a real ObjC2 runtime. */
+#  include <objc/runtime.h>
+#else
+#  /* We emulate an ObjC2 runtime. */
+#  include <ObjectiveC2/objc/runtime.h>
+#endif
+
+
 /*
  * Hack for older compiler versions that don't have all defines
  * needed in  objc-api.h
  */
 #ifndef	_C_LNG_LNG
-#define	_C_LNG_LNG	'q'
-#endif
-#ifndef	_C_ULNG_LNG
-#define	_C_ULNG_LNG	'Q'
-#endif
-
-#if	OBJC2RUNTIME
-/* We have a real ObjC2 runtime.
- */
-#include <objc/runtime.h>
-#else
-/* We emulate an ObjC2 runtime.
- */
-#include <ObjectiveC2/objc/runtime.h>
+#  define _C_LNG_LNG	'q'
 #endif
 
-#ifdef __cplusplus
-extern "C" {
+#ifndef	_C_ULNG_LNG
+#  define _C_ULNG_LNG	'Q'
 #endif
 
-@class	NSArray;
-@class	NSDictionary;
-@class	NSObject;
-@class	NSString;
-@class	NSValue;
-
-#ifndef YES
-#define YES		1
-#endif
-#ifndef NO
-#define NO		0
-#endif
-#ifndef nil
-#define nil		0
-#endif
 
 #if	!defined(_C_CONST)
-#define _C_CONST        'r'
+#  define _C_CONST        'r'
 #endif
+#
 #if	!defined(_C_IN)
-#define _C_IN           'n'
+#  define _C_IN           'n'
 #endif
+#
 #if	!defined(_C_INOUT)
-#define _C_INOUT        'N'
+#  define _C_INOUT        'N'
 #endif
+#
 #if	!defined(_C_OUT)
-#define _C_OUT          'o'
+#  define _C_OUT          'o'
 #endif
+#
 #if	!defined(_C_BYCOPY)
-#define _C_BYCOPY       'O'
+#  define _C_BYCOPY       'O'
 #endif
+#
 #if	!defined(_C_BYREF)
-#define _C_BYREF        'R'
+#  define _C_BYREF        'R'
 #endif
+#
 #if	!defined(_C_ONEWAY)
-#define _C_ONEWAY       'V'
+#  define _C_ONEWAY       'V'
 #endif
+#
 #if	!defined(_C_GCINVISIBLE)
-#define _C_GCINVISIBLE  '!'
+#  define _C_GCINVISIBLE  '!'
 #endif
 
+#ifdef __cplusplus
+extern "C" {
+#endif
+    
+/* Logging */
+/**
+ *  OpenStep spec states that log messages go to stderr, but just in case
+ *  someone wants them to go somewhere else, they can implement a function
+ *  like this and assign a pointer to it to _NSLog_printf_handler.
+ */
+typedef void NSLog_printf_handler (NSString* message);
+GS_EXPORT NSLog_printf_handler	*_NSLog_printf_handler;
+GS_EXPORT int	_NSLogDescriptor;
+@class NSRecursiveLock;
+GS_EXPORT NSRecursiveLock	*GSLogLock(void);
+    
+#if defined(__clang__) && defined(__OBJC__)
+static inline void gs_consumed(id NS_CONSUMED o) GS_UNUSED_FUNC;
+static inline void gs_consumed(id NS_CONSUMED GS_UNUSED_ARG o) { return; }
+#  define GS_CONSUMED(O) gs_consumed(O);
+#else
+#  define GS_CONSUMED(O)
+#endif
+
+
+#if defined(NeXT_RUNTIME)
+    
+  NS_INLINE IMP
+  GSObjCMethodForSelector(id object, SEL selector)
+  {
+    return class_getMethodImplementation(object_getClass(object), selector);
+  }
+  
+#else
+    
+  NS_INLINE IMP
+  GSObjCMethodForSelector(id object, SEL selector)
+  {
+    /* The Apple runtime API would do:
+     * return class_getMethodImplementation(object_getClass(self), aSelector);
+     * but this cannot ask self for information about any method reached by
+     * forwarding, so the returned forwarding function would ge a generic one
+     * rather than one aware of hardware issues with returning structures
+     * and floating points.  We therefore prefer the GNU API which is able to
+     * use forwarding callbacks to get better type information.
+     */
+    return objc_msg_lookup (object, selector);
+  }
+
+#endif /* NeXT_RUNTIME */
+
+@class	NSArray;
+@class	NSDictionary;
+@class	NSObject;
+@class	NSString;
+@class	NSValue;
+
+/*
+ * Any malloc() implementation is required to return pointers aligned suitably
+ * to be used as a pointer to any posible primitive data type (bigest-possible
+ * aligment). So the padding size can be easily determined.
+ */
+NS_INLINE NSUInteger GSPointerHash(uintptr_t pointer)
+{
+  #define __MALLOC_ALIGNMENT (__alignof__(_Complex long double))
+
+  static uintptr_t const shift = __MALLOC_ALIGNMENT == 16 ? 4 : (__MALLOC_ALIGNMENT == 8 ? 3 : 2);
+  /* Compiled as "rolq $60, %rdi" or "rol $28, %eax" */
+  return (NSUInteger)((pointer >> shift) | (pointer << (sizeof(uintptr_t) * 8 - shift)));
+}
+
 /*
  * Functions for accessing instance variables directly -
  * We can copy an ivar into arbitrary data,
@@ -138,13 +194,13 @@ extern "C" {
  */
 GS_EXPORT BOOL
 GSObjCFindVariable(id obj, const char *name,
-		   const char **type, unsigned int *size, int *offset);
+		   const char **type, size_t *size, ptrdiff_t *offset);
 
 GS_EXPORT void
-GSObjCGetVariable(id obj, int offset, unsigned int size, void *data);
+GSObjCGetVariable(id obj, ptrdiff_t offset, size_t size, void *data);
 
 GS_EXPORT void
-GSObjCSetVariable(id obj, int offset, unsigned int size, const void *data);
+GSObjCSetVariable(id obj, ptrdiff_t offset, size_t size, const void *data);
 
 GS_EXPORT NSArray *
 GSObjCMethodNames(id obj, BOOL recurse);
@@ -241,11 +297,20 @@ GSObjCAddMethods(Class cls, Method *list, BOOL replace);
  */
 GS_EXPORT id
 GSObjCGetVal(NSObject *self, const char *key, SEL sel,
-  const char *type, unsigned size, int offset);
+             const char *type, size_t size, ptrdiff_t offset);
 
 GS_EXPORT void
 GSObjCSetVal(NSObject *self, const char *key, id val, SEL sel,
-  const char *type, unsigned size, int offset);
+             const char *type, size_t size, ptrdiff_t offset);
+
+
+GS_EXPORT id
+GSObjCGetValue(NSObject *self, NSString *key, SEL sel,
+               const char *type, size_t size, ptrdiff_t offset);
+
+GS_EXPORT void
+GSObjCSetValue(NSObject *self, NSString *key, id val, SEL sel,
+               const char *type, size_t size, ptrdiff_t offset);
 
 /*
  * This section includes runtime functions
@@ -432,7 +497,7 @@ GS_EXPORT int GSObjCVersion(Class cls);
  * Quickly return autoreleased data storage area.
  */
 GS_EXPORT void *
-GSAutoreleasedBuffer(unsigned size);
+GSAutoreleasedBuffer(size_t size);
 
 /**
  * <p>Prints a message to fptr using the format string provided and any
diff --git a/Headers/GNUstepBase/GSTypeEncoding.h b/Headers/GNUstepBase/GSTypeEncoding.h
new file mode 100644
index 0000000..46e3726
--- /dev/null
+++ b/Headers/GNUstepBase/GSTypeEncoding.h
@@ -0,0 +1,224 @@
+/*
+ * Objective-C type encoding support
+ *
+ * Copyright (C) 2012-2013 Free Software Foundation, Inc.
+ *
+ * Written by Marat Ibadinov <ibadinov@me.com>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+#ifndef GS_TYPE_ENCODING_H
+#define GS_TYPE_ENCODING_H
+
+#if defined (NeXT_RUNTIME)
+#  include <objc/objc-runtime.h>
+#else
+#  if defined (__GNU_LIBOBJC__)
+#    include <objc/runtime.h>
+#  else
+#    include <objc/objc-api.h>
+#    include <objc/encoding.h>
+#  endif
+#endif
+
+#if !defined(ENCODING_INLINE)
+#  if defined(__GNUC__)
+#    define ENCODING_INLINE static __inline__ __attribute__((always_inline))
+#  elif
+#    define ENCODING_INLINE static inline
+#  endif
+#endif
+
+/* type mangling is compiler independent so we can safely define this by hand */
+
+typedef enum GSObjCTypeQualifier
+{
+    GSObjCQualifierConst        = 'r',
+    GSObjCQualifierIn           = 'n',
+    GSObjCQualifierInOut        = 'N',
+    GSObjCQualifierOut          = 'o',
+    GSObjCQualifierByCopy       = 'O',
+    GSObjCQualifierByRef        = 'R',
+    GSObjCQualifierOneWay       = 'V',
+    GSObjCQualifierInvisible    = '!'
+} GSObjCTypeQualifier;
+
+typedef enum GSObjCType
+{
+    GSObjCTypeId                = '@',
+    GSObjCTypeClass             = '#',
+    GSObjCTypeSelector          = ':',
+    GSObjCTypeChar              = 'c',
+    GSObjCTypeUnsignedChar      = 'C',
+    GSObjCTypeShort             = 's',
+    GSObjCTypeUnsignedShort     = 'S',
+    GSObjCTypeInt               = 'i',
+    GSObjCTypeUnsignedInt       = 'I',
+    GSObjCTypeLong              = 'l',
+    GSObjCTypeUnsignedLong      = 'L',
+    GSObjCTypeLongLong          = 'q',
+    GSObjCTypeUnsignedLongLong  = 'Q',
+    GSObjCTypeFloat             = 'f',
+    GSObjCTypeDouble            = 'd',
+    GSObjCTypeComplex           = 'j',
+    GSObjCTypeBitField          = 'b',
+    GSObjCTypeBool              = 'B',
+    GSObjCTypeVoid              = 'v',
+    GSObjCTypePointer           = '^',
+    GSObjCTypeCharPointer       = '*',
+    GSObjCTypeAtom              = '%',
+    GSObjCTypeArrayBegin        = '[',
+    GSObjCTypeArrayEnd          = ']',
+    GSObjCTypeStructureBegin    = '{',
+    GSObjCTypeStructureEnd      = '}',
+    GSObjCTypeUnionBegin        = '(',
+    GSObjCTypeUnionEnd          = ')',
+    GSObjCTypeUnknown           = '?'
+} GSObjCType;
+
+/* maximum an minimum char values in a type specification */
+typedef enum GSObjCTypeBound
+{
+    GSObjCTypeMin               = ' ',
+    GSObjCTypeMax               = '~'
+} GSObjCTypeBound;
+
+#if defined (NeXT_RUNTIME)
+typedef enum GSObjCTypeQualifierMask
+{
+    GSObjCQualifierConstMask        = 0x01,
+    GSObjCQualifierInMask           = 0x01,
+    GSObjCQualifierOutMask          = 0x02,
+    GSObjCQualifierInOutMask        = 0x03,
+    GSObjCQualifierByCopyMask       = 0x04,
+    GSObjCQualifierByRefMask        = 0x08,
+    GSObjCQualifierOneWayMask       = 0x10,
+    GSObjCQualifierInvisibleMask    = 0x20
+} GSObjCTypeQualifierMask;
+#else
+typedef enum GSObjCTypeQualifierMask
+{
+    GSObjCQualifierConstMask        = _F_CONST,
+    GSObjCQualifierInMask           = _F_IN,
+    GSObjCQualifierOutMask          = _F_OUT,
+    GSObjCQualifierInOutMask        = _F_INOUT,
+    GSObjCQualifierByCopyMask       = _F_BYCOPY,
+    GSObjCQualifierByRefMask        = _F_BYREF,
+    GSObjCQualifierOneWayMask       = _F_ONEWAY,
+    GSObjCQualifierInvisibleMask    = _F_GCINVISIBLE
+} GSObjCTypeQualifierMask;
+#endif
+
+/*
+ * parser-related stuff
+ */
+
+typedef struct GSObjCTypeInfo {
+    /* store pointer to allow recursive parsing of pointer types, e.g. ^{^[2*]} */
+    const char  *type;
+    size_t      size;
+    uint8_t     alignment;
+    uint8_t     qualifiers;
+} GSObjCTypeInfo;
+
+typedef void (*GSObjCTypeParserDelegate)(void *context, GSObjCTypeInfo type);
+
+typedef enum GSObjCParserOptions {
+    GSObjCReportArrayOnceMask = 1
+} GSObjCParserOptions;
+
+const char *
+GSObjCParseTypeSpecification (const char *cursor,
+                              GSObjCTypeParserDelegate delegate,
+                              void *context,
+                              unsigned options);
+
+ENCODING_INLINE size_t
+GSObjCPadSize (size_t size, uint8_t alignment)
+{
+    return alignment * ((size + alignment - 1) / alignment);
+}
+
+ENCODING_INLINE size_t
+GSObjCGetPadding (size_t size, uint8_t alignment)
+{
+    return (alignment - (size & (alignment - 1))) & (alignment - 1);
+}
+
+const char *
+GSGetSizeAndAlignment (const char *type, size_t *sizep, uint8_t *alignp);
+
+
+#if defined (NeXT_RUNTIME)
+
+/* GNU API support for NeXT runtime */
+
+int
+objc_sizeof_type (const char* type);
+int
+objc_alignof_type (const char* type);
+int
+objc_aligned_size (const char* type);
+int
+objc_promoted_size (const char* type);
+
+unsigned
+objc_get_type_qualifiers (const char* type);
+
+const char *
+objc_skip_typespec (const char* type);
+const char *
+objc_skip_offset (const char* type);
+const char *
+objc_skip_argspec (const char* type);
+const char *
+objc_skip_type_qualifiers (const char* type);
+
+struct objc_struct_layout
+{
+    GSObjCTypeInfo  *info;
+    long            position;
+    unsigned        count;
+    unsigned        allocated;
+    unsigned        depth;
+    unsigned        offset;
+    unsigned        alignment;
+};
+
+void
+objc_layout_structure (const char *type,
+                       struct objc_struct_layout *layout);
+
+BOOL
+objc_layout_structure_next_member (struct objc_struct_layout *layout);
+
+void
+objc_layout_structure_get_info (struct objc_struct_layout *layout,
+                                unsigned int *offset,
+                                unsigned int *align,
+                                const char **type);
+
+void
+objc_layout_finish_structure (struct objc_struct_layout *layout,
+                              unsigned int *size,
+                              unsigned int *align);
+
+#endif /* NeXT_RUNTIME */
+#endif /* GS_TYPE_ENCODING_H */
\ No newline at end of file
diff --git a/Headers/GNUstepBase/GSVersionMacros.h b/Headers/GNUstepBase/GSVersionMacros.h
index 9bbbcc9..4d58c05 100644
--- a/Headers/GNUstepBase/GSVersionMacros.h
+++ b/Headers/GNUstepBase/GSVersionMacros.h
@@ -27,17 +27,17 @@
 
 /* By default we defined NO_GNUSTEP to 0 so that we will include extensions.
  */
-#if	!defined(NO_GNUSTEP)
+#if !defined(NO_GNUSTEP)
 #  define	NO_GNUSTEP	0
 #endif
 
 /* Check consistency of definitions for system compatibility.
  */
-#if	defined(STRICT_OPENSTEP)
+#if defined(STRICT_OPENSTEP)
 #  define	GS_OPENSTEP_V	 10000
 #  undef	NO_GNUSTEP
 #  define	NO_GNUSTEP	1
-#elif	defined(STRICT_MACOS_X)
+#elif defined(STRICT_MACOS_X)
 #  define	GS_OPENSTEP_V	100600
 #  undef	NO_GNUSTEP
 #  define	NO_GNUSTEP	1
@@ -49,25 +49,53 @@
  * instead of GS_OPENSTEP_V
  */
 
+/*
+ * "For MacOS-X compatibility, we define the MacOS-X version constants"
+ * that are COMPLETELY INCOMPATIBLE with MacOS-X 
+ */
 #ifndef	MAC_OS_X_VERSION_10_0
-#define	MAC_OS_X_VERSION_10_0	100000
-#define	MAC_OS_X_VERSION_10_1	100100
-#define	MAC_OS_X_VERSION_10_2	100200
-#define	MAC_OS_X_VERSION_10_3	100300
-#define	MAC_OS_X_VERSION_10_4	100400
-#define	MAC_OS_X_VERSION_10_5	100500
-#define	MAC_OS_X_VERSION_10_6	100600
+#  define MAC_OS_X_VERSION_10_0 100000
+#  define MAC_OS_X_VERSION_10_1 100100
+#  define MAC_OS_X_VERSION_10_2 100200
+#  define MAC_OS_X_VERSION_10_3 100300
+#  define MAC_OS_X_VERSION_10_4 100400
+#  define MAC_OS_X_VERSION_10_5 100500
+#  define MAC_OS_X_VERSION_10_6 100600
 #endif	/* MAC_OS_X_VERSION_10_0 */
 
+#ifndef MAC_OS_X_VERSION_10_7
+# if MAC_OS_X_VERSION_10_6 > 1060
+#   define MAC_OS_X_VERSION_10_7 100700
+# else
+#   define MAC_OS_X_VERSION_10_7 1070
+# endif
+#endif
+
+/*
+ * This library relies on GS_OPENSTEP_V to be not defined at all. Technically, 
+ * it needs MAC_OS_X_VERSION_MIN_ALLOWED and MAC_OS_X_VERSION_MAX_ALLOWED not 
+ * to be defined during the compilation of the library itself, but it's compiled
+ * with "-pthread" and as a consequence system headers are included which in 
+ * their turn include AvailabilityMacros.h and it defines both of them. 
+ * And GS_OPENSTEP_V gets defined and all the OS_API_VERSION(*, GS_API_NONE) 
+ * fail, and the  implementation of the library relies on the functionality 
+ * introduced up to 10.7 API version and everything goes bad.
+ *
+ * So, just disable it for now.
+ */
+#if 0
+
 #ifndef	GS_OPENSTEP_V
-#ifdef	MAC_OS_X_VERSION_MIN_ALLOWED
-#define	GS_OPENSTEP_V	MAC_OS_X_VERSION_MIN_ALLOWED
-#else
-#ifdef	MAC_OS_X_VERSION_MAX_ALLOWED
-#define	GS_OPENSTEP_V	MAC_OS_X_VERSION_MAX_ALLOWED
-#endif	/* MAC_OS_X_VERSION_MAX_ALLOWED */
-#endif	/* MAC_OS_X_VERSION_MIN_ALLOWED */
-#endif	/* GS_OPENSTEP_V */
+#  ifdef MAC_OS_X_VERSION_MIN_ALLOWED
+#    define GS_OPENSTEP_V       MAC_OS_X_VERSION_MIN_ALLOWED
+#  else
+#    ifdef MAC_OS_X_VERSION_MAX_ALLOWED
+#      define GS_OPENSTEP_V     MAC_OS_X_VERSION_MAX_ALLOWED
+#    endif /* MAC_OS_X_VERSION_MAX_ALLOWED */
+#  endif /* MAC_OS_X_VERSION_MIN_ALLOWED */
+#endif /* GS_OPENSTEP_V */
+
+#endif /* 0 */
 
 /*
  * NB. The version values below must be integers ... by convention these are
@@ -184,13 +212,13 @@
  * (GS_API_MACOSX, GS_API_LATEST)<br />
  * denotes code present from the initial MacOS-X version onwards.
  */
-#define	GS_API_MACOSX	100000
+#define	GS_API_MACOSX	MAC_OS_X_VERSION_10_0
 
 
-#if	defined(GNUSTEP_BASE_INTERNAL)
-#import "GNUstepBase/GSConfig.h"
+#if defined(GNUSTEP_BASE_INTERNAL)
+#  import "GNUstepBase/GSConfig.h"
 #else
-#import <GNUstepBase/GSConfig.h>
+#  import <GNUstepBase/GSConfig.h>
 #endif
 
 
@@ -223,7 +251,11 @@
 
 
 #ifndef __has_feature
-#define __has_feature(x) 0
+#  define __has_feature(x) 0
+#endif
+
+#ifndef __has_attribute
+#  define __has_attribute(x) 0
 #endif
 
 /* The following is for deciding whether private instance variables
@@ -238,13 +270,13 @@
  * in the class source itsself
  */
 
-#if	GS_MIXEDABI
+#if GS_MIXEDABI
 #  undef	GS_NONFRAGILE
 #  define	GS_NONFRAGILE	0	/* Mixed is treated as fragile */
 #else
 #  if (__has_feature(objc_nonfragile_abi))
 #    if	!GS_NONFRAGILE
-#      if	defined(GNUSTEP_BASE_INTERNAL)
+#      if defined(GNUSTEP_BASE_INTERNAL)
 #        error "You are building gnustep-base using the objc-nonfragile-abi but your gnustep-base was not configured to use it."
 #      endif
 #    endif
@@ -264,47 +296,6 @@
 #  define GS_NORETURN_METHOD
 #endif
 
-#ifndef NS_RETURNS_RETAINED
-#  if __has_feature(attribute_ns_returns_retained)
-#    define NS_RETURNS_RETAINED __attribute__((ns_returns_retained))
-#  else
-#    define NS_RETURNS_RETAINED
-#  endif
-#endif
-
-#ifndef NS_RETURNS_NOT_RETAINED
-#  if __has_feature(attribute_ns_returns_not_retained)
-#    define NS_RETURNS_NOT_RETAINED __attribute__((ns_returns_not_retained))
-#  else
-#    define NS_RETURNS_NOT_RETAINED
-#  endif
-#endif
-
-#ifndef NS_CONSUMED
-#  if __has_feature(attribute_ns_consumed)
-#    define NS_CONSUMED __attribute__((ns_consumed))
-#  else
-#    define NS_CONSUMED
-#  endif
-#endif
-
-
-#ifndef NS_CONSUMES_SELF
-#  if __has_feature(attribute_ns_consumes_self)
-#    define NS_CONSUMES_SELF __attribute__((ns_consumes_self))
-#  else
-#    define NS_CONSUMES_SELF
-#  endif
-#endif
-
-#if defined(__clang__) && defined(__OBJC__)
-static inline void gs_consumed(id NS_CONSUMED o) GS_UNUSED_FUNC;
-static inline void gs_consumed(id NS_CONSUMED GS_UNUSED_ARG o) { return; }
-#define	GS_CONSUMED(O)	gs_consumed(O);
-#else
-#define	GS_CONSUMED(O)
-#endif
-
 /* Include the appropriate header for ObjC2 blocks support if it is in use.
  *
  * FIXME: "OBJC2RUNTIME" is set to "1" if the runtime supports the ObjC2
@@ -312,8 +303,8 @@ static inline void gs_consumed(id NS_CONSUMED GS_UNUSED_ARG o) { return; }
  * support or not.
  */
 #if __has_feature(blocks)
-#  if	OBJC2RUNTIME
-#    if defined(_APPLE_)
+#  if OBJC2RUNTIME
+#    if defined(__APPLE__)
 #      include <Block.h>
 #    else
 #      include <objc/blocks_runtime.h>
@@ -327,7 +318,7 @@ static inline void gs_consumed(id NS_CONSUMED GS_UNUSED_ARG o) { return; }
  * of the class.
  */
 #ifndef GS_ROOT_CLASS
-#  if GS_HAVE_OBJC_ROOT_CLASS_ATTR || __has_feature(attribute_objc_root_class)
+#  if GS_HAVE_OBJC_ROOT_CLASS_ATTR || __has_attribute(objc_root_class)
 #    define GS_ROOT_CLASS __attribute__((objc_root_class))
 #  else
 #    define GS_ROOT_CLASS
@@ -336,49 +327,28 @@ static inline void gs_consumed(id NS_CONSUMED GS_UNUSED_ARG o) { return; }
 
 
 
-#if	defined(GNUSTEP_WITH_DLL)
-
-#if BUILD_libgnustep_base_DLL
-#
-# if defined(__MINGW__)
-  /* On Mingw, the compiler will export all symbols automatically, so
-   * __declspec(dllexport) is not needed.
-   */
-#  define GS_EXPORT  extern
-#  define GS_DECLARE
-# else
-#  define GS_EXPORT  __declspec(dllexport)
-#  define GS_DECLARE __declspec(dllexport)
-# endif
-#else
-#  define GS_EXPORT  extern __declspec(dllimport)
-#  define GS_DECLARE __declspec(dllimport)
-#endif
-
-#else /* GNUSTEP_WITH[OUT]_DLL */
-
+/* Define appropriate export and import macros.
+ * On Mingw, the compiler will export all symbols automatically, 
+ * so __declspec(dllexport) is not needed while building Foundation.
+ */
+#if defined(GNUSTEP_WITH_DLL)
+#  if BUILD_libgnustep_base_DLL
+#    if defined(__MINGW__)
+#      define GS_EXPORT  extern
+#      define GS_DECLARE
+#    else
+#      define GS_EXPORT  __declspec(dllexport)
+#      define GS_DECLARE __declspec(dllexport)
+#    endif
+#  else /* BUILD_libgnustep_base_DLL */
+#    define GS_EXPORT  extern __declspec(dllimport)
+#    define GS_DECLARE __declspec(dllimport)
+#  endif /* BUILD_libgnustep_base_DLL */
+#else /* GNUSTEP_WITH_DLL */
 #  define GS_EXPORT extern
 #  define GS_DECLARE
+#endif /* GNUSTEP_WITH_DLL */
 
-#endif
-
-
-/* Attribute macros compatible with Apple.
- */
-
-#if __GNUC__*10+__GNUC_MINOR__ >= 42
-#  define NS_FORMAT_ARGUMENT(A) __attribute__((format_arg(A)))
-#else
-#  define NS_FORMAT_ARGUMENT(F,A) 
-#endif
-
-#if __GNUC__*10+__GNUC_MINOR__ >= 42
-#  define NS_FORMAT_FUNCTION(F,A) __attribute__((format(__NSString__, F, A)))
-#else
-#  define NS_FORMAT_FUNCTION(F,A) 
-#endif
-
-#define NS_REQUIRES_NIL_TERMINATION __attribute__((sentinel))
 
 
-#endif /* __GNUSTEP_GSVERSIONMACROS_H_INCLUDED_ */
+#endif /* __GNUSTEP_GSVERSIONMACROS_H_INCLUDED_ */
\ No newline at end of file
diff --git a/Headers/GNUstepBase/NSBundle+GNUstepBase.h b/Headers/GNUstepBase/NSBundle+GNUstepBase.h
index 4fcd748..5b0c6fe 100644
--- a/Headers/GNUstepBase/NSBundle+GNUstepBase.h
+++ b/Headers/GNUstepBase/NSBundle+GNUstepBase.h
@@ -36,10 +36,12 @@ extern "C" {
 
 #if	OS_API_VERSION(GS_API_NONE,GS_API_LATEST)
 
-@interface NSBundle(GNUstepBase)
+@interface NSBundle (GNUstepBase)
+#ifndef GNUSTEP /* declared in NSBundle */
 + (NSString *) pathForLibraryResource: (NSString *)name
-                               ofType: (NSString *)ext
+                               ofType: (NSString *)extension
                           inDirectory: (NSString *)bundlePath;
+#endif
 @end
 
 #endif	/* OS_API_VERSION */
diff --git a/Headers/GNUstepBase/NSLock+GNUstepBase.h b/Headers/GNUstepBase/NSLock+GNUstepBase.h
index 4451a54..9261a91 100644
--- a/Headers/GNUstepBase/NSLock+GNUstepBase.h
+++ b/Headers/GNUstepBase/NSLock+GNUstepBase.h
@@ -44,7 +44,7 @@ extern "C" {
  * IDENT is considered uninitialized, if it contains nil.
  * CLASSNAME must be either NSLock, NSRecursiveLock or one
  * of their subclasses.
- * See [NSLock+newLockAt:] for details.
+ * See +[NSLock createLockAt:] for details.
  * This macro is intended for code that cannot insure
  * that a lock can be initialized in thread safe manner otherwise.
  * <example>
@@ -59,8 +59,14 @@ extern "C" {
  *
  * </example>
  */
-#define GS_INITIALIZED_LOCK(IDENT,CLASSNAME) \
-           (IDENT != nil ? (id)IDENT : (id)[CLASSNAME newLockAt: &IDENT])
+#define GS_INITIALIZED_LOCK(IDENT, CLASSNAME)       \
+({                                                  \
+    if (IDENT == nil)                               \
+    {                                               \
+        [CLASSNAME createLockAt:&IDENT];            \
+    }                                               \
+    (id)IDENT;                                      \
+})
 
 @interface NSLock (GNUstepBase)
 /**
@@ -68,7 +74,6 @@ extern "C" {
  * with a new instance of the receiver's class
  * in a thread safe manner, unless
  * it has been previously initialized.
- * Returns the contents pointed to by location.  
  * The location is considered unintialized if it contains nil.
  * <br/>
  * This method is used in the GS_INITIALIZED_LOCK macro
@@ -86,7 +91,7 @@ extern "C" {
  * 
  * </example>
  */
-+ (id) newLockAt: (id *)location;
++ (void)createLockAt:(id *)location;
 @end
 
 @interface NSRecursiveLock (GNUstepBase)
@@ -95,7 +100,6 @@ extern "C" {
  * with a new instance of the receiver's class
  * in a thread safe manner, unless
  * it has been previously initialized.
- * Returns the contents pointed to by location.  
  * The location is considered unintialized if it contains nil.
  * <br/>
  * This method is used in the GS_INITIALIZED_LOCK macro
@@ -113,7 +117,7 @@ extern "C" {
  * 
  * </example>
  */
-+ (id) newLockAt: (id *)location;
++ (void)createLockAt:(id *)location;
 @end
 
 #endif	/* OS_API_VERSION */
diff --git a/Headers/GNUstepBase/NSObject+GNUstepBase.h b/Headers/GNUstepBase/NSObject+GNUstepBase.h
index cff8942..08bdd78 100644
--- a/Headers/GNUstepBase/NSObject+GNUstepBase.h
+++ b/Headers/GNUstepBase/NSObject+GNUstepBase.h
@@ -59,15 +59,13 @@ extern "C" {
  * Transmutes the receiver into an immutable version of the same object
  * and returns the result.<br />
  * If the receiver is not a mutable object or cannot be simply transmuted,
- * then this method either returns the receiver unchanged or,
- * if the force flag is set to YES, returns an autoreleased copy of the
- * receiver.<br />
+ * then returns a copy of the receiver.<br />
  * Mutable classes should override this default implementation.<br />
  * This method is used in methods which are declared to return immutable
  * objects (eg. an NSArray), but which create and build mutable ones
  * internally.
  */
-- (id) makeImmutableCopyOnFail: (BOOL)force;
+- (id) makeImmutable NS_RETURNS_RETAINED NS_CONSUMES_SELF;
 
 /**
  * Message sent when an implementation wants to explicitly exclude a method
@@ -144,7 +142,12 @@ extern "C" {
  * it is released during process exit if cleanup is enabled.<br />
  * Returns its argument.
  */
-+ (id) NS_RETURNS_RETAINED leak: (id)anObject;
++ (id) leak: (id)anObject;
+
+/**
+ * Same as above, but does not retain anObject
+ */
++ (id) leakRetained: (id) NS_CONSUMED anObject;
 
 /** This method retains the object at *anAddress so that it will never be
  * deallocated during normal operation, but keeps track of the address
@@ -152,7 +155,7 @@ extern "C" {
  * exit if cleanup is enabled.<br />
  * Returns the object at *anAddress.
  */
-+ (id) NS_RETURNS_RETAINED leakAt: (id*)anAddress;
++ (id) leakAt: (id*)anAddress;
 
 /** Sets the receiver to have its +atExit method called at the point when
  * the process terminates.<br />
diff --git a/Headers/GNUstepBase/NSString+GNUstepBase.h b/Headers/GNUstepBase/NSString+GNUstepBase.h
index 09a64cf..23b3de9 100644
--- a/Headers/GNUstepBase/NSString+GNUstepBase.h
+++ b/Headers/GNUstepBase/NSString+GNUstepBase.h
@@ -88,10 +88,12 @@ extern "C" {
 - (NSString*) stringByReplacingString: (NSString*)replace
 			   withString: (NSString*)by;
 
+#ifndef GNUSTEP /* declared in NSString */
 /**
  * An obsolete name for -substringWithRange: ... deprecated.
  */
 - (NSString*) substringFromRange: (NSRange)aRange;
+#endif
 
 @end
 
diff --git a/Headers/GNUstepBase/Unicode.h b/Headers/GNUstepBase/Unicode.h
index 6053c61..f95faf1 100644
--- a/Headers/GNUstepBase/Unicode.h
+++ b/Headers/GNUstepBase/Unicode.h
@@ -98,7 +98,7 @@ GS_EXPORT unichar uni_toupper(unichar ch);
 GS_EXPORT unsigned char uni_cop(unichar u);
 GS_EXPORT BOOL uni_isnonsp(unichar u);
 GS_EXPORT unichar *uni_is_decomp(unichar u);
-GS_EXPORT unsigned GSUnicode(const unichar *chars, unsigned length,
+GS_EXPORT NSUInteger GSUnicode(const unichar *chars, NSUInteger length,
   BOOL *isASCII, BOOL *isLatin1);
 #endif
 
@@ -112,11 +112,11 @@ GS_EXPORT unsigned GSUnicode(const unichar *chars, unsigned length,
 #define	GSUniBOM	0x08
 #define	GSUniShortOk	0x10
 
-GS_EXPORT BOOL GSFromUnicode(unsigned char **dst, unsigned int *size,
-  const unichar *src, unsigned int slen, NSStringEncoding enc, NSZone *zone,
+GS_EXPORT BOOL GSFromUnicode(unsigned char **dst, NSUInteger *size,
+  const unichar *src, NSUInteger slen, NSStringEncoding enc, NSZone *zone,
   unsigned int options);
-GS_EXPORT BOOL GSToUnicode(unichar **dst, unsigned int *size,
-  const unsigned char *src, unsigned int slen, NSStringEncoding enc,
+GS_EXPORT BOOL GSToUnicode(unichar **dst, NSUInteger *size,
+  const unsigned char *src, NSUInteger slen, NSStringEncoding enc,
   NSZone *zone, unsigned int options);
 
 #if	defined(__cplusplus)
diff --git a/Source/Additions/GCArray.m b/Source/Additions/GCArray.m
index 29865f1..562cb4e 100644
--- a/Source/Additions/GCArray.m
+++ b/Source/Additions/GCArray.m
@@ -208,8 +208,8 @@ static Class	gcClass = 0;
   if (index >= _count)
     {
       [NSException raise: NSRangeException
-		  format: @"[%@-%@]: index: %u",
-	NSStringFromClass([self class]), NSStringFromSelector(_cmd), index];
+		  format: @"[%@-%@]: index: %lu",
+	NSStringFromClass([self class]), NSStringFromSelector(_cmd), (unsigned long)index];
     }
   return _contents[index];
 }
@@ -333,8 +333,8 @@ static Class	gcClass = 0;
   if (index > _count)
     {
       [NSException raise: NSRangeException
-		  format: @"[%@-%@]: bad index %u",
-	NSStringFromClass([self class]), NSStringFromSelector(_cmd), index];
+		  format: @"[%@-%@]: bad index %lu",
+	NSStringFromClass([self class]), NSStringFromSelector(_cmd), (unsigned long)index];
     }
 
   if (_count == _maxCount)
@@ -419,8 +419,8 @@ static Class	gcClass = 0;
   if (index >= _count)
     {
       [NSException raise: NSRangeException
-		  format: @"[%@-%@]: bad index %u",
-	NSStringFromClass([self class]), NSStringFromSelector(_cmd), index];
+		  format: @"[%@-%@]: bad index %lu",
+	NSStringFromClass([self class]), NSStringFromSelector(_cmd), (unsigned long)index];
     }
   ASSIGN(_contents[index], anObject);
   _isGCObject[index] = [anObject isKindOfClass: gcClass];
diff --git a/Source/Additions/GCDictionary.m b/Source/Additions/GCDictionary.m
index 092393c..6d00f3b 100644
--- a/Source/Additions/GCDictionary.m
+++ b/Source/Additions/GCDictionary.m
@@ -84,7 +84,7 @@ typedef struct {
 
 @implementation GCDictionary
 
-static unsigned
+static NSUInteger
 _GCHashObject(NSMapTable *table, const GCInfo *objectStruct)
 {
   return [objectStruct->object hash];
diff --git a/Source/Additions/GNUmakefile b/Source/Additions/GNUmakefile
index dc0062d..f1d0f92 100644
--- a/Source/Additions/GNUmakefile
+++ b/Source/Additions/GNUmakefile
@@ -64,6 +64,9 @@ Additions_OBJC_FILES =\
 
 Additions_OBJC_FILES += Unicode.m
 
+Additions_C_FILES = \
+        GSTypeEncoding.c
+
 -include Makefile.preamble
 
 include $(GNUSTEP_MAKEFILES)/subproject.make
diff --git a/Source/Additions/GSInsensitiveDictionary.m b/Source/Additions/GSInsensitiveDictionary.m
index 0225236..3f174d3 100644
--- a/Source/Additions/GSInsensitiveDictionary.m
+++ b/Source/Additions/GSInsensitiveDictionary.m
@@ -163,7 +163,9 @@ static SEL	objSel;
         {
 	  (*imp)(aCoder, sel, type, &key);
 	  (*imp)(aCoder, sel, type, &value);
-	  GSIMapAddPairNoRetain(&map, (GSIMapKey)key, (GSIMapVal)value);
+	  GSIMapAddPair(&map, (GSIMapKey)key, (GSIMapVal)value);
+            [key release];
+            [value release];
 	}
     }
   return self;
@@ -271,8 +273,10 @@ static SEL	objSel;
 	    }
 	  else
 	    {
-	      GSIMapAddPairNoRetain(&map, (GSIMapKey)k, (GSIMapVal)o);
+	      GSIMapAddPair(&map, (GSIMapKey)k, (GSIMapVal)o);
+            [o release];
 	    }
+        [k release];
 	}
     }
   return self;
@@ -371,7 +375,7 @@ static SEL	objSel;
   return self;
 }
 
-- (id) makeImmutableCopyOnFail: (BOOL)force
+- (id) makeImmutable
 {
   GSClassSwizzle(self, [_GSInsensitiveDictionary class]);
   return self;
@@ -433,10 +437,12 @@ static SEL	objSel;
 
 - (id) initWithDictionary: (NSDictionary*)d
 {
-  [super init];
-  dictionary = (_GSInsensitiveDictionary*)RETAIN(d);
-  enumerator = GSIMapEnumeratorForMap(&dictionary->map);
-  return self;
+    if (self = [super init])
+    {
+        dictionary = (_GSInsensitiveDictionary*)RETAIN(d);
+        enumerator = GSIMapEnumeratorForMap(&dictionary->map);
+    }
+    return self;
 }
 
 - (id) nextObject
diff --git a/Source/Additions/GSMime.m b/Source/Additions/GSMime.m
index 86fc179..d51185a 100644
--- a/Source/Additions/GSMime.m
+++ b/Source/Additions/GSMime.m
@@ -141,11 +141,11 @@ decodebase64(unsigned char *dst, const unsigned char *src)
 static char b64[]
   = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
 
-static int
-encodebase64(unsigned char *dst, const unsigned char *src, int length)
+static NSUInteger
+encodebase64(unsigned char *dst, const unsigned char *src, NSUInteger length)
 {
-  int	dIndex = 0;
-  int	sIndex;
+  NSUInteger dIndex = 0;
+  NSUInteger sIndex;
 
   for (sIndex = 0; sIndex < length; sIndex += 3)
     {
@@ -179,13 +179,13 @@ encodebase64(unsigned char *dst, const unsigned char *src, int length)
 
 static void
 encodeQuotedPrintable(NSMutableData *result,
-  const unsigned char *src, unsigned length)
+  const unsigned char *src, NSUInteger length)
 {
   static char	*hex = "0123456789ABCDEF";
-  unsigned	offset;
-  unsigned	column = 0;
-  unsigned	size = 0;
-  unsigned	i;
+  NSUInteger offset;
+  NSUInteger column = 0;
+  NSUInteger size = 0;
+  NSUInteger i;
   unsigned char	*dst;
 
   for (i = 0; i < length; i++)
@@ -521,13 +521,13 @@ wordData(NSString *word)
     }
   else
     {
-      int		len = [charset length];
-      char		buf[len + 1];
+      NSUInteger len = [charset length];
+      char buf[len + 1];
       NSMutableData	*md;
 
       [charset getCString: buf
-		maxLength: len + 1
-		 encoding: NSISOLatin1StringEncoding];
+                maxLength: len + 1
+                 encoding: NSISOLatin1StringEncoding];
       md = [NSMutableData dataWithCapacity: [d length]*4/3 + len + 8];
       d = [documentClass encodeBase64: d];
       [md appendBytes: "=?" length: 2];
@@ -1302,7 +1302,7 @@ wordData(NSString *word)
 {
   NSMutableString	*desc;
 
-  desc = [NSMutableString stringWithFormat: @"GSMimeParser <%0x> -\n", self];
+  desc = [NSMutableString stringWithFormat: @"GSMimeParser <%0lx> -\n", (unsigned long)self];
   [desc appendString: [document description]];
   return desc;
 }
@@ -1535,7 +1535,7 @@ wordData(NSString *word)
       return NO;		/* Want no more data	*/
     }
 
-  NSDebugMLLog(@"GSMime", @"Parse %u bytes - '%*.*s'", l, l, l, [d bytes]);
+  NSDebugMLLog(@"GSMime", @"Parse %lu bytes - '%*.*s'", (unsigned long)l, (int)l, (int)l, [d bytes]);
 
   r = [self _endOfHeaders: d];
   if (r.location == NSNotFound)
@@ -1625,8 +1625,7 @@ wordData(NSString *word)
                * This is an intermediary response ... so we have
                * to restart the parsing operation!
                */
-              NSDebugMLLog(@"GSMime",
-                @"Parsed http continuation", "");
+              NSDebugMLLog(@"GSMime", @"Parsed http continuation");
               flags.inBody = 0;
               if ([d length] == 0)
                 {
@@ -1958,11 +1957,11 @@ NSDebugMLLog(@"GSMime", @"Header parsed - %@", info);
    */
   if ([name isEqualToString: @"http"] == YES)
     {
-      int	loc = [scanner scanLocation];
+      NSUInteger loc = [scanner scanLocation];
       int	major;
       int	minor;
       int	status;
-      NSUInteger	count;
+      NSUInteger count;
       NSArray	*hdrs;
 
       if ([scanner scanInt: &major] == NO || major < 0)
@@ -2083,7 +2082,7 @@ NSDebugMLLog(@"GSMime", @"Header parsed - %@", info);
     }
   else
     {
-      int	loc;
+      NSUInteger loc;
 
       [self scanPastSpace: scanner];
       loc = [scanner scanLocation];
@@ -2212,7 +2211,7 @@ NSDebugMLLog(@"GSMime", @"Header parsed - %@", info);
 	    }
 	  if ([string characterAtIndex: r.location - 1] == '\\')
 	    {
-	      int	p;
+	      NSUInteger p;
 
 	      /*
                * Count number of escape ('\') characters ... if it's odd
@@ -2421,10 +2420,10 @@ NSDebugMLLog(@"GSMime", @"Header parsed - %@", info);
 	}
       context = [self contextFor: hdr];
       IF_NO_GC([context retain];)
-      NSDebugMLLog(@"GSMime", @"Parse body expects %u bytes", expect);
+      NSDebugMLLog(@"GSMime", @"Parse body expects %lu bytes", (unsigned long)expect);
     }
 
-  NSDebugMLLog(@"GSMime", @"Parse %u bytes - '%*.*s'", l, l, l, [d bytes]);
+  NSDebugMLLog(@"GSMime", @"Parse %lu bytes - '%*.*s'", (unsigned long)l, (int)l, (int)l, [d bytes]);
   // NSDebugMLLog(@"GSMime", @"Boundary - '%*.*s'", [boundary length], [boundary length], [boundary bytes]);
 
   if ([context atEnd] == YES)
@@ -2480,7 +2479,7 @@ NSDebugMLLog(@"GSMime", @"Header parsed - %@", info);
 	      flags.inBody = 0;
 	      flags.complete = 1;
 
-	      NSDebugMLLog(@"GSMime", @"Parse body complete", "");
+	      NSDebugMLLog(@"GSMime", @"Parse body complete");
 	      /*
 	       * If no content type is supplied, we assume text ... unless
 	       * we have something that's known to be a file.
@@ -3086,10 +3085,10 @@ unfold(const unsigned char *src, const unsigned char *end, BOOL *folded)
  */
 - (NSRange) _endOfHeaders: (NSData*)newData
 {
-  unsigned int		ol = [data length];
-  unsigned int		nl = [newData length];
-  unsigned int		len = ol + nl;
-  unsigned int		pos = ol;
+  NSUInteger ol = [data length];
+  NSUInteger nl = [newData length];
+  NSUInteger len = ol + nl;
+  NSUInteger pos = ol;
   const unsigned char	*op = (const unsigned char*)[data bytes];
   const unsigned char	*np = (const unsigned char*)[newData bytes];
   char			c;
@@ -3430,7 +3429,7 @@ static NSCharacterSet	*tokenSet = nil;
 {
   NSMutableString	*desc;
 
-  desc = [NSMutableString stringWithFormat: @"GSMimeHeader <%0x> -\n", self];
+  desc = [NSMutableString stringWithFormat: @"GSMimeHeader <%0lx> -\n", (unsigned long)self];
   [desc appendFormat: @"  name: %@\n", [self name]];
   [desc appendFormat: @"  value: %@\n", [self value]];
   [desc appendFormat: @"  params: %@\n", [self parameters]];
@@ -3451,7 +3450,7 @@ static NSCharacterSet	*tokenSet = nil;
       NSEnumerator	*e;
       NSString		*k;
 
-      m = [[value mutableCopy] autorelease];
+      m = [value mutableCopy];
       e = [params keyEnumerator];
       while ((k = [e nextObject]) != nil)
 	{
@@ -3463,7 +3462,7 @@ static NSCharacterSet	*tokenSet = nil;
 	  [m appendString: @"="];
 	  [m appendString: v];
 	}
-      return [m makeImmutableCopyOnFail: YES];
+      return [[m makeImmutable] autorelease];
     }
   else
     {
@@ -3608,7 +3607,7 @@ static NSCharacterSet	*tokenSet = nil;
   NSEnumerator		*e;
   NSString		*k;
 
-  m = [NSMutableDictionary dictionaryWithCapacity: [params count]];
+  m = [[NSMutableDictionary alloc] initWithCapacity: [params count]];
   e = [params keyEnumerator];
   if (preserve == YES)
     {
@@ -3624,7 +3623,7 @@ static NSCharacterSet	*tokenSet = nil;
 	  [m setObject: [params objectForKey: k] forKey: [k lowercaseString]];
 	}
     }
-  return [m makeImmutableCopyOnFail: YES];
+  return [[m makeImmutable] autorelease];
 }
 
 static NSUInteger
@@ -3836,7 +3835,7 @@ appendString(NSMutableData *m, NSUInteger offset, NSUInteger fold,
   if (ok == NO)
     {
       NSDebugMLLog(@"GSMime",
-	@"Value for '%@' too long for folding at %u in header", n, fold);
+	@"Value for '%@' too long for folding at %lu in header", n, (unsigned long)fold);
     }
 
   while ((k = [e nextObject]) != nil)
@@ -3854,16 +3853,16 @@ appendString(NSMutableData *m, NSUInteger offset, NSUInteger fold,
       if (ok == NO)
         {
 	  NSDebugMLLog(@"GSMime",
-	    @"Parameter name '%@' in '%@' too long for folding at %u",
-            k, n, fold);
+	    @"Parameter name '%@' in '%@' too long for folding at %lu",
+            k, n, (unsigned long)fold);
         }
       offset = appendBytes(md, offset, fold, "=", 1);
       offset = appendString(md, offset, fold, v, &ok);
       if (ok == NO)
         {
 	  NSDebugMLLog(@"GSMime",
-	    @"Parameter value for '%@' in '%@' too long for folding at %u",
-            k, n, fold);
+	    @"Parameter value for '%@' in '%@' too long for folding at %lu",
+            k, n, (unsigned long)fold);
         }
     }
   [md appendBytes: "\r\n" length: 2];
@@ -4189,8 +4188,8 @@ appendString(NSMutableData *m, NSUInteger offset, NSUInteger fold,
 
 + (NSData*) decodeBase64: (NSData*)source
 {
-  int		length;
-  int		declen;
+  NSUInteger length;
+  NSUInteger declen;
   const unsigned char	*src;
   const unsigned char	*end;
   unsigned char *result;
@@ -4338,8 +4337,8 @@ appendString(NSMutableData *m, NSUInteger offset, NSUInteger fold,
 
 + (NSData*) encodeBase64: (NSData*)source
 {
-  int		length;
-  int		destlen;
+  NSUInteger length;
+  NSUInteger destlen;
   unsigned char *sBuf;
   unsigned char *dBuf;
 
@@ -5449,7 +5448,7 @@ appendString(NSMutableData *m, NSUInteger offset, NSUInteger fold,
   NSMutableString	*desc;
   NSDictionary		*locale;
 
-  desc = [NSMutableString stringWithFormat: @"GSMimeDocument <%0x> -\n", self];
+  desc = [NSMutableString stringWithFormat: @"GSMimeDocument <%0lx> -\n", (unsigned long)self];
   locale = [[NSUserDefaults standardUserDefaults] dictionaryRepresentation];
   [desc appendString: [headers descriptionWithLocale: locale]];
   [desc appendFormat: @"\nDocument content -\n%@", content];
@@ -5581,7 +5580,7 @@ appendString(NSMutableData *m, NSUInteger offset, NSUInteger fold,
   NSData		*source;
   NSData		*digest;
   int			sequence = ++count;
-  int			length;
+  NSUInteger length;
 
   source = [[[NSProcessInfo processInfo] globallyUniqueString]
     dataUsingEncoding: NSUTF8StringEncoding];
@@ -6464,7 +6463,7 @@ typedef	enum	{
   SMTPE_DSN,		// delivery status notification extension
 } SMTPE;
 
-NSString *
+static NSString *
 eventText(NSStreamEvent e)
 {
   if (e == NSStreamEventNone)
@@ -6482,7 +6481,7 @@ eventText(NSStreamEvent e)
   return @"unknown event";
 }
 
-NSString *
+static NSString *
 statusText(NSStreamStatus s)
 {
   if (s == NSStreamStatusNotOpen) return @"NSStreamStatusNotOpen";
@@ -6749,12 +6748,10 @@ GS_PRIVATE_INTERNAL(GSMimeSMTPClient)
  */
 - (void) stream: (NSStream*)aStream handleEvent: (NSStreamEvent)anEvent
 {
-  NSStreamStatus	sStatus = [aStream streamStatus];
-
   if (aStream == internal->istream)
     {
       NSDebugMLLog(@"GSMime", @"%@ istream event %@ in %@",
-	self, eventText(anEvent), statusText(sStatus));
+	self, eventText(anEvent), statusText([aStream streamStatus]));
       if (anEvent == NSStreamEventHasBytesAvailable)
         {
 	  internal->readable = YES;
@@ -6763,7 +6760,7 @@ GS_PRIVATE_INTERNAL(GSMimeSMTPClient)
   else
     {
       NSDebugMLLog(@"GSMime", @"%@ ostream event %@ in %@",
-	self, eventText(anEvent), statusText(sStatus));
+	self, eventText(anEvent), statusText([aStream streamStatus]));
       if (anEvent == NSStreamEventHasSpaceAvailable)
         {
 	  internal->writable = YES;
@@ -6913,11 +6910,11 @@ GS_PRIVATE_INTERNAL(GSMimeSMTPClient)
 	  const char	*ibuf;
 	  char		*obuf;
 	  BOOL		sol = YES;
-	  unsigned	ilen;
-	  unsigned	olen;
-	  unsigned	osiz;
-	  unsigned	ipos = 0;
-	  unsigned	opos = 0;
+	  NSUInteger ilen;
+	  NSUInteger olen;
+	  NSUInteger osiz;
+	  NSUInteger ipos = 0;
+	  NSUInteger opos = 0;
 
 	  internal->cState = TP_BODY;
 
@@ -7013,8 +7010,8 @@ GS_PRIVATE_INTERNAL(GSMimeSMTPClient)
        */
       while (internal->readable == YES && internal->cState != TP_OPEN)
         {
-          uint8_t       buf[BUFSIZ];
-          int   	length;
+          uint8_t     buf[BUFSIZ];
+          NSUInteger  length;
 
           /* Try to fill the buffer, then process any data we have.
            */
@@ -7082,21 +7079,21 @@ GS_PRIVATE_INTERNAL(GSMimeSMTPClient)
        */
       while (internal->writable == YES && [internal->pending count] > 0)
         {
-          uint8_t   *wbytes = [internal->wdata mutableBytes];
-          unsigned  wlength = [internal->wdata length];
-          int       result;
+          uint8_t     *wbytes = [internal->wdata mutableBytes];
+          NSUInteger  wlength = [internal->wdata length];
+          NSUInteger  result;
 
           result = [internal->ostream write: wbytes + internal->woffset
 				  maxLength: wlength - internal->woffset];
           if (result > 0)
             {
               NSData    *d = [internal->pending objectAtIndex: 0];
-              unsigned  dlength = [d length];
+              NSUInteger dlength = [d length];
 
               internal->woffset += result;
               if (internal->woffset >= dlength)
                 {
-                  unsigned      total = 0;
+                  NSUInteger total = 0;
 
                   while (internal->woffset >= total + dlength)
                     {
@@ -7180,7 +7177,7 @@ GS_PRIVATE_INTERNAL(GSMimeSMTPClient)
       if (sep != ' ' && sep != '-')
 	{
 	  NSLog(@"Server made illegal response ... %@", s);
-          RELEASE(s);
+	  RELEASE(s);
 	  [self _shutdown: [self _response: @"bad format"]];
 	  return;
 	}
diff --git a/Source/Additions/GSObjCRuntime.m b/Source/Additions/GSObjCRuntime.m
index 8df40e7..eea7e13 100644
--- a/Source/Additions/GSObjCRuntime.m
+++ b/Source/Additions/GSObjCRuntime.m
@@ -54,8 +54,9 @@
 #include <ctype.h>
 
 #ifndef NeXT_RUNTIME
-#include <pthread.h>
+#  include <pthread.h>
 #endif
+
 #ifdef __GNUSTEP_RUNTIME__
 extern struct objc_slot	*objc_get_slot(Class, SEL);
 #endif
@@ -66,9 +67,11 @@ extern struct objc_slot	*objc_get_slot(Class, SEL);
 @end
 #endif
 
+
 #define BDBGPrintf(format, args...) \
   do { if (behavior_debug) { fprintf(stderr, (format) , ## args); } } while (0)
 
+
 Class
 GSObjCClass(id obj)
 {
@@ -153,7 +156,7 @@ SEL sel_register_typed_name(const char *name, const char*type);
 SEL
 GSSelectorFromNameAndTypes(const char *name, const char *types)
 {
-#if NeXT_RUNTIME
+#if defined (NeXT_RUNTIME)
   return sel_getUid(name);
 #elif defined (__GNU_LIBOBJC__) && (__GNU_LIBOBJC__ >= 20110608)
   return sel_registerTypedName(name, types);
@@ -200,7 +203,7 @@ extern SEL sel_register_typed_name(const char*, const char*);
 const char *
 GSTypesFromSelector(SEL sel)
 {
-#if NeXT_RUNTIME
+#if defined (NeXT_RUNTIME)
   return 0;
 #elif defined (__GNU_LIBOBJC__)
   return sel_getTypeEncoding(sel);
@@ -239,7 +242,7 @@ GSObjCVersion(Class cls)
  */
 BOOL
 GSObjCFindVariable(id obj, const char *name,
-  const char **type, unsigned int *size, int *offset)
+  const char **type, size_t *size, ptrdiff_t *offset)
 {
   Class		class = object_getClass(obj);
   Ivar		ivar = class_getInstanceVariable(class, name);
@@ -390,7 +393,7 @@ GSObjCVariableNames(id obj, BOOL recurse)
  * and you know that the data area provided is the correct size.
  */
 void
-GSObjCGetVariable(id obj, int offset, unsigned int size, void *data)
+GSObjCGetVariable(id obj, ptrdiff_t offset, size_t size, void *data)
 {
   memcpy(data, ((void*)obj) + offset, size);
 }
@@ -402,7 +405,7 @@ GSObjCGetVariable(id obj, int offset, unsigned int size, void *data)
  * and you know that the data area provided is the correct size.
  */
 void
-GSObjCSetVariable(id obj, int offset, unsigned int size, const void *data)
+GSObjCSetVariable(id obj, ptrdiff_t offset, size_t size, const void *data)
 {
   memcpy(((void*)obj) + offset, data, size);
 }
@@ -674,6 +677,16 @@ GSSelectorTypesMatch(const char *types1, const char *types2)
               types2++;
             }
 	}
+    
+      /* Ignore field names */
+      if (*types1 == '"')
+        {
+            for (++types1; *types1++ != '"';);
+        }
+      if (*types2 == '"')
+        {
+            for (++types2; *types2++ != '"';);
+        }
 
       if (*types1 != *types2)
         {
@@ -766,7 +779,7 @@ GSRegisterProtocol(Protocol *proto)
 	(GSIMapKey)protocol_getName(proto));
       if (node == 0)
 	{
-	  GSIMapAddPairNoRetain(&protocol_by_name,
+	  GSIMapAddPair(&protocol_by_name,
 	    (GSIMapKey)(void*)protocol_getName(proto),
 	    (GSIMapVal)(void*)proto);
 	}
@@ -806,7 +819,7 @@ GSProtocolFromName(const char *name)
 	    {
 	      /* Use the protocol's name to save us from allocating
 		 a copy of the parameter 'name'.  */
-	      GSIMapAddPairNoRetain(&protocol_by_name,
+	      GSIMapAddPair(&protocol_by_name,
 	        (GSIMapKey)(void*)protocol_getName(p),
 		(GSIMapVal)(void*)p);
 	    }
@@ -990,6 +1003,19 @@ GSObjCAddClassOverride(Class receiver, Class override)
 #import	"Foundation/NSKeyValueCoding.h"
 #endif
 
+/*
+ * NSPoint and NSSize are equal using GSSelectorTypesMatch(),
+ * but corresponding NSValue instances are not.
+ * This function compares only "{<name>=" part of type encoding.
+ */
+static BOOL StructureTypesMatch(const char *type1, const char *type2)
+{
+    while (*type1 != '\0' && *type2 != '\0' && *type1 == *type2 && *type1 != '=' && *type2 != '=') {
+        ++type1;
+        ++type2;
+    }
+    return *type1 == *type2;
+}
 
 /**
  * This is used internally by the key-value coding methods, to get a
@@ -1003,7 +1029,7 @@ GSObjCAddClassOverride(Class receiver, Class override)
  */
 id
 GSObjCGetVal(NSObject *self, const char *key, SEL sel,
-	       const char *type, unsigned size, int offset)
+	       const char *type, size_t size, ptrdiff_t offset)
 {
   NSMethodSignature	*sig = nil;
 
@@ -1295,7 +1321,7 @@ GSObjCGetVal(NSObject *self, const char *key, SEL sel,
             break;
 
           case _C_STRUCT_B:
-            if (GSSelectorTypesMatch(@encode(NSPoint), type))
+            if (StructureTypesMatch(@encode(NSPoint), type))
               {
                 NSPoint	v;
 
@@ -1312,7 +1338,7 @@ GSObjCGetVal(NSObject *self, const char *key, SEL sel,
                   }
                 val = [NSValue valueWithPoint: v];
               }
-            else if (GSSelectorTypesMatch(@encode(NSRange), type))
+            else if (StructureTypesMatch(@encode(NSRange), type))
               {
                 NSRange	v;
 
@@ -1329,7 +1355,7 @@ GSObjCGetVal(NSObject *self, const char *key, SEL sel,
                   }
                 val = [NSValue valueWithRange: v];
               }
-            else if (GSSelectorTypesMatch(@encode(NSRect), type))
+            else if (StructureTypesMatch(@encode(NSRect), type))
               {
                 NSRect	v;
 
@@ -1346,7 +1372,7 @@ GSObjCGetVal(NSObject *self, const char *key, SEL sel,
                   }
                 val = [NSValue valueWithRect: v];
               }
-            else if (GSSelectorTypesMatch(@encode(NSSize), type))
+            else if (StructureTypesMatch(@encode(NSSize), type))
               {
                 NSSize	v;
 
@@ -1419,7 +1445,7 @@ GSObjCGetVal(NSObject *self, const char *key, SEL sel,
  */
 id
 GSObjCGetValue(NSObject *self, NSString *key, SEL sel,
-	       const char *type, unsigned size, int offset)
+	       const char *type, size_t size, ptrdiff_t offset)
 {
   return GSObjCGetVal(self, [key UTF8String], sel, type, size, offset);
 }
@@ -1436,7 +1462,7 @@ GSObjCGetValue(NSObject *self, NSString *key, SEL sel,
  */
 void
 GSObjCSetVal(NSObject *self, const char *key, id val, SEL sel,
-  const char *type, unsigned size, int offset)
+  const char *type, size_t size, ptrdiff_t offset)
 {
   static NSNull		*null = nil;
   NSMethodSignature	*sig = nil;
@@ -1741,7 +1767,7 @@ GSObjCSetVal(NSObject *self, const char *key, id val, SEL sel,
 	    break;
 
           case _C_STRUCT_B:
-            if (GSSelectorTypesMatch(@encode(NSPoint), type))
+            if (StructureTypesMatch(@encode(NSPoint), type))
               {
                 NSPoint	v = [val pointValue];
 
@@ -1759,7 +1785,7 @@ GSObjCSetVal(NSObject *self, const char *key, id val, SEL sel,
                     (*imp)(self, sel, v);
                   }
               }
-            else if (GSSelectorTypesMatch(@encode(NSRange), type))
+            else if (StructureTypesMatch(@encode(NSRange), type))
               {
                 NSRange	v = [val rangeValue];
 
@@ -1777,7 +1803,7 @@ GSObjCSetVal(NSObject *self, const char *key, id val, SEL sel,
                     (*imp)(self, sel, v);
                   }
               }
-            else if (GSSelectorTypesMatch(@encode(NSRect), type))
+            else if (StructureTypesMatch(@encode(NSRect), type))
               {
                 NSRect	v = [val rectValue];
 
@@ -1795,7 +1821,7 @@ GSObjCSetVal(NSObject *self, const char *key, id val, SEL sel,
                     (*imp)(self, sel, v);
                   }
               }
-            else if (GSSelectorTypesMatch(@encode(NSSize), type))
+            else if (StructureTypesMatch(@encode(NSSize), type))
               {
                 NSSize	v = [val sizeValue];
 
@@ -1848,7 +1874,7 @@ GSObjCSetVal(NSObject *self, const char *key, id val, SEL sel,
  */
 void
 GSObjCSetValue(NSObject *self, NSString *key, id val, SEL sel,
-	       const char *type, unsigned size, int offset)
+	       const char *type, size_t size, ptrdiff_t offset)
 {
   GSObjCSetVal(self, [key UTF8String], val, sel, type, size, offset);
 }
@@ -1926,7 +1952,7 @@ NSArray *GSObjCDirectSubclassesOfClass(Class cls)
 @end
 
 void *
-GSAutoreleasedBuffer(unsigned size)
+GSAutoreleasedBuffer(size_t size)
 {
 #if GS_WITH_GC || __OBJC_GC__
   return NSAllocateCollectable(size, NSScannedOption);
@@ -1938,11 +1964,11 @@ GSAutoreleasedBuffer(unsigned size)
 
   static Class	buffer_class = 0;
   static Class	autorelease_class;
-  static SEL	autorelease_sel;
-  static IMP	autorelease_imp;
-  static int	instance_size;
-  static int	offset;
-  NSObject	*o;
+  static SEL    autorelease_sel;
+  static IMP    autorelease_imp;
+  static size_t	instance_size;
+  static size_t	offset;
+  NSObject      *o;
 
   if (buffer_class == 0)
     {
@@ -2002,7 +2028,7 @@ GSPrintf (FILE *fptr, NSString* format, ...)
 
   if (data != nil)
     {
-      unsigned int      length = [data length];
+      NSUInteger length = [data length];
 
       if (length == 0 || fwrite([data bytes], 1, length, fptr) == length)
         {
diff --git a/Source/Additions/GSTypeEncoding.c b/Source/Additions/GSTypeEncoding.c
new file mode 100644
index 0000000..06020bc
--- /dev/null
+++ b/Source/Additions/GSTypeEncoding.c
@@ -0,0 +1,696 @@
+/*
+ * Objective-C type encoding support
+ *
+ * Copyright (C) 2012-2013 Free Software Foundation, Inc.
+ *
+ * Written by Marat Ibadinov <ibadinov@me.com>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+#include <stdlib.h>
+#include <string.h>
+#include "GNUstepBase/GSTypeEncoding.h"
+
+#undef  MAX
+#define MAX(X, Y)                     \
+({                                    \
+  typeof (X) __x = (X), __y = (Y);    \
+  (__x > __y ? __x : __y);            \
+})
+
+/*
+ * We store here aligned sizes of primitive types
+ * and bit-masks of type qualifiers
+ */
+static const int8_t typeInfoTable[] =
+{
+  /* types */
+  [GSObjCTypeId]                  = sizeof(id),
+  [GSObjCTypeClass]               = sizeof(Class),
+  [GSObjCTypeSelector]            = sizeof(SEL),
+  [GSObjCTypeChar]                = sizeof(char),
+  [GSObjCTypeUnsignedChar]        = sizeof(unsigned char),
+  [GSObjCTypeShort]               = sizeof(short),
+  [GSObjCTypeUnsignedShort]       = sizeof(unsigned short),
+  [GSObjCTypeInt]                 = sizeof(int),
+  [GSObjCTypeUnsignedInt]         = sizeof(unsigned int),
+  [GSObjCTypeLong]                = sizeof(long),
+  [GSObjCTypeUnsignedLong]        = sizeof(unsigned long),
+  [GSObjCTypeLongLong]            = sizeof(long long),
+  [GSObjCTypeUnsignedLongLong]    = sizeof(unsigned long long),
+  [GSObjCTypeFloat]               = sizeof(float),
+  [GSObjCTypeDouble]              = sizeof(double),
+  [GSObjCTypeBool]                = sizeof(_Bool),
+  [GSObjCTypeVoid]                = sizeof(void),
+  /* here would go Pointer, but in most cases it needs special treatment */
+  [GSObjCTypeCharPointer]         = sizeof(char *),
+  [GSObjCTypeAtom]                = sizeof(void *),
+  /* type qualifiers (negated for distinctiveness) */
+  [GSObjCQualifierConst]          = -GSObjCQualifierConstMask,
+  [GSObjCQualifierIn]             = -GSObjCQualifierInMask,
+  [GSObjCQualifierInOut]          = -GSObjCQualifierInOutMask,
+  [GSObjCQualifierOut]            = -GSObjCQualifierOutMask,
+  [GSObjCQualifierByCopy]         = -GSObjCQualifierByCopyMask,
+  [GSObjCQualifierByRef]          = -GSObjCQualifierByRefMask,
+  [GSObjCQualifierOneWay]         = -GSObjCQualifierOneWayMask,
+  [GSObjCQualifierInvisible]      = -GSObjCQualifierInvisible,
+  /* ensure an appropriate table size */
+  [GSObjCTypeMax]                 = 0
+};
+
+/* all substripts of typeInfoTable are of char type */
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wchar-subscripts"
+
+ENCODING_INLINE uint8_t
+RoundToThePowerOfTwo (uint8_t value)
+{
+  --value;
+  value |= value >> 1;
+  value |= value >> 2;
+  value |= value >> 4;
+  return ++value;
+}
+
+ENCODING_INLINE const char *
+GetNumericValue (const char *cursor, int *value)
+{
+  *value = 0;
+  while (*cursor >= '0' && *cursor <= '9')
+    {
+      *value = 10 * (*value) + (*cursor++ - '0');
+    }
+  return cursor;
+}
+
+ENCODING_INLINE const char *
+SkipName (const char *cursor)
+{
+  if (*cursor == '"')
+    {
+      for (++cursor; *cursor++ != '"';);
+    }
+  return cursor;
+}
+
+ENCODING_INLINE const char *
+SkipType (const char *cursor)
+{
+  unsigned depth = 0;
+  do {
+    while (typeInfoTable[*cursor] < 0)
+      {
+        ++cursor;
+      }
+    
+    if (!typeInfoTable[*cursor])
+      {
+        switch (*cursor)
+          {
+            case GSObjCTypeArrayBegin:
+            case GSObjCTypeStructureBegin:
+            case GSObjCTypeUnionBegin:
+              ++depth;
+              break;
+            case GSObjCTypeArrayEnd:
+            case GSObjCTypeStructureEnd:
+            case GSObjCTypeUnionEnd:
+              --depth;
+              break;
+            case GSObjCTypePointer:
+              ++cursor;
+            default:
+              break;
+          }
+      }
+    cursor = SkipName(++cursor);
+  } while (depth);
+  return cursor;
+}
+
+ENCODING_INLINE const char *
+GetQualifiers (const char *cursor, uint8_t *qualifiers)
+{
+  *qualifiers = 0;
+  while (typeInfoTable[*cursor] < 0)
+    {
+      *qualifiers |= (uint8_t) -typeInfoTable[*cursor];
+      ++cursor;
+    }
+  return cursor;
+}
+
+typedef struct ParserStackElement
+{
+  const char *cursor;
+  size_t      size;
+  size_t      count; /* for arrays */
+  char        alignment;
+  char        qualifiers;
+} ParserStackElement;
+
+
+typedef struct ParserOutput
+{
+  GSObjCTypeInfo      info;
+  unsigned            parentDepth;
+  BOOL                suppressed;
+} ParserOutput;
+
+typedef struct ParserState
+{
+  ParserStackElement  *stack;
+  ParserOutput        *buffer;
+  unsigned            stackSize;
+  unsigned            bufferSize;
+  unsigned            allocated;
+  unsigned            stackSpace;
+  unsigned            bufferSpace;
+} ParserState;
+
+/**
+ * Complex type nesting level of 4 or greater is a rare case.
+ * With initial size of 3 total memory footprint of stack and
+ * buffer is 224 bytes (on machines with 64-bit word).
+ *
+ * Nesting depth of 16 will require circa 1K of memory, 64 - approximately 4K.
+ * Maybe it would be better to place an upper bound on nesting depth and simply
+ * allocate space on stack once. This will certainly be a performance again.
+ */
+static const unsigned ParserInitialStackSize = 3;
+
+ENCODING_INLINE ParserStackElement *
+ParserStackTop (ParserState *state)
+{
+  return state->stackSize ? &state->stack[state->stackSize - 1] : NULL;
+}
+
+const char *
+GSObjCParseTypeSpecification (const char *cursor,
+                              GSObjCTypeParserDelegate delegate,
+                              void *context,
+                              unsigned options)
+{
+  ParserState state;
+  state.stackSize = state.bufferSize = 0;
+  state.stackSpace = sizeof(ParserStackElement) * ParserInitialStackSize;
+  state.bufferSpace = sizeof(ParserOutput) * (ParserInitialStackSize + 1);
+  state.stack = malloc(state.stackSpace + state.bufferSpace);
+  state.buffer = (void *)state.stack + state.stackSpace;
+  state.allocated = ParserInitialStackSize;
+  
+  unsigned suppressionDepth = 0;
+  unsigned bitFieldSpaceAvailable = 0;
+  ParserStackElement el;
+  do {
+    GSObjCTypeInfo info = {cursor, 0, 1, 0};
+    cursor = GetQualifiers(cursor, &info.qualifiers);
+    cursor = SkipName(cursor);
+    
+    BOOL pushStack = NO, popStack = NO, pushBuffer = YES, suppress = suppressionDepth != 0;
+    unsigned parentDepth = state.stackSize;
+    
+    /* is it a primitive type? */
+    if (typeInfoTable[*cursor])
+      {
+        info.size = info.alignment = typeInfoTable[*cursor];
+        cursor = SkipName(++cursor);
+      }
+    else
+      {
+        switch (*cursor) {
+          case GSObjCTypeBitField:
+            {
+              info.alignment = 1;
+              int totalBitCount = -bitFieldSpaceAvailable, bitCount = 0;
+              while (totalBitCount < 8 && *cursor == GSObjCTypeBitField) /* can we emit token */
+                {
+                  cursor = GetNumericValue(++cursor, &bitCount);
+                  totalBitCount += bitCount;
+                  /* round bitCount to the nearest power of 2 */
+                  info.alignment = MAX(info.alignment, RoundToThePowerOfTwo(bitCount) / 8);
+                }
+              info.size = totalBitCount / 8 + ((totalBitCount & 7 /* mod 8 */) != 0);
+              if (*cursor == GSObjCTypeBitField)
+                bitFieldSpaceAvailable = (unsigned)info.alignment * 8 - totalBitCount;
+              else
+                bitFieldSpaceAvailable = 0;
+              break;
+            }
+          case GSObjCTypePointer:
+            {
+              info.size = info.alignment = sizeof(void *);
+              cursor = SkipType(++cursor);
+              break;
+            }
+          case GSObjCTypeComplex:
+            {
+              info.size = 2 * (info.alignment = typeInfoTable[*++cursor]);
+              ++cursor;
+              break;
+            }
+          case GSObjCTypeArrayBegin:
+            {
+              int length;
+              cursor = GetNumericValue(++cursor, &length);
+              el = (ParserStackElement){cursor, 0, length - 1, 1, info.qualifiers};
+              pushStack = YES;
+              suppressionDepth += (options & GSObjCReportArrayOnceMask) != 0;
+              break;
+            }
+          case GSObjCTypeStructureBegin:
+            {
+              el = (ParserStackElement){cursor, 0, 0, 1, info.qualifiers};
+              /* skip typename annotation */
+              while (*cursor != GSObjCTypeStructureEnd && *cursor++ != '=');
+              pushStack = YES;
+              break;
+            }
+          case GSObjCTypeUnionBegin:
+            {
+              el = (ParserStackElement){cursor, 0, 0, 1, info.qualifiers};
+              /* skip typename annotation */
+              while (*cursor != GSObjCTypeUnionEnd && *cursor++ != '=');
+              ++suppressionDepth;
+              pushStack = YES;
+              break;
+            }
+          case GSObjCTypeUnionEnd:
+          case GSObjCTypeArrayEnd:
+          case GSObjCTypeStructureEnd:
+            {
+              popStack = YES;
+              break;
+            }
+            
+          default:
+            abort();
+        }
+      }
+    
+    if (pushStack)
+      {
+        if (state.stackSize == state.allocated)
+          {
+            state.allocated *= 2;
+            unsigned stackSpace = sizeof(ParserStackElement) * state.allocated;
+            unsigned bufferSpace = sizeof(ParserOutput) * (state.allocated + 1);
+            void *data = malloc(stackSpace + bufferSpace);
+            memcpy(data, state.stack, state.stackSpace);
+            memcpy(data + stackSpace, state.buffer, state.bufferSpace);
+            free(state.stack);
+            state.stack = data;
+            state.buffer = (void *)data + stackSpace;
+            state.stackSpace = stackSpace;
+            state.bufferSpace = bufferSpace;
+          }
+        state.stack[state.stackSize] = el;
+        ++state.stackSize;
+      }
+    else
+      {
+        /* we can safely flush the buffer */
+        for (unsigned index = 0; index < state.bufferSize; ++index)
+          {
+            GSObjCTypeInfo output = state.buffer[index].info;
+            unsigned depth = state.buffer[index].parentDepth;
+            if (depth)
+              {
+                ParserStackElement *parent = &state.stack[depth - 1];
+                if (*parent->cursor != GSObjCTypeUnionBegin)
+                  {
+                    /* in array and structure we should align data according
+                     * to the element that triggered flushing (it may be the
+                     * next real member of the data-structure or a closing
+                     * tag)
+                     */
+                    output.alignment = MAX(output.alignment, info.alignment);
+                    size_t alignedSize = GSObjCPadSize(output.size, output.alignment);
+                    parent->size += alignedSize;
+                  }
+                else
+                  {
+                    parent->size = MAX(parent->size, output.size);
+                  }
+                parent->alignment = MAX(parent->alignment, output.alignment);
+              }
+            if (!state.buffer[index].suppressed)
+              {
+                delegate(context, output);
+              }
+          }
+        state.bufferSize = 0;
+      }
+    
+    if (popStack)
+      {
+        ParserStackElement *element = ParserStackTop(&state);
+        switch (*cursor)
+          {
+            case GSObjCTypeUnionEnd:
+              --suppressionDepth;
+            case GSObjCTypeArrayEnd:
+              {
+                if (element->count)
+                  {
+                    if (options & GSObjCReportArrayOnceMask)
+                      {
+                        /* we need to compensate "length - 1" */
+                        element->size *= (element->count + 1);
+                        --suppressionDepth;
+                      }
+                    else
+                      {
+                        /* decrease length and rewind */
+                        --element->count;
+                        cursor = element->cursor;
+                        pushBuffer = NO;
+                        break;
+                      }
+                  }
+              }
+            case GSObjCTypeStructureEnd:
+              {
+                info.qualifiers = element->qualifiers;
+                info.size = element->size;
+                info.alignment = element->alignment;
+                parentDepth = --state.stackSize;
+                ++cursor;
+                break;
+              }
+          }
+      }
+    
+    if (pushBuffer)
+      {
+        /* outermost GSObjCTypeUnionBegin and GSObjCTypeUnionEnd should be reported */
+        state.buffer[state.bufferSize].suppressed   = suppress && suppressionDepth != 0;
+        state.buffer[state.bufferSize].parentDepth  = parentDepth;
+        state.buffer[state.bufferSize].info         = info;
+        ++state.bufferSize;
+      }
+  } while (state.stackSize);
+  
+  for (unsigned index = 0; index < state.bufferSize; ++index)
+    {
+      if (!state.buffer[index].suppressed)
+        {
+          delegate(context, state.buffer[index].info);
+        }
+    }
+  
+  free(state.stack);
+  
+  return cursor;
+}
+
+#pragma GCC diagnostic pop
+
+typedef struct InfoAccumulator
+{
+    size_t  size;
+    char    alignment;
+} InfoAccumulator;
+
+static void
+InfoAccumulatorAddInfo (InfoAccumulator *this, GSObjCTypeInfo info)
+{
+    /* if it's the end of structure, accumulate only padding */
+    if (*info.type == GSObjCTypeStructureEnd)
+        this->size += GSObjCGetPadding (info.size, info.alignment);
+    else
+        this->size += GSObjCPadSize (info.size, info.alignment);
+    this->alignment = MAX(this->alignment, info.alignment);
+};
+
+const char *
+GSGetSizeAndAlignment (const char *type, size_t *sizep, uint8_t *alignp)
+{
+    InfoAccumulator accumulator = {0, 0};
+    type = GSObjCParseTypeSpecification (type,
+                                         (GSObjCTypeParserDelegate)&InfoAccumulatorAddInfo,
+                                         &accumulator,
+                                         GSObjCReportArrayOnceMask);
+    if (sizep)
+    {
+        *sizep = accumulator.size;
+    }
+    if (alignp)
+    {
+        *alignp = accumulator.alignment;
+    }
+    return type;
+}
+
+
+#if defined (NeXT_RUNTIME)
+
+/* emulate GNU API */
+
+typedef struct SizeInfoAccumulator
+{
+  size_t      size;
+  unsigned    depth;
+} SizeInfoAccumulator;
+
+static void
+SizeInfoAccumulatorAddInfo (SizeInfoAccumulator *this, GSObjCTypeInfo info)
+{
+  /* we wait until typespec's last element and save it's unaligned size */
+  switch (*info.type)
+  {
+    case GSObjCTypeArrayBegin:
+    case GSObjCTypeStructureBegin:
+    case GSObjCTypeUnionBegin:
+      ++this->depth;
+      break;
+    case GSObjCTypeArrayEnd:
+    case GSObjCTypeStructureEnd:
+    case GSObjCTypeUnionEnd:
+      --this->depth;
+      break;
+    default:
+      break;
+  }
+  if (!this->depth)
+    {
+      this->size += info.size;
+    }
+};
+
+int
+objc_sizeof_type (const char* type)
+{
+  SizeInfoAccumulator accumulator = {0, 0};
+  GSObjCParseTypeSpecification (type,
+                                (GSObjCTypeParserDelegate)&SizeInfoAccumulatorAddInfo,
+                                &accumulator,
+                                GSObjCReportArrayOnceMask);
+  return (int)accumulator.size;
+}
+
+int
+objc_alignof_type (const char* type)
+{
+  uint8_t alignment;
+  GSGetSizeAndAlignment (type, NULL, &alignment);
+  return (int)alignment;
+}
+
+int
+objc_aligned_size (const char* type)
+{
+  size_t size;
+  GSGetSizeAndAlignment (type, &size, NULL);
+  return (int)size;
+}
+
+int
+objc_promoted_size (const char* type)
+{
+  size_t size;
+  GSGetSizeAndAlignment (type, &size, NULL);
+  return (int)GSObjCPadSize (size, sizeof(void *));
+}
+
+/* we should not instantiate this function more than once */
+static const char *
+GetQualifiersInst (const char *cursor, uint8_t *qualifiers)
+{
+  return GetQualifiers (cursor, qualifiers);
+}
+
+/* we should not instantiate this function more than once */
+static const char *
+SkipTypeInst (const char *cursor)
+{
+  return SkipType(cursor);
+}
+
+unsigned
+objc_get_type_qualifiers (const char* type)
+{
+  uint8_t qualifiers;
+  GetQualifiersInst (type, &qualifiers);
+  return qualifiers;
+}
+
+const char *
+objc_skip_type_qualifiers (const char* type)
+{
+  uint8_t qualifiers;
+  return GetQualifiersInst (type, &qualifiers);
+}
+
+const char *
+objc_skip_typespec (const char* type)
+{
+  uint8_t qualifiers;
+  type = GetQualifiersInst (type, &qualifiers);
+  return SkipTypeInst (type);
+}
+
+const char *
+objc_skip_offset (const char* type)
+{
+  if (*type == '+' || *type == '-')
+    {
+      type++;
+    }
+  while (*type >= '0' && *type <= '9')
+    {
+      type++;
+    }
+  return type;
+}
+
+const char *
+objc_skip_argspec (const char* type)
+{
+  type = SkipTypeInst (type);
+  return objc_skip_offset (type);
+}
+
+static void
+objc_layout_structure_append_info(struct objc_struct_layout *this,
+                                  GSObjCTypeInfo info)
+{
+  if (this->count == this->allocated)
+    {
+      this->info = realloc(this->info, sizeof(GSObjCTypeInfo) * (this->allocated *= 2));
+    }
+  this->info[this->count] = info;
+  ++this->count;
+}
+
+static void
+objc_layout_structure_parser_delegate(struct objc_struct_layout *this,
+                                      GSObjCTypeInfo info)
+{
+  unsigned initialDepth = this->depth;
+  switch (*info.type)
+  {
+    case GSObjCTypeArrayEnd:
+    case GSObjCTypeStructureEnd:
+    case GSObjCTypeUnionEnd:
+    {
+      if (--this->depth == 1)
+        {
+          this->info[this->count - 1].size = info.size;
+          this->info[this->count - 1].alignment = info.alignment;
+        }
+      break;
+    }
+    case GSObjCTypeArrayBegin:
+    case GSObjCTypeStructureBegin:
+    case GSObjCTypeUnionBegin:
+      ++this->depth;
+    default:
+      if (initialDepth == 1)
+        {
+          objc_layout_structure_append_info(this, info);
+        }
+      break;
+  }
+}
+
+void
+objc_layout_structure (const char *type,
+                       struct objc_struct_layout *layout)
+{
+  *layout = (struct objc_struct_layout)
+  {
+    malloc(8 * sizeof(GSObjCTypeInfo)),
+    -1, 0, 8, 0, 0, 0
+  };
+  GSObjCParseTypeSpecification(type,
+                               (GSObjCTypeParserDelegate)&objc_layout_structure_parser_delegate,
+                               layout,
+                               GSObjCReportArrayOnceMask);
+}
+
+BOOL
+objc_layout_structure_next_member (struct objc_struct_layout *layout)
+{
+  return ++layout->position < layout->count;
+}
+
+void
+objc_layout_structure_get_info (struct objc_struct_layout *layout,
+                                unsigned int *offset,
+                                unsigned int *align,
+                                const char **type)
+{
+  GSObjCTypeInfo info = layout->info[layout->position];
+  
+  if (offset)
+    {
+      *offset = layout->offset;
+    }
+  if (align)
+    {
+      *align = info.alignment;
+    }
+  if (type)
+    {
+      *type = info.type;
+    }
+  
+  layout->offset += GSObjCPadSize(info.size, info.alignment);
+  layout->alignment = MAX(layout->alignment, info.alignment);
+}
+
+void
+objc_layout_finish_structure (struct objc_struct_layout *layout,
+                              unsigned int *size,
+                              unsigned int *align)
+{
+  if (size)
+    {
+      *size = (unsigned int) GSObjCPadSize(layout->offset, layout->alignment);
+    }
+  if (align)
+    {
+      *align = layout->alignment;
+    }
+  free(layout->info);
+}
+
+#endif /* NeXT_RUNTIME */
\ No newline at end of file
diff --git a/Source/Additions/GSXML.m b/Source/Additions/GSXML.m
index a5acaea..e5a762d 100644
--- a/Source/Additions/GSXML.m
+++ b/Source/Additions/GSXML.m
@@ -132,7 +132,7 @@ UTF8Str(const unsigned char *bytes)
 }
 
 inline static NSString*
-UTF8StrLen(const unsigned char *bytes, unsigned length)
+UTF8StrLen(const unsigned char *bytes, NSUInteger length)
 {
   NSString	*str;
 
@@ -152,8 +152,8 @@ static BOOL cacheDone = NO;
 
 static char * xml_strdup(const char *from)
 {
-  unsigned	len;
-  char		*to;
+  size_t  len;
+  char    *to;
 
   if (0 == from) from = "";
   len = strlen(from) + 1;
@@ -2354,7 +2354,7 @@ static NSString	*endMarker = @"At end of incremental parse";
     {
       return;	// Parsing impossible or disabled.
     }
-  xmlParseChunk(lib, [data bytes], [data length], data == nil);
+  xmlParseChunk(lib, [data bytes], (int)[data length], data == nil);
 }
 
 @end
@@ -2389,7 +2389,7 @@ static NSString	*endMarker = @"At end of incremental parse";
 
 - (void) _parseChunk: (NSData*)data
 {
-  htmlParseChunk(lib, [data bytes], [data length], data == nil);
+  htmlParseChunk(lib, [data bytes], (int)[data length], data == nil);
 }
 
 @end
@@ -2445,13 +2445,13 @@ static xmlParserInputPtr
 loadEntityFunction(void *ctx,
   const unsigned char *eid, const unsigned char *url)
 {
-  NSString			*file = nil;
-  NSString			*entityId;
-  NSString			*location;
-  NSArray			*components;
-  NSMutableString		*local;
-  unsigned			count;
-  unsigned			index;
+  NSString          *file = nil;
+  NSString          *entityId;
+  NSString          *location;
+  NSArray           *components;
+  NSMutableString   *local;
+  NSUInteger        count;
+  NSUInteger        index;
 
   NSCAssert(ctx, @"No Context");
   if (url == NULL)
@@ -2518,10 +2518,10 @@ loadEntityFunction(void *ctx,
       if ([entityId hasPrefix: @"-//GNUstep//DTD "] == YES)
 	{
 	  NSCharacterSet	*ws = [NSCharacterSet whitespaceCharacterSet];
-	  NSString		*found = nil;
+	  NSString        *found = nil;
 	  NSMutableString	*name;
-	  unsigned		len;
-	  NSRange		r;
+	  NSUInteger      len;
+	  NSRange         r;
 
 	  /*
 	   * Extract the relevent DTD name
@@ -2681,17 +2681,17 @@ endDocumentFunction(void *ctx)
   [HANDLER endDocument];
 }
 
-static int
+static NSInteger
 isStandaloneFunction(void *ctx)
 {
   NSCAssert(ctx,@"No Context");
   return [HANDLER isStandalone];
 }
 
-static int
+static NSInteger
 hasInternalSubsetFunction(void *ctx)
 {
-  int	has;
+  NSInteger	has;
 
   NSCAssert(ctx,@"No Context");
   has = [HANDLER hasInternalSubset];
@@ -2702,10 +2702,10 @@ hasInternalSubsetFunction(void *ctx)
   return has;
 }
 
-static int
+static NSInteger
 hasExternalSubsetFunction(void *ctx)
 {
-  int	has;
+  NSInteger	has;
 
   NSCAssert(ctx,@"No Context");
   has = [HANDLER hasExternalSubset];
@@ -3306,8 +3306,8 @@ fatalErrorFunction(void *ctx, const unsigned char *msg, ...)
        colNumber: (NSInteger)colNumber
       lineNumber: (NSInteger)lineNumber
 {
-  e = [NSString stringWithFormat: @"at line: %d column: %d ... %@",
-    lineNumber, colNumber, e];
+  e = [NSString stringWithFormat: @"at line: %ld column: %ld ... %@",
+    (long)lineNumber, (long)colNumber, e];
   [self warning: e];
 }
 
@@ -3318,8 +3318,8 @@ fatalErrorFunction(void *ctx, const unsigned char *msg, ...)
      colNumber: (NSInteger)colNumber
     lineNumber: (NSInteger)lineNumber
 {
-  e = [NSString stringWithFormat: @"at line: %d column: %d ... %@",
-    lineNumber, colNumber, e];
+  e = [NSString stringWithFormat: @"at line: %ld column: %ld ... %@",
+    (long)lineNumber, (long)colNumber, e];
   [self error: e];
 }
 
@@ -3330,8 +3330,8 @@ fatalErrorFunction(void *ctx, const unsigned char *msg, ...)
           colNumber: (NSInteger)colNumber
          lineNumber: (NSInteger)lineNumber
 {
-  e = [NSString stringWithFormat: @"at line: %d column: %d ... %@",
-    lineNumber, colNumber, e];
+  e = [NSString stringWithFormat: @"at line: %ld column: %ld ... %@",
+    (long)lineNumber, (long)colNumber, e];
   [self fatalError: e];
 }
 
@@ -3791,7 +3791,7 @@ fatalErrorFunction(void *ctx, const unsigned char *msg, ...)
 }
 - (NSString *) description
 {
-  return [NSString_class stringWithFormat: @"NodeSet (count %u)", [self count]];
+  return [NSString_class stringWithFormat: @"NodeSet (count %lu)", (unsigned long)[self count]];
 }
 @end
 
@@ -4058,8 +4058,8 @@ static BOOL warned = NO; if (warned == NO) { warned = YES; NSLog(@"WARNING, use
     {
       xsltStylesheetPtr ss = NULL;
       xmlDocPtr		ssXml = (xmlDocPtr)[xsltStylesheet lib];
-      int		pSize = params == nil ? 1 : ([params count] * 2) + 1;
-      int		pNum = 0;
+      NSUInteger  pSize = params == nil ? 1 : ([params count] * 2) + 1;
+      NSUInteger  pNum = 0;
       const char	*parameters[pSize];
 
       if (params != nil)
@@ -4227,11 +4227,11 @@ static BOOL warned = NO; if (warned == NO) { warned = YES; NSLog(@"WARNING, use
 @implementation	NSString (GSXML)
 - (NSString*) stringByEscapingXML
 {
-  unsigned	length = [self length];
-  unsigned	output = 0;
-  unichar	*from;
-  unsigned	i = 0;
-  BOOL		escape = NO;
+  NSUInteger  length = [self length];
+  unsigned    output = 0;
+  unichar     *from;
+  NSUInteger  i = 0;
+  BOOL        escape = NO;
 
   from = NSZoneMalloc (NSDefaultMallocZone(), sizeof(unichar) * length);
   [self getCharacters: from];
@@ -4381,8 +4381,8 @@ static BOOL warned = NO; if (warned == NO) { warned = YES; NSLog(@"WARNING, use
 
 - (NSString*) stringByUnescapingXML
 {
-  unsigned		length = [self length];
-  NSRange		r = NSMakeRange(0, length);
+  NSUInteger  length = [self length];
+  NSRange     r = NSMakeRange(0, length);
 
   r = [self rangeOfString: @"&" options: NSLiteralSearch range: r];
   if (r.length > 0)
@@ -4392,15 +4392,15 @@ static BOOL warned = NO; if (warned == NO) { warned = YES; NSLog(@"WARNING, use
       while (r.length > 0)
 	{
 	  NSRange	e;
-	  unsigned	s0 = NSMaxRange(r);
+	  NSUInteger s0 = NSMaxRange(r);
 
 	  e = [m rangeOfString: @";"
 		       options: NSLiteralSearch
 			 range: NSMakeRange(s0, length - s0)];
 	  if (e.length > 0)
 	    {
-	      unsigned	s1 = NSMaxRange(e);
-	      NSString	*s = [m substringWithRange: NSMakeRange(s0, s1 - s0)];
+	      NSUInteger  s1 = NSMaxRange(e);
+	      NSString    *s = [m substringWithRange: NSMakeRange(s0, s1 - s0)];
 
 	      if ([s hasPrefix: @"&#"] == YES)
 		{
@@ -4558,7 +4558,7 @@ static NSString	*indentations[] = {
   @"\t\t\t      ",
   @"\t\t\t\t"
 };
-static void indentation(unsigned level, NSMutableString *str)
+static void indentation(NSUInteger level, NSMutableString *str)
 {
   if (level > 0)
     {
@@ -4584,9 +4584,9 @@ static void indentation(unsigned level, NSMutableString *str)
 		 indent: (NSUInteger)indent
 		    for: (GSXMLRPC*)rpc
 {
-  unsigned 		i;
-  unsigned		c = [self count];
-  BOOL			compact = [rpc compact];
+  NSUInteger  i;
+  NSUInteger  c = [self count];
+  BOOL        compact = [rpc compact];
   
   INDENT(indent++);
   [str appendString: @"<array>"];
@@ -4980,8 +4980,8 @@ static void indentation(unsigned level, NSMutableString *str)
                        params: (NSArray*)params
 {
   NSMutableString	*str = [NSMutableString stringWithCapacity: 1024];
-  unsigned		c = [params count];
-  unsigned		i;
+  NSUInteger      c = [params count];
+  NSUInteger      i;
   
   if ([method length] == 0)
     {
@@ -5054,7 +5054,7 @@ static void indentation(unsigned level, NSMutableString *str)
   NSDictionary		*fault;
 
   fault = [NSDictionary dictionaryWithObjectsAndKeys:
-    [NSNumber numberWithInt: code], @"faultCode",
+    [NSNumber numberWithInteger: code], @"faultCode",
     s, @"faultString",
     nil];
 
@@ -5083,8 +5083,8 @@ static void indentation(unsigned level, NSMutableString *str)
 - (NSString*) buildResponseWithParams: (NSArray*)params
 {
   NSMutableString	*str = [NSMutableString stringWithCapacity: 1024];
-  unsigned		c = [params count];
-  unsigned		i;
+  NSUInteger      c = [params count];
+  NSUInteger      i;
   
   [str appendString: @"<?xml version=\"1.0\"?>\n"];
   [str appendString: @"<methodResponse>"];
diff --git a/Source/Additions/NSBundle+GNUstepBase.m b/Source/Additions/NSBundle+GNUstepBase.m
index 20b921e..06c3124 100644
--- a/Source/Additions/NSBundle+GNUstepBase.m
+++ b/Source/Additions/NSBundle+GNUstepBase.m
@@ -31,12 +31,12 @@
 #import "Foundation/NSSet.h"
 #import "GNUstepBase/NSBundle+GNUstepBase.h"
 
-@implementation NSBundle(GNUstepBase)
+@implementation NSBundle (GNUstepBase)
 
-// In NSBundle.m
+#ifndef GNUSTEP /* defined in NSBundle.m */
 + (NSString *) pathForLibraryResource: (NSString *)name
-			       ofType: (NSString *)ext
-			  inDirectory: (NSString *)bundlePath
+                               ofType: (NSString *)ext
+                          inDirectory: (NSString *)bundlePath
 {
   NSString	*path = nil;
   NSString	*bundle_path = nil;
@@ -59,6 +59,7 @@
 
   return path;
 }
+#endif
 
 @end
 
diff --git a/Source/Additions/NSData+GNUstepBase.m b/Source/Additions/NSData+GNUstepBase.m
index 7b30f9d..ef4cfb9 100644
--- a/Source/Additions/NSData+GNUstepBase.m
+++ b/Source/Additions/NSData+GNUstepBase.m
@@ -53,15 +53,15 @@
  */
 - (NSString*) hexadecimalRepresentation
 {
-  static const char	*hexChars = "0123456789ABCDEF";
-  unsigned		slen = [self length];
-  unsigned		dlen = slen * 2;
+  static const char   *hexChars = "0123456789ABCDEF";
+  NSUInteger          slen = [self length];
+  NSUInteger          dlen = slen * 2;
   const unsigned char	*src = (const unsigned char *)[self bytes];
-  char			*dst = (char*)NSZoneMalloc(NSDefaultMallocZone(), dlen);
-  unsigned		spos = 0;
-  unsigned		dpos = 0;
-  NSData		*data;
-  NSString		*string;
+  char                *dst = (char*)NSZoneMalloc(NSDefaultMallocZone(), dlen);
+  NSUInteger          spos = 0;
+  NSUInteger          dpos = 0;
+  NSData              *data;
+  NSString            *string;
 
   while (spos < slen)
     {
@@ -169,7 +169,7 @@ struct MD5Context
 };
 static void MD5Init (struct MD5Context *context);
 static void MD5Update (struct MD5Context *context, unsigned char const *buf,
-unsigned len);
+                       NSUInteger len);
 static void MD5Final (unsigned char digest[16], struct MD5Context *context);
 static void MD5Transform (uint32_t buf[4], uint32_t const in[16]);
 
@@ -238,7 +238,7 @@ static void MD5Init (struct MD5Context *ctx)
  * of bytes.
  */
 static void MD5Update (struct MD5Context *ctx, unsigned char const *buf,
-  unsigned len)
+  NSUInteger len)
 {
   uint32_t t;
 
@@ -468,10 +468,10 @@ static void MD5Transform (uint32_t buf[4], uint32_t const in[16])
 		 mode: (NSInteger*)modePtr
 {
   const unsigned char	*bytes = (const unsigned char*)[self bytes];
-  unsigned		length = [self length];
-  unsigned		decLength = [decoded length];
-  unsigned		pos = 0;
-  NSString		*name = nil;
+  NSUInteger  length = [self length];
+  NSUInteger  decLength = [decoded length];
+  NSUInteger  pos = 0;
+  NSString    *name = nil;
 
   if (namePtr != 0)
     {
@@ -490,8 +490,8 @@ static void MD5Transform (uint32_t buf[4], uint32_t const in[16])
 	{
 	  if (name != nil)
 	    {
-	      unsigned		i = 0;
-	      int		lineLength;
+	      NSUInteger i = 0;
+	      int lineLength;
 	      unsigned char	*decPtr;
 
 	      lineLength = DEC(bytes[i++]);
@@ -561,8 +561,8 @@ static void MD5Transform (uint32_t buf[4], uint32_t const in[16])
 	    }
 	  else if (pos > 6 && strncmp((const char*)bytes, "begin ", 6) == 0)
 	    {
-	      unsigned	off = 6;
-	      unsigned	end = pos;
+	      NSUInteger off = 6;
+	      NSUInteger end = pos;
 	      int	mode = 0;
 	      NSData	*d;
 
@@ -616,9 +616,9 @@ static void MD5Transform (uint32_t buf[4], uint32_t const in[16])
 		 mode: (NSInteger)mode
 {
   const unsigned char	*bytes = (const unsigned char*)[self bytes];
-  int			length = [self length];
+  NSUInteger length = [self length];
   unsigned char		buf[64];
-  unsigned		i;
+  NSUInteger i;
 
   name = [name stringByTrimmingSpaces];
   if ([name length] == 0)
@@ -637,8 +637,8 @@ static void MD5Transform (uint32_t buf[4], uint32_t const in[16])
 
   while (length > 0)
     {
-      int	count;
-      unsigned	pos;
+      NSUInteger count;
+      NSUInteger pos;
 
       /*
        * We want up to 45 bytes in a line ... and we record the
@@ -646,55 +646,56 @@ static void MD5Transform (uint32_t buf[4], uint32_t const in[16])
        */
       count = length;
       if (count > 45)
-	{
-	  count = 45;
-	}
+        {
+          count = 45;
+        }
       i = 0;
       buf[i++] = ENC(count);
 
       /*
        * Now we encode the actual data for the line.
        */
-      for (pos = 0; count > 0; count -= 3)
-	{
-	  unsigned char	tmp[3];
-	  int		c;
-
-	  /*
-	   * Copy data into a temporary buffer ensuring we don't
-	   * overrun the end of the original buffer risking access
-	   * violation.
-	   */
-	  tmp[0] = bytes[pos++];
-	  if (pos < length)
-	    {
-	      tmp[1] = bytes[pos++];
-	      if (pos < length)
-		{
-		  tmp[2] = bytes[pos++];
-		}
-	      else
-		{
-		  tmp[2] = 0;
-		}
-	    }
-	  else
-	    {
-	      tmp[1] = 0;
-	      tmp[2] = 0;
-	    }
-
-	  c = tmp[0] >> 2;
-	  buf[i++] = ENC(c);
-	  c = ((tmp[0] << 4) & 060) | ((tmp[1] >> 4) & 017);
-	  buf[i++] = ENC(c);
-	  c = ((tmp[1] << 2) & 074) | ((tmp[2] >> 6) & 03);
-	  buf[i++] = ENC(c);
-	  c = tmp[2] & 077;
-	  buf[i++] = ENC(c);
-	}
+      for (pos = 0; count > 0;)
+      {
+        unsigned char	tmp[3];
+        int		c;
+
+        /*
+         * Copy data into a temporary buffer ensuring we don't
+         * overrun the end of the original buffer risking access
+         * violation.
+         */
+        tmp[0] = bytes[pos++];
+        if (pos < length)
+          {
+            tmp[1] = bytes[pos++];
+            if (pos < length)
+              {
+                tmp[2] = bytes[pos++];
+              }
+            else
+              {
+                tmp[2] = 0;
+              }
+          }
+        else
+          {
+            tmp[1] = 0;
+            tmp[2] = 0;
+          }
+
+        c = tmp[0] >> 2;
+        buf[i++] = ENC(c);
+        c = ((tmp[0] << 4) & 060) | ((tmp[1] >> 4) & 017);
+        buf[i++] = ENC(c);
+        c = ((tmp[1] << 2) & 074) | ((tmp[2] >> 6) & 03);
+        buf[i++] = ENC(c);
+        c = tmp[2] & 077;
+        buf[i++] = ENC(c);
+      }
       bytes += pos;
       length -= pos;
+      count -= pos;
       buf[i++] = '\n';
       [encoded appendBytes: buf length: i];
     }
diff --git a/Source/Additions/NSError+GNUstepBase.m b/Source/Additions/NSError+GNUstepBase.m
index 7ee15a5..8cdef5b 100644
--- a/Source/Additions/NSError+GNUstepBase.m
+++ b/Source/Additions/NSError+GNUstepBase.m
@@ -103,7 +103,7 @@ strerror_r(int eno, char *buf, int len)
   return [self _systemError: eno];
 }
 
-+ (NSError*) _systemError: (long)code
++ (NSError*) _systemError: (int)code
 {
   NSError	*error;
   NSString	*domain;
@@ -140,7 +140,7 @@ strerror_r(int eno, char *buf, int len)
 # if STRERROR_R_CHAR_P
   if (result == 0)
     {
-      snprintf(buf, sizeof(buf), "%ld", code);
+      snprintf(buf, sizeof(buf), "%d", code);
       result = buf;
     }
   message = [NSString stringWithCString: result
@@ -148,7 +148,7 @@ strerror_r(int eno, char *buf, int len)
 # else
   if (result < 0)
     {
-      snprintf(buf, sizeof(buf), "%ld", code);
+      snprintf(buf, sizeof(buf), "%d", code);
     }
   message = [NSString stringWithCString: buf
 			       encoding: [NSString defaultCStringEncoding]];
diff --git a/Source/Additions/NSLock+GNUstepBase.m b/Source/Additions/NSLock+GNUstepBase.m
index e501d4b..526cfda 100644
--- a/Source/Additions/NSLock+GNUstepBase.m
+++ b/Source/Additions/NSLock+GNUstepBase.m
@@ -33,68 +33,72 @@
 
 static GSLazyRecursiveLock *local_lock = nil;
 
-/* This class only exists to provide a thread safe mechanism to
-   initialize local_lock as +initialize is called under a lock in ObjC
-   runtimes.  User code should resort to GS_INITIALIZED_LOCK(), which
-   uses the +newLockAt: extension.  */
-
+/*
+ * This class only exists to provide a thread safe mechanism to
+ * initialize local_lock as +initialize is called under a lock in ObjC
+ * runtimes.  User code should resort to GS_INITIALIZED_LOCK(), which
+ * uses the +createLockAt: extension.
+ */
 @interface _GSLockInitializer : NSObject
 @end
+
 @implementation _GSLockInitializer
-+ (void) initialize
+
++ (void)initialize
 {
-  if (local_lock == nil)
+    if (local_lock == nil)
     {
-      /* As we do not know whether creating custom locks may
-	 implicitly create other locks, we use a recursive lock.  */
-      local_lock = [GSLazyRecursiveLock new];
+        /*
+         * As we do not know whether creating custom locks may
+         * implicitly create other locks, we use a recursive lock.
+         */
+        local_lock = [GSLazyRecursiveLock new];
     }
 }
 
 @end
 
-static inline id
-newLockAt(Class self, SEL _cmd, id *location)
+static inline void
+createLockAt(Class self, SEL _cmd, id *location)
 {
-  if (location == 0)
+    if (location == 0)
     {
-      [NSException raise: NSInvalidArgumentException
-                   format: @"'%@' called with nil location",
-		   NSStringFromSelector(_cmd)];
+        [NSException raise:NSInvalidArgumentException
+                    format:@"'%@' called with nil location", NSStringFromSelector(_cmd)];
     }
-
-  if (*location == nil)
+    
+    if (*location == nil)
     {
-      if (local_lock == nil)
-	{
-	  [_GSLockInitializer class];
-	}
-
-      [local_lock lock];
-
-      if (*location == nil)
-	{
-	  *location = [[(id)self alloc] init];
-	}
-
-      [local_lock unlock];
+        if (local_lock == nil)
+        {
+            [_GSLockInitializer class];
+        }
+        
+        [local_lock lock];
+        
+        if (*location == nil)
+        {
+            *location = [[(id)self alloc] init];
+        }
+        
+        [local_lock unlock];
     }
-
-  return *location;
 }
 
-
 @implementation NSLock (GNUstepBase)
-+ (id) newLockAt: (id *)location
+
++ (void)createLockAt:(id *)location
 {
-  return newLockAt(self, _cmd, location);
+    createLockAt(self, _cmd, location);
 }
+
 @end
 
 @implementation NSRecursiveLock (GNUstepBase)
-+ (id) newLockAt: (id *)location
+
++ (void)createLockAt:(id *)location
 {
-  return newLockAt(self, _cmd, location);
+    createLockAt(self, _cmd, location);
 }
-@end
 
+@end
\ No newline at end of file
diff --git a/Source/Additions/NSMutableString+GNUstepBase.m b/Source/Additions/NSMutableString+GNUstepBase.m
index 67bf122..f582d20 100644
--- a/Source/Additions/NSMutableString+GNUstepBase.m
+++ b/Source/Additions/NSMutableString+GNUstepBase.m
@@ -270,8 +270,8 @@
 	    withString: (NSString*)by
 {
   NSRange       range;
-  unsigned int  count = 0;
-  unsigned int	newEnd;
+  NSUInteger    count = 0;
+  NSUInteger	newEnd;
   NSRange	searchRange;
 
   if (replace == nil)
@@ -290,7 +290,7 @@
 
   if (range.length > 0)
     {
-      unsigned  byLen = [by length];
+      NSUInteger  byLen = [by length];
 
       do
         {
@@ -315,11 +315,11 @@
  */
 - (void) trimLeadSpaces
 {
-  unsigned	length = [self length];
+  NSUInteger	length = [self length];
 
   if (length > 0)
     {
-      unsigned	start = 0;
+      NSUInteger	start = 0;
       unichar	(*caiImp)(NSString*, SEL, NSUInteger);
       SEL caiSel = @selector(characterAtIndex:);
 
@@ -340,11 +340,11 @@
  */
 - (void) trimTailSpaces
 {
-  unsigned	length = [self length];
+  NSUInteger	length = [self length];
 
   if (length > 0)
     {
-      unsigned	end = length;
+      NSUInteger	end = length;
       unichar	(*caiImp)(NSString*, SEL, NSUInteger);
       SEL caiSel = @selector(characterAtIndex:);
 
diff --git a/Source/Additions/NSObject+GNUstepBase.m b/Source/Additions/NSObject+GNUstepBase.m
index bab62e5..542d565 100644
--- a/Source/Additions/NSObject+GNUstepBase.m
+++ b/Source/Additions/NSObject+GNUstepBase.m
@@ -37,7 +37,7 @@
 + (id) notImplemented: (SEL)selector
 {
   [NSException raise: NSGenericException
-    format: @"method %@ not implemented in %s(class)",
+    format: @"method %@ not implemented in %@(class)",
     selector ? (id)NSStringFromSelector(selector) : (id)@"(null)",
     NSStringFromClass(self)];
   return nil;
@@ -81,13 +81,11 @@
   return class_isMetaClass([self class]) ? NO : YES;
 }
 
-- (id) makeImmutableCopyOnFail: (BOOL)force
+- (id) makeImmutable
 {
-  if (force == YES)
-    {
-      return AUTORELEASE([self copy]);
-    }
-  return self;
+    id result = [self copy];
+    [self release];
+    return self = result;
 }
 
 - (id) notImplemented: (SEL)aSel
@@ -205,6 +203,13 @@ handleExit()
   return l->obj;
 }
 
++ (id) leakRetained: (id)anObject
+{
+  id result = [self leak:anObject];
+  [anObject release];
+  return result;
+}
+
 + (BOOL) registerAtExit
 {
   return [self registerAtExit: @selector(atExit)];
@@ -319,5 +324,7 @@ handleExit()
   return NO;
 }
 
+@end
+
 #endif
 
diff --git a/Source/Additions/NSProcessInfo+GNUstepBase.m b/Source/Additions/NSProcessInfo+GNUstepBase.m
index 9823e25..4d8926d 100644
--- a/Source/Additions/NSProcessInfo+GNUstepBase.m
+++ b/Source/Additions/NSProcessInfo+GNUstepBase.m
@@ -83,9 +83,9 @@ BOOL GSDebugSet(NSString *level)
 {
   if (_debug_set == nil)
     {
-      int		argc = [[self arguments] count];
+      NSUInteger		argc = [[self arguments] count];
       NSMutableSet	*mySet;
-      int		i;
+      NSUInteger		i;
 
       mySet = [NSMutableSet new];
       for (i = 0; i < argc; i++)
diff --git a/Source/Additions/NSString+GNUstepBase.m b/Source/Additions/NSString+GNUstepBase.m
index a0af224..bc67d6e 100644
--- a/Source/Additions/NSString+GNUstepBase.m
+++ b/Source/Additions/NSString+GNUstepBase.m
@@ -99,11 +99,11 @@
  */
 - (NSString*) stringByTrimmingLeadSpaces
 {
-  unsigned	length = [self length];
+  NSUInteger	length = [self length];
 
   if (length > 0)
     {
-      unsigned	start = 0;
+      NSUInteger	start = 0;
       unichar	(*caiImp)(NSString*, SEL, NSUInteger);
       SEL caiSel = @selector(characterAtIndex:);
 
@@ -126,11 +126,11 @@
  */
 - (NSString*) stringByTrimmingTailSpaces
 {
-  unsigned	length = [self length];
+  NSUInteger	length = [self length];
 
   if (length > 0)
     {
-      unsigned	end = length;
+      NSUInteger	end = length;
       unichar	(*caiImp)(NSString*, SEL, NSUInteger);
       SEL caiSel = @selector(characterAtIndex:);
 
@@ -157,12 +157,12 @@
  */
 - (NSString*) stringByTrimmingSpaces
 {
-  unsigned	length = [self length];
+  NSUInteger	length = [self length];
 
   if (length > 0)
     {
-      unsigned	start = 0;
-      unsigned	end = length;
+      NSUInteger	start = 0;
+      NSUInteger	end = length;
       unichar	(*caiImp)(NSString*, SEL, NSUInteger);
       SEL caiSel = @selector(characterAtIndex:);
 
@@ -183,7 +183,7 @@
 	{
           if (start < end)
 	    {
-	      return [self substringFromRange:
+	      return [self substringWithRange:
 		NSMakeRange(start, end - start)];
 	    }
           else
@@ -221,9 +221,11 @@
     return self;
 }
 
+#ifndef GNUSTEP /* defined in NSString */
 - (NSString*) substringFromRange:(NSRange)range
 {
   return [self substringWithRange:range];
 }
+#endif
 
 @end
diff --git a/Source/Additions/Unicode.m b/Source/Additions/Unicode.m
index 49b32df..f26d6d6 100644
--- a/Source/Additions/Unicode.m
+++ b/Source/Additions/Unicode.m
@@ -323,7 +323,7 @@ static void GSSetupEncodingTable(void)
 	      if (entry->iconv != 0 && *(entry->iconv) != 0)
 		{
 		  iconv_t	c;
-		  int		l;
+		  size_t    l;
 		  char	*lossy;
 
 		  /*
@@ -673,7 +673,7 @@ uni_is_decomp(unichar u)
       unichar	code;
       unichar	count = 0;
       unichar	first = 0;
-      unichar	last = uni_dec_table_size;
+      unichar	last = uni_dec_table_size - 1;
 
       while (first <= last)
 	{
@@ -714,12 +714,12 @@ uni_is_decomp(unichar u)
  * be in native byte order.<br />
  * Returns the number of characters which were found valid.
  */
-unsigned
-GSUnicode(const unichar *chars, unsigned length,
+NSUInteger
+GSUnicode(const unichar *chars, NSUInteger length,
   BOOL *isASCII, BOOL *isLatin1)
 {
-  unsigned	i = 0;
-  unichar	c;
+  NSUInteger  i = 0;
+  unichar     c;
 
   if (isASCII) *isASCII = YES;
   if (isLatin1) *isLatin1 = YES;
@@ -847,7 +847,7 @@ else if (zone == 0) \
   } \
 else \
   { \
-    unsigned	grow = slen; \
+    NSUInteger	grow = slen; \
 \
     if (grow < bsize + BUFSIZ) \
       { \
@@ -937,19 +937,19 @@ else \
  * </p>
  */
 BOOL
-GSToUnicode(unichar **dst, unsigned int *size, const unsigned char *src,
-  unsigned int slen, NSStringEncoding enc, NSZone *zone,
+GSToUnicode(unichar **dst, NSUInteger *size, const unsigned char *src,
+  NSUInteger slen, NSStringEncoding enc, NSZone *zone,
   unsigned int options)
 {
-  unichar	buf[BUFSIZ];
-  unichar	*ptr;
-  unsigned	bsize;
-  unsigned	dpos = 0;	// Offset into destination buffer.
-  unsigned	spos = 0;	// Offset into source buffer.
-  unsigned	extra = (options & GSUniTerminate) ? sizeof(unichar) : 0;
-  unichar	base = 0;
-  unichar	*table = 0;
-  BOOL		result = YES;
+  unichar     buf[BUFSIZ];
+  unichar     *ptr;
+  NSUInteger  bsize;
+  NSUInteger  dpos = 0;	// Offset into destination buffer.
+  unsigned    spos = 0;	// Offset into source buffer.
+  unsigned    extra = (options & GSUniTerminate) ? sizeof(unichar) : 0;
+  unichar     base = 0;
+  unichar     *table = 0;
+  BOOL        result = YES;
 
   /*
    * Ensure we have an initial buffer set up to decode data into.
@@ -1101,8 +1101,8 @@ GSToUnicode(unichar **dst, unsigned int *size, const unsigned char *src,
 		  }
 		else
 		  {
-		    unsigned	grow = (dpos + slen) * sizeof(unichar);
-		    unichar	*tmp;
+		    NSUInteger  grow = (dpos + slen) * sizeof(unichar);
+		    unichar     *tmp;
 
 #if	GS_WITH_GC
 		    tmp = NSAllocateCollectable(grow + extra, 0);
@@ -1165,8 +1165,8 @@ GSToUnicode(unichar **dst, unsigned int *size, const unsigned char *src,
 		  }
 		else
 		  {
-		    unsigned	grow = (dpos + slen) * sizeof(unichar);
-		    unichar	*tmp;
+		    NSUInteger  grow = (dpos + slen) * sizeof(unichar);
+		    unichar     *tmp;
 
 #if	GS_WITH_GC
 		    tmp = NSAllocateCollectable(grow + extra, 0);
@@ -1254,8 +1254,8 @@ tables:
 		  }
 		else
 		  {
-		    unsigned	grow = (dpos + slen) * sizeof(unichar);
-		    unichar	*tmp;
+		    NSUInteger  grow = (dpos + slen) * sizeof(unichar);
+		    unichar     *tmp;
 
 #if	GS_WITH_GC
 		    tmp = NSAllocateCollectable(grow + extra, 0);
@@ -1388,7 +1388,7 @@ tables:
 		{
 		  if (errno == E2BIG)
 		    {
-		      unsigned	old = bsize;
+		      NSUInteger old = bsize;
 
 		      GROW();
 		      outbuf = (unsigned char*)&ptr[dpos];
@@ -1397,7 +1397,7 @@ tables:
 		  else
 		    {
 		      result = NO;
-		      goto done;
+		      break;
 		    }
 		}
 	    } while (!done || rval != 0);
@@ -1423,8 +1423,8 @@ done:
     {
       if (options & GSUniTemporary)
 	{
-	  unsigned	bytes = dpos * sizeof(unichar) + extra;
-	  void		*r;
+	  NSUInteger  bytes = dpos * sizeof(unichar) + extra;
+	  void        *r;
 
 	  /*
 	   * Temporary string was requested ... make one.
@@ -1445,7 +1445,7 @@ done:
 	}
       else if (zone != 0 && (ptr == buf || bsize > dpos))
 	{
-	  unsigned	bytes = dpos * sizeof(unichar) + extra;
+	  NSUInteger bytes = dpos * sizeof(unichar) + extra;
 
 	  /*
 	   * Resizing is permitted, try ensure we return a buffer which
@@ -1579,7 +1579,7 @@ else if (zone == 0) \
   } \
 else \
   { \
-    unsigned	grow = slen; \
+    NSUInteger grow = slen; \
 \
     if (grow < bsize + BUFSIZ) \
       { \
@@ -1695,27 +1695,27 @@ static inline int chop(unichar c, _ucc_ *table, int hi)
  * </p>
  */
 BOOL
-GSFromUnicode(unsigned char **dst, unsigned int *size, const unichar *src,
-  unsigned int slen, NSStringEncoding enc, NSZone *zone,
+GSFromUnicode(unsigned char **dst, NSUInteger *size, const unichar *src,
+  NSUInteger slen, NSStringEncoding enc, NSZone *zone,
   unsigned int options)
 {
   unsigned char	buf[BUFSIZ];
   unsigned char	*ptr;
-  unsigned	bsize;
-  unsigned	dpos = 0;	// Offset into destination buffer.
+  NSUInteger    bsize;
+  NSUInteger    dpos = 0;	// Offset into destination buffer.
   unsigned	spos = 0;	// Offset into source buffer.
   unsigned	extra = (options & GSUniTerminate) ? 1 : 0;
-  BOOL		strict = (options & GSUniStrict) ? YES : NO;
-  unichar	base = 0;
-  _ucc_		*table = 0;
+  BOOL      strict = (options & GSUniStrict) ? YES : NO;
+  unichar   base = 0;
+  _ucc_     *table = 0;
   unsigned	tsize = 0;
   unsigned char	escape = 0;
-  _ucc_		*etable = 0;
+  _ucc_     *etable = 0;
   unsigned	etsize = 0;
-  _ucc_		*ltable = 0;
+  _ucc_     *ltable = 0;
   unsigned	ltsize = 0;
-  BOOL		swapped = NO;
-  BOOL		result = YES;
+  BOOL      swapped = NO;
+  BOOL      result = YES;
 
   if (options & GSUniBOM)
     {
@@ -2353,7 +2353,7 @@ iconv_start:
 		    {
 		      if (errno == E2BIG)
 			{
-			  unsigned	old = bsize;
+			  NSUInteger old = bsize;
 
 			  GROW();
 			  outbuf = (unsigned char*)&ptr[dpos];
@@ -2419,8 +2419,8 @@ iconv_start:
     {
       if (options & GSUniTemporary)
 	{
-	  unsigned	bytes = dpos + extra;
-	  void		*r;
+	  NSUInteger  bytes = dpos + extra;
+	  void        *r;
 
 	  /*
 	   * Temporary string was requested ... make one.
@@ -2441,7 +2441,7 @@ iconv_start:
 	}
       else if (zone != 0 && (ptr == buf || bsize > dpos))
 	{
-	  unsigned	bytes = dpos + extra;
+	  NSUInteger bytes = dpos + extra;
 
 	  /*
 	   * Resizing is permitted - try ensure we return a buffer
diff --git a/Source/GNUmakefile b/Source/GNUmakefile
index 7034f58..f95fdb9 100644
--- a/Source/GNUmakefile
+++ b/Source/GNUmakefile
@@ -116,6 +116,7 @@ GNUSTEPBASE_HEADERS = \
 GSBlocks.h \
 GSVersionMacros.h \
 GSObjCRuntime.h \
+GSTypeEncoding.h \
 GSUnion.h \
 GSIArray.h \
 GSIMap.h \
@@ -174,6 +175,21 @@ GSString.m \
 GSTimSort.m \
 GSTLS.m \
 GSValue.m \
+GSSocksParser/GSSocksParser.m \
+GSSocksParser/GSSocksParserPrivate.m \
+GSSocksParser/GSSocks4Parser.m \
+GSSocksParser/GSSocks5Parser.m \
+KVO/NSArray+KVO.m \
+KVO/NSKVONotifying.m \
+KVO/NSKeyValueNestedProperty.m \
+KVO/NSKeyValueObservance.m \
+KVO/NSKeyValueObservationInfo.m \
+KVO/NSKeyValueObserving.m \
+KVO/NSKeyValueObservingPrivate.m \
+KVO/NSKeyValueProperty.m \
+KVO/NSKeyValueUnnestedProperty.m \
+KVO/NSObject+KVO.m \
+KVO/NSSet+KVO.m \
 NSAffineTransform.m \
 NSArchiver.m \
 NSArray.m \
@@ -218,12 +234,12 @@ NSHTTPCookie.m \
 NSHTTPCookieStorage.m \
 NSIndexPath.m \
 NSIndexSet.m \
-NSInvocation.m \
+NSInvocation.ff.m \
+NSInvocation.x86_64.m \
 NSJSONSerialization.m \
 NSKeyedArchiver.m \
 NSKeyedUnarchiver.m \
 NSKeyValueCoding.m \
-NSKeyValueObserving.m \
 NSLocale.m \
 NSLock.m \
 NSLog.m \
@@ -504,6 +520,14 @@ libbase-resources_RESOURCE_FILES = Info-gnustep.plist
 libgnustep-base_NEEDS_GUI = NO
 libgnustep-baseadd_NEEDS_GUI = NO
 
+libgnustep-base_OBJ_FILES = $(GNUSTEP_OBJ_DIR)/NSInvocation.x86_64.S.o
+
+# Rule for building assembly files. 
+# AUXILIARY_CPPFLAGS are used for RUNTIME_DEFINE
+
+$(GNUSTEP_OBJ_DIR)/%${OEXT}: %
+	$(ECHO_COMPILING)$(CC) $(AUXILIARY_CPPFLAGS) -c $< -o $@$(END_ECHO)
+
 # Build the Additions subproject first.  It can then be used in by
 # both gnustep-base and gnustep-baseadd (otherwise, if we ever build
 # gnustep-base and gnustep-baseadd in parallel, they'd both try to
diff --git a/Source/GSArray.m b/Source/GSArray.m
index bc62e6c..8f1196c 100644
--- a/Source/GSArray.m
+++ b/Source/GSArray.m
@@ -84,13 +84,13 @@ static Class	GSInlineArrayClass;
   NSString     *reason;
 
   info = [NSDictionary dictionaryWithObjectsAndKeys:
-    [NSNumber numberWithUnsignedInt: index], @"Index",
-    [NSNumber numberWithUnsignedInt: _count], @"Count",
+    [NSNumber numberWithUnsignedInteger: index], @"Index",
+    [NSNumber numberWithUnsignedInteger: _count], @"Count",
     self, @"Array", nil, nil];
 
   reason = [NSString stringWithFormat:
-    @"Index %d is out of range %d (in '%@')",
-    index, _count, NSStringFromSelector(sel)];
+    @"Index %lu is out of range %lu (in '%@')",
+    (unsigned long)index, (unsigned long)_count, NSStringFromSelector(sel)];
 
   exception = [NSException exceptionWithName: NSRangeException
 		                      reason: reason
@@ -591,7 +591,7 @@ static Class	GSInlineArrayClass;
       NSDictionary *info;
 
       info = [NSDictionary dictionaryWithObjectsAndKeys:
-	[NSNumber numberWithUnsignedInt: index], @"Index",
+	[NSNumber numberWithUnsignedInteger: index], @"Index",
 	self, @"Array", nil, nil];
 
       exception = [NSException exceptionWithName: NSInvalidArgumentException
@@ -631,7 +631,7 @@ static Class	GSInlineArrayClass;
   _version++;
 }
 
-- (id) makeImmutableCopyOnFail: (BOOL)force
+- (id) makeImmutable
 {
   GSClassSwizzle(self, [GSArray class]);
   return self;
@@ -772,7 +772,7 @@ static Class	GSInlineArrayClass;
       NSDictionary *info;
 
       info = [NSDictionary dictionaryWithObjectsAndKeys:
-	[NSNumber numberWithUnsignedInt: index], @"Index",
+	[NSNumber numberWithUnsignedInteger: index], @"Index",
         _contents_array[index], @"OldObject",
 	self, @"Array", nil, nil];
 
@@ -920,9 +920,11 @@ static Class	GSInlineArrayClass;
 
 - (id) initWithArray: (GSArray*)anArray
 {
-  [super initWithArray: anArray];
-  pos = array->_count;
-  return self;
+    if (self = [super initWithArray: anArray])
+    {
+        pos = array->_count;
+    }
+    return self;
 }
 
 - (id) nextObject
diff --git a/Source/GSAttributedString.m b/Source/GSAttributedString.m
index 02d9efe..13734b1 100644
--- a/Source/GSAttributedString.m
+++ b/Source/GSAttributedString.m
@@ -31,19 +31,6 @@
    Boston, MA 02111 USA.
 */
 
-/* Warning -	[-initWithString:attributes:] is the designated initialiser,
- *		but it doesn't provide any way to perform the function of the
- *		[-initWithAttributedString:] initialiser.
- *		In order to work round this, the string argument of the
- *		designated initialiser has been overloaded such that it
- *		is expected to accept an NSAttributedString here instead of
- *		a string.  If you create an NSAttributedString subclass, you
- *		must make sure that your implementation of the initialiser
- *		copes with either an NSString or an NSAttributedString.
- *		If it receives an NSAttributedString, it should ignore the
- *		attributes argument and use the values from the string.
- */
-
 #import "common.h"
 #import "GNUstepBase/GSLock.h"
 #import "GNUstepBase/NSMutableString+GNUstepBase.h"
@@ -184,7 +171,7 @@ unCacheAttributes(NSDictionary *attrs)
 @interface	GSAttrInfo : NSObject
 {
 @public
-  unsigned	loc;
+  NSUInteger    loc;
   NSDictionary	*attrs;
 }
 
@@ -216,8 +203,8 @@ unCacheAttributes(NSDictionary *attrs)
 
 - (NSString*) description
 {
-  return [NSString stringWithFormat: @"Attributes at %u are - %@",
-    loc, attrs];
+  return [NSString stringWithFormat: @"Attributes at %lu are - %@",
+    (unsigned long)loc, attrs];
 }
 
 - (void) encodeWithCoder: (NSCoder*)aCoder
@@ -263,11 +250,11 @@ static SEL	oatSel;
 static SEL	remSel;
 
 static IMP	infImp;
-static void	(*addImp)(NSMutableArray*,SEL,id);
-static unsigned (*cntImp)(NSArray*,SEL);
-static void	(*insImp)(NSMutableArray*,SEL,id,unsigned);
+static void	(*addImp)(NSMutableArray*, SEL, id);
+static NSUInteger (*cntImp)(NSArray*, SEL);
+static void	(*insImp)(NSMutableArray*, SEL, id, NSUInteger);
 static IMP	oatImp;
-static void	(*remImp)(NSMutableArray*,SEL,unsigned);
+static void	(*remImp)(NSMutableArray*, SEL, NSUInteger);
 
 #define	NEWINFO(Z,O,L)	((*infImp)(infCls, infSel, (Z), (O), (L)))
 #define	ADDOBJECT(O)	((*addImp)(_infoArray, addSel, (O)))
@@ -304,12 +291,12 @@ static void _setup(void)
 
       a = [NSMutableArray allocWithZone: NSDefaultMallocZone()];
       a = [a initWithCapacity: 1];
-      addImp = (void (*)(NSMutableArray*,SEL,id))[a methodForSelector: addSel];
-      cntImp = (unsigned (*)(NSArray*,SEL))[a methodForSelector: cntSel];
-      insImp = (void (*)(NSMutableArray*,SEL,id,unsigned))
+      addImp = (void (*)(NSMutableArray*, SEL, id))[a methodForSelector: addSel];
+      cntImp = (NSUInteger (*)(NSArray*, SEL))[a methodForSelector: cntSel];
+      insImp = (void (*)(NSMutableArray*, SEL, id, NSUInteger))
 	[a methodForSelector: insSel];
       oatImp = [a methodForSelector: oatSel];
-      remImp = (void (*)(NSMutableArray*,SEL,unsigned))
+      remImp = (void (*)(NSMutableArray*, SEL, NSUInteger))
 	[a methodForSelector: remSel];
       RELEASE(a);
       d = [NSDictionary new];
@@ -328,7 +315,7 @@ _setAttributesFrom(
   NSRange	range;
   NSDictionary	*attr;
   GSAttrInfo	*info;
-  unsigned	loc;
+  NSUInteger	loc;
 
   /*
    * remove any old attributes of the string.
@@ -363,13 +350,13 @@ _setAttributesFrom(
 
 inline static NSDictionary*
 _attributesAtIndexEffectiveRange(
-  unsigned int index,
-  NSRange *aRange,
-  unsigned int tmpLength,
+  NSUInteger  index,
+  NSRange     *aRange,
+  NSUInteger  tmpLength,
   NSMutableArray *_infoArray,
-  unsigned int *foundIndex)
+  NSUInteger  *foundIndex)
 {
-  unsigned	low, high, used, cnt, nextLoc;
+  NSUInteger	low, high, used, cnt, nextLoc;
   GSAttrInfo	*found = nil;
 
   used = (*cntImp)(_infoArray, cntSel);
@@ -456,50 +443,52 @@ _attributesAtIndexEffectiveRange(
   unlockImp = [attrLock methodForSelector: unlockSel];
 }
 
-- (id) initWithString: (NSString*)aString
-	   attributes: (NSDictionary*)attributes
+- (id)initWithString:(NSString *)aString attributes:(NSDictionary *)attributes
 {
-  NSZone	*z = [self zone];
-
-  if (nil == aString)
+    if (!(self = [super initWithString:aString attributes:attributes]))
     {
-      [NSException raise: NSInvalidArgumentException
-		  format: @"aString object passed to -[GSAttributedString initWithString:attributes:] is nil"];
+        return nil;
     }
-  if (![aString respondsToSelector: @selector(length)])
+    
+    NSZone	*zone = [self zone];
+    GSAttrInfo	*info;
+    
+    _infoArray = [[NSMutableArray allocWithZone:zone] initWithCapacity:1];
+    if (attributes == nil)
+	{
+        attributes = blank;
+	}
+    attributes = cacheAttributes(attributes);
+    info = NEWINFO(zone, attributes, 0);
+    ADDOBJECT(info);
+    RELEASE(info);
+    
+    _textChars = [aString copyWithZone: zone];
+    return self;
+}
+
+- (id)initWithAttributedString:(NSAttributedString *)attributedString
+{
+    if (!(self = [super initWithAttributedString:attributedString]))
     {
-      [NSException raise: NSInvalidArgumentException
-		  format: @"aString object passed to -[GSAttributedString initWithString:attributes:] does not respond to -length"];
+        return nil;
     }
-
-  _infoArray = [[NSMutableArray allocWithZone: z] initWithCapacity: 1];
-  if (aString != nil && [aString isKindOfClass: [NSAttributedString class]])
+    
+    NSZone *zone = [self zone];
+    NSString *string = [attributedString string];
+    
+    _infoArray = [[NSMutableArray allocWithZone:zone] initWithCapacity:1];
+    _setAttributesFrom(attributedString, NSMakeRange(0, [string length]), _infoArray);
+    
+    if (string == nil)
     {
-      NSAttributedString	*as = (NSAttributedString*)aString;
-      unsigned			len;
-
-      aString = [as string];
-      len = [aString length];
-      _setAttributesFrom(as, NSMakeRange(0, len), _infoArray);
+        _textChars = @"";
     }
-  else
+    else
     {
-      GSAttrInfo	*info;
-
-      if (attributes == nil)
-	{
-	  attributes = blank;
-	}
-      attributes = cacheAttributes(attributes);
-      info = NEWINFO(z, attributes, 0);
-      ADDOBJECT(info);
-      RELEASE(info);
+        _textChars = [string copyWithZone:zone];
     }
-  if (aString == nil)
-    _textChars = @"";
-  else
-    _textChars = [aString copyWithZone: z];
-  return self;
+    return self;
 }
 
 - (NSString*) string
@@ -541,15 +530,17 @@ _attributesAtIndexEffectiveRange(
 #define	SANITY()	
 #endif
 
-/* We always compile in this method so that it is available from
- * regression test cases.  */
+/*
+ * We always compile in this method so that it is available from
+ * regression test cases.
+ */
 - (void) _sanity
 {
   GSAttrInfo	*info;
-  unsigned	i;
-  unsigned	l = 0;
-  unsigned	len = [_textChars length];
-  unsigned	c = (*cntImp)(_infoArray, cntSel);
+  NSUInteger  i;
+  NSUInteger  l = 0;
+  NSUInteger  len = [_textChars length];
+  NSUInteger  c = (*cntImp)(_infoArray, cntSel);
 
   NSAssert(c > 0, NSInternalInconsistencyException);
   info = OBJECTAT(0);
@@ -565,61 +556,77 @@ _attributesAtIndexEffectiveRange(
 
 + (void) initialize
 {
-  [GSAttributedString class];	// Ensure immutable class is initialised
+    [GSAttributedString class];	/* Ensure immutable class is initialised */
 }
 
-- (id) initWithString: (NSString*)aString
-	   attributes: (NSDictionary*)attributes
+- (id)initWithString:(NSString *)aString attributes:(NSDictionary *)attributes
 {
-  NSZone	*z = [self zone];
-
-  if (nil == aString)
+    if (!(self = [super initWithString:aString attributes:attributes]))
     {
-      [NSException raise: NSInvalidArgumentException
-		  format: @"aString object passed to -[GSAttributedString initWithString:attributes:] is nil"];
+        return nil;
     }
-  if (![aString respondsToSelector: @selector(length)])
+  
+    NSZone *zone = [self zone];
+    GSAttrInfo *info;
+    
+    _infoArray = [[NSMutableArray allocWithZone:zone] initWithCapacity:1];
+    if (attributes == nil)
     {
-      [NSException raise: NSInvalidArgumentException
-		  format: @"aString object passed to -[GSAttributedString initWithString:attributes:] does not respond to -length"];
+        attributes = blank;
     }
+    attributes = cacheAttributes(attributes);
+    info = NEWINFO(zone, attributes, 0);
+    ADDOBJECT(info);
+    RELEASE(info);
+    
+    /*
+     * WARNING!
+     *
+     * NSLayoutManager depends on the fact that we create the _textChars 
+     * instance variable by copying the aString argument to get
+     * its own string subclass into the attributed string.
+     */
+    _textChars = [aString mutableCopyWithZone:zone];
+    SANITY();
+    return self;
+}
 
-  _infoArray = [[NSMutableArray allocWithZone: z] initWithCapacity: 1];
-  if (aString != nil && [aString isKindOfClass: [NSAttributedString class]])
+- (id)initWithAttributedString:(NSAttributedString *)attributedString
+{
+    if (!(self = [super initWithAttributedString:attributedString]))
     {
-      NSAttributedString	*as = (NSAttributedString*)aString;
-
-      aString = [as string];
-      _setAttributesFrom(as, NSMakeRange(0, [aString length]), _infoArray);
+        return nil;
     }
-  else
+    
+    NSZone *zone = [self zone];
+    NSString *string = [attributedString string];
+    
+    _infoArray = [[NSMutableArray allocWithZone:zone] initWithCapacity:1];
+    _setAttributesFrom(attributedString, NSMakeRange(0, [string length]), _infoArray);
+    
+    /*
+     * WARNING!
+     *
+     * NSLayoutManager depends on the fact that we create the _textChars 
+     * instance variable by copying the aString argument to get
+     * its own string subclass into the attributed string.
+     */
+    if (string == nil)
     {
-      GSAttrInfo	*info;
-
-      if (attributes == nil)
-        {
-          attributes = blank;
-        }
-      attributes = cacheAttributes(attributes);
-      info = NEWINFO(z, attributes, 0);
-      ADDOBJECT(info);
-      RELEASE(info);
+        _textChars = [[NSMutableString allocWithZone:zone] init];
     }
-/* WARNING ... NSLayoutManager depends on the fact that we create the
- * _textChars instance variable by copying the aString argument to get
- * its own string subclass into the attributed string.
- */
-  if (aString == nil)
-    _textChars = [[NSMutableString allocWithZone: z] init];
-  else
-    _textChars = [aString mutableCopyWithZone: z];
-SANITY();
-  return self;
+    else
+    {
+        _textChars = [string mutableCopyWithZone:zone];
+    }
+    SANITY();
+    return self;
 }
 
 - (NSString*) string
 {
-  /* NB. This method is SUPPOSED to return a proxy to the mutable string!
+  /*
+   * NB. This method is SUPPOSED to return a proxy to the mutable string!
    * This is a performance feature documented ifor OSX.
    */
   if (_textProxy == nil)
@@ -632,7 +639,7 @@ SANITY();
 - (NSDictionary*) attributesAtIndex: (NSUInteger)index
 		     effectiveRange: (NSRange*)aRange
 {
-  unsigned	dummy;
+  NSUInteger dummy;
   return _attributesAtIndexEffectiveRange(
     index, aRange, [_textChars length], _infoArray, &dummy);
 }
@@ -651,14 +658,14 @@ SANITY();
 - (void) setAttributes: (NSDictionary*)attributes
 		 range: (NSRange)range
 {
-  unsigned	tmpLength;
-  unsigned	arrayIndex = 0;
-  unsigned	arraySize;
-  NSRange	effectiveRange = NSMakeRange(0, NSNotFound);
-  unsigned	afterRangeLoc, beginRangeLoc;
-  NSDictionary	*attrs;
-  NSZone	*z = [self zone];
+  NSUInteger  tmpLength;
+  NSUInteger  arrayIndex = 0;
+  NSUInteger  arraySize;
+  NSRange     effectiveRange = NSMakeRange(0, NSNotFound);
+  NSUInteger  afterRangeLoc, beginRangeLoc;
   GSAttrInfo	*info;
+  NSDictionary *attrs;
+  NSZone *z = [self zone];
 
   if (range.length == 0)
     {
@@ -778,13 +785,13 @@ SANITY();
 - (void) replaceCharactersInRange: (NSRange)range
 		       withString: (NSString*)aString
 {
-  unsigned	tmpLength;
-  unsigned	arrayIndex = 0;
-  unsigned	arraySize;
-  NSRange	effectiveRange = NSMakeRange(0, NSNotFound);
+  NSUInteger  tmpLength;
+  NSUInteger  arrayIndex = 0;
+  NSUInteger  arraySize;
+  NSRange     effectiveRange = NSMakeRange(0, NSNotFound);
   GSAttrInfo	*info;
-  int		moveLocations;
-  unsigned	start;
+  ssize_t     moveLocations;
+  NSUInteger  start;
 
 SANITY();
   if (aString == nil)
@@ -840,7 +847,7 @@ SANITY();
       info = OBJECTAT(arrayIndex);
       if (info->loc < NSMaxRange(range))
 	{
-	  unsigned int	next = arrayIndex + 1;
+	  NSUInteger next = arrayIndex + 1;
 
 	  while (next < arraySize)
 	    {
@@ -924,10 +931,12 @@ SANITY();
   [super dealloc];
 }
 
-// The superclass implementation is correct but too slow
+/*
+ * The superclass implementation is correct but too slow
+ */
 - (NSUInteger) length
 {
-  return [_textChars length];
+    return [_textChars length];
 }
 
 @end
diff --git a/Source/GSBlocks.m b/Source/GSBlocks.m
index 09da221..23590e7 100644
--- a/Source/GSBlocks.m
+++ b/Source/GSBlocks.m
@@ -21,12 +21,19 @@
    */ 
 
 #import "Foundation/NSObject.h"
+#import "GNUstepBase/GSObjCRuntime.h"
 
+/* 
+ * It conflicts with the NeXT runtime (they use const void*), 
+ * don't know whether it's viable to include <GNUstepBase/GSObjCRuntime.h> 
+ */
+#ifndef NeXT_RUNTIME
 /* Declare the block copy functions ourself so that we don't depend on a
  * specific header location.
  */
 void *_Block_copy(void *);
 void _Block_release(void *);
+#endif
 
 @interface GSBlock : NSObject
 @end
diff --git a/Source/GSConcreteValueTemplate.m b/Source/GSConcreteValueTemplate.m
index c536a1e..a9322a8 100644
--- a/Source/GSConcreteValueTemplate.m
+++ b/Source/GSConcreteValueTemplate.m
@@ -120,15 +120,13 @@
 // Accessing Data
 - (void) getValue: (void *)value
 {
-  NSUInteger	size;
   if (!value)
     {
       [NSException raise: NSInvalidArgumentException
 		  format: @"Cannot copy value into NULL buffer"];
 	/* NOT REACHED */
     }
-  NSGetSizeAndAlignment([self objCType], 0, &size);
-  memcpy(value, &data, size);
+  *(__typeof__(data) *)value = data;
 }
 
 - (BOOL) isEqual: (id)other
diff --git a/Source/GSCountedSet.m b/Source/GSCountedSet.m
index 44c0f59..d2aa1a0 100644
--- a/Source/GSCountedSet.m
+++ b/Source/GSCountedSet.m
@@ -167,14 +167,15 @@ static GC_descr	nodeDesc;	// Type descriptor for map node.
 
 - (void) encodeWithCoder: (NSCoder*)aCoder
 {
-  unsigned	count = map.nodeCount;
-  SEL		sel1 = @selector(encodeObject:);
-  IMP		imp1 = [aCoder methodForSelector: sel1];
-  SEL		sel2 = @selector(encodeValueOfObjCType:at:);
-  IMP		imp2 = [aCoder methodForSelector: sel2];
-  const char	*type = @encode(unsigned);
-  GSIMapEnumerator_t	enumerator = GSIMapEnumeratorForMap(&map);
-  GSIMapNode 		node = GSIMapEnumeratorNextNode(&enumerator);
+  NSUInteger    count = map.nodeCount;
+  SEL           sel1 = @selector(encodeObject:);
+  IMP           imp1 = [aCoder methodForSelector: sel1];
+  SEL           sel2 = @selector(encodeValueOfObjCType:at:);
+  IMP           imp2 = [aCoder methodForSelector: sel2];
+  const char    *type = @encode(unsigned);
+    
+  GSIMapEnumerator_t    enumerator = GSIMapEnumeratorForMap(&map);
+  GSIMapNode            node = GSIMapEnumeratorNextNode(&enumerator);
 
   (*imp2)(aCoder, sel2, type, &count);
 
@@ -221,7 +222,8 @@ static GC_descr	nodeDesc;	// Type descriptor for map node.
     {
       (*imp)(aCoder, sel, otype, &value);
       (*imp)(aCoder, sel, utype, &valcnt);
-      GSIMapAddPairNoRetain(&map, (GSIMapKey)value, (GSIMapVal)valcnt);
+      GSIMapAddPair(&map, (GSIMapKey)value, (GSIMapVal)valcnt);
+        [value release];
     }
 
   return self;
diff --git a/Source/GSDictionary.m b/Source/GSDictionary.m
index 87ec82a..9d849fb 100644
--- a/Source/GSDictionary.m
+++ b/Source/GSDictionary.m
@@ -127,11 +127,12 @@ static SEL	objSel;
     }
   else
     {
-      unsigned	count = map.nodeCount;
-      SEL		sel = @selector(encodeObject:);
-      IMP		imp = [aCoder methodForSelector: sel];
-      GSIMapEnumerator_t	enumerator = GSIMapEnumeratorForMap(&map);
-      GSIMapNode	node = GSIMapEnumeratorNextNode(&enumerator);
+      NSUInteger    count = map.nodeCount;
+      SEL           sel = @selector(encodeObject:);
+      IMP           imp = [aCoder methodForSelector: sel];
+
+      GSIMapEnumerator_t    enumerator = GSIMapEnumeratorForMap(&map);
+      GSIMapNode            node = GSIMapEnumeratorNextNode(&enumerator);
 
       [aCoder encodeValueOfObjCType: @encode(unsigned) at: &count];
       while (node != 0)
@@ -177,7 +178,9 @@ static SEL	objSel;
         {
 	  (*imp)(aCoder, sel, type, &key);
 	  (*imp)(aCoder, sel, type, &value);
-	  GSIMapAddPairNoRetain(&map, (GSIMapKey)key, (GSIMapVal)value);
+	  GSIMapAddPair(&map, (GSIMapKey)key, (GSIMapVal)value);
+            [key release];
+            [value release];
 	}
     }
   return self;
@@ -287,8 +290,10 @@ static SEL	objSel;
 	    }
 	  else
 	    {
-	      GSIMapAddPairNoRetain(&map, (GSIMapKey)k, (GSIMapVal)o);
+	      GSIMapAddPair(&map, (GSIMapKey)k, (GSIMapVal)o);
+            [o release];
 	    }
+        [k release];
 	}
     }
   return self;
@@ -395,7 +400,7 @@ static SEL	objSel;
   return self;
 }
 
-- (id) makeImmutableCopyOnFail: (BOOL)force
+- (id) makeImmutable
 {
   GSClassSwizzle(self, [GSDictionary class]);
   return self;
@@ -474,10 +479,12 @@ static SEL	objSel;
 
 - (id) initWithDictionary: (NSDictionary*)d
 {
-  [super init];
-  dictionary = (GSDictionary*)RETAIN(d);
-  enumerator = GSIMapEnumeratorForMap(&dictionary->map);
-  return self;
+    if (self = [super init])
+    {
+        dictionary = (GSDictionary*)RETAIN(d);
+        enumerator = GSIMapEnumeratorForMap(&dictionary->map);
+    }
+    return self;
 }
 
 - (id) nextObject
diff --git a/Source/GSFFIInvocation.m b/Source/GSFFIInvocation.m
index d8a0c78..a59e5f9 100644
--- a/Source/GSFFIInvocation.m
+++ b/Source/GSFFIInvocation.m
@@ -24,7 +24,7 @@
 
 #import "common.h"
 
-#if !defined (__GNU_LIBOBJC__)
+#if !defined (__GNU_LIBOBJC__) && !defined (NeXT_RUNTIME)
 #  include <objc/encoding.h>
 #endif
 
@@ -113,7 +113,7 @@ gs_find_best_typed_sel (SEL sel)
  */
   return sel_getTypedSelector(sel_getName(sel));
 }
-#elif defined(NeXTRUNTIME)
+#elif defined(NeXT_RUNTIME)
 {
   /* The NeXT runtime does not support typed selectors, so we simply
    * return 0 here.  */
@@ -301,7 +301,7 @@ static id gs_objc_proxy_lookup(id receiver, SEL op)
  */
 - (id) initWithMethodSignature: (NSMethodSignature*)aSignature
 {
-  int	i;
+  size_t	i;
 
   if (aSignature == nil)
     {
@@ -309,7 +309,7 @@ static id gs_objc_proxy_lookup(id receiver, SEL op)
       return nil;
     }
   _sig = RETAIN(aSignature);
-  _numArgs = [aSignature numberOfArguments];
+  _numArgs = (unsigned)[aSignature numberOfArguments];
   _info = [aSignature methodInfo];
   _frame = cifframe_from_signature(_sig);
   [_frame retain];
@@ -343,10 +343,10 @@ static id gs_objc_proxy_lookup(id receiver, SEL op)
 	      signature: (NSMethodSignature*)aSignature
 {
   cifframe_t *f;
-  int i;
+  size_t i;
 
   _sig = RETAIN(aSignature);
-  _numArgs = [aSignature numberOfArguments];
+  _numArgs = (unsigned)[aSignature numberOfArguments];
   _info = [aSignature methodInfo];
   _frame = (NSMutableData*)frame;
   [_frame retain];
@@ -683,19 +683,17 @@ GSFFIInvocationCallback(ffi_cif *cif, void *retp, void **args, void *user)
       switch (*type)
 	{
 	  case _C_ID:
-	    if (flags & _F_BYCOPY)
+	    if (flags & GSObjCQualifierByCopyMask)
 	      {
-		[coder encodeBycopyObject: *(id*)datum];
+          [coder encodeBycopyObject: *(id*)datum];
 	      }
-#ifdef	_F_BYREF
-	    else if (flags & _F_BYREF)
+	    else if (flags & GSObjCQualifierByRefMask)
 	      {
-		[coder encodeByrefObject: *(id*)datum];
+          [coder encodeByrefObject: *(id*)datum];
 	      }
-#endif
 	    else
 	      {
-		[coder encodeObject: *(id*)datum];
+          [coder encodeObject: *(id*)datum];
 	      }
 	    break;
 	  case _C_CHARPTR:
@@ -707,18 +705,18 @@ GSFFIInvocationCallback(ffi_cif *cif, void *retp, void **args, void *user)
 	     * because the method may have changed it.  Set
 	     * OUT_PARAMETERS accordingly.
 	     */
-	    if ((flags & _F_OUT) || !(flags & _F_IN))
+	    if ((flags & GSObjCQualifierOutMask) || !(flags & GSObjCQualifierInMask))
 	      {
-		out_parameters = YES;
+          out_parameters = YES;
 	      }
 	    /*
 	     * If the char* is qualified as an IN parameter, or not
 	     * explicity qualified as an OUT parameter, then encode
 	     * it.
 	     */
-	    if ((flags & _F_IN) || !(flags & _F_OUT))
+	    if ((flags & GSObjCQualifierInMask) || !(flags & GSObjCQualifierOutMask))
 	      {
-		[coder encodeValueOfObjCType: type at: datum];
+          [coder encodeValueOfObjCType: type at: datum];
 	      }
 	    break;
 
@@ -730,16 +728,16 @@ GSFFIInvocationCallback(ffi_cif *cif, void *retp, void **args, void *user)
 	     * the method is run, because the method may have changed
 	     * it.  Set OUT_PARAMETERS accordingly.
 	     */
-	    if ((flags & _F_OUT) || !(flags & _F_IN))
+	    if ((flags & GSObjCQualifierOutMask) || !(flags & GSObjCQualifierInMask))
 	      {
-		out_parameters = YES;
+          out_parameters = YES;
 	      }
 	    if (passp)
 	      {
-		if ((flags & _F_IN) || !(flags & _F_OUT))
-		  {
-		    [coder encodeValueOfObjCType: type at: datum];
-		  }
+          if ((flags & GSObjCQualifierInMask) || !(flags & GSObjCQualifierOutMask))
+            {
+              [coder encodeValueOfObjCType: type at: datum];
+            }
 	      }
 	    else
 	      {
@@ -755,7 +753,7 @@ GSFFIInvocationCallback(ffi_cif *cif, void *retp, void **args, void *user)
 		 * or not explicity qualified as an OUT parameter, then
 		 * encode it.
 		 */
-		if ((flags & _F_IN) || !(flags & _F_OUT))
+		if ((flags & GSObjCQualifierInMask) || !(flags & GSObjCQualifierOutMask))
 		  {
 		    [coder encodeValueOfObjCType: type at: *(void**)datum];
 		  }
diff --git a/Source/GSFTPURLHandle.m b/Source/GSFTPURLHandle.m
index 1fa31cd..19857fc 100644
--- a/Source/GSFTPURLHandle.m
+++ b/Source/GSFTPURLHandle.m
@@ -148,9 +148,9 @@ NSString * const GSTelnetTextKey = @"GSTelnetTextKey";
   unsigned char	*to;
   NSData	*d = [s dataUsingEncoding: enc];
   unsigned char	*from = (unsigned char *)[d bytes];
-  unsigned int	len = [d length];
-  unsigned int	i = 0;
-  unsigned int	count = 0;
+  NSUInteger    len = [d length];
+  NSUInteger    i = 0;
+  NSUInteger    count = 0;
 
   for (i = 0; i < len; i++)
     {
@@ -729,7 +729,7 @@ static NSLock			*urlLock = nil;
 
 	      if (r.length > 0)
 		{
-		  unsigned	pos = NSMaxRange(r);
+		  NSUInteger pos = NSMaxRange(r);
 
 		  r = [line rangeOfString: @")"];
 		  if (r.length > 0 && r.location > pos)
diff --git a/Source/GSFileHandle.h b/Source/GSFileHandle.h
index 8194656..b19765b 100644
--- a/Source/GSFileHandle.h
+++ b/Source/GSFileHandle.h
@@ -31,6 +31,7 @@
 #import <Foundation/NSRunLoop.h>
 
 #import <GNUstepBase/GSConfig.h>
+#import "GSSocksParser/GSSocksParser.h"
 
 #if	USE_ZLIB
 #include <zlib.h>
@@ -43,7 +44,7 @@ struct sockaddr_in;
  * and is not intended to be used by anyone else ... it is subject to
  * change or removal without warning.
  */
-@interface GSFileHandle : NSFileHandle <RunLoopEvents>
+@interface GSFileHandle : NSFileHandle <RunLoopEvents, GSSocksParserDelegate>
 {
 #if	GS_EXPOSE(GSFileHandle)
   int			descriptor;
@@ -58,9 +59,9 @@ struct sockaddr_in;
   BOOL			readOK;
   BOOL			writeOK;
   NSMutableDictionary	*readInfo;
-  int			readMax;
+  ssize_t			readMax;
   NSMutableArray	*writeInfo;
-  int			writePos;
+  ssize_t			writePos;
   NSString		*address;
   NSString		*service;
   NSString		*protocol;
@@ -71,6 +72,7 @@ struct sockaddr_in;
   WSAEVENT  		event;
 #endif
 #endif
+  GSSocksParser *parser;
 }
 
 - (id) initAsClientAtAddress: (NSString*)address
diff --git a/Source/GSFileHandle.m b/Source/GSFileHandle.m
index d671351..8e909bd 100644
--- a/Source/GSFileHandle.m
+++ b/Source/GSFileHandle.m
@@ -38,6 +38,7 @@
 #import "Foundation/NSByteOrder.h"
 #import "Foundation/NSProcessInfo.h"
 #import "Foundation/NSUserDefaults.h"
+#import "Foundation/NSValue.h"
 #import "GSPrivate.h"
 #import "GSNetwork.h"
 #import "GNUstepBase/NSObject+GNUstepBase.h"
@@ -103,6 +104,12 @@ static GSFileHandle*	fh_stdin = nil;
 static GSFileHandle*	fh_stdout = nil;
 static GSFileHandle*	fh_stderr = nil;
 
+static NSString *const SocksConnectNotification = @"SocksConnectNotification";
+static NSString *const SocksReadNotification    = @"SocksReadNotification";
+static NSString *const SocksWriteNotification   = @"SocksWriteNotification";
+
+static NSDictionary *GlobalSOCKSProxyConfiguration = nil;
+
 // Key to info dictionary for operation mode.
 static NSString*	NotificationKey = @"NSFileHandleNotificationKey";
 
@@ -117,60 +124,64 @@ static NSString*	NotificationKey = @"NSFileHandleNotificationKey";
  * Encapsulates low level read operation to get data from the operating
  * system.
  */
-- (NSInteger) read: (void*)buf length: (NSUInteger)len
+- (NSInteger)read:(void *)buf length:(NSUInteger)len
 {
-  int	result;
-
-  do
+    ssize_t	result;
+    
+    NSAssert1(!gzDescriptor || len <= UINT_MAX, @"Maximum read size with gzip is %u", UINT_MAX);
+    
+    do
     {
 #if	USE_ZLIB
-      if (gzDescriptor != 0)
-	{
-	  result = gzread(gzDescriptor, buf, len);
-	}
-      else
+        if (gzDescriptor)
+        {
+            result = gzread(gzDescriptor, buf, (unsigned)len);
+        }
+        else
 #endif
-      if (isSocket)
-	{
-	  result = recv(descriptor, buf, len, 0);
-	}
-      else
-	{
-	  result = read(descriptor, buf, len);
-	}
+            if (isSocket)
+            {
+                result = recv(descriptor, buf, len, 0);
+            }
+            else
+            {
+                result = read(descriptor, buf, len);
+            }
     }
-  while (result < 0 && EINTR == errno);
-  return result;
+    while (result < 0 && EINTR == errno);
+    return result;
 }
 
 /**
  * Encapsulates low level write operation to send data to the operating
  * system.
  */
-- (NSInteger) write: (const void*)buf length: (NSUInteger)len
+- (NSInteger)write:(const void *)buf length:(NSUInteger)len
 {
-  int	result;
-
-  do
+    ssize_t	result;
+    
+    NSAssert1(!gzDescriptor || len <= UINT_MAX, @"Maximum write size with gzip is %u", UINT_MAX);
+    
+    do
     {
 #if	USE_ZLIB
-    if (gzDescriptor != 0)
-      {
-	result = gzwrite(gzDescriptor, (char*)buf, len);
-      }
-    else
+        if (gzDescriptor != 0)
+        {
+            result = gzwrite(gzDescriptor, (char *)buf, (unsigned)len);
+        }
+        else
 #endif
-      if (isSocket)
-	{
-	  result = send(descriptor, buf, len, 0);
-	}
-      else
-	{
-	  result = write(descriptor, buf, len);
-	}
+            if (isSocket)
+            {
+                result = send(descriptor, buf, len, 0);
+            }
+            else
+            {
+                result = write(descriptor, buf, len);
+            }
     }
-  while (result < 0 && EINTR == errno);
-  return result;
+    while (result < 0 && EINTR == errno);
+    return result;
 }
 
 + (id) allocWithZone: (NSZone*)z
@@ -180,15 +191,16 @@ static NSString*	NotificationKey = @"NSFileHandleNotificationKey";
 
 - (void) dealloc
 {
-  DESTROY(address);
-  DESTROY(service);
-  DESTROY(protocol);
-
-  [self finalize];
-
-  DESTROY(readInfo);
-  DESTROY(writeInfo);
-  [super dealloc];
+    DESTROY(address);
+    DESTROY(service);
+    DESTROY(protocol);
+    
+    [self finalize];
+    
+    DESTROY(readInfo);
+    DESTROY(writeInfo);
+    DESTROY(parser);
+    [super dealloc];
 }
 
 - (void) finalize
@@ -231,6 +243,65 @@ static NSString*	NotificationKey = @"NSFileHandleNotificationKey";
   return [self initWithNullDevice];
 }
 
+- (void)_setupDescriptor:(int)aDescriptor
+{
+    struct stat	sbuf;
+    int         e;
+    
+    if (fstat(aDescriptor, &sbuf) < 0) {
+#if	defined(__MINGW__)
+        /* On windows, an fstat will fail if the descriptor is a pipe
+         * or socket, so we simply mark the descriptor as not being a
+         * standard file.
+         */
+        isStandardFile = NO;
+#else
+        /* This should never happen on unix.  If it does, we have somehow
+         * ended up with a bad descriptor.
+         */
+        NSLog(@"unable to get status of descriptor %d - %@", aDescriptor, [NSError _last]);
+        isStandardFile = NO;
+#endif
+	} else {
+        if (S_ISREG(sbuf.st_mode)) {
+            isStandardFile = YES;
+	    } else {
+            isStandardFile = NO;
+	    }
+	}
+    
+    if ((e = fcntl(aDescriptor, F_GETFL, 0)) >= 0)	{
+        if (e & NBLK_OPT) {
+            wasNonBlocking = YES;
+	    } else {
+            wasNonBlocking = NO;
+	    }
+	}
+    
+    isNonBlocking = wasNonBlocking;
+    descriptor = aDescriptor;
+    readInfo = nil;
+    writeInfo = [NSMutableArray new];
+    readMax = 0;
+    writePos = 0;
+    readOK = YES;
+    writeOK = YES;
+    acceptOK = YES;
+    connectOK = YES;
+}
+
+- (id) initWithFileDescriptor: (int)desc closeOnDealloc: (BOOL)flag
+{
+    if (self = [super init]) {
+        [self _setupDescriptor:desc];
+        closeOnDealloc = flag;
+        parser = nil;
+    } else if (flag == YES) {
+        close(desc);
+    }
+    return self;
+}
+
 /**
  * Initialise as a client socket connection ... do this by using
  * [-initAsClientInBackgroundAtAddress:service:protocol:forModes:]
@@ -271,547 +342,269 @@ static NSString*	NotificationKey = @"NSFileHandleNotificationKey";
   return self;
 }
 
-/*
- * States for socks connection negotiation
- */
-NSString * const GSSOCKSConnect = @"GSSOCKSConnect";
-NSString * const GSSOCKSSendAuth = @"GSSOCKSSendAuth";
-NSString * const GSSOCKSRecvAuth = @"GSSOCKSRecvAuth";
-NSString * const GSSOCKSSendConn = @"GSSOCKSSendConn";
-NSString * const GSSOCKSRecvConn = @"GSSOCKSRecvConn";
-NSString * const GSSOCKSRecvAddr = @"GSSOCKSRecvAddr";
-
-- (void) _socksHandler: (NSNotification*)aNotification
-{
-  NSNotificationCenter	*nc = [NSNotificationCenter defaultCenter];
-  NSString		*name = [aNotification name];
-  NSDictionary		*info = (NSMutableDictionary*)[aNotification userInfo];
-  NSArray		*modes;
-  NSString		*error;
-  NSMutableDictionary	*i = nil;
-  NSNotification	*n = nil;
-
-  NSDebugMLLog(@"NSFileHandle", @"%@ SOCKS connection: %@",
-    self, aNotification);
-
-  [nc removeObserver: self name: name object: self];
-
-  modes = (NSArray*)[info objectForKey: NSFileHandleNotificationMonitorModes];
-  error = [info objectForKey: GSFileHandleNotificationError];
-
-  if (error == nil)
-    {
-      if (name == GSSOCKSConnect)
-	{
-	  NSData	*item;
-
-	  /*
-	   * Send an authorisation record to the SOCKS server.
-	   */
-	  i = [info mutableCopy];
-	  /*
-	   * Authorisation record is at least three bytes -
-	   *   socks version (5)
-	   *   authorisation method bytes to follow (1)
-	   *   say we do no authorisation (0)
-	   */
-	  item = [[NSData alloc] initWithBytes: "\5\1\0"
-					length: 3];
-	  [i setObject: item forKey: NSFileHandleNotificationDataItem];
-	  RELEASE(item);
-	  [i setObject: GSSOCKSSendAuth forKey: NotificationKey];
-	  [writeInfo addObject: i];
-	  RELEASE(i);
-	  [nc addObserver: self
-		 selector: @selector(_socksHandler:)
-		     name: GSSOCKSSendAuth
-		   object: self];
-	  [self watchWriteDescriptor];
-	}
-      else if (name == GSSOCKSSendAuth)
-	{
-	  NSMutableData	*item;
-
-	  /*
-	   * We have written the authorisation record, so we
-	   * request a response from the SOCKS server.
-	   */
-	  readMax = 2;
-	  readInfo = [info mutableCopy];
-	  [readInfo setObject: GSSOCKSRecvAuth forKey: NotificationKey];
-	  item = [[NSMutableData alloc] initWithCapacity: 0];
-	  [readInfo setObject: item forKey: NSFileHandleNotificationDataItem];
-	  RELEASE(item);
-	  [nc addObserver: self
-		 selector: @selector(_socksHandler:)
-		     name: GSSOCKSRecvAuth
-		   object: self];
-	  [self watchReadDescriptorForModes: modes];
-	}
-      else if (name == GSSOCKSRecvAuth)
-	{
-	  NSData		*response;
-	  const unsigned char	*bytes;
-
-	  response = [info objectForKey: NSFileHandleNotificationDataItem];
-	  bytes = (const unsigned char*)[response bytes];
-	  if ([response length] != 2)
-	    {
-	      error = @"authorisation response from SOCKS was not two bytes";
-	    }
-	  else if (bytes[0] != 5)
-	    {
-	      error = @"authorisation response from SOCKS had wrong version";
-	    }
-	  else if (bytes[1] != 0)
-	    {
-	      error = @"authorisation response from SOCKS had wrong method";
-	    }
-	  else
-	    {
-	      NSData		*item;
-	      char		buf[10];
-	      const char	*ptr;
-	      int		p;
-
-	      /*
-	       * Send the address information to the SOCKS server.
-	       */
-	      i = [info mutableCopy];
-	      /*
-	       * Connect command is ten bytes -
-	       *   socks version
-	       *   connect command
-	       *   reserved byte
-	       *   address type
-	       *   address 4 bytes (big endian)
-	       *   port 2 bytes (big endian)
-	       */
-	      buf[0] = 5;	// Socks version number
-	      buf[1] = 1;	// Connect command
-	      buf[2] = 0;	// Reserved
-	      buf[3] = 1;	// Address type (IPV4)
-	      ptr = [address lossyCString];
-	      buf[4] = atoi(ptr);
-	      while (isdigit(*ptr))
-		ptr++;
-	      ptr++;
-	      buf[5] = atoi(ptr);
-	      while (isdigit(*ptr))
-		ptr++;
-	      ptr++;
-	      buf[6] = atoi(ptr);
-	      while (isdigit(*ptr))
-		ptr++;
-	      ptr++;
-	      buf[7] = atoi(ptr);
-	      p = [service intValue];
-	      buf[8] = ((p & 0xff00) >> 8);
-	      buf[9] = (p & 0xff);
-
-	      item = [[NSData alloc] initWithBytes: buf length: 10];
-	      [i setObject: item forKey: NSFileHandleNotificationDataItem];
-	      RELEASE(item);
-	      [i setObject: GSSOCKSSendConn
-		    forKey: NotificationKey];
-	      [writeInfo addObject: i];
-	      RELEASE(i);
-	      [nc addObserver: self
-		     selector: @selector(_socksHandler:)
-			 name: GSSOCKSSendConn
-		       object: self];
-	      [self watchWriteDescriptor];
-	    }
-	}
-      else if (name == GSSOCKSSendConn)
-	{
-	  NSMutableData	*item;
-
-	  /*
-	   * We have written the connect command, so we
-	   * request a response from the SOCKS server.
-	   */
-	  readMax = 4;
-	  readInfo = [info mutableCopy];
-	  [readInfo setObject: GSSOCKSRecvConn forKey: NotificationKey];
-	  item = [[NSMutableData alloc] initWithCapacity: 0];
-	  [readInfo setObject: item forKey: NSFileHandleNotificationDataItem];
-	  RELEASE(item);
-	  [nc addObserver: self
-		 selector: @selector(_socksHandler:)
-		     name: GSSOCKSRecvConn
-		   object: self];
-	  [self watchReadDescriptorForModes: modes];
-	}
-      else if (name == GSSOCKSRecvConn)
-	{
-	  NSData		*response;
-	  const unsigned char	*bytes;
-	  unsigned		len = 0;
-
-	  response = [info objectForKey: NSFileHandleNotificationDataItem];
-	  bytes = (const unsigned char*)[response bytes];
-	  if ([response length] != 4)
-	    {
-	      error = @"connect response from SOCKS had bad length";
-	    }
-	  else if (bytes[0] != 5)
-	    {
-	      error = @"connect response from SOCKS had wrong version";
-	    }
-	  else if (bytes[1] != 0)
-	    {
-	      switch (bytes[1])
-		{
-		  case 1:
-		    error = @"SOCKS server general failure";
-		    break;
-		  case 2:
-		    error = @"SOCKS server says permission denied";
-		    break;
-		  case 3:
-		    error = @"SOCKS server says network unreachable";
-		    break;
-		  case 4:
-		    error = @"SOCKS server says host unreachable";
-		    break;
-		  case 5:
-		    error = @"SOCKS server says connection refused";
-		    break;
-		  case 6:
-		    error = @"SOCKS server says connection timed out";
-		    break;
-		  case 7:
-		    error = @"SOCKS server says command not supported";
-		    break;
-		  case 8:
-		    error = @"SOCKS server says address type not supported";
-		    break;
-		  default:
-		    error = @"connect response from SOCKS was failure";
-		    break;
-		}
-	    }
-	  else if (bytes[3] == 1)
-	    {
-	      len = 4;			// Fixed size (IPV4) address
-	    }
-	  else if (bytes[3] == 3)
-	    {
-	      len = 1 + bytes[4];	// Domain name with leading length
-	    }
-	  else if (bytes[3] == 4)
-	    {
-	      len = 16;			// Fixed size (IPV6) address
-	    }
-	  else
-	    {
-	      error = @"SOCKS server returned unknown address type";
-	    }
-
-	  if (error == nil)
-	    {
-	      NSMutableData	*item;
-
-	      /*
-	       * We have received a success, so we must now consume the
-	       * address and port information the SOCKS server sends.
-	       */
-	      readMax = len + 2;
-	      readInfo = [info mutableCopy];
-	      [readInfo setObject: GSSOCKSRecvAddr forKey: NotificationKey];
-	      item = [[NSMutableData alloc] initWithCapacity: 0];
-	      [readInfo setObject: item
-			   forKey: NSFileHandleNotificationDataItem];
-	      RELEASE(item);
-	      [nc addObserver: self
-		     selector: @selector(_socksHandler:)
-			 name: GSSOCKSRecvAddr
-		       object: self];
-	      [self watchReadDescriptorForModes: modes];
-	    }
-	}
-      else if (name == GSSOCKSRecvAddr)
-	{
-	  /*
-	   * Success ... We read the address from the socks server so
-	   * the connection is now ready to go.
-	   */
-	  name = GSFileHandleConnectCompletionNotification;
-	  i = [info mutableCopy];
-	  [i setObject: name forKey: NotificationKey];
-	  n = [NSNotification notificationWithName: name
-					    object: self
-					  userInfo: i];
-	  RELEASE(i);
-	}
-      else
-	{
-	  /*
-	   * Argh ... unexpected notification.
-	   */
-	  error = @"unexpected notification during SOCKS connection";
-	}
-    }
-
-  /*
-   * If 'error' is non-null, we set up a notification to tell people
-   * the connection failed.
-   */
-  if (error != nil)
-    {
-      NSDebugMLLog(@"NSFileHandle", @"%@ SOCKS error: %@", self, error);
-
-      /*
-       * An error in the initial connection ... notify observers
-       * by re-posting the notification with a new name.
-       */
-      name = GSFileHandleConnectCompletionNotification;
-      i = [info mutableCopy];
-      [i setObject: name forKey: NotificationKey];
-      [i setObject: error forKey: GSFileHandleNotificationError];
-      n = [NSNotification notificationWithName: name
-					object: self
-				      userInfo: i];
-      RELEASE(i);
+- (BOOL)_connectToService:(NSString *)aService
+                   atHost:(NSString *)aHost
+            usingProtocol:(NSString *)aProtocol
+              fromAddress:(NSString *)localAddress
+                  service:(NSString *)localService
+      observeNotification:(NSString *)aName
+                 forModes:(NSArray  *)aModes
+{
+    if (descriptor >= 0) {
+        close(descriptor);
+        descriptor = -1;
+    }
+    
+    struct sockaddr socketAddress;
+    
+    if (!GSPrivateSockaddrSetup(aHost, 0, aService, aProtocol, &socketAddress)) {
+        NSLog(@"bad address-service-protocol combination");
+        return NO;
+    }
+    [self setAddr:&socketAddress]; /* Store the address of the remote end */
+
+    if ((descriptor = socket(socketAddress.sa_family, SOCK_STREAM, PF_UNSPEC)) == -1) {
+        NSLog(@"unable to create socket - %@", [NSError _last]);
+        return NO;
+    }
+    
+    /* Enable tcp-level tracking of whether connection is alive */
+    int status = 1;
+    setsockopt(descriptor, SOL_SOCKET, SO_KEEPALIVE, (char *)&status, sizeof(status));
+    
+    if (localAddress) {
+        setsockopt(descriptor, SOL_SOCKET, SO_REUSEADDR, (char *)&status, sizeof(status));
+        struct sockaddr localSocketAddress;
+        if (!GSPrivateSockaddrSetup(localAddress, 0, localService, aProtocol, &localSocketAddress)) {
+            NSLog(@"bad bind address specification");
+            return NO;
+        }
+        if (bind(descriptor, &localSocketAddress, GSPrivateSockaddrLength(&localSocketAddress)) == -1)
+        {
+            NSLog(@"unable to bind to socket to address %@ - %@", GSPrivateSockaddrName(&localSocketAddress), [NSError _last]);
+            return NO;
+        }
     }
-
-  /*
-   * If a notification has been set up, we post it as the last thing we do.
-   */
-  if (n != nil)
-    {
-      NSNotificationQueue	*q;
-
-      q = [NSNotificationQueue defaultQueue];
-      [q enqueueNotification: n
-		postingStyle: NSPostASAP
-		coalesceMask: NSNotificationNoCoalescing
-		    forModes: modes];
+    
+    [self _setupDescriptor:descriptor];
+    
+    NSMutableDictionary*	info;
+    isSocket = YES;
+    [self setNonBlocking: YES];
+    if (connect(descriptor, &socketAddress, GSPrivateSockaddrLength(&socketAddress)) == -1) {
+        if (!GSWOULDBLOCK) {
+            NSLog(@"unable to make socket connection to %@ - %@", GSPrivateSockaddrName(&socketAddress), [NSError _last]);
+            return NO;
+        }
     }
+    
+    info = [[NSMutableDictionary alloc] initWithCapacity:4];
+    [info setObject:address forKey:NSFileHandleNotificationDataItem];
+    [info setObject:aName forKey:NotificationKey];
+    if (aModes) {
+        [info setObject:aModes forKey:NSFileHandleNotificationMonitorModes];
+    }
+    [writeInfo addObject:info];
+    RELEASE(info);
+    [self watchWriteDescriptor];
+    connectOK = YES;
+    acceptOK = NO;
+    readOK = NO;
+    writeOK = NO;
+    
+    return YES;
 }
 
-- (id) initAsClientInBackgroundAtAddress: (NSString*)a
-				 service: (NSString*)s
-			        protocol: (NSString*)p
-			        forModes: (NSArray*)modes
++ (void)initialize
 {
-  static NSString	*esocks = nil;
-  static NSString	*dsocks = nil;
-  static BOOL		beenHere = NO;
-  int			net;
-  struct sockaddr	sin;
-  struct sockaddr	lsin;
-  NSString		*lhost = nil;
-  NSString		*shost = nil;
-  NSString		*sport = nil;
-  int			status;
-
-  if (beenHere == NO)
-    {
-      NSUserDefaults	*defs;
-
-      beenHere = YES;
-      defs = [NSUserDefaults standardUserDefaults];
-      dsocks = [[defs stringForKey: @"GSSOCKS"] copy];
-      if (dsocks == nil)
-	{
-	  NSDictionary	*env;
-
-	  env = [[NSProcessInfo processInfo] environment];
-	  esocks = [env objectForKey: @"SOCKS5_SERVER"];
-	  if (esocks == nil)
-	    {
-	      esocks = [env objectForKey: @"SOCKS_SERVER"];
-	    }
-	  esocks = [esocks copy];
-	}
-    }
-
-  if (a == nil || [a isEqualToString: @""])
-    {
-      a = @"localhost";
-    }
-  if (s == nil)
-    {
-      NSLog(@"bad argument - service is nil");
-      DESTROY(self);
-      return nil;
-    }
-
-  if ([p hasPrefix: @"bind-"] == YES)
-    {
-      NSRange	r;
-
-      lhost = [p substringFromIndex: 5];
-      r = [lhost rangeOfString: @":"];
-      if (r.length > 0)
-	{
-	  p = [lhost substringFromIndex: NSMaxRange(r)];
-	  lhost = [lhost substringToIndex: r.location];
-	}
-      else
-	{
-	  p = nil;
-	}
-      if (GSPrivateSockaddrSetup(lhost, 0, p, @"tcp", &lsin) == NO)
-	{
-	  NSLog(@"bad bind address specification");
-	  DESTROY(self);
-	  return nil;
-	}
-      p = @"tcp";
-    }
-
-  /**
-   * A protocol fo the form 'socks-...' controls socks operation,
-   * overriding defaults and environment variables.<br />
-   * If it is just 'socks-' it turns off socks for this fiel handle.<br />
-   * Otherwise, the following text must be the name of the socks server
-   * (optionally followed by :port).
-   */
-  if ([p hasPrefix: @"socks-"] == YES)
-    {
-      shost = [p substringFromIndex: 6];
-      p = @"tcp";
-    }
-  else if (dsocks != nil)
-    {
-      shost = dsocks;	// GSSOCKS user default
-    }
-  else
-    {
-      shost = esocks;	// SOCKS_SERVER environment variable.
-    }
-
-  if (shost != nil && [shost length] > 0)
-    {
-      NSRange	r;
-
-      r = [shost rangeOfString: @":"];
-      if (r.length > 0)
-	{
-	  sport = [shost substringFromIndex: NSMaxRange(r)];
-	  shost = [shost substringToIndex: r.location];
-	}
-      else
-	{
-	  sport = @"1080";
-	}
-      p = @"tcp";
-    }
-
-  if (GSPrivateSockaddrSetup(a, 0, s, p, &sin) == NO)
-    {
-      DESTROY(self);
-      NSLog(@"bad address-service-protocol combination");
-      return nil;
-    }
-  [self setAddr: &sin];		// Store the address of the remote end.
+    GlobalSOCKSProxyConfiguration = [GSPrivateGetGlobalSOCKSProxyConfiguration() copy];
+}
 
-  /*
-   * Don't use SOCKS if we are contacting the local host.
-   */
-  if (shost != nil)
-    {
-      NSHost	*remote = [NSHost hostWithAddress: [self socketAddress]];
-      NSHost	*local = [NSHost currentHost];
+- (id)initAsClientInBackgroundAtAddress:(NSString *)anAddress
+                                service:(NSString *)aService
+                               protocol:(NSString *)aProtocol
+                               forModes:(NSArray  *)modes
+{
+    /* dirty trick: init with /dev/null and close it immediately  */
+    if (!(self = [self init])) {
+        return nil;
+    }
+    
+    if (!anAddress || ![anAddress length]) {
+        anAddress = @"localhost";
+    }
+    if (!aService) {
+        NSLog(@"bad argument - service is nil");
+        DESTROY(self);
+        return nil;
+    }
+    
+    NSDictionary *socksConfiguration = nil;
+    NSHost *host = [NSHost hostWithName:anAddress];
+    /* Don't use SOCKS if we are contacting the local host */
+    if (![host isEqualToHost:[NSHost currentHost]] && ![host isEqualToHost:[NSHost localHost]]) {
+        if ([aProtocol hasPrefix:@"socks-"]) {
+            socksConfiguration = GSPrivateParseGSSOCKS([aProtocol substringFromIndex:6]);
+        } else if (GlobalSOCKSProxyConfiguration) {
+            socksConfiguration = GlobalSOCKSProxyConfiguration;
+        }
+        if (socksConfiguration) {
+            aProtocol = @"tcp";
+        }
+    }    
+    
+    NSString *localAddress = nil;
+    NSString *localService = nil;
+    if ([aProtocol hasPrefix:@"bind-"]) {
+        localAddress = [aProtocol substringFromIndex:5];
+        
+        NSRange range = [aProtocol rangeOfString:@":"];
+        if (range.location != NSNotFound) {
+            localService = [localAddress substringFromIndex:NSMaxRange(range)];
+            localAddress = [localAddress substringToIndex:range.location];
+        }
+        
+        aProtocol = @"tcp";
+    }
+    
+    NSString *dstHost, *dstService, *notification;
+    if (socksConfiguration) {
+        dstHost = [socksConfiguration objectForKey:NSStreamSOCKSProxyHostKey];
+        dstService = [socksConfiguration objectForKey:NSStreamSOCKSProxyPortKey];
+        notification = SocksConnectNotification;
+        
+        parser = [[GSSocksParser alloc] initWithConfiguration:socksConfiguration
+                                                      address:anAddress
+                                                         port:[aService integerValue]];
+        
+        [[NSNotificationCenter defaultCenter] addObserver:self
+                                                 selector:@selector(_handleSocksNotification:)
+                                                     name:SocksConnectNotification
+                                                   object:self];
+    } else {
+        dstHost = anAddress;
+        dstService = aService;
+        notification = GSFileHandleConnectCompletionNotification;
+    }
+    
+    BOOL connected = [self _connectToService:dstService
+                                      atHost:dstHost
+                               usingProtocol:aProtocol
+                                 fromAddress:localAddress
+                                     service:localService
+                         observeNotification:notification
+                                    forModes:modes];
+    closeOnDealloc = YES;
+    if (!connected) {
+        DESTROY(self);
+        return nil;
+    }
+    return self;
+}
 
-      if ([remote isEqual: local] || [remote isEqual: [NSHost localHost]])
-        {
-	  shost = nil;
-	}
-    }
-  if (shost != nil)
-    {
-      if (GSPrivateSockaddrSetup(shost, 0, sport, p, &sin) == NO)
-	{
-	  NSLog(@"bad SOCKS host-port combination");
-	  DESTROY(self);
-	  return nil;
-	}
-    }
+- (void)_postNotificationWithSocksError:(NSError *)error
+                               userInfo:(NSDictionary *)userInfo
+{
+    NSDebugMLLog(@"NSFileHandle", @"%@ SOCKS error: %@", self, error);
+    
+    /* Error in the initial connection. Notify everybody */
+    NSMutableDictionary *info = [userInfo mutableCopy];
+    [info setObject:GSFileHandleConnectCompletionNotification forKey:NotificationKey];
+    [info setObject:[[error userInfo] objectForKey:NSLocalizedDescriptionKey] forKey:GSFileHandleNotificationError];
+    NSInteger errorCode = [error domain] == NSPOSIXErrorDomain ? [error code] : EPROTO;
+    [info setObject:[NSNumber numberWithInteger:errorCode] forKey:@"NSFileHandleError"];
+    
+    NSNotification *noification = [NSNotification notificationWithName:[info objectForKey:NotificationKey]
+                                                                object:self
+                                                              userInfo:info];
+    
+    [[NSNotificationQueue defaultQueue] enqueueNotification:noification
+                                               postingStyle:NSPostASAP
+                                               coalesceMask:NSNotificationNoCoalescing
+                                                   forModes:[info objectForKey:NSFileHandleNotificationMonitorModes]];
+    RELEASE(info);
+    readOK = NO;
+    writeOK = NO;
+}
 
-  if ((net = socket(sin.sa_family, SOCK_STREAM, PF_UNSPEC)) == -1)
-    {
-      NSLog(@"unable to create socket - %@", [NSError _last]);
-      DESTROY(self);
-      return nil;
-    }
-  /*
-   * Enable tcp-level tracking of whether connection is alive.
-   */
-  status = 1;
-  setsockopt(net, SOL_SOCKET, SO_KEEPALIVE, (char *)&status, sizeof(status));
+- (NSError *)_errorWithCode:(NSInteger)errorCode description:(NSString *)description
+{
+    NSDictionary *userInfo = [NSDictionary dictionaryWithObject:NSLocalizedString(description, nil) forKey:NSLocalizedDescriptionKey];
+    return [NSError errorWithDomain:NSPOSIXErrorDomain code:errorCode userInfo:userInfo];
+}
 
-  if (lhost != nil)
-    {
-      if (bind(net, &lsin, GSPrivateSockaddrLength(&lsin)) == -1)
-	{
-	  NSLog(@"unable to bind to port %@ - %@",
-	    GSPrivateSockaddrName(&lsin), [NSError _last]);
-	  (void) close(net);
-	  DESTROY(self);
-	  return nil;
-	}
+- (void)_handleSocksNotification:(NSNotification *)aNotification
+{
+    NSString *notificationName = [aNotification name];
+    [[NSNotificationCenter defaultCenter] removeObserver:self
+                                                    name:notificationName
+                                                  object:self];
+    
+    NSDictionary *userInfo = [aNotification userInfo];
+    NSString *error = [userInfo objectForKey:GSFileHandleNotificationError];
+    if (error) {
+        [self _postNotificationWithSocksError:[self _errorWithCode:ECONNABORTED description:error]
+                                     userInfo:userInfo];
+    }
+    
+    if (notificationName == SocksConnectNotification) { 
+        [parser setDelegate:self];
+        [parser start];
+    } else if (notificationName == SocksReadNotification) {
+        NSData *chunk = [userInfo objectForKey:NSFileHandleNotificationDataItem];
+        if (![chunk length]) {
+            [self _postNotificationWithSocksError:[self _errorWithCode:EPIPE description:@"Connection to SOCKS server has been closed prematurely"]
+                                         userInfo:userInfo];
+            return;
+        }
+        [parser parseNextChunk:chunk];
     }
+}
 
-  self = [self initWithFileDescriptor: net closeOnDealloc: YES];
-  if (self)
-    {
-      NSMutableDictionary*	info;
-
-      isSocket = YES;
-      [self setNonBlocking: YES];
-      if (connect(net, &sin, GSPrivateSockaddrLength(&sin)) == -1)
-	{
-	  if (!GSWOULDBLOCK)
-	    {
-	      NSError	*e = [NSError _last];
+- (void)parser:(GSSocksParser *)aParser needsMoreBytes:(NSUInteger)aLength
+{
+    [self readDataInBackgroundAndNotifyLength:aLength];
+    [readInfo setObject:SocksReadNotification forKey:NotificationKey];
+    
+    [[NSNotificationCenter defaultCenter] addObserver:self
+                                             selector:@selector(_handleSocksNotification:)
+                                                 name:SocksReadNotification
+                                               object:self];
+}
 
-	      NSLog(@"unable to make socket connection to %@ - %@ (%d)",
-		GSPrivateSockaddrName(&sin), e, (int)[e code]);
-	      DESTROY(self);
-	      return nil;
-	    }
-	}
+- (void)parser:(GSSocksParser *)aParser formedRequest:(NSData *)aRequest
+{
+    [self writeInBackgroundAndNotify:aRequest];
+    [[writeInfo lastObject] setObject:SocksWriteNotification forKey:NotificationKey];
+    
+    [[NSNotificationCenter defaultCenter] addObserver:self
+                                             selector:@selector(_handleSocksNotification:)
+                                                 name:SocksWriteNotification
+                                               object:self];
+}
 
-      info = [[NSMutableDictionary alloc] initWithCapacity: 4];
-      [info setObject: address forKey: NSFileHandleNotificationDataItem];
-      if (shost == nil)
-	{
-	  [info setObject: GSFileHandleConnectCompletionNotification
-		   forKey: NotificationKey];
-	}
-      else
-	{
-	  NSNotificationCenter	*nc;
+- (void)parser:(GSSocksParser *)aParser finishedWithAddress:(NSString *)anAddress port:(NSUInteger)aPort
+{
+    [parser setDelegate:nil];
+    [parser release];
+    parser = nil;
+    
+    /* Success. Notify everybody */
+    NSMutableDictionary *info = [[NSMutableDictionary alloc] initWithCapacity:4];
+    [info setObject:self forKey:NSFileHandleNotificationFileHandleItem];
+    [info setObject:address forKey:NSFileHandleNotificationDataItem];
+    [info setObject:GSFileHandleConnectCompletionNotification forKey:NotificationKey];
+    
+    [writeInfo addObject:info];
+    [self postWriteNotification];
+    RELEASE(info);
+}
 
-	  /*
-	   * If we are making a socks connection, register self as an
-	   * observer of notifications and ensure we will manage this.
-	   */
-	  nc = [NSNotificationCenter defaultCenter];
-	  [nc addObserver: self
-		 selector: @selector(_socksHandler:)
-		     name: GSSOCKSConnect
-		   object: self];
-	  [info setObject: GSSOCKSConnect
-		   forKey: NotificationKey];
-	}
-      if (modes)
-	{
-	  [info setObject: modes forKey: NSFileHandleNotificationMonitorModes];
-	}
-      [writeInfo addObject: info];
-      RELEASE(info);
-      [self watchWriteDescriptor];
-      connectOK = YES;
-      acceptOK = NO;
-      readOK = NO;
-      writeOK = NO;
-    }
-  return self;
+- (void)parser:(GSSocksParser *)aParser encounteredError:(NSError *)anError
+{
+    NSMutableDictionary *info = [[NSMutableDictionary alloc] initWithCapacity:4];
+    [self _postNotificationWithSocksError:anError userInfo:info];
+    RELEASE(info);
 }
 
 - (id) initAsServerAtAddress: (NSString*)a
@@ -1021,85 +814,14 @@ NSString * const GSSOCKSRecvAddr = @"GSSOCKSRecvAddr";
   return self;
 }
 
-- (id) initWithFileDescriptor: (int)desc closeOnDealloc: (BOOL)flag
-{
-  self = [super init];
-  if (nil == self)
-    {
-      if (YES == flag)
-	{
-	  close(desc);
-	}
-    }
-  else
-    {
-      struct stat	sbuf;
-      int		e;
-
-      if (fstat(desc, &sbuf) < 0)
-	{
-#if	defined(__MINGW__)
-	  /* On windows, an fstat will fail if the descriptor is a pipe
-	   * or socket, so we simply mark the descriptor as not being a
-	   * standard file.
-	   */
-	  isStandardFile = NO;
-#else
-	  /* This should never happen on unix.  If it does, we have somehow
-	   * ended up with a bad descriptor.
-	   */
-          NSLog(@"unable to get status of descriptor %d - %@",
-	    desc, [NSError _last]);
-	  isStandardFile = NO;
-#endif
-	}
-      else
-	{
-	  if (S_ISREG(sbuf.st_mode))
-	    {
-	      isStandardFile = YES;
-	    }
-	  else
-	    {
-	      isStandardFile = NO;
-	    }
-	}
-
-      if ((e = fcntl(desc, F_GETFL, 0)) >= 0)
-	{
-	  if (e & NBLK_OPT)
-	    {
-	      wasNonBlocking = YES;
-	    }
-	  else
-	    {
-	      wasNonBlocking = NO;
-	    }
-	}
-
-      isNonBlocking = wasNonBlocking;
-      descriptor = desc;
-      closeOnDealloc = flag;
-      readInfo = nil;
-      writeInfo = [NSMutableArray new];
-      readMax = 0;
-      writePos = 0;
-      readOK = YES;
-      writeOK = YES;
-      acceptOK = YES;
-      connectOK = YES;
-    }
-  return self;
-}
-
 - (id) initWithNativeHandle: (void*)hdl
 {
-  return [self initWithFileDescriptor: (uintptr_t)hdl closeOnDealloc: NO];
+  return [self initWithFileDescriptor: (int)hdl closeOnDealloc: NO];
 }
 
 - (id) initWithNativeHandle: (void*)hdl closeOnDealloc: (BOOL)flag
 {
-  return [self initWithFileDescriptor: (uintptr_t)hdl closeOnDealloc: flag];
+  return [self initWithFileDescriptor: (int)hdl closeOnDealloc: flag];
 }
 
 - (void) checkAccept
@@ -1211,9 +933,9 @@ NSString * const GSSOCKSRecvAddr = @"GSSOCKSRecvAddr";
 
 - (NSData*) availableData
 {
-  char			buf[READ_SIZE];
+  char buf[READ_SIZE];
   NSMutableData*	d;
-  int			len;
+  NSInteger       len;
 
   [self checkRead];
   d = [NSMutableData dataWithCapacity: 0];
@@ -1280,9 +1002,9 @@ NSString * const GSSOCKSRecvAddr = @"GSSOCKSRecvAddr";
 
 - (NSData*) readDataToEndOfFile
 {
-  char			buf[READ_SIZE];
+  char buf[READ_SIZE];
   NSMutableData*	d;
-  int			len;
+  NSInteger       len;
 
   [self checkRead];
   if (isNonBlocking == YES)
@@ -1306,8 +1028,8 @@ NSString * const GSSOCKSRecvAddr = @"GSSOCKSRecvAddr";
 - (NSData*) readDataOfLength: (unsigned)len
 {
   NSMutableData	*d;
-  int		got;
-  char		buf[READ_SIZE];
+  NSInteger     got;
+  char buf[READ_SIZE];
 
   [self checkRead];
   if (isNonBlocking == YES)
@@ -1340,10 +1062,10 @@ NSString * const GSSOCKSRecvAddr = @"GSSOCKSRecvAddr";
 
 - (void) writeData: (NSData*)item
 {
-  int		rval = 0;
+  NSInteger   rval = 0;
   const void*	ptr = [item bytes];
-  unsigned int	len = [item length];
-  unsigned int	pos = 0;
+  NSUInteger  len = [item length];
+  NSUInteger  pos = 0;
 
   [self checkWrite];
   if (isNonBlocking == YES)
@@ -1352,7 +1074,7 @@ NSString * const GSSOCKSRecvAddr = @"GSSOCKSRecvAddr";
     }
   while (pos < len)
     {
-      int	toWrite = len - pos;
+      NSUInteger toWrite = len - pos;
 
       if (toWrite > NETBUF_SIZE)
 	{
@@ -1394,8 +1116,8 @@ NSString * const GSSOCKSRecvAddr = @"GSSOCKSRecvAddr";
   [self watchReadDescriptorForModes: modes];
 }
 
-- (void) readDataInBackgroundAndNotifyLength: (unsigned)len
-				    forModes: (NSArray*)modes
+- (void) readDataInBackgroundAndNotifyLength: (NSUInteger)len
+                                    forModes: (NSArray*)modes
 {
   NSMutableData	*d;
 
@@ -1403,7 +1125,7 @@ NSString * const GSSOCKSRecvAddr = @"GSSOCKSRecvAddr";
   if (len > 0x7fffffff)
     {
       [NSException raise: NSInvalidArgumentException
-                  format: @"length (%u) too large", len];
+                  format: @"length (%lu) too large", (unsigned long)len];
     }
   readMax = len;
   RELEASE(readInfo);
@@ -1901,9 +1623,9 @@ NSString * const GSSOCKSRecvAddr = @"GSSOCKSRecvAddr";
   else
     {
       NSMutableData	*item;
-      int		length;
-      int		received = 0;
-      char		buf[READ_SIZE];
+      NSInteger     length;
+      NSInteger     received = 0;
+      char buf[READ_SIZE];
 
       item = [readInfo objectForKey: NSFileHandleNotificationDataItem];
       /*
@@ -1959,7 +1681,7 @@ NSString * const GSSOCKSRecvAddr = @"GSSOCKSRecvAddr";
   info = [writeInfo objectAtIndex: 0];
   operation = [info objectForKey: NotificationKey];
   if (operation == GSFileHandleConnectCompletionNotification
-    || operation == GSSOCKSConnect)
+    || operation == SocksConnectNotification)
     { // Connection attempt completed.
       int	result;
       int	rval;
@@ -1992,16 +1714,16 @@ NSString * const GSSOCKSRecvAddr = @"GSSOCKSRecvAddr";
     }
   else
     {
-      NSData	*item;
-      int		length;
-      const void	*ptr;
+      NSData      *item;
+      NSInteger   length;
+      const void  *ptr;
 
       item = [info objectForKey: NSFileHandleNotificationDataItem];
       length = [item length];
       ptr = [item bytes];
       if (writePos < length)
         {
-          int	written;
+          NSInteger	written;
 
           written = [self write: (char*)ptr+writePos
     		     length: length-writePos];
diff --git a/Source/GSFormat.m b/Source/GSFormat.m
index be710bd..30d0c8c 100644
--- a/Source/GSFormat.m
+++ b/Source/GSFormat.m
@@ -111,8 +111,8 @@ typedef unsigned long long uintmax_t;
 
 struct printf_info
 {
-  int prec;			/* Precision.  */
-  int width;			/* Width.  */
+  NSInteger prec;			/* Precision.  */
+  NSInteger width;			/* Width.  */
   unichar spec;			/* Format letter.  */
   unsigned int is_long_double:1;/* L flag.  */
   unsigned int is_short:1;	/* h flag.  */
@@ -291,7 +291,7 @@ _itowa_word (unsigned long value, unichar *buflim,
 
 #define PAD(Padchar) \
   { \
-    int w = width; \
+    NSInteger w = width; \
     while (w-- > 0) outchar(Padchar); \
   }
 
@@ -347,23 +347,23 @@ _i18n_number_rewrite (unichar *w, unichar *rear_ptr, NSString *locale_digits)
 
 
 struct printf_spec
-  {
+{
     /* Information parsed from the format spec.  */
     struct printf_info info;
-
+    
     /* Pointers into the format string for the end of this format
-       spec and the next (or to the end of the string if no more).  */
+     spec and the next (or to the end of the string if no more).  */
     const unichar *end_of_fmt, *next_fmt;
-
+    
     /* Position of arguments for precision and width, or -1 if `info' has
-       the constant value.  */
-    int prec_arg, width_arg;
-
-    int data_arg;		/* Position of data argument.  */
-    int data_arg_type;		/* Type of first argument.  */
+     the constant value.  */
+    NSInteger prec_arg, width_arg;
+    
+    size_t      ndata_args;
+    NSUInteger  data_arg;		/* Position of data argument.  */
+    int         data_arg_type;		/* Type of first argument.  */
     /* Number of arguments consumed by this format specifier.  */
-    size_t ndata_args;
-  };
+};
 
 
 /* The various kinds off arguments that can be passed to printf.  */
@@ -1104,8 +1104,8 @@ NSDictionary *locale)
 	int is_short = specs[nspecs_done].info.is_short;
 	int is_char = specs[nspecs_done].info.is_char;
 	int is_long = specs[nspecs_done].info.is_long;
-	int width = specs[nspecs_done].info.width;
-	int prec = specs[nspecs_done].info.prec;
+	NSInteger width = specs[nspecs_done].info.width;
+	NSInteger prec = specs[nspecs_done].info.prec;
 	int use_outdigits = specs[nspecs_done].info.i18n;
 	char pad = specs[nspecs_done].info.pad;
 	unichar spec = specs[nspecs_done].info.spec;
@@ -1396,7 +1396,7 @@ NSDictionary *locale)
 
 	  if (prec > 0)
 	    {
-	      int temp = width;
+	      NSInteger temp = width;
 	      width = prec;
 	      PAD ('0');
 	      width = temp;
@@ -1507,8 +1507,8 @@ NSDictionary *locale)
 	  {
 	    if (*bp == '\033')
 	      {
-		int	i = 0;
-		int	c = [decimal_sep length];
+		NSUInteger	i = 0;
+		NSUInteger	c = [decimal_sep length];
 		unichar	b[c];
 
 		[decimal_sep getCharacters: b];
@@ -1625,8 +1625,8 @@ NSDictionary *locale)
 	  {
 	    if (*bp == '\033')
 	      {
-		int	i = 0;
-		int	c = [decimal_sep length];
+		NSUInteger	i = 0;
+		NSUInteger	c = [decimal_sep length];
 		unichar	b[c];
 
 		[decimal_sep getCharacters: b];
@@ -1747,10 +1747,10 @@ NSDictionary *locale)
 	  {
 	    /* This is complicated.  We have to transform the multibyte
 	       string into a unicode string.  */
-	    const char			*str = (const char*)string;
-	    unsigned			blen;
-	    static NSStringEncoding	enc = GSUndefinedEncoding;
-	    static BOOL			byteEncoding = NO;
+	    const char                  *str = (const char*)string;
+	    NSUInteger                  blen;
+	    static NSStringEncoding     enc = GSUndefinedEncoding;
+	    static BOOL                 byteEncoding = NO;
 
 	    if (enc == GSUndefinedEncoding)
 	      {
@@ -1818,7 +1818,7 @@ NSDictionary *locale)
 	else
 	  {
 	    /* This is simple.  Wide string == unicode string.  */
-	    int prc;
+	    NSInteger prc;
 	    unichar *wsp;
 
 	    len = 0;
diff --git a/Source/GSHTTPAuthentication.m b/Source/GSHTTPAuthentication.m
index 659c1f5..f3bd004 100644
--- a/Source/GSHTTPAuthentication.m
+++ b/Source/GSHTTPAuthentication.m
@@ -47,15 +47,15 @@ static GSMimeParser		*mimeParser = nil;
 @implementation NSData(GSHTTPDigest)
 - (NSString*) digestHex
 {
-  static const char	*hexChars = "0123456789abcdef";
-  unsigned		slen = [self length];
-  unsigned		dlen = slen * 2;
+  static const char   *hexChars = "0123456789abcdef";
+  NSUInteger          slen = [self length];
+  NSUInteger          dlen = slen * 2;
   const unsigned char	*src = (const unsigned char *)[self bytes];
-  char			*dst;
-  unsigned		spos = 0;
-  unsigned		dpos = 0;
-  NSData		*data;
-  NSString		*string;
+  char                *dst;
+  NSUInteger          spos = 0;
+  NSUInteger          dpos = 0;
+  NSData              *data;
+  NSString            *string;
 
 #if	GS_WITH_GC
   dst = (char*)NSAllocateCollectable(dlen, 0);
@@ -268,7 +268,7 @@ static GSMimeParser		*mimeParser = nil;
       NSString		*found = nil;
       NSDictionary	*sDict;
       NSArray		*keys;
-      unsigned		count;
+      NSUInteger		count;
       NSString		*path;
 
       sDict = [domainMap objectForKey: server];
@@ -278,7 +278,7 @@ static GSMimeParser		*mimeParser = nil;
       while (count-- > 0)
 	{
 	  NSString	*key = [keys objectAtIndex: count];
-	  unsigned	kl = [key length];
+	  NSUInteger	kl = [key length];
 
 	  if (found == nil || kl > [found length])
 	    {
diff --git a/Source/GSHTTPURLHandle.m b/Source/GSHTTPURLHandle.m
index e7a2753..d9efed1 100644
--- a/Source/GSHTTPURLHandle.m
+++ b/Source/GSHTTPURLHandle.m
@@ -118,7 +118,7 @@ static NSString	*httpVersion = @"1.1";
   NSMapTable            *wProperties;
   NSData		*wData;
   NSMutableDictionary   *request;
-  unsigned int          bodyPos;
+  NSUInteger          bodyPos;
   unsigned int		redirects;
   enum {
     idle,
@@ -409,7 +409,7 @@ debugWrite(GSHTTPURLHandle *handle, NSData *data)
   if ((id)NSMapGet(wProperties, (void*)@"Content-Length") == nil)
     {
       NSMapInsert(wProperties, (void*)@"Content-Length",
-        (void*)[NSString stringWithFormat: @"%d", [wData length]]);
+        (void*)[NSString stringWithFormat: @"%lu", (unsigned long)[wData length]]);
     }
 
   if ([wData length] > 0)
@@ -532,7 +532,7 @@ debugWrite(GSHTTPURLHandle *handle, NSData *data)
   NSDictionary		*dict = [not userInfo];
   NSData		*d;
   NSRange		r;
-  unsigned		readCount;
+  NSUInteger    readCount;
 
   IF_NO_GC([self retain];)
 
@@ -1352,7 +1352,7 @@ debugWrite(GSHTTPURLHandle *handle, NSData *data)
 	}
       if (fd >= 0)
         {
-	  int		result;
+	  ssize_t		result;
 	  unsigned char	c;
 
 #if     !defined(MSG_DONTWAIT)
diff --git a/Source/GSICUString.m b/Source/GSICUString.m
index 201557d..15f4e30 100644
--- a/Source/GSICUString.m
+++ b/Source/GSICUString.m
@@ -48,7 +48,7 @@ UTextNSStringNativeLength(UText *ut)
  * Loads a group of characters into the buffer that can be directly accessed by
  * users of the UText.  This is used for iteration but UText users.
  */
-UBool
+static UBool
 UTextNSStringAccess(UText *ut, int64_t nativeIndex, UBool forward)
 {
   NSString	*str = (NSString*)ut->p;
@@ -65,7 +65,7 @@ UTextNSStringAccess(UText *ut, int64_t nativeIndex, UBool forward)
   if (nativeIndex >= ut->chunkNativeStart
     && nativeIndex < (ut->chunkNativeStart + ut->chunkLength))
     {
-      ut->chunkOffset = nativeIndex - ut->chunkNativeStart;
+      ut->chunkOffset = (int32_t)(nativeIndex - ut->chunkNativeStart);
       return TRUE;
     }
   r = NSMakeRange(nativeIndex, chunkSize);
@@ -93,7 +93,7 @@ UTextNSStringAccess(UText *ut, int64_t nativeIndex, UBool forward)
   [str getCharacters: ut->pExtra range: r];
   ut->chunkNativeStart = r.location;
   ut->chunkNativeLimit = r.location + r.length;
-  ut->chunkLength = r.length;
+  ut->chunkLength = (int32_t)r.length;
   ut->chunkOffset = 0;
   return TRUE;
 }
@@ -146,12 +146,13 @@ UTextNSMutableStringReplace(UText *ut,
  */
 static int32_t
 UTextNSStringExtract(UText *ut,
-  int64_t nativeStart,
-  int64_t nativeLimit,
-  UChar *dest,
-  int32_t destCapacity,
-  UErrorCode *status)
+                     int64_t nativeStart,
+                     int64_t nativeLimit,
+                     UChar *dest,
+                     int32_t destCapacity,
+                     UErrorCode *status)
 {
+  NSCParameterAssert(nativeLimit - nativeStart < INT32_MAX);
   NSString	*str;
   NSUInteger	length;
   NSRange	r;
@@ -161,7 +162,7 @@ UTextNSStringExtract(UText *ut,
    */
   if (destCapacity == 0)
     {
-      return nativeLimit - nativeStart;
+      return (int32_t)(nativeLimit - nativeStart);
     }
   str = (NSString*)ut->p;
   length = [str length];
@@ -179,18 +180,19 @@ UTextNSStringExtract(UText *ut,
     {
       dest[r.length] = 0;
     }
-  return r.length;
+  return (int32_t)r.length;
 }
 
 /**
  * Copy or move some characters within a UText.
  */
-void UTextNSStringCopy(UText *ut,
-  int64_t nativeStart,
-  int64_t nativeLimit,
-  int64_t nativeDest,
-  UBool move,
-  UErrorCode *status)
+static void 
+UTextNSStringCopy(UText *ut,
+                  int64_t nativeStart,
+                  int64_t nativeLimit,
+                  int64_t nativeDest,
+                  UBool move,
+                  UErrorCode *status)
 {
   NSMutableString	*str = (NSMutableString*)ut->p;
   NSUInteger		length = [str length];
@@ -238,11 +240,11 @@ UTextNStringClose(UText *ut)
  * Typically, this should not actually copy the underlying storage, because it
  * is immutable.
  */
-UText*
+static UText*
 UTextNSStringClone(UText *dest,
-  const UText *src,
-  UBool deep,
-  UErrorCode *status)
+                   const UText *src,
+                   UBool deep,
+                   UErrorCode *status)
 {
   NSString	*str = (NSString*)src->p;
 
@@ -256,11 +258,11 @@ UTextNSStringClone(UText *dest,
 /**
  * Copies the UText object, optionally copying the NSMutableString.
  */
-UText*
+static UText*
 UTextNSMutableStringClone(UText *dest,
-  const UText *src,
-  UBool deep,
-  UErrorCode *status)
+                          const UText *src,
+                          UBool deep,
+                          UErrorCode *status)
 {
   NSMutableString	*str = (NSMutableString*)src->p;
   UText			*txt;
@@ -281,7 +283,7 @@ UTextNSMutableStringClone(UText *dest,
 /**
  * Returns the index of the current character in the temporary buffer.
  */
-int64_t
+static int64_t
 UTextNSStringMapOffsetToNative(const UText *ut)
 {
   return ut->chunkNativeStart + ut->chunkOffset;
@@ -393,13 +395,13 @@ UTextInitWithNSString(UText *txt, NSString *str)
 
 - (void) getCharacters: (unichar*)buffer range: (NSRange)r
 {
-  UErrorCode status = 0;
-
-  utext_extract(&txt, r.location, r.location+r.length, buffer, r.length,
-    &status);
-  if (U_FAILURE(status))
+    NSParameterAssert(r.length < INT32_MAX);
+    UErrorCode status = 0;
+    
+    utext_extract(&txt, r.location, r.location+r.length, buffer, (int32_t)r.length, &status);
+    if (U_FAILURE(status))
     {
-      _NSRangeExceptionRaise();
+        _NSRangeExceptionRaise();
     }
 }
 
@@ -436,13 +438,13 @@ UTextInitWithNSString(UText *txt, NSString *str)
 
 - (void) getCharacters: (unichar*)buffer range: (NSRange)r
 {
-  UErrorCode status = 0;
-
-  utext_extract(&txt, r.location, r.location+r.length, buffer, r.length,
-    &status);
-  if (U_FAILURE(status))
+    NSParameterAssert(r.length < INT32_MAX);
+    UErrorCode status = 0;
+    
+    utext_extract(&txt, r.location, r.location+r.length, buffer, (int32_t)r.length, &status);
+    if (U_FAILURE(status))
     {
-      _NSRangeExceptionRaise();
+        _NSRangeExceptionRaise();
     }
 }
 
@@ -451,11 +453,12 @@ UTextInitWithNSString(UText *txt, NSString *str)
 {
   NSUInteger	size = [aString length];
   UErrorCode	status = 0;
+  NSParameterAssert(size < INT32_MAX);
 
   TEMP_BUFFER(buffer, size);
   [aString getCharacters: buffer range: NSMakeRange(0, size)];
 
-  utext_replace(&txt, r.location, r.location + r.length, buffer, size, &status);
+  utext_replace(&txt, r.location, r.location + r.length, buffer, (int32_t)size, &status);
 }
 
 - (void) dealloc
diff --git a/Source/GSInvocation.h b/Source/GSInvocation.h
index 03d751b..32ce84c 100644
--- a/Source/GSInvocation.h
+++ b/Source/GSInvocation.h
@@ -27,8 +27,6 @@
 
 #include <Foundation/NSInvocation.h>
 
-@class	NSMutableData;
-
 typedef struct	{
   int		offset;
   unsigned	size;
@@ -39,6 +37,10 @@ typedef struct	{
   BOOL		isReg;
 } NSArgumentInfo;
 
+#if !defined (NeXT_RUNTIME)
+
+@class	NSMutableData;
+
 @interface NSInvocation (MacroSetup)
 - (id) initWithMethodSignature: (NSMethodSignature*)aSignature;
 @end
@@ -66,17 +68,19 @@ typedef struct	{
 - (BOOL) encodeWithDistantCoder: (NSCoder*)coder passPointers: (BOOL)passp;
 @end
 
-@interface NSMethodSignature (GNUstep)
-- (const char*) methodType;
-- (NSArgumentInfo*) methodInfo;
-@end
-
 extern void
 GSFFCallInvokeWithTargetAndImp(NSInvocation *inv, id anObject, IMP imp);
 
 extern void
 GSFFIInvokeWithTargetAndImp(NSInvocation *inv, id anObject, IMP imp);
 
+#endif /* NeXT_RUNTIME */
+
+@interface NSMethodSignature (GNUstep)
+- (const char*) methodType;
+- (NSArgumentInfo*) methodInfo;
+@end
+
 #define CLEAR_RETURN_VALUE_IF_OBJECT  do { if (_validReturn && *_inf[0].type == _C_ID) \
                                             { \
                                             RELEASE (*(id*) _retval); \
diff --git a/Source/GSMDNSNetServices.m b/Source/GSMDNSNetServices.m
index a620a50..ece554a 100644
--- a/Source/GSMDNSNetServices.m
+++ b/Source/GSMDNSNetServices.m
@@ -372,23 +372,23 @@ static void DNSSD_API
   {
     do
       {
-	if (! [self delegate])
-	  {
-	    err = NSNetServicesInvalidError;
-	    break;
-	  }
-	
-	if (browser->timer)
-	  {
-	    err = NSNetServicesActivityInProgress;
-	    break;
-	  }
-	
-	err = DNSServiceEnumerateDomains((DNSServiceRef *)&_netServiceBrowser,
-	  aFlag,
-	  browser->interfaceIndex,
-	  EnumerationCallback,
-	  self);
+        if (! [self delegate])
+          {
+            err = NSNetServicesInvalidError;
+            break;
+          }
+        
+        if (browser->timer)
+          {
+            err = NSNetServicesActivityInProgress;
+            break;
+          }
+        
+        err = DNSServiceEnumerateDomains((DNSServiceRef *)&_netServiceBrowser,
+                                         (DNSServiceFlags)aFlag,
+                                         browser->interfaceIndex,
+                                         EnumerationCallback,
+                                         self);
       }
     while (0);
   }
@@ -793,8 +793,8 @@ static void DNSSD_API
     {
       Browser	*browser;
       
-      browser = malloc(sizeof (struct _Browser));
-      memset(browser, 0, sizeof &browser);
+      browser = malloc(sizeof(struct _Browser));
+      memset(browser, 0, sizeof(struct _Browser));
       
       CREATELOCK(browser);
       
@@ -1132,111 +1132,109 @@ static void DNSSD_API
                type: (uint16_t) rrtype
           interface: (uint32_t) interfaceIndex
 {
-  Service	*service;
-  
-  INTERNALTRACE;
-  
-  service = (Service *) _reserved;
-  
-  LOCK(service);
-  {
-    NSData		*data = nil;
-    NSMutableArray	*addresses = nil;
-    struct sockaddr	*address = { 0 };
-    size_t		length = 0;
-    const unsigned char	*rd = rdata;
-    char		rdb[INET6_ADDRSTRLEN];
+    Service	*service;
     
-    memset(rdb, 0, sizeof rdb);
+    INTERNALTRACE;
     
-    addresses = [service->info objectForKey: @"Addresses"];
+    service = (Service *) _reserved;
     
-    if (nil == addresses)
-      {
-	addresses = [[NSMutableArray alloc] initWithCapacity: 1];
-      }
-    
-    switch(rrtype)
-      {
-	case kDNSServiceType_A:		// AF_INET
-	  {
-	    struct sockaddr_in	ip4;
-	    
-	    // oogly
-	    snprintf(rdb, sizeof(rdb),
-	      "%d.%d.%d.%d", rd[0], rd[1], rd[2], rd[3]);
-	    LOG(@"Found IPv4 <%s> on port %d", rdb, ntohs(service->port));
-	    
-	    length = sizeof (struct sockaddr_in);
-	    memset(&ip4, 0, length);
-	    
-	    inet_pton(AF_INET, rdb, &ip4.sin_addr);
-	    ip4.sin_family = AF_INET;
-	    ip4.sin_port = service->port;
-	    
-	    address = (struct sockaddr *) &ip4;
-	  }
-	  break;
-	
-  #if defined(AF_INET6)
-	case kDNSServiceType_AAAA:	// AF_INET6
-	case kDNSServiceType_A6:		// deprecates AAAA
-	  {
-	    struct sockaddr_in6	ip6;
-	    
-	    // Even more oogly
-	    snprintf(rdb, sizeof(rdb),
-	      "%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%x%x",
-	      rd[0], rd[1], rd[2], rd[3],
-	      rd[4], rd[5], rd[6], rd[7],
-	      rd[8], rd[9], rd[10], rd[11],
-	      rd[12], rd[13], rd[14], rd[15]);
-	    LOG(@"Found IPv6 <%s> on port %d", rdb, ntohs(service->port));
-	    
-	    length = sizeof (struct sockaddr_in6);
-	    memset(&ip6, 0, length);
-	    
-	    inet_pton(AF_INET6, rdb, &ip6.sin6_addr);
+    LOCK(service);
+    {
+        NSData		*data = nil;
+        NSMutableArray	*addresses = nil;
+        struct sockaddr	*address = { 0 };
+        size_t		length = 0;
+        const unsigned char	*rd = rdata;
+        char		rdb[INET6_ADDRSTRLEN];
+        
+        memset(rdb, 0, sizeof rdb);
+        
+        addresses = [service->info objectForKey: @"Addresses"];
+        
+        if (nil == addresses)
+        {
+            addresses = [NSMutableArray arrayWithCapacity:1];
+        }
+        
+        switch(rrtype)
+        {
+            case kDNSServiceType_A:		// AF_INET
+            {
+                struct sockaddr_in	ip4;
+                
+                // oogly
+                snprintf(rdb, sizeof(rdb),
+                         "%d.%d.%d.%d", rd[0], rd[1], rd[2], rd[3]);
+                LOG(@"Found IPv4 <%s> on port %d", rdb, ntohs(service->port));
+                
+                length = sizeof (struct sockaddr_in);
+                memset(&ip4, 0, length);
+                
+                inet_pton(AF_INET, rdb, &ip4.sin_addr);
+                ip4.sin_family = AF_INET;
+                ip4.sin_port = service->port;
+                
+                address = (struct sockaddr *) &ip4;
+            }
+                break;
+                
+#if defined(AF_INET6)
+            case kDNSServiceType_AAAA:	// AF_INET6
+            case kDNSServiceType_A6:		// deprecates AAAA
+            {
+                struct sockaddr_in6	ip6;
+                
+                // Even more oogly
+                snprintf(rdb, sizeof(rdb),
+                         "%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%x%x",
+                         rd[0], rd[1], rd[2], rd[3],
+                         rd[4], rd[5], rd[6], rd[7],
+                         rd[8], rd[9], rd[10], rd[11],
+                         rd[12], rd[13], rd[14], rd[15]);
+                LOG(@"Found IPv6 <%s> on port %d", rdb, ntohs(service->port));
+                
+                length = sizeof (struct sockaddr_in6);
+                memset(&ip6, 0, length);
+                
+                inet_pton(AF_INET6, rdb, &ip6.sin6_addr);
 #if defined(HAVE_SA_LEN)
-	    ip6.sin6_len = sizeof ip6;
+                ip6.sin6_len = sizeof ip6;
 #endif
-	    ip6.sin6_family = AF_INET6;
-	    ip6.sin6_port = service->port;
-	    ip6.sin6_flowinfo = 0;
-	    ip6.sin6_scope_id = interfaceIndex;
-	    
-	    address = (struct sockaddr *) &ip6;
-	  }
-	  break;
+                ip6.sin6_family = AF_INET6;
+                ip6.sin6_port = service->port;
+                ip6.sin6_flowinfo = 0;
+                ip6.sin6_scope_id = interfaceIndex;
+                
+                address = (struct sockaddr *) &ip6;
+            }
+                break;
 #endif /* AF_INET6 */      
-	
-	default:
-	  LOG(@"Unkown type of length <%d>", rdlen);
-	  break;
-      }
+                
+            default:
+                LOG(@"Unkown type of length <%d>", rdlen);
+                break;
+        }
+        
+        // check for duplicate entries
+        if ([self addAddress: rdb])
+        {
+            // add it
+            data = [NSData dataWithBytes: address
+                                  length: length];
+            
+            [addresses addObject: data];
+            [service->info setObject:addresses forKey:@"Addresses"];
+            
+            // notify the delegate
+            [self netServiceDidResolveAddress: self];
+            
+            // got it, so invalidate the timeout
+            [service->timeout invalidate];
+            service->timeout = nil;
+        }
+    }
     
-    // check for duplicate entries
-    if ([self addAddress: rdb])
-      {
-	// add it
-	data = [NSData dataWithBytes: address
-			      length: length];
-	
-	[addresses addObject: data];
-	[service->info setObject: [addresses retain]
-			  forKey: @"Addresses"];
-	
-	// notify the delegate
-	[self netServiceDidResolveAddress: self];
-	
-	[addresses release];
-	
-	// got it, so invalidate the timeout
-	[service->timeout invalidate];
-	service->timeout = nil;
-      }
-  }
-  UNLOCK(service);
+    UNLOCK(service);
 }
 
 /**
@@ -1480,124 +1478,123 @@ static void DNSSD_API
 
 + (NSData *) dataFromTXTRecordDictionary: (NSDictionary *) txtDictionary
 {
-  NSMutableData	*result = nil;
-  NSArray	*keys = nil;
-  NSArray	*values = nil;
-  int		count = 0;
-  
-  INTERNALTRACE;
-  
-  count = [txtDictionary count];
-  
-  if (count)
+    NSMutableData	*result = nil;
+    NSArray       *keys   = nil;
+    NSArray       *values = nil;
+    NSUInteger    count   = 0;
+    
+    INTERNALTRACE;
+    
+    count = [txtDictionary count];
+    
+    if (count)
     {
-      keys = [txtDictionary allKeys];
-      values = [txtDictionary allValues];
-      
-      if (keys && values)
-	{
-	  TXTRecordRef	txt;
-	  int		i = 0;
-	  char		key[256];
-	  
-	  TXTRecordCreate(&txt, 0, NULL);
-	  
-	  for (; i < count; i++)
-	    {
-	      int			length = 0;
-	      int			used = 0;
-	      DNSServiceErrorType err = kDNSServiceErr_Unknown;
-	      
-	      if (! [[keys objectAtIndex: i] isKindOfClass: [NSString class]])
-		{
-		  LOG(@"%@ is not a string", [keys objectAtIndex: i]);
-		  break;
-		}
-	      
-	      length = [[keys objectAtIndex: i] length];
-	      [[keys objectAtIndex: i] getCString: key
-					maxLength: sizeof key];
-	      used = strlen(key);
-	      
-	      if (! length || (used >= sizeof key))
-		{
-		  LOG(@"incorrect length %d - %d - %d",
-		    length, used, sizeof key);
-		  break;
-		}
-	      
-	      if ([[values objectAtIndex: i] isKindOfClass: [NSString class]])
-		{
-		  char	value[256];
-		  
-		  length = [[values objectAtIndex: i] length];
-		  [[values objectAtIndex: i] getCString: value
-					      maxLength: sizeof value];
-		  used = strlen(value);
-		  
-		  if (used >= sizeof value)
-		    {
-		      LOG(@"incorrect length %d - %d - %d",
-			length, used, sizeof value);
-		      break;
-		    }
-		  
-		  err = TXTRecordSetValue(&txt,
-		    (const char *) key,
-		    used,
-		    value);
-		}
-	      else if ([[values objectAtIndex: i] isKindOfClass: [NSData class]]
-		&& [[values objectAtIndex: i] length] < 256
-		&& [[values objectAtIndex: i] length] >= 0)
-		{
-		  err = TXTRecordSetValue(&txt,
-		    (const char *) key,
-		    [[values objectAtIndex: i] length],
-		    [[values objectAtIndex: i] bytes]);
-		}
-	      else if ([values objectAtIndex: i] == [NSNull null])
-		{
-		  err = TXTRecordSetValue(&txt,
-		    (const char *) key,
-		    0,
-		    NULL);
-		}
-	      else
-		{
-		  LOG(@"unknown value type");
-		  break;
-		}
-	      
-	      if (err != kDNSServiceErr_NoError)
-		{
-		  LOG(@"error creating data type");
-		  break;
-		}
-	    }
-	  
-	  if (i == count)
-	    {
-	      result = [NSData dataWithBytes: TXTRecordGetBytesPtr(&txt)
-				      length: TXTRecordGetLength(&txt)];
-	    }
-	  
-	  TXTRecordDeallocate(&txt);
-	}
-      else
-	{
-	  LOG(@"No keys or values");
-	}
-      
-      // both are autorelease'd
-      keys = nil;
-      values = nil;
+        keys = [txtDictionary allKeys];
+        values = [txtDictionary allValues];
+        
+        if (keys && values)
+        {
+            TXTRecordRef  txt;
+            NSUInteger		i = 0;
+            char          key[256];
+            
+            TXTRecordCreate(&txt, 0, NULL);
+            
+            for (; i < count; i++)
+            {
+                size_t length = 0;
+                size_t used = 0;
+                DNSServiceErrorType err = kDNSServiceErr_Unknown;
+                
+                if (![[keys objectAtIndex: i] isKindOfClass: [NSString class]])
+                {
+                    LOG(@"%@ is not a string", [keys objectAtIndex: i]);
+                    break;
+                }
+                
+                length = [[keys objectAtIndex: i] length];
+                [[keys objectAtIndex: i] getCString: key
+                                          maxLength: sizeof key];
+                used = strlen(key);
+                
+                if (!length || (used >= sizeof key))
+                {
+                    LOG(@"incorrect length %d - %d - %d",
+                        length, used, sizeof key);
+                    break;
+                }
+                
+                if ([[values objectAtIndex: i] isKindOfClass: [NSString class]])
+                {
+                    char	value[256];
+                    
+                    [[values objectAtIndex: i] getCString: value
+                                                maxLength: sizeof value];
+                    used = strlen(value);
+                    
+                    if (used >= sizeof value)
+                    {
+                        LOG(@"incorrect length %d - %d - %d",
+                            length, used, sizeof value);
+                        break;
+                    }
+                    
+                    err = TXTRecordSetValue(&txt,
+                                            (const char *) key,
+                                            used,
+                                            value);
+                }
+                else if ([[values objectAtIndex: i] isKindOfClass: [NSData class]]
+                         && [[values objectAtIndex: i] length] < 256
+                         && [[values objectAtIndex: i] length] > 0)
+                {
+                    err = TXTRecordSetValue(&txt,
+                                            (const char *) key,
+                                            [[values objectAtIndex: i] length],
+                                            [[values objectAtIndex: i] bytes]);
+                }
+                else if ([values objectAtIndex: i] == [NSNull null])
+                {
+                    err = TXTRecordSetValue(&txt,
+                                            (const char *) key,
+                                            0,
+                                            NULL);
+                }
+                else
+                {
+                    LOG(@"unknown value type");
+                    break;
+                }
+                
+                if (err != kDNSServiceErr_NoError)
+                {
+                    LOG(@"error creating data type");
+                    break;
+                }
+            }
+            
+            if (i == count)
+            {
+                result = [NSData dataWithBytes: TXTRecordGetBytesPtr(&txt)
+                                        length: TXTRecordGetLength(&txt)];
+            }
+            
+            TXTRecordDeallocate(&txt);
+        }
+        else
+        {
+            LOG(@"No keys or values");
+        }
+        
+        // both are autorelease'd
+        keys = nil;
+        values = nil;
     }
-  else
+    else
     {
-      LOG(@"Dictionary seems empty");
+        LOG(@"Dictionary seems empty");
     }
-  return result;
+    return result;
 }
 
 /**
@@ -1609,8 +1606,8 @@ static void DNSSD_API
 + (NSDictionary *) dictionaryFromTXTRecordData: (NSData *) txtData
 {
   NSMutableDictionary	*result = nil;
-  int			len = 0;
-  const void		*txt = 0;
+  NSUInteger          len   = 0;
+  const void          *txt  = 0;
   
   INTERNALTRACE;
   
@@ -1735,8 +1732,8 @@ static void DNSSD_API
     {
       Service	*service;
       
-      service = malloc(sizeof (struct _Service));
-      memset(service, 0, sizeof &service);
+      service = malloc(sizeof(struct _Service));
+      memset(service, 0, sizeof(struct _Service));
       
       CREATELOCK(service);
       
@@ -1901,12 +1898,12 @@ static void DNSSD_API
 
 - (void) publishWithOptions: (NSNetServiceOptions)options
 {
-  DNSServiceFlags flags = 0;
-  if (options & NSNetServiceNoAutoRename)
-  {
-    flags = flags | kDNSServiceFlagsNoAutoRename;
-  }
-  [self publishWithFlags: flags];
+    DNSServiceFlags flags = 0;
+    if (options & NSNetServiceNoAutoRename)
+    {
+        flags = kDNSServiceFlagsNoAutoRename;
+    }
+    [self publishWithFlags: flags];
 }
 
 - (void) publish
@@ -2472,8 +2469,8 @@ static void DNSSD_API
     {
       Monitor	*monitor;
       
-      monitor = malloc(sizeof (struct _Monitor));
-      memset(monitor, 0, sizeof &monitor);
+      monitor = malloc(sizeof(struct _Monitor));
+      memset(monitor, 0, sizeof(struct _Monitor));
       
       CREATELOCK(monitor);
       
@@ -2559,61 +2556,61 @@ static void DNSSD_API
 
 - (void) start
 {
-  Monitor	*monitor;
-  
-  INTERNALTRACE;
-  
-  monitor = (Monitor *) _reserved;
-  
-  LOCK(monitor);
-  {
-    DNSServiceErrorType	err = kDNSServiceErr_NoError;
-    DNSServiceFlags	flags = kDNSServiceFlagsLongLivedQuery;
-    NSString		*fullname = nil;
+    Monitor	*monitor;
     
-    do
-      {
-	if (! _delegate)
-	  {
-	    err = NSNetServicesInvalidError;
-	    break;
-	  }
-	
-	if (monitor->timer)
-	  {
-	    err = NSNetServicesActivityInProgress;
-	    break;
-	  }
-	
-	fullname = [NSString stringWithFormat: @"%@.%@%@",
-	  [_delegate name], [_delegate type], [_delegate domain]];
-	
-	err = DNSServiceQueryRecord((DNSServiceRef *) &_netServiceMonitor,
-	  flags,
-	  0,
-	  [fullname UTF8String],
-	  kDNSServiceType_TXT,
-	  kDNSServiceClass_IN,
-	  QueryCallback,
-	  self);
-	
-	if (kDNSServiceErr_NoError == err)
-	  {
-	    monitor->timer = [NSTimer timerWithTimeInterval: INTERVAL
-						     target: self
-						   selector: @selector(loop:)
-						   userInfo: nil
-						    repeats: YES];
-
-	    [monitor->runloop addTimer: monitor->timer
-			       forMode: monitor->runloopmode];
-	    
-	    [monitor->timer fire];
-	  }
-      }
-    while (0);
-  }
-  UNLOCK(monitor);
+    INTERNALTRACE;
+    
+    monitor = (Monitor *) _reserved;
+    
+    LOCK(monitor);
+    {
+        DNSServiceErrorType	err = kDNSServiceErr_NoError;
+        DNSServiceFlags	flags = kDNSServiceFlagsLongLivedQuery;
+        NSString		*fullname = nil;
+        
+        do
+        {
+            if (! _delegate)
+            {
+                // err = NSNetServicesInvalidError;
+                break;
+            }
+            
+            if (monitor->timer)
+            {
+                // err = NSNetServicesActivityInProgress;
+                break;
+            }
+            
+            fullname = [NSString stringWithFormat: @"%@.%@%@",
+                        [_delegate name], [_delegate type], [_delegate domain]];
+            
+            err = DNSServiceQueryRecord((DNSServiceRef *) &_netServiceMonitor,
+                                        flags,
+                                        0,
+                                        [fullname UTF8String],
+                                        kDNSServiceType_TXT,
+                                        kDNSServiceClass_IN,
+                                        QueryCallback,
+                                        self);
+            
+            if (kDNSServiceErr_NoError == err)
+            {
+                monitor->timer = [NSTimer timerWithTimeInterval: INTERVAL
+                                                         target: self
+                                                       selector: @selector(loop:)
+                                                       userInfo: nil
+                                                        repeats: YES];
+                
+                [monitor->runloop addTimer: monitor->timer
+                                   forMode: monitor->runloopmode];
+                
+                [monitor->timer fire];
+            }
+        }
+        while (0);
+    }
+    UNLOCK(monitor);
 }
 
 /**
diff --git a/Source/GSPrivate.h b/Source/GSPrivate.h
index 56c1658..46091eb 100644
--- a/Source/GSPrivate.h
+++ b/Source/GSPrivate.h
@@ -51,7 +51,7 @@
  */
 #define GREGORIAN_REFERENCE 730486
 
-NSTimeInterval   GSPrivateTimeNow() GS_ATTRIB_PRIVATE;
+NSTimeInterval   GSPrivateTimeNow(void) GS_ATTRIB_PRIVATE;
 
 #include "GNUstepBase/GSObjCRuntime.h"
 
@@ -65,19 +65,19 @@ typedef struct objc_category* Category;
 @interface GSArray : NSArray
 {
 @public
-  id		*_contents_array;
-  unsigned	_count;
+  id          *_contents_array;
+  NSUInteger  _count;
 }
 @end
 
 @interface GSMutableArray : NSMutableArray
 {
 @public
-  id		*_contents_array;
-  unsigned	_count;
-  unsigned	_capacity;
-  int		_grow_factor;
-  unsigned long		_version;
+  id              *_contents_array;
+  NSUInteger      _count;
+  NSUInteger      _capacity;
+  NSUInteger      _grow_factor;
+  unsigned long   _version;
 }
 @end
 
@@ -165,11 +165,12 @@ __attribute__((unused)) static void GSFreeTempBuffer(void **b)
  * Yet the optimization of the stored hash value is currently deemed
  * more important.
  */
-#define GS_REPLACE_CONSTANT_STRING(ID) [(ID = [NSObject \
-  leak: [[NSString alloc] initWithUTF8String: [ID UTF8String]]]) release]
-/* Using cString here is OK here
-   because NXConstantString returns a pointer
-   to it's internal pointer.  */
+#define GS_REPLACE_CONSTANT_STRING(string)                                  \
+do {                                                                        \
+    id copy = [[NSString alloc] initWithUTF8String:[string UTF8String]];    \
+    string = [NSObject leak:copy];                                          \
+    [copy release];                                                         \
+} while (0)
 
 /*
  * Type to hold either UTF-16 (unichar) or 8-bit encodings,
@@ -182,17 +183,12 @@ typedef union {
 
 /*
  * Private concrete string classes.
- * NB. All these concrete string classes MUST have the same initial ivar
- * layout so that we can swap between them as necessary.
- * The initial layout must also match that of NXConstantString (which is
- * determined by the compiler) - an initial pointer to the string data
- * followed by the string length (number of characters).
  */
 @interface GSString : NSString
 {
 @public
   GSCharPtr _contents;
-  unsigned int	_count;
+  NSUInteger	_count;
   struct {
     unsigned int	wide: 1;	// 16-bit characters in string?
     unsigned int	owned: 1;	// Set if the instance owns the
@@ -211,14 +207,14 @@ typedef union {
 {
 @public
   GSCharPtr _contents;
-  unsigned int	_count;
+  NSUInteger	_count;
   struct {
     unsigned int	wide: 1;
     unsigned int	owned: 1;
     unsigned int	unused: 2;
     unsigned int	hash: 28;
   } _flags;
-  unsigned int	_capacity;
+  NSUInteger	_capacity;
   NSZone	*_zone;
 }
 @end
@@ -248,8 +244,8 @@ typedef enum {
 @interface	_NSKeyedCoderOldStyleArray : NSObject <NSCoding>
 {
   char		_t[2];
-  unsigned	_c;
-  unsigned	_s;
+  NSUInteger	_c;
+  NSUInteger	_s;
   const void	*_a;
   NSData	*_d;	// Only valid after initWithCoder:
 }
@@ -266,7 +262,7 @@ typedef enum {
  */
 @interface	NSError (GNUstepBase)
 + (NSError*) _last;
-+ (NSError*) _systemError: (long)number;
++ (NSError*) _systemError: (int)number;
 @end
 
 @class  NSRunLoop;
@@ -313,12 +309,12 @@ GSRunLoopInfoForThread(NSThread *aThread) GS_ATTRIB_PRIVATE;
  * methods/functions which might cause a recursive exception.
  */
 const char*
-GSPrivateArgZero() GS_ATTRIB_PRIVATE;
+GSPrivateArgZero(void) GS_ATTRIB_PRIVATE;
 
 /* get the available string encodings (nul terminated array)
  */
 NSStringEncoding *
-GSPrivateAvailableEncodings() GS_ATTRIB_PRIVATE;
+GSPrivateAvailableEncodings(void);// GS_ATTRIB_PRIVATE;
 
 /* Initialise constant strings
  */
@@ -333,13 +329,13 @@ GSPrivateCheckTasks(void) GS_ATTRIB_PRIVATE;
 /* get the default C-string encoding.
  */
 NSStringEncoding
-GSPrivateDefaultCStringEncoding() GS_ATTRIB_PRIVATE;
+GSPrivateDefaultCStringEncoding(void);// GS_ATTRIB_PRIVATE;
 
 /* Get default locale quickly (usually from cache).
  * External apps would cache the locale themselves.
  */
 NSDictionary *
-GSPrivateDefaultLocale() GS_ATTRIB_PRIVATE;
+GSPrivateDefaultLocale(void) GS_ATTRIB_PRIVATE;
 
 /* Get one of several standard values.
  */
@@ -349,7 +345,7 @@ GSPrivateDefaultsFlag(GSUserDefaultFlagType type) GS_ATTRIB_PRIVATE;
 /* get the name of a string encoding as an NSString.
  */
 NSString *
-GSPrivateEncodingName(NSStringEncoding encoding) GS_ATTRIB_PRIVATE;
+GSPrivateEncodingName(NSStringEncoding encoding);// GS_ATTRIB_PRIVATE;
 
 /* get a flag from an environment variable - return def if not defined.
  */
@@ -371,12 +367,12 @@ GSPrivateFormat(GSStr fb, const unichar *fmt, va_list ap, NSDictionary *loc)
  * generally be represented as 8-bit characters including ascii.
  */
 BOOL
-GSPrivateIsByteEncoding(NSStringEncoding encoding) GS_ATTRIB_PRIVATE;
+GSPrivateIsByteEncoding(NSStringEncoding encoding);// GS_ATTRIB_PRIVATE;
 
 /* determine whether encoding is currently supported.
  */
 BOOL
-GSPrivateIsEncodingSupported(NSStringEncoding encoding) GS_ATTRIB_PRIVATE;
+GSPrivateIsEncodingSupported(NSStringEncoding encoding);// GS_ATTRIB_PRIVATE;
 
 /* load a module into the runtime
  */
@@ -390,7 +386,7 @@ GSPrivateLoadModule(NSString *filename, FILE *errorStream,
  * if the latter has bewen set via an environment variable.
  */
 NSStringEncoding
-GSPrivateNativeCStringEncoding() GS_ATTRIB_PRIVATE;
+GSPrivateNativeCStringEncoding(void);// GS_ATTRIB_PRIVATE;
 
 /* Function used by the NSRunLoop and friends for processing
  * queued notifications which should be processed at the first safe moment.
@@ -409,7 +405,7 @@ BOOL GSPrivateNotifyMore(NSString *mode) GS_ATTRIB_PRIVATE;
 
 /* Function to return the function for searching in a string for a range.
  */
-typedef NSRange (*GSRSFunc)(id, id, unsigned, NSRange);
+typedef NSRange (*GSRSFunc)(id, id, NSUInteger, NSRange);
 GSRSFunc
 GSPrivateRangeOfString(NSString *receiver, NSString *target) GS_ATTRIB_PRIVATE;
 
@@ -426,7 +422,7 @@ GSPrivateSmallHash(int n) GS_ATTRIB_PRIVATE;
 /* Function to append data to an GSStr
  */
 void
-GSPrivateStrAppendUnichars(GSStr s, const unichar *u, unsigned l)
+GSPrivateStrAppendUnichars(GSStr s, const unichar *u, NSUInteger l)
   GS_ATTRIB_PRIVATE;
 
 /* Make the content of this string into unicode if it is not in
@@ -485,7 +481,7 @@ GSPrivateSymbolPath (Class theClass, Category *theCategory) GS_ATTRIB_PRIVATE;
 /* Combining class for composite unichars
  */
 unsigned char
-GSPrivateUniCop(unichar u) GS_ATTRIB_PRIVATE;
+GSPrivateUniCop(unichar u);// GS_ATTRIB_PRIVATE;
 
 /* unload a module from the runtime (not implemented)
  */
@@ -498,7 +494,7 @@ GSPrivateUnloadModule(FILE *errorStream,
  */
 @interface      GSCodeBuffer : NSObject
 {
-  unsigned      size;
+  NSUInteger      size;
   void          *buffer;
   void		*executable;
   id            frame;
@@ -517,28 +513,47 @@ GSPrivateIsCollectable(const void *ptr) GS_ATTRIB_PRIVATE;
 NSZone*
 GSAtomicMallocZone (void);
 
+void
+GSBreakTime(NSTimeInterval when, NSInteger*year, NSInteger*month, NSInteger*day,
+            NSInteger*hour, NSInteger*minute, NSInteger*second, NSInteger*mil);
+
+const char*
+GSPathHandling(const char *mode);
+
+void
+GSPropertyListMake(id obj, NSDictionary *loc, BOOL xml,
+                   BOOL forDescription, unsigned step, id *str);
+
+id
+GSPropertyListFromStringsFormat(NSString *string);
+
+BOOL
+GSScanDouble(unichar *buffer, NSUInteger length, double *result);
+
 /* Generate a 32bit hash from supplied byte data.
  */
 uint32_t
-GSPrivateHash(uint32_t seed, const void *bytes, int length)
-  GS_ATTRIB_PRIVATE;
+GSPrivateHash(uint32_t seed, const void *bytes, NSUInteger length) GS_ATTRIB_PRIVATE;
 
-/* Incorporate 'l' bytes of data from the buffer pointed to by 'b' into
+/* Incorporate 'length' bytes of data from the buffer pointed to by 'bytes' into
  * the hash state information pointed to by p0 and p1.
  * The hash state variables should have been initialised to zero before
  * the first call to this function, and the result should be produced
  * by calling the GSPrivateFinishHash() function.
  */
 void
-GSPrivateIncrementalHash(uint32_t *p0, uint32_t *p1, const void *b, int l)
-  GS_ATTRIB_PRIVATE;
+GSPrivateIncrementalHash(uint32_t *p0, uint32_t *p1, const void *bytes, NSUInteger length) GS_ATTRIB_PRIVATE;
 
 /* Generate a 32bit hash from supplied state variables resulting from
  * calls to the GSPrivateIncrementalHash() function.
  */
 uint32_t
-GSPrivateFinishHash(uint32_t s0, uint32_t s1, uint32_t totalLength)
-  GS_ATTRIB_PRIVATE;
+GSPrivateFinishHash(uint32_t s0, uint32_t s1, NSUInteger totalLength) GS_ATTRIB_PRIVATE;
 
-#endif /* _GSPrivate_h_ */
+NSDictionary *
+GSPrivateParseGSSOCKS(NSString *gsSocks) GS_ATTRIB_PRIVATE;
+
+NSDictionary *
+GSPrivateGetGlobalSOCKSProxyConfiguration(void) GS_ATTRIB_PRIVATE;
 
+#endif /* _GSPrivate_h_ */
diff --git a/Source/GSPrivateHash.m b/Source/GSPrivateHash.m
index 4a08590..528dcc1 100644
--- a/Source/GSPrivateHash.m
+++ b/Source/GSPrivateHash.m
@@ -24,7 +24,7 @@
 #import "GSPrivate.h"
 
 uint32_t
-GSPrivateHash(uint32_t seed, const void *bytes, int length)
+GSPrivateHash(uint32_t seed, const void *bytes, NSUInteger length)
 {
   uint32_t      carry = 0;
 
@@ -41,18 +41,18 @@ GSPrivateHash(uint32_t seed, const void *bytes, int length)
 /* Very fast, simple hash.  Poor distribution properties though.
  */
 void
-GSPrivateIncrementalHash(uint32_t *p0, uint32_t *p1, const void *b, int l)
+GSPrivateIncrementalHash(uint32_t *p0, uint32_t *p1, const void *bytes, NSUInteger length)
 {
-  unsigned   i;
+  NSUInteger   index;
 
-  for (i = 0; i < l; i++)
+  for (index = 0; index < length; index++)
     {
-      *p0 = (*p0 << 5) + *p0 + ((const uint8_t*)b)[i];
+      *p0 = (*p0 << 5) + *p0 + ((const uint8_t*)bytes)[index];
     }
 }
 
 uint32_t
-GSPrivateFinishHash(uint32_t s0, uint32_t s1, uint32_t totalLength)
+GSPrivateFinishHash(uint32_t s0, uint32_t s1, NSUInteger totalLength)
 {
   return s0;
 }
diff --git a/Source/GSRunLoopCtxt.h b/Source/GSRunLoopCtxt.h
index 3d5e530..0f39a0c 100644
--- a/Source/GSRunLoopCtxt.h
+++ b/Source/GSRunLoopCtxt.h
@@ -62,11 +62,11 @@ typedef struct{
   void		*extra;		/** Copy of the RunLoop ivar.		*/
   NSString	*mode;		/** The mode for this context.		*/
   GSIArray	performers;	/** The actions to perform regularly.	*/
-  unsigned	maxPerformers;
+  NSUInteger	maxPerformers;
   GSIArray	timers;		/** The timers set for the runloop mode */
-  unsigned	maxTimers;
+  NSUInteger	maxTimers;
   GSIArray	watchers;	/** The inputs set for the runloop mode */
-  unsigned	maxWatchers;
+  NSUInteger	maxWatchers;
   NSTimer	*housekeeper;	/** Housekeeping timer for loop.	*/
 @private
 #if	defined(__MINGW__)
@@ -80,7 +80,7 @@ typedef struct{
   GSIArray	_trigger;	// Watchers to trigger unconditionally.
   int		fairStart;	// For trying to ensure fair handling.
   BOOL		completed;	// To mark operation as completed.
-#ifdef	HAVE_POLL
+#if defined(HAVE_POLL)
   unsigned int	pollfds_capacity;
   unsigned int	pollfds_count;
   struct pollfd	*pollfds;
diff --git a/Source/GSSet.m b/Source/GSSet.m
index b1807f0..ae6c16f 100644
--- a/Source/GSSet.m
+++ b/Source/GSSet.m
@@ -199,7 +199,7 @@ static Class	mutableSetClass;
     }
   else
     {
-      unsigned		count = map.nodeCount;
+      NSUInteger    count = map.nodeCount;
       SEL			sel = @selector(encodeObject:);
       IMP			imp = [aCoder methodForSelector: sel];
       GSIMapEnumerator_t	enumerator = GSIMapEnumeratorForMap(&map);
@@ -245,7 +245,8 @@ static Class	mutableSetClass;
       while (count-- > 0)
         {
 	  (*imp)(aCoder, sel, type, &value);
-	  GSIMapAddKeyNoRetain(&map, (GSIMapKey)value);
+	  GSIMapAddKey(&map, (GSIMapKey)value);
+            [value release];
 	}
     }
   return self;
@@ -701,7 +702,7 @@ static Class	mutableSetClass;
     }
 }
 
-- (id) makeImmutableCopyOnFail: (BOOL)force
+- (id) makeImmutable
 {
   GSClassSwizzle(self, [GSSet class]);
   return self;
diff --git a/Source/GSShellSort.m b/Source/GSShellSort.m
index 2e523fa..a8339b4 100644
--- a/Source/GSShellSort.m
+++ b/Source/GSShellSort.m
@@ -31,7 +31,7 @@
 #import "GSSorting.h"
 
 #if GS_USE_SHELLSORT
-void
+static void
 _GSShellSort(id *objects,
   NSRange sortRange,
   id comparisonEntity,
diff --git a/Source/GSSocketStream.m b/Source/GSSocketStream.m
index a72e4ad..04228e1 100644
--- a/Source/GSSocketStream.m
+++ b/Source/GSSocketStream.m
@@ -40,6 +40,7 @@
 #import "GSPrivate.h"
 #import "GSStream.h"
 #import "GSSocketStream.h"
+#import "GSSocksParser/GSSocksParser.h"
 #import "GNUstepBase/NSObject+GNUstepBase.h"
 
 #import "GSTLS.h"
@@ -66,7 +67,7 @@ GSPrivateSockaddrLength(struct sockaddr *addr)
 {
   switch (addr->sa_family) {
     case AF_INET:       return sizeof(struct sockaddr_in);
-#ifdef	AF_INET6
+#ifdef AF_INET6
     case AF_INET6:      return sizeof(struct sockaddr_in6);
 #endif
 #ifndef	__MINGW__
@@ -81,7 +82,7 @@ GSPrivateSockaddrHost(struct sockaddr *addr)
 {
   char		buf[40];
 
-#if     defined(AF_INET6)
+#if defined(AF_INET6)
   if (AF_INET6 == addr->sa_family)
     {
       struct sockaddr_in6	*addr6 = (struct sockaddr_in6*)(void*)addr;
@@ -108,7 +109,7 @@ GSPrivateSockaddrPort(struct sockaddr *addr)
 {
   uint16_t	port;
 
-#if     defined(AF_INET6)
+#if defined(AF_INET6)
   if (AF_INET6 == addr->sa_family)
     {
       struct sockaddr_in6	*addr6 = (struct sockaddr_in6*)(void*)addr;
@@ -161,7 +162,7 @@ GSPrivateSockaddrSetup(NSString *machine, uint16_t port,
 	}
       else
 	{
-#if     defined(AF_INET6)
+#if defined(AF_INET6)
 	  struct sockaddr_in6	*addr6 = (struct sockaddr_in6*)(void*)sin;
 
 	  sin->sa_family = AF_INET6;
@@ -214,7 +215,7 @@ GSPrivateSockaddrSetup(NSString *machine, uint16_t port,
 	    }
 	  else if (strcmp(ptr, "gdomap") == 0)
 	    {
-#ifdef	GDOMAP_PORT_OVERRIDE
+#ifdef GDOMAP_PORT_OVERRIDE
 	      port = GDOMAP_PORT_OVERRIDE;
 #else
 	      port = 538;	// IANA allocated port
@@ -231,7 +232,7 @@ GSPrivateSockaddrSetup(NSString *machine, uint16_t port,
 	}
     }
 
-#if     defined(AF_INET6)
+#if defined(AF_INET6)
   if (AF_INET6 == sin->sa_family)
     {
       ((struct sockaddr_in6*)(void*)sin)->sin6_port = GSSwapHostI16ToBig(port);
@@ -246,6 +247,66 @@ GSPrivateSockaddrSetup(NSString *machine, uint16_t port,
   return YES;
 }
 
+NS_INLINE void 
+SetObjectForKey(NSMutableDictionary *dictionary, id object, id key)
+{
+    if (object) {
+        [dictionary setObject:object forKey:key];
+    }
+}
+
+NSDictionary *
+GSPrivateParseGSSOCKS(NSString *gsSocks)
+{
+    if (!gsSocks && ![gsSocks length]) {
+        return nil;
+    }
+    NSString *socksHost = gsSocks;
+    NSString *socksPort = nil;
+    NSString *socksUser = nil;
+    NSString *socksPass = nil;
+    
+    NSRange range = [socksHost rangeOfString:@"@"];
+    if (range.location != NSNotFound) {
+        socksUser = [socksHost substringToIndex:range.location];
+        socksHost = [socksHost substringFromIndex:NSMaxRange(range)];
+        range = [socksUser rangeOfString:@":"];
+        if (range.location != NSNotFound) {
+            socksPass = [socksUser substringFromIndex:NSMaxRange(range)];
+            socksUser = [socksUser substringToIndex:range.location];
+        }
+    }
+    range = [socksHost rangeOfString:@":"];
+    if (range.location != NSNotFound) {
+        socksPort = [socksHost substringFromIndex:NSMaxRange(range)];
+        socksHost = [socksHost substringToIndex:range.location];
+    } else
+        socksPort = @"1080";
+    
+    NSMutableDictionary *result = [NSMutableDictionary dictionaryWithCapacity:5];
+    SetObjectForKey(result, socksHost, NSStreamSOCKSProxyHostKey);
+    SetObjectForKey(result, socksPort, NSStreamSOCKSProxyPortKey);
+    SetObjectForKey(result, socksUser, NSStreamSOCKSProxyUserKey);
+    SetObjectForKey(result, socksPass, NSStreamSOCKSProxyPasswordKey);
+    SetObjectForKey(result, NSStreamSOCKSProxyVersion5, NSStreamSOCKSProxyVersionKey);
+    return result;
+}
+
+NSDictionary *
+GSPrivateGetGlobalSOCKSProxyConfiguration()
+{
+    NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];
+    NSString *gsSocks = [defaults stringForKey:@"GSSOCKS"];
+    if (!gsSocks) {
+        NSDictionary *environment = [[NSProcessInfo processInfo] environment];
+        gsSocks = [environment objectForKey:@"SOCKS5_SERVER"];
+        if (!gsSocks) {
+            gsSocks = [environment objectForKey:@"SOCKS_SERVER"];
+        }
+    }
+    return GSPrivateParseGSSOCKS(gsSocks);
+}
+
 /** The GSStreamHandler abstract class defines the methods used to
  * implement a handler object for a pair of streams.
  * The idea is that the handler is installed once the connection is
@@ -259,7 +320,7 @@ GSPrivateSockaddrSetup(NSString *machine, uint16_t port,
  * -_read:maxLength: and _write:maxLength: methods instead of the public
  * methods).
  */
-@interface      GSStreamHandler : NSObject
+@interface GSStreamHandler : NSObject
 {
   GSSocketInputStream   *istream;	// Not retained
   GSSocketOutputStream  *ostream;       // Not retained
@@ -348,9 +409,9 @@ GSPrivateSockaddrSetup(NSString *machine, uint16_t port,
 
 @end
 
-#if     defined(HAVE_GNUTLS)
+#if defined(HAVE_GNUTLS)
 
-@interface      GSTLSHandler : GSStreamHandler
+@interface GSTLSHandler : GSStreamHandler
 {
 @public
   GSTLSSession  *session;
@@ -369,7 +430,7 @@ GSTLSPull(gnutls_transport_ptr_t handle, void *buffer, size_t len)
   result = [[tls istream] _read: buffer maxLength: len];
   if (result < 0)
     {
-      int       e;
+      NSInteger       e;
 
       if ([[tls istream] streamStatus] == NSStreamStatusError)
         {
@@ -379,7 +440,7 @@ GSTLSPull(gnutls_transport_ptr_t handle, void *buffer, size_t len)
         {
           e = EAGAIN;	// Tell GNUTLS this would block.
         }
-#if	HAVE_GNUTLS_TRANSPORT_SET_ERRNO
+#if HAVE_GNUTLS_TRANSPORT_SET_ERRNO
       gnutls_transport_set_errno (tls->session->session, e);
 #else
       errno = e;	// Not thread-safe
@@ -400,7 +461,7 @@ GSTLSPush(gnutls_transport_ptr_t handle, const void *buffer, size_t len)
   result = [[tls ostream] _write: buffer maxLength: len];
   if (result < 0)
     {
-      int       e;
+      NSInteger       e;
 
       if ([[tls ostream] streamStatus] == NSStreamStatusError)
         {
@@ -410,7 +471,7 @@ GSTLSPush(gnutls_transport_ptr_t handle, const void *buffer, size_t len)
         {
           e = EAGAIN;	// Tell GNUTLS this would block.
         }
-#if	HAVE_GNUTLS_TRANSPORT_SET_ERRNO
+#if HAVE_GNUTLS_TRANSPORT_SET_ERRNO
       gnutls_transport_set_errno (tls->session->session, e);
 #else
       errno = e;	// Not thread-safe
@@ -647,12 +708,14 @@ static NSArray  *keys = nil;
 
 @end
 
-#else   /* HAVE_GNUTLS */
+#else /* HAVE_GNUTLS */
 
-/* GNUTLS not available ...
+/*
+ * GNUTLS not available ...
  */
-@interface      GSTLSHandler : GSStreamHandler
+@interface GSTLSHandler : GSStreamHandler
 @end
+
 @implementation GSTLSHandler
 + (void) tryInput: (GSSocketInputStream*)i output: (GSSocketOutputStream*)o
 {
@@ -679,596 +742,268 @@ static NSArray  *keys = nil;
 }
 @end
 
-#endif   /* HAVE_GNUTLS */
+#endif /* HAVE_GNUTLS */
 
 
-
-/*
- * States for socks connection negotiation
- */
-static NSString * const GSSOCKSOfferAuth = @"GSSOCKSOfferAuth";
-static NSString * const GSSOCKSRecvAuth = @"GSSOCKSRecvAuth";
-static NSString * const GSSOCKSSendAuth = @"GSSOCKSSendAuth";
-static NSString * const GSSOCKSAckAuth = @"GSSOCKSAckAuth";
-static NSString * const GSSOCKSSendConn = @"GSSOCKSSendConn";
-static NSString * const GSSOCKSAckConn = @"GSSOCKSAckConn";
-
-@interface	GSSOCKS : GSStreamHandler
-{
-  NSString		*state;		/* Not retained */
-  NSString		*address;
-  NSString		*port;
-  int			roffset;
-  int			woffset;
-  int			rwant;
-  unsigned char		rbuffer[128];
+@interface GSSOCKS : GSStreamHandler<GSSocksParserDelegate> {
+    GSSocksParser   *parser;
+    NSData          *request;
+    NSMutableData   *response;
+    NSUInteger      bytesRequired;
 }
-- (void) stream: (NSStream*)stream handleEvent: (NSStreamEvent)event;
-@end
-
-@implementation	GSSOCKS
-+ (void) tryInput: (GSSocketInputStream*)i output: (GSSocketOutputStream*)o
-{
-  NSDictionary          *conf;
-
-  conf = [i propertyForKey: NSStreamSOCKSProxyConfigurationKey];
-  if (conf == nil)
-    {
-      conf = [o propertyForKey: NSStreamSOCKSProxyConfigurationKey];
-      if (conf != nil)
-        {
-          [i setProperty: conf forKey: NSStreamSOCKSProxyConfigurationKey];
-        }
-    }
-  else
-    {
-      [o setProperty: conf forKey: NSStreamSOCKSProxyConfigurationKey];
-    }
 
-  if (conf != nil)
-    {
-      GSSOCKS           *h;
-      struct sockaddr   *sa = [i _address];
-      NSString          *v;
-      BOOL              i6 = NO;
+- (void)stream:(NSStream *)stream handleEvent:(NSStreamEvent)event;
 
-      v = [conf objectForKey: NSStreamSOCKSProxyVersionKey];
-      if ([v isEqualToString: NSStreamSOCKSProxyVersion4] == YES)
-        {
-          v = NSStreamSOCKSProxyVersion4;
-        }
-      else
-        {
-          v = NSStreamSOCKSProxyVersion5;
-        }
+@end
 
-#if     defined(AF_INET6)
-      if (sa->sa_family == AF_INET6)
-        {
-          i6 = YES;
-        }
-      else
-#endif
-      if (sa->sa_family != AF_INET)
-        {
-          GSOnceMLog(@"SOCKS not supported for socket type %d", sa->sa_family);
-          return;
-        }
+static NSDictionary *GlobalSOCKSProxyConfiguration = nil;
 
-      if (v == NSStreamSOCKSProxyVersion5)
-        {
-          GSOnceMLog(@"SOCKS 5 not supported yet");
-          return;
-        }
-      else if (i6 == YES)
-        {
-          GSOnceMLog(@"INET6 not supported with SOCKS 4");
-          return;
-        }
+@implementation	GSSOCKS
 
-      h = [[GSSOCKS alloc] initWithInput: i output: o];
-      [i _setHandler: h];
-      [o _setHandler: h];
-      RELEASE(h);
-    }
++ (void)initialize
+{
+    GlobalSOCKSProxyConfiguration = [GSPrivateGetGlobalSOCKSProxyConfiguration() copy];
 }
 
-- (void) bye
++ (void)tryInput:(GSSocketInputStream *)input output:(GSSocketOutputStream *)output
 {
-  if (handshake == YES)
-    {
-      GSSocketInputStream	*is = RETAIN(istream);
-      GSSocketOutputStream	*os = RETAIN(ostream);
-
-      handshake = NO;
-
-      [is _setHandler: nil];
-      [os _setHandler: nil];
-      [GSTLSHandler tryInput: is output: os];
-      if ([is streamStatus] == NSStreamStatusOpen)
-        {
-	  [is _resetEvents: NSStreamEventOpenCompleted];
-          [is _sendEvent: NSStreamEventOpenCompleted];
-        }
-      else
-        {
-	  [is _resetEvents: NSStreamEventErrorOccurred];
-          [is _sendEvent: NSStreamEventErrorOccurred];
+    NSDictionary *configuration;
+    
+    configuration = [input propertyForKey:NSStreamSOCKSProxyConfigurationKey];
+    if (configuration == nil) {
+        configuration = [output propertyForKey:NSStreamSOCKSProxyConfigurationKey];
+        if (configuration != nil) {
+            [input setProperty:configuration forKey:NSStreamSOCKSProxyConfigurationKey];
         }
-      if ([os streamStatus]  == NSStreamStatusOpen)
-        {
-	  [os _resetEvents: NSStreamEventOpenCompleted
-	    | NSStreamEventHasSpaceAvailable];
-          [os _sendEvent: NSStreamEventOpenCompleted];
-          [os _sendEvent: NSStreamEventHasSpaceAvailable];
+    } else {
+        [output setProperty:configuration forKey:NSStreamSOCKSProxyConfigurationKey];
+    }
+    
+    if (configuration == nil) {
+        if (GlobalSOCKSProxyConfiguration != nil) {
+            configuration = GlobalSOCKSProxyConfiguration;
+            [input setProperty:configuration forKey:NSStreamSOCKSProxyConfigurationKey];
+            [output setProperty:configuration forKey:NSStreamSOCKSProxyConfigurationKey];
+        } else {
+            return;
         }
-      else
-        {
-	  [os _resetEvents: NSStreamEventErrorOccurred];
-          [os _sendEvent: NSStreamEventErrorOccurred];
-        }
-      RELEASE(is);
-      RELEASE(os);
     }
+    
+    id handler = [[self alloc] initWithInput:input output:output];
+    [input _setHandler:handler];
+    [output _setHandler:handler];
+    RELEASE(handler);
+}
+
+- (void)reconfigureStreamsForAddress:(NSString *)anAddress port:(NSUInteger)aPort
+{
+    anAddress = [[NSHost hostWithName:anAddress] address];
+    NSInteger family = [anAddress rangeOfString:@":"].location == NSNotFound ? AF_INET : AF_INET6;
+    [istream _setSocketAddress:anAddress port:aPort family:family];
+    [ostream _setSocketAddress:anAddress port:aPort family:family];    
+}
+
+- (id)initWithInput:(GSSocketInputStream *)input
+             output:(GSSocketOutputStream *)output
+{
+    if (!(self = [super initWithInput:input output:output])) {
+        return nil;
+    }
+    if (![istream isKindOfClass:[GSInetInputStream class]] && ![istream isKindOfClass: [GSInet6InputStream class]]) {
+        NSLog(@"Attempt to use SOCKS with non-INET stream will be ignored");
+        DESTROY(self);
+        return nil;
+    }
+    
+    NSDictionary    *configuration = [istream propertyForKey:NSStreamSOCKSProxyConfigurationKey];
+    struct sockaddr *socketAddress = [istream _address];
+    
+    NSString        *address;
+    NSUInteger      port;
+    /*
+     * Record the host and port that the streams are supposed to be
+     * connecting to.
+     */
+    address = GSPrivateSockaddrHost(socketAddress);
+    port = GSPrivateSockaddrPort(socketAddress);
+    
+    parser = [[GSSocksParser alloc] initWithConfiguration:configuration
+                                                  address:address
+                                                     port:port];
+    [parser setDelegate:self];
+    request = nil;
+    response = [[NSMutableData alloc] init];
+    bytesRequired = 0;
+    
+    /*
+     * Now reconfigure the streams so they will actually connect
+     * to the socks proxy server.
+     */
+    address = [configuration objectForKey:NSStreamSOCKSProxyHostKey];
+    port = [[configuration objectForKey:NSStreamSOCKSProxyPortKey] integerValue];
+    [self reconfigureStreamsForAddress:address port:port];
+    return self;
 }
 
-- (void) dealloc
+- (void)dealloc
 {
-  RELEASE(address);
-  RELEASE(port);
-  [super dealloc];
+    RELEASE(response);
+    RELEASE(request);
+    [parser setDelegate:nil];
+    RELEASE(parser);
+    [super dealloc];
 }
 
-- (void) hello
+- (void)hello
 {
-  if (handshake == NO)
-    {
-      handshake = YES;
-      /* Now send self an event to say we can write, to kick off the
-       * handshake with the SOCKS server.
-       */
-      [self stream: ostream handleEvent: NSStreamEventHasSpaceAvailable];
+    if (handshake) {
+        return;
     }
+    handshake = YES;
+    /*
+     * Now send self an event to say we can write, to kick off the
+     * handshake with the SOCKS server.
+     */
+    [self stream:ostream handleEvent:NSStreamEventHasSpaceAvailable];
 }
 
-- (id) initWithInput: (GSSocketInputStream*)i
-              output: (GSSocketOutputStream*)o
+- (void)bye
 {
-  if ((self = [super initWithInput: i output: o]) != nil)
+    if (!handshake)
     {
-      if ([istream isKindOfClass: [GSInetInputStream class]] == NO)
-	{
-	  NSLog(@"Attempt to use SOCKS with non-INET stream ignored");
-	  DESTROY(self);
-	}
-#if	defined(AF_INET6)
-      else if ([istream isKindOfClass: [GSInet6InputStream class]] == YES)
-	{
-          GSOnceMLog(@"INET6 not supported with SOCKS yet...");
-	  DESTROY(self);
-	}
-#endif	/* AF_INET6 */
-      else
-	{
-	  struct sockaddr_in	*addr;
-          NSDictionary          *conf;
-          NSString              *host;
-          int                   pnum;
-
-          /* Record the host and port that the streams are supposed to be
-           * connecting to.
-           */
-	  addr = (struct sockaddr_in*)(void*)[istream _address];
-	  address = [[NSString alloc] initWithUTF8String:
-	    (char*)inet_ntoa(addr->sin_addr)];
-	  port = [[NSString alloc] initWithFormat: @"%d",
-	    (NSInteger)GSSwapBigI16ToHost(addr->sin_port)];
-
-          /* Now reconfigure the streams so they will actually connect
-           * to the socks proxy server.
-           */
-          conf = [istream propertyForKey: NSStreamSOCKSProxyConfigurationKey];
-          host = [conf objectForKey: NSStreamSOCKSProxyHostKey];
-          pnum = [[conf objectForKey: NSStreamSOCKSProxyPortKey] intValue];
-          [istream _setSocketAddress: host port: pnum family: AF_INET];
-          [ostream _setSocketAddress: host port: pnum family: AF_INET];
-	}
+        return;
     }
-  return self;
+    GSSocketInputStream     *input = RETAIN(istream);
+    GSSocketOutputStream    *output = RETAIN(ostream);
+    
+    handshake = NO;
+    
+    [input _setHandler: nil];
+    [output _setHandler: nil];
+    [GSTLSHandler tryInput:input output:output];
+    if ([input streamStatus] == NSStreamStatusOpen) {
+        [input _resetEvents:NSStreamEventOpenCompleted];
+        [input _sendEvent:NSStreamEventOpenCompleted];
+    } else {
+        [input _resetEvents:NSStreamEventErrorOccurred];
+        [input _sendEvent:NSStreamEventErrorOccurred];
+    }
+    if ([output streamStatus] == NSStreamStatusOpen)
+    {
+        [output _resetEvents:NSStreamEventOpenCompleted | NSStreamEventHasSpaceAvailable];
+        [output _sendEvent:NSStreamEventOpenCompleted];
+        [output _sendEvent:NSStreamEventHasSpaceAvailable];
+    } else {
+        [output _resetEvents:NSStreamEventErrorOccurred];
+        [output _sendEvent:NSStreamEventErrorOccurred];
+    }
+    RELEASE(input);
+    RELEASE(output);
 }
 
-- (NSInteger) read: (uint8_t *)buffer maxLength: (NSUInteger)len
+- (NSInteger)read:(uint8_t *)buffer maxLength:(NSUInteger)len
 {
-  return [istream _read: buffer maxLength: len];
+  return [istream _read:buffer maxLength:len];
 }
 
-- (void) stream: (NSStream*)stream handleEvent: (NSStreamEvent)event
+- (NSInteger)write:(const uint8_t *)buffer maxLength:(NSUInteger)len
 {
-  NSString		*error = nil;
-  NSDictionary		*conf;
-  NSString		*user;
-  NSString		*pass;
+    return [ostream _write: buffer maxLength: len];
+}
 
-  if (event == NSStreamEventErrorOccurred
-    || [stream streamStatus] == NSStreamStatusError
-    || [stream streamStatus] == NSStreamStatusClosed)
-    {
-      [self bye];
-      return;
-    }
+- (void)closeAndBye {
+    [istream close];
+    [ostream close];
+    [self bye];
+}
 
-  conf = [stream propertyForKey: NSStreamSOCKSProxyConfigurationKey];
-  user = [conf objectForKey: NSStreamSOCKSProxyUserKey];
-  pass = [conf objectForKey: NSStreamSOCKSProxyPasswordKey];
-  if ([[conf objectForKey: NSStreamSOCKSProxyVersionKey]
-    isEqual: NSStreamSOCKSProxyVersion4] == YES)
-    {
+- (void)stream:(NSStream*)stream handleEvent:(NSStreamEvent)event
+{
+    if (!handshake) {
+        return;
     }
-  else
-    {
-      again:
-
-      if (state == GSSOCKSOfferAuth)
-	{
-	  int		result;
-	  int		want;
-	  unsigned char	buf[4];
-
-	  /*
-	   * Authorisation record is at least three bytes -
-	   *   socks version (5)
-	   *   authorisation method bytes to follow (1)
-	   *   say we do no authorisation (0)
-	   *   say we do user/pass authorisation (2)
-	   */
-	  buf[0] = 5;
-	  if (user && pass)
-	    {
-	      buf[1] = 2;
-	      buf[2] = 2;
-	      buf[3] = 0;
-	      want = 4;
-	    }
-	  else
-	    {
-	      buf[1] = 1;
-	      buf[2] = 0;
-	      want = 3;
-	    }
-
-	  result = [ostream _write: buf + woffset maxLength: 4 - woffset];
-	  if (result > 0)
-	    {
-	      woffset += result;
-	      if (woffset == want)
-		{
-		  woffset = 0;
-		  state = GSSOCKSRecvAuth;
-		  goto again;
-		}
-	    }
-	}
-      else if (state == GSSOCKSRecvAuth)
-	{
-	  int	result;
-
-	  result = [istream _read: rbuffer + roffset maxLength: 2 - roffset];
-	  if (result == 0)
-	    {
-	      error = @"SOCKS end-of-file during negotiation";
-	    }
-	  else if (result > 0)
-	    {
-	      roffset += result;
-	      if (roffset == 2)
-		{
-		  roffset = 0;
-		  if (rbuffer[0] != 5)
-		    {
-		      error = @"SOCKS authorisation response had wrong version";
-		    }
-		  else if (rbuffer[1] == 0)
-		    {
-		      state = GSSOCKSSendConn;
-		      goto again;
-		    }
-		  else if (rbuffer[1] == 2)
-		    {
-		      state = GSSOCKSSendAuth;
-		      goto again;
-		    }
-		  else
-		    {
-		      error = @"SOCKS authorisation response had wrong method";
-		    }
-		}
-	    }
-	}
-      else if (state == GSSOCKSSendAuth)
-	{
-	  NSData	*u = [user dataUsingEncoding: NSUTF8StringEncoding];
-	  unsigned	ul = [u length];
-	  NSData	*p = [pass dataUsingEncoding: NSUTF8StringEncoding];
-	  unsigned	pl = [p length];
-
-	  if (ul < 1 || ul > 255)
-	    {
-	      error = @"NSStreamSOCKSProxyUserKey value too long";
-	    }
-	  else if (ul < 1 || ul > 255)
-	    {
-	      error = @"NSStreamSOCKSProxyPasswordKey value too long";
-	    }
-	  else
-	    {
-	      int		want = ul + pl + 3;
-	      unsigned char	buf[want];
-	      int		result;
-
-	      buf[0] = 5;
-	      buf[1] = ul;
-	      memcpy(buf + 2, [u bytes], ul);
-	      buf[ul + 2] = pl;
-	      memcpy(buf + ul + 3, [p bytes], pl);
-	      result = [ostream _write: buf + woffset
-			     maxLength: want - woffset];
-	      if (result == 0)
-		{
-		  error = @"SOCKS end-of-file during negotiation";
-		}
-	      else if (result > 0)
-		{
-		  woffset += result;
-		  if (woffset == want)
-		    {
-		      state = GSSOCKSAckAuth;
-		      goto again;
-		    }
-		}
-	    }
-	}
-      else if (state == GSSOCKSAckAuth)
-	{
-	  int	result;
-
-	  result = [istream _read: rbuffer + roffset maxLength: 2 - roffset];
-	  if (result == 0)
-	    {
-	      error = @"SOCKS end-of-file during negotiation";
-	    }
-	  else if (result > 0)
-	    {
-	      roffset += result;
-	      if (roffset == 2)
-		{
-		  roffset = 0;
-		  if (rbuffer[0] != 5)
-		    {
-		      error = @"SOCKS authorisation response had wrong version";
-		    }
-		  else if (rbuffer[1] == 0)
-		    {
-		      state = GSSOCKSSendConn;
-		      goto again;
-		    }
-		  else if (rbuffer[1] == 2)
-		    {
-		      error = @"SOCKS authorisation failed";
-		    }
-		}
-	    }
-	}
-      else if (state == GSSOCKSSendConn)
-	{
-	  unsigned char	buf[10];
-	  int		want = 10;
-	  int		result;
-	  const char	*ptr;
-
-	  /*
-	   * Connect command is ten bytes -
-	   *   socks version
-	   *   connect command
-	   *   reserved byte
-	   *   address type
-	   *   address 4 bytes (big endian)
-	   *   port 2 bytes (big endian)
-	   */
-	  buf[0] = 5;	// Socks version number
-	  buf[1] = 1;	// Connect command
-	  buf[2] = 0;	// Reserved
-	  buf[3] = 1;	// Address type (IPV4)
-	  ptr = [address UTF8String];
-	  buf[4] = atoi(ptr);
-	  while (isdigit(*ptr))
-	    ptr++;
-	  ptr++;
-	  buf[5] = atoi(ptr);
-	  while (isdigit(*ptr))
-	    ptr++;
-	  ptr++;
-	  buf[6] = atoi(ptr);
-	  while (isdigit(*ptr))
-	    ptr++;
-	  ptr++;
-	  buf[7] = atoi(ptr);
-	  result = [port intValue];
-	  buf[8] = ((result & 0xff00) >> 8);
-	  buf[9] = (result & 0xff);
-
-	  result = [ostream _write: buf + woffset maxLength: want - woffset];
-	  if (result == 0)
-	    {
-	      error = @"SOCKS end-of-file during negotiation";
-	    }
-	  else if (result > 0)
-	    {
-	      woffset += result;
-	      if (woffset == want)
-		{
-		  rwant = 5;
-		  state = GSSOCKSAckConn;
-		  goto again;
-		}
-	    }
-	}
-      else if (state == GSSOCKSAckConn)
-	{
-	  int	result;
-
-	  result = [istream _read: rbuffer + roffset
-                        maxLength: rwant - roffset];
-	  if (result == 0)
-	    {
-	      error = @"SOCKS end-of-file during negotiation";
-	    }
-	  else if (result > 0)
-	    {
-	      roffset += result;
-	      if (roffset == rwant)
-		{
-		  if (rbuffer[0] != 5)
-		    {
-		      error = @"connect response from SOCKS had wrong version";
-		    }
-		  else if (rbuffer[1] != 0)
-		    {
-		      switch (rbuffer[1])
-			{
-			  case 1:
-			    error = @"SOCKS server general failure";
-			    break;
-			  case 2:
-			    error = @"SOCKS server says permission denied";
-			    break;
-			  case 3:
-			    error = @"SOCKS server says network unreachable";
-			    break;
-			  case 4:
-			    error = @"SOCKS server says host unreachable";
-			    break;
-			  case 5:
-			    error = @"SOCKS server says connection refused";
-			    break;
-			  case 6:
-			    error = @"SOCKS server says connection timed out";
-			    break;
-			  case 7:
-			    error = @"SOCKS server says command not supported";
-			    break;
-			  case 8:
-			    error = @"SOCKS server says address not supported";
-			    break;
-			  default:
-			    error = @"connect response from SOCKS was failure";
-			    break;
-			}
-		    }
-		  else if (rbuffer[3] == 1)
-		    {
-		      rwant = 10;		// Fixed size (IPV4) address
-		    }
-		  else if (rbuffer[3] == 3)
-		    {
-		      rwant = 7 + rbuffer[4];	// Domain name leading length
-		    }
-		  else if (rbuffer[3] == 4)
-		    {
-		      rwant = 22;		// Fixed size (IPV6) address
-		    }
-		  else
-		    {
-		      error = @"SOCKS server returned unknown address type";
-		    }
-		  if (error == nil)
-		    {
-		      if (roffset < rwant)
-			{
-			  goto again;	// Need address/port bytes
-			}
-		      else
-			{
-			  NSString	*a;
-
-			  if (rbuffer[3] == 1)
-			    {
-			      a = [NSString stringWithFormat: @"%d.%d.%d.%d",
-			        rbuffer[4], rbuffer[5], rbuffer[6], rbuffer[7]];
-			    }
-			  else if (rbuffer[3] == 3)
-			    {
-			      rbuffer[rwant] = '\0';
-			      a = [NSString stringWithUTF8String:
-			        (const char*)rbuffer];
-			    }
-			  else
-			    {
-			      unsigned char	buf[40];
-			      int		i = 4;
-			      int		j = 0;
-
-			      while (i < rwant)
-			        {
-				  int	val;
-
-				  val = rbuffer[i++];
-				  val = val * 256 + rbuffer[i++];
-				  if (i > 4)
-				    {
-				      buf[j++] = ':';
-				    }
-				  snprintf((char*)&buf[j], 5, "%04x", val);
-				  j += 4;
-				}
-			      a = [NSString stringWithUTF8String:
-			        (const char*)buf];
-			    }
-
-			  [istream setProperty: a
-					forKey: GSStreamRemoteAddressKey];
-			  [ostream setProperty: a
-					forKey: GSStreamRemoteAddressKey];
-			  a = [NSString stringWithFormat: @"%d",
-			    rbuffer[rwant-1] * 256 * rbuffer[rwant-2]];
-			  [istream setProperty: a
-					forKey: GSStreamRemotePortKey];
-			  [ostream setProperty: a
-					forKey: GSStreamRemotePortKey];
-			  /* Return immediately after calling -bye as it
-			   * will cause this instance to be deallocated.
-			   */
-			  [self bye];
-			  return;
-			}
-		    }
-		}
-	    }
-	}
+    if (event == NSStreamEventErrorOccurred || [stream streamStatus] == NSStreamStatusError || [stream streamStatus] == NSStreamStatusClosed) {
+        [self closeAndBye];
+        return;
     }
+    switch (event) {
+        case NSStreamEventOpenCompleted:
+        {
+            if (stream == istream) {
+                [parser start];
+            }
+            break;
+        }
+        case NSStreamEventHasSpaceAvailable:
+        {
+            NSUInteger requestLength = [request length];
+            NSInteger bytesWritten = [self write:[request bytes] maxLength:requestLength];
+            if (bytesWritten < 0) {
+                [self closeAndBye];
+                return;
+            }
+            NSData *requestTail = nil;
+            if (bytesWritten < requestLength) {
+                requestTail = [[NSData alloc] initWithBytes:[request bytes] + bytesWritten
+                                                     length:requestLength - bytesWritten];
+            }
+            [request release];
+            request = requestTail;
+            break;
+        }
+        case NSStreamEventHasBytesAvailable:
+        {
+            if (!bytesRequired) {
+                break;
+            }
+            static NSUInteger const bufferSize = 1024;
+            uint8_t buffer[bufferSize];
+            NSUInteger length = MIN(bufferSize, bytesRequired);
+            
+            NSInteger bytesRead = [self read:buffer maxLength:length];
+            if (bytesRead < 0) {
+                [self closeAndBye];
+                return;
+            }
+            [response appendBytes:buffer length:bytesRead];
+            if (!(bytesRequired -= bytesRead)) {
+                [parser parseNextChunk:response];
+                [response setLength:0];
+            }
+            break;
+        }
+        case NSStreamEventErrorOccurred:
+        case NSStreamEventEndEncountered:
+        {
+            [self closeAndBye];
+            return;
+        }
+        default:
+            break;
+    } 
+}
 
-  if ([error length] > 0)
-    {
-      NSError *theError;
+- (void)parser:(GSSocksParser *)aParser encounteredError:(NSError *)anError
+{
+    [istream _recordError:anError];
+    [self closeAndBye];
+}
 
-      theError = [NSError errorWithDomain: NSCocoaErrorDomain
-	code: 0
-	userInfo: [NSDictionary dictionaryWithObject: error
-	  forKey: NSLocalizedDescriptionKey]];
-      if ([istream streamStatus] != NSStreamStatusError)
-	{
-	  [istream _recordError: theError];
-	}
-      if ([ostream streamStatus] != NSStreamStatusError)
-	{
-	  [ostream _recordError: theError];
-	}
-      [self bye];
-    }
+- (void)parser:(GSSocksParser *)aParser formedRequest:(NSData *)aRequest
+{
+    id previous = request;
+    request = [aRequest retain];
+    [previous release];
 }
 
-- (NSInteger) write: (const uint8_t *)buffer maxLength: (NSUInteger)len
+- (void)parser:(GSSocksParser *)aParser needsMoreBytes:(NSUInteger)aLength
+{
+    bytesRequired += aLength;
+}
+
+- (void)parser:(GSSocksParser *)aParser finishedWithAddress:(NSString *)anAddress port:(NSUInteger)aPort
 {
-  return [ostream _write: buffer maxLength: len];
+    [self bye];
 }
 
 @end
@@ -1277,7 +1012,7 @@ static NSString * const GSSOCKSAckConn = @"GSSOCKSAckConn";
 static inline BOOL
 socketError(int result)
 {
-#if	defined(__MINGW__)
+#if defined(__MINGW__)
   return (result == SOCKET_ERROR) ? YES : NO;
 #else
   return (result < 0) ? YES : NO;
@@ -1294,7 +1029,7 @@ socketWouldBlock()
 static void
 setNonBlocking(SOCKET fd)
 {
-#if	defined(__MINGW__)
+#if defined(__MINGW__)
   unsigned long dummy = 1;
 
   if (ioctlsocket(fd, FIONBIO, &dummy) == SOCKET_ERROR)
@@ -1334,7 +1069,7 @@ setNonBlocking(SOCKET fd)
       _sibling = nil;
       _closing = NO;
       _passive = NO;
-#if	defined(__MINGW__)
+#if defined(__MINGW__)
       _loopID = WSA_INVALID_EVENT;
 #else
       _loopID = (void*)(intptr_t)-1;
@@ -1402,26 +1137,26 @@ setNonBlocking(SOCKET fd)
   return -1;
 }
 
-- (void) _sendEvent: (NSStreamEvent)event
+- (void) _dispatchEvent:(NSNumber *)anEvent
 {
-  /* If the receiver has a TLS handshake in progress,
-   * we must send events to the TLS handler rather than
-   * the stream delegate.
-   */
-  if (_handler != nil && [_handler handshake] == YES)
+    /* If the receiver has a TLS handshake in progress,
+     * we must send events to the TLS handler rather than
+     * the stream delegate.
+     */
+    if (_handler != nil && [_handler handshake] == YES)
     {
-      id        del = _delegate;
-      BOOL      val = _delegateValid;
-
-      _delegate = _handler;
-      _delegateValid = YES;
-      [super _sendEvent: event];
-      _delegate = del;
-      _delegateValid = val;
+        id        del = _delegate;
+        BOOL      val = _delegateValid;
+        
+        _delegate = _handler;
+        _delegateValid = YES;
+        [super _dispatchEvent: anEvent];
+        _delegate = del;
+        _delegateValid = val;
     }
-  else
+    else
     {
-      [super _sendEvent: event];
+        [super _dispatchEvent: anEvent];
     }
 }
 
@@ -1455,7 +1190,7 @@ setNonBlocking(SOCKET fd)
             }
         }
 
-#if	defined(AF_INET6)
+#if defined(AF_INET6)
       case AF_INET6:
         {
           int           ptonReturn;
@@ -1479,7 +1214,7 @@ setNonBlocking(SOCKET fd)
         }
 #endif
 
-#ifndef	__MINGW__
+#ifndef __MINGW__
       case AF_LOCAL:
 	{
 	  struct sockaddr_un	peer;
@@ -1513,7 +1248,7 @@ setNonBlocking(SOCKET fd)
 
 - (void) _setLoopID: (void *)ref
 {
-#if	!defined(__MINGW__)
+#if !defined(__MINGW__)
   _sock = (SOCKET)(intptr_t)ref;        // On gnu/linux _sock is _loopID
 #endif
   _loopID = ref;
@@ -1544,7 +1279,7 @@ setNonBlocking(SOCKET fd)
    * monitored, and on mswindows systems we create an event object to be
    * monitored (the socket events are assoociated with this object later).
    */
-#if	defined(__MINGW__)
+#if defined(__MINGW__)
   _loopID = CreateEvent(NULL, NO, NO, NULL);
 #else
   _loopID = (void*)(intptr_t)sock;      // On gnu/linux _sock is _loopID
@@ -1720,9 +1455,9 @@ setNonBlocking(SOCKET fd)
 #else
   // read shutdown is ignored, because the other side may shutdown first.
   if (!_sibling || [_sibling streamStatus] == NSStreamStatusClosed)
-    close((intptr_t)_loopID);
+    close((int)_loopID);
   else
-    shutdown((intptr_t)_loopID, SHUT_RD);
+    shutdown((int)_loopID, SHUT_RD);
   [super close];
   _loopID = (void*)(intptr_t)-1;
 #endif
@@ -1750,7 +1485,7 @@ setNonBlocking(SOCKET fd)
 
 - (NSInteger) _read: (uint8_t *)buffer maxLength: (NSUInteger)len
 {
-  int readLen;
+  NSInteger readLen;
 
   _events &= ~NSStreamEventHasBytesAvailable;
 
@@ -1770,7 +1505,7 @@ setNonBlocking(SOCKET fd)
       readLen = read([self _sock], buffer, len);
 #endif
     }
-  if (socketError(readLen))
+  if (socketError((int)readLen))
     {
       if (_closing == YES)
         {
@@ -1928,7 +1663,7 @@ setNonBlocking(SOCKET fd)
 	    }
 	}
     }
-#else
+#else /* __MINGW__ */    
   NSStreamEvent myEvent;
 
   if ([self streamStatus] == NSStreamStatusOpening)
@@ -1997,7 +1732,7 @@ setNonBlocking(SOCKET fd)
 
 - (NSInteger) _write: (const uint8_t *)buffer maxLength: (NSUInteger)len
 {
-  int writeLen;
+  NSInteger writeLen;
 
   _events &= ~NSStreamEventHasSpaceAvailable;
 
@@ -2017,7 +1752,7 @@ setNonBlocking(SOCKET fd)
   writeLen = write([self _sock], buffer, (socklen_t) len);
 #endif
 
-  if (socketError(writeLen))
+  if (socketError((int)writeLen))
     {
       if (_closing == YES)
         {
@@ -2194,9 +1929,9 @@ setNonBlocking(SOCKET fd)
 #else
   // read shutdown is ignored, because the other side may shutdown first.
   if (!_sibling || [_sibling streamStatus] == NSStreamStatusClosed)
-    close((intptr_t)_loopID);
+    close((int)_loopID);
   else
-    shutdown((intptr_t)_loopID, SHUT_WR);
+    shutdown((int)_loopID, SHUT_WR);
   [super close];
   _loopID = (void*)(intptr_t)-1;
 #endif
@@ -2332,7 +2067,7 @@ setNonBlocking(SOCKET fd)
 	    }
 	}
     }
-#else
+#else /* __MINGW__ */
   NSStreamEvent myEvent;
 
   if ([self streamStatus] == NSStreamStatusOpening)
@@ -2344,7 +2079,7 @@ setNonBlocking(SOCKET fd)
       IF_NO_GC([[self retain] autorelease];)
       [self _schedule];
       result
-	= getsockopt((intptr_t)_loopID, SOL_SOCKET, SO_ERROR, &error, &len);
+	= getsockopt((int)_loopID, SOL_SOCKET, SO_ERROR, &error, &len);
       if (result >= 0 && !error)
         { // finish up the opening
           myEvent = NSStreamEventOpenCompleted;
@@ -2500,7 +2235,7 @@ setNonBlocking(SOCKET fd)
 #else
   if (_loopID != (void*)(intptr_t)-1)
     {
-      close((intptr_t)_loopID);
+      close((int)_loopID);
       [super close];
       _loopID = (void*)(intptr_t)-1;
     }
@@ -2711,7 +2446,7 @@ setNonBlocking(SOCKET fd)
 
 - (id) initToAddr: (NSString*)addr port: (NSInteger)port
 {
-  if ([super init] != nil)
+  if ((self = [super init]))
     {
       if ([addr length] == 0)
         {
diff --git a/Source/GSSocksParser/GSSocks4Parser.h b/Source/GSSocksParser/GSSocks4Parser.h
new file mode 100644
index 0000000..f759ad3
--- /dev/null
+++ b/Source/GSSocksParser/GSSocks4Parser.h
@@ -0,0 +1,33 @@
+/*
+ * Parsers of SOCKS protocol messages
+ * Copyright (C) 2013 Free Software Foundation, Inc.
+ *
+ * Written by Marat Ibadinov <ibadinov@me.com>
+ * Date: 2013
+ *
+ * This file is part of the GNUstep Base Library.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free
+ * Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110 USA.
+ *
+ * $Date$ $Revision$
+ */
+
+#import "GSSocksParser.h"
+
+@interface GSSocks4Parser : GSSocksParser {
+}
+
+@end
diff --git a/Source/GSSocksParser/GSSocks4Parser.m b/Source/GSSocksParser/GSSocks4Parser.m
new file mode 100644
index 0000000..8641ca4
--- /dev/null
+++ b/Source/GSSocksParser/GSSocks4Parser.m
@@ -0,0 +1,137 @@
+/*
+ * Parsers of SOCKS protocol messages
+ * Copyright (C) 2013 Free Software Foundation, Inc.
+ *
+ * Written by Marat Ibadinov <ibadinov@me.com>
+ * Date: 2013
+ *
+ * This file is part of the GNUstep Base Library.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free
+ * Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110 USA.
+ *
+ * $Date$ $Revision$
+ */
+
+#import "GSSocks4Parser.h"
+#import "GSSocksParserPrivate.h"
+#import <arpa/inet.h>
+
+typedef enum GSSocks4InternalError {
+    GSSocks4InternalErrorIPv6 = 0x4a
+} GSSocks4InternalError;
+
+typedef enum GSSocks4ResponseStatus {
+    GSSocks4ResponseStatusAccessGranted     = 0x5a,
+    GSSocks4ResponseStatusRequestRejected   = 0x5b,
+    GSSocks4ResponseStatusIdentdFailed      = 0x5c,
+    GSSocks4ResponseStatusUserNotConfirmed  = 0x5d,
+} GSSocks4ResponseStatus;
+
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wcast-align"
+
+@implementation GSSocks4Parser
+
+- (id)initWithConfiguration:(NSDictionary *)aConfiguration
+                    address:(NSString *)anAddress
+                       port:(NSUInteger)aPort
+{
+    if (self = [super init]) {
+        configuration = [aConfiguration retain];
+        address = [anAddress retain];
+        port = aPort;
+    }
+    return self;
+}
+
+- (void)start
+{
+    GSSocksAddressType addressType = [self addressType];
+    if (addressType == GSSocksAddressTypeIPv6) {
+        NSError *error = [self errorWithCode:GSSocks4InternalErrorIPv6
+                                 description:@"IPv6 addresses are not supported by SOCKS4 porxies"];
+        [delegate parser:self encounteredError:error];
+        return;
+    }
+    
+    NSMutableData *data = [NSMutableData dataWithLength:8];
+    uint8_t *bytes = [data mutableBytes];
+    bytes[0] = 0x4;
+    bytes[1] = 0x1;
+    *(uint16_t *)(bytes + 2) = htons((uint16_t)port);
+    if (addressType == GSSocksAddressTypeDomain) {
+        bytes[4] = bytes[5] = bytes[6] = 0;
+        bytes[7] = 1;
+    } else {
+        const uint32_t *addressBytes = [[self addressData] bytes];
+        *(uint32_t *)(bytes + 4) = htonl(*addressBytes);
+    }
+    uint8_t zero = 0x0;
+    NSString *user = [configuration objectForKey:NSStreamSOCKSProxyUserKey];
+    if (user) {
+        [data appendData:[user dataUsingEncoding:NSUTF8StringEncoding]];
+        [data appendBytes:&zero length:1];
+    }
+    if (addressType == GSSocksAddressTypeDomain) {
+        [data appendData:[address dataUsingEncoding:NSUTF8StringEncoding]];
+        [data appendBytes:&zero length:1];
+    }
+    
+    [delegate parser:self formedRequest:data];
+    [delegate parser:self needsMoreBytes:8];
+}
+
+- (NSError *)errorWithResponseStatus:(NSInteger)aStatus
+{
+    NSString *description;
+    switch ((GSSocks4ResponseStatus)aStatus) {
+        case GSSocks4ResponseStatusRequestRejected:
+            description = @"request was rejected or the server failed to fulfil it";
+            break;
+        case GSSocks4ResponseStatusIdentdFailed:
+            description = @"identd is not running or not reachable from the server";
+            break;
+        case GSSocks4ResponseStatusUserNotConfirmed:
+            description = @"identd could not confirm the user ID string in the request";
+            break;
+        default:
+            description = @"unknown";
+            break;
+    }
+    description = [NSString stringWithFormat:@"SOCKS4 connnection failed, reason: %@", description];
+    return [self errorWithCode:aStatus description:description];
+}
+
+- (void)parseNextChunk:(NSData *)aChunk
+{
+    const uint8_t *bytes = [aChunk bytes];
+    if (bytes[1] != GSSocks4ResponseStatusAccessGranted) {
+        NSError *error = [self errorWithResponseStatus:bytes[1]];
+        [delegate parser:self encounteredError:error];
+        return;
+    }
+    
+    NSUInteger  bndPort = ntohs(*(uint16_t *)(bytes + 2));
+    uint32_t    addressBytes = ntohl(*(uint32_t *)(bytes + 4));
+    NSData      *addressData = [NSData dataWithBytesNoCopy:&addressBytes length:4 freeWhenDone:NO];
+    NSString    *bndAddress = [self addressFromData:addressData withType:GSSocksAddressTypeIPv4];
+    
+    [delegate parser:self finishedWithAddress:bndAddress port:bndPort];
+}
+
+@end
+
+#pragma GCC diagnostic pop
\ No newline at end of file
diff --git a/Source/GSSocksParser/GSSocks5Parser.h b/Source/GSSocksParser/GSSocks5Parser.h
new file mode 100644
index 0000000..6a7c946
--- /dev/null
+++ b/Source/GSSocksParser/GSSocks5Parser.h
@@ -0,0 +1,37 @@
+/*
+ * Parsers of SOCKS protocol messages
+ * Copyright (C) 2013 Free Software Foundation, Inc.
+ *
+ * Written by Marat Ibadinov <ibadinov@me.com>
+ * Date: 2013
+ *
+ * This file is part of the GNUstep Base Library.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free
+ * Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110 USA.
+ *
+ * $Date$ $Revision$
+ */
+
+#import "GSSocksParser.h"
+
+@interface GSSocks5Parser : GSSocksParser {
+    NSUInteger  state;
+    NSUInteger  addressSize;
+    uint8_t     addressType;
+    BOOL        stopped;
+}
+
+@end
\ No newline at end of file
diff --git a/Source/GSSocksParser/GSSocks5Parser.m b/Source/GSSocksParser/GSSocks5Parser.m
new file mode 100644
index 0000000..6093e35
--- /dev/null
+++ b/Source/GSSocksParser/GSSocks5Parser.m
@@ -0,0 +1,242 @@
+/*
+ * Parsers of SOCKS protocol messages
+ * Copyright (C) 2013 Free Software Foundation, Inc.
+ *
+ * Written by Marat Ibadinov <ibadinov@me.com>
+ * Date: 2013
+ *
+ * This file is part of the GNUstep Base Library.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free
+ * Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110 USA.
+ *
+ * $Date$ $Revision$
+ */
+
+#import "GSSocks5Parser.h"
+#import "GSSocksParserPrivate.h"
+#import <arpa/inet.h>
+
+typedef enum GSSocks5ParserState {
+    GSSocks5ParserStateHandshake,
+    GSSocks5ParserStateAuthenticationRequest,
+    GSSocks5ParserStateAuthenticationResponse,
+    GSSocks5ParserStateRequest,
+    GSSocks5ParserStateResponse,
+    GSSocks5ParserStateResponseAddressLength,
+    GSSocks5ParserStateResponseAddressAndPort,
+} GSSocks5ParserState;
+
+typedef enum GSSocks5AuthenticationMethod {
+    GSSocks5AuthenticationMethodNone                = 0x00,
+    GSSocks5AuthenticationMethodGSSAPI              = 0x01,
+    GSSocks5AuthenticationMethodPassword            = 0x02,
+    GSSocks5AuthenticationMethodNoAcceptable        = 0xFF,
+} GSSocks5AuthenticationMethod;
+
+typedef enum GSSocks5ResponseStatus {
+    GSSocks5ResponseStatusSuccess                   = 0x0,
+    GSSocks5ResponseStatusGeneralFailure            = 0x1,
+    GSSocks5ResponseStatusConnectionNotAllowed      = 0x2,
+    GSSocks5ResponseStatusNetworkUnreachable        = 0x3,
+    GSSocks5ResponseStatusHostUnreachable           = 0x4,
+    GSSocks5ResponseStatusConnectionRefused         = 0x5,
+    GSSocks5ResponseStatusTTLExpired                = 0x6,
+    GSSocks5ResponseStatusCommandNotSupported       = 0x7,
+    GSSocks5ResponseStatusAddressTypeNotSupported   = 0x8,
+} GSSocks5ResponseStatus;
+
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wcast-align"
+
+@implementation GSSocks5Parser
+
+- (id)initWithConfiguration:(NSDictionary *)aConfiguration
+                    address:(NSString *)anAddress
+                       port:(NSUInteger)aPort
+{
+    if (self = [super init]) {
+        configuration = [aConfiguration retain];
+        address = [anAddress retain];
+        port = aPort;
+        stopped = YES;
+    }
+    return self;
+}
+
+- (void)start
+{
+    state = GSSocks5ParserStateHandshake;
+    stopped = NO;
+    
+    uint8_t bytes[3] = {0x5, 0x1, GSSocks5AuthenticationMethodNone};
+    if ([configuration objectForKey:NSStreamSOCKSProxyUserKey]) {
+        bytes[2] = GSSocks5AuthenticationMethodPassword;
+    }
+    
+    [delegate parser:self formedRequest:[NSData dataWithBytes:bytes length:3]];
+    [delegate parser:self needsMoreBytes:2];
+}
+
+- (NSError *)errorWithResponseStatus:(NSInteger)aStatus
+{
+    NSString *description;
+    switch ((GSSocks5ResponseStatus)aStatus) {
+        case GSSocks5ResponseStatusGeneralFailure:
+            description = @"general server failure";
+            break;
+        case GSSocks5ResponseStatusConnectionNotAllowed:
+            description = @"connection is not allowed by a ruleset";
+            break;
+        case GSSocks5ResponseStatusNetworkUnreachable:
+            description = @"destination network is unreachable";
+            break;
+        case GSSocks5ResponseStatusHostUnreachable:
+            description = @"destination host is unreachable";
+            break;
+        case GSSocks5ResponseStatusConnectionRefused:
+            description = @"connection has been refused";
+            break;
+        case GSSocks5ResponseStatusTTLExpired:
+            description = @"connection has timed out";
+            break;
+        case GSSocks5ResponseStatusCommandNotSupported:
+            description = @"command is not supported";
+            break;
+        case GSSocks5ResponseStatusAddressTypeNotSupported:
+            description = @"address type is not supported";
+            break;
+        default:
+            description = @"unkown";
+            break;
+    }
+    description = [NSString stringWithFormat:@"SOCKS5 server failed to fulfil request, reason: %@", description];
+    return [self errorWithCode:aStatus description:description];
+}
+
+- (void)reportError:(NSError *)anError
+{
+    stopped = YES;
+    [delegate parser:self encounteredError:anError];
+}
+
+- (void)parseNextChunk:(NSData *)aChunk
+{
+    if (stopped) {
+        return;
+    }
+    const uint8_t *bytes = [aChunk bytes];
+    switch ((GSSocks5ParserState)state) {
+        case GSSocks5ParserStateHandshake:
+        {
+            if (bytes[1] == GSSocks5AuthenticationMethodNoAcceptable) {
+                NSError *error = [self errorWithCode:GSSocks5AuthenticationMethodNoAcceptable
+                                         description:@"SOCKS server does not support requested authentication method"];
+                [self reportError:error];
+                break;
+            }
+            if (![configuration objectForKey:NSStreamSOCKSProxyUserKey]) {
+                state = GSSocks5ParserStateRequest;
+                goto GSSocks5ParserStateRequest;
+            }
+            state = GSSocks5ParserStateAuthenticationRequest;
+        }
+        case GSSocks5ParserStateAuthenticationRequest:
+        {
+            NSString *username = [configuration objectForKey:NSStreamSOCKSProxyUserKey];
+            NSString *password = [configuration objectForKey:NSStreamSOCKSProxyPasswordKey];
+            uint8_t bytes[3] = {0x5, (uint8_t)[username length], (uint8_t)[password length]};
+            NSMutableData *request = [NSMutableData dataWithCapacity:bytes[1] + bytes[2] + 3];
+            [request appendBytes:bytes length:2];
+            [request appendBytes:[username UTF8String] length:bytes[1]];
+            [request appendBytes:&bytes[2] length:1];
+            [request appendBytes:[password UTF8String] length:bytes[2]];
+            
+            state = GSSocks5ParserStateAuthenticationResponse;
+            [delegate parser:self formedRequest:request];
+            [delegate parser:self needsMoreBytes:2];
+            break;
+        }
+        case GSSocks5ParserStateAuthenticationResponse:
+        {
+            if (bytes[1]) {
+                NSError *error = [self errorWithCode:0xFF + bytes[1]
+                                         description:@"SOCKS authentication failed"];
+                [self reportError:error];
+                break;
+            }
+            state = GSSocks5ParserStateRequest;
+        }
+        GSSocks5ParserStateRequest:
+        case GSSocks5ParserStateRequest:
+        {
+            GSSocksAddressType type = [self addressType];
+            uint8_t request[4] = {
+                0x5, 0x1, 0x0, type
+            };
+            NSMutableData *data = [NSMutableData dataWithBytes:request length:4];
+            NSData *addressData = [self addressData];
+            if (type == GSSocksAddressTypeDomain) {
+                uint8_t length = (uint8_t)[addressData length];
+                [data appendBytes:&length length:1];
+            }
+            [data appendData:addressData];
+            uint16_t portWithNetworkEndianness = htons((uint16_t)port);
+            [data appendBytes:&portWithNetworkEndianness length:2];
+            
+            state = GSSocks5ParserStateResponse;
+            [delegate parser:self formedRequest:data];
+            [delegate parser:self needsMoreBytes:4];
+            break;
+        }
+        case GSSocks5ParserStateResponse:
+        {
+            if (bytes[1] != GSSocks5ResponseStatusSuccess) {
+                NSError *error = [self errorWithResponseStatus:bytes[1]];
+                [self reportError:error];
+                break;
+            }
+            addressType = bytes[3]; /* addess type */
+            if (addressType == GSSocksAddressTypeDomain) {
+                state = GSSocks5ParserStateResponseAddressLength;
+                [delegate parser:self needsMoreBytes:1];
+            } else {
+                state = GSSocks5ParserStateResponseAddressAndPort;
+                addressSize = addressType == GSSocksAddressTypeIPv4 ? 4 : 16;
+                [delegate parser:self needsMoreBytes:addressSize + 2];
+            }
+            break;
+        }
+        case GSSocks5ParserStateResponseAddressLength:
+        {
+            addressSize = bytes[0];
+            state = GSSocks5ParserStateResponseAddressAndPort;
+            [delegate parser:self needsMoreBytes:addressSize + 2];
+            break;
+        }
+        case GSSocks5ParserStateResponseAddressAndPort:
+        {
+            NSString    *bndAddress = [self addressFromData:[NSData dataWithBytes:[aChunk bytes] length:addressSize]
+                                                   withType:addressType];
+            NSUInteger  bndPort     = ntohs(*(uint16_t *)(bytes + addressSize));
+            [delegate parser:self finishedWithAddress:bndAddress port:bndPort];
+            break;
+        }
+    }
+}
+
+@end
+
+#pragma GCC diagnostic pop
\ No newline at end of file
diff --git a/Source/GSSocksParser/GSSocksParser.h b/Source/GSSocksParser/GSSocksParser.h
new file mode 100644
index 0000000..f878445
--- /dev/null
+++ b/Source/GSSocksParser/GSSocksParser.h
@@ -0,0 +1,66 @@
+/*
+ * Parsers of SOCKS protocol messages
+ * Copyright (C) 2013 Free Software Foundation, Inc.
+ *
+ * Written by Marat Ibadinov <ibadinov@me.com>
+ * Date: 2013
+ *
+ * This file is part of the GNUstep Base Library.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free
+ * Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110 USA.
+ *
+ * $Date$ $Revision$
+ */
+
+#import <Foundation/NSData.h>
+#import <Foundation/NSDictionary.h>
+#import <Foundation/NSError.h>
+#import <Foundation/NSStream.h>
+#import <Foundation/NSString.h>
+
+@class GSSocksParser;
+
+@protocol GSSocksParserDelegate <NSObject>
+
+- (void)parser:(GSSocksParser *)aParser needsMoreBytes:(NSUInteger)aLength;
+- (void)parser:(GSSocksParser *)aParser formedRequest:(NSData *)aRequest;
+- (void)parser:(GSSocksParser *)aParser finishedWithAddress:(NSString *)anAddress port:(NSUInteger)aPort;
+
+- (void)parser:(GSSocksParser *)aParser encounteredError:(NSError *)anError;
+
+@end
+
+@interface GSSocksParser : NSObject {
+    NSDictionary                *configuration;
+    NSString                    *address;
+    id<GSSocksParserDelegate>   delegate;
+    NSUInteger                  port;
+}
+
+- (id)initWithConfiguration:(NSDictionary *)aConfiguration
+                    address:(NSString *)anAddress
+                       port:(NSUInteger)aPort;
+
+- (id<GSSocksParserDelegate>)delegate;
+- (void)setDelegate:(id<GSSocksParserDelegate>)aDelegate;
+
+- (NSString *)address;
+- (NSUInteger)port;
+
+- (void)start;
+- (void)parseNextChunk:(NSData *)aChunk;
+
+@end
\ No newline at end of file
diff --git a/Source/GSSocksParser/GSSocksParser.m b/Source/GSSocksParser/GSSocksParser.m
new file mode 100644
index 0000000..2439c1d
--- /dev/null
+++ b/Source/GSSocksParser/GSSocksParser.m
@@ -0,0 +1,112 @@
+/*
+ * Parsers of SOCKS protocol messages
+ * Copyright (C) 2013 Free Software Foundation, Inc.
+ *
+ * Written by Marat Ibadinov <ibadinov@me.com>
+ * Date: 2013
+ *
+ * This file is part of the GNUstep Base Library.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free
+ * Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110 USA.
+ *
+ * $Date$ $Revision$
+ */
+
+#import "GSSocksParser.h"
+#import "GSSocks4Parser.h"
+#import "GSSocks5Parser.h"
+#import <Foundation/NSException.h>
+
+@interface NSObject (SubclassResponsibility)
+- subclassResponsibility:(SEL)aSelector;
+@end
+
+@implementation GSSocksParser
+
+- (id)init
+{
+    if (self = [super init]) {
+        configuration = nil;
+        address = nil;
+        delegate = nil;
+        port = 0;
+    }
+    return self;
+}
+
+- (id)initWithConfiguration:(NSDictionary *)aConfiguration
+                    address:(NSString *)anAddress
+                       port:(NSUInteger)aPort
+{
+    NSString *version = [aConfiguration objectForKey:NSStreamSOCKSProxyVersionKey];
+    version = version ? version : NSStreamSOCKSProxyVersion5;
+    
+    [self release];
+    
+    Class concreteClass;
+    if ([version isEqualToString:NSStreamSOCKSProxyVersion5]) {
+        concreteClass = [GSSocks5Parser class];
+    } else if ([version isEqualToString:NSStreamSOCKSProxyVersion4]) {
+        concreteClass = [GSSocks4Parser class];
+    } else {
+        [NSException raise:NSInternalInconsistencyException format:@"Unsupported socks verion: %@", version];
+    }
+    return [[concreteClass alloc] initWithConfiguration:aConfiguration
+                                                address:anAddress 
+                                                   port:aPort];
+}
+
+- (void)dealloc
+{
+    [delegate release];
+    [address release];
+    [configuration release];
+    [super dealloc];
+}
+
+- (id<GSSocksParserDelegate>)delegate
+{
+    return delegate;
+}
+
+- (void)setDelegate:(id<GSSocksParserDelegate>)aDelegate
+{
+    id previous = delegate;
+    delegate = [aDelegate retain];
+    [previous release];
+}
+
+- (NSString *)address
+{
+    return address;
+}
+
+- (NSUInteger)port
+{
+    return port;
+}
+
+- (void)start
+{
+    [self subclassResponsibility:_cmd];
+}
+
+- (void)parseNextChunk:(NSData *)aChunk
+{
+    [self subclassResponsibility:_cmd];
+}
+
+@end
\ No newline at end of file
diff --git a/Source/GSSocksParser/GSSocksParserPrivate.h b/Source/GSSocksParser/GSSocksParserPrivate.h
new file mode 100644
index 0000000..b8ba576
--- /dev/null
+++ b/Source/GSSocksParser/GSSocksParserPrivate.h
@@ -0,0 +1,46 @@
+/*
+ * Parsers of SOCKS protocol messages
+ * Copyright (C) 2013 Free Software Foundation, Inc.
+ *
+ * Written by Marat Ibadinov <ibadinov@me.com>
+ * Date: 2013
+ *
+ * This file is part of the GNUstep Base Library.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free
+ * Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110 USA.
+ *
+ * $Date$ $Revision$
+ */
+
+#import "GSSocksParser.h"
+
+typedef enum GSSocksAddressType {
+    GSSocksAddressTypeIPv4     = 0x1,
+    GSSocksAddressTypeIPv6     = 0x4,
+    GSSocksAddressTypeDomain   = 0x3,
+} GSSocksAddressType;
+
+@interface GSSocksParser (Private)
+
+- (NSError *)errorWithCode:(NSInteger)aCode description:(NSString *)aDescription;
+
+
+- (GSSocksAddressType)addressType;
+
+- (NSData *)addressData;
+- (NSString *)addressFromData:(NSData *)aData withType:(GSSocksAddressType)anAddressType;
+
+@end
\ No newline at end of file
diff --git a/Source/GSSocksParser/GSSocksParserPrivate.m b/Source/GSSocksParser/GSSocksParserPrivate.m
new file mode 100644
index 0000000..098acea
--- /dev/null
+++ b/Source/GSSocksParser/GSSocksParserPrivate.m
@@ -0,0 +1,145 @@
+/*
+ * Parsers of SOCKS protocol messages
+ * Copyright (C) 2013 Free Software Foundation, Inc.
+ *
+ * Written by Marat Ibadinov <ibadinov@me.com>
+ * Date: 2013
+ *
+ * This file is part of the GNUstep Base Library.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free
+ * Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110 USA.
+ *
+ * $Date$ $Revision$
+ */
+
+#import "GSSocksParserPrivate.h"
+#import <Foundation/NSArray.h>
+#import <Foundation/NSBundle.h>
+#import <Foundation/NSCharacterSet.h>
+#import <stdio.h>
+
+@implementation NSString (GSSocksParser)
+
+- (NSString *)stringByRepeatingCurrentString:(NSUInteger)times
+{
+    return [@"" stringByPaddingToLength:times * [self length] withString:self startingAtIndex:0];
+}
+
+@end
+
+@implementation GSSocksParser (Private)
+
+- (NSError *)errorWithCode:(NSInteger)aCode description:(NSString *)aDescription
+{
+    NSDictionary *userInfo = [NSDictionary dictionaryWithObject:NSLocalizedString(aDescription, @"")
+                                                         forKey:NSLocalizedDescriptionKey];
+    return [NSError errorWithDomain:NSStreamSOCKSErrorDomain code:aCode userInfo:userInfo];
+}
+
+- (GSSocksAddressType)addressType
+{
+    if ([address length] > 16) {
+        return GSSocksAddressTypeDomain;
+    }
+    const char *cAddress = [address UTF8String];
+    NSUInteger index = 0;
+    BOOL hasAlpha = NO, hasDot = NO;
+    char character;
+    while ((character = cAddress[index])) {
+        BOOL isAlpha = character >= 'a' && character <= 'f';
+        if (!(character >= '0' && character <= '9') && !isAlpha && character != '.' && character != ':') {
+            return GSSocksAddressTypeDomain;
+        }
+        hasAlpha    = hasAlpha  || isAlpha;
+        hasDot      = hasDot    || character == '.';
+        ++index;
+    }
+    return hasAlpha && hasDot ? GSSocksAddressTypeDomain : (hasDot ? GSSocksAddressTypeIPv4 : GSSocksAddressTypeIPv6);
+}
+
+- (NSData *)addressData
+{
+    switch ([self addressType]) {
+        case GSSocksAddressTypeIPv4:
+        {
+            NSMutableData *result = [NSMutableData dataWithLength:4];
+            const char *cString = [address UTF8String];
+            uint8_t *bytes = [result mutableBytes];
+            sscanf(cString, "%hhu.%hhu.%hhu.%hhu", &bytes[0], &bytes[1], &bytes[2], &bytes[3]);
+            return result;
+        }
+        case GSSocksAddressTypeIPv6:
+        {
+            NSArray *components = [address componentsSeparatedByString:@"::"];
+            
+            if ([components count] == 2) {
+                NSString *leading = [components objectAtIndex:0];
+                NSString *trailing = [components objectAtIndex:1];
+                NSCharacterSet *charset = [NSCharacterSet characterSetWithCharactersInString:@":"];
+                NSUInteger leadingCount = [leading length] ? [[leading componentsSeparatedByCharactersInSet:charset] count] : 0;
+                NSUInteger trailingCount = [trailing length] ? [[leading componentsSeparatedByCharactersInSet:charset] count] : 0;
+                
+                if (leadingCount && trailingCount) {
+                    NSString *middle = [@"0:" stringByRepeatingCurrentString:8 - leadingCount - trailingCount];
+                    address = [[[leading stringByAppendingString:@":"] stringByAppendingString:middle] stringByAppendingString:trailing];
+                } else if (!leadingCount) {
+                    NSString *start = [@"0:" stringByRepeatingCurrentString:8 - trailingCount];
+                    address = [start stringByAppendingString:trailing];
+                } else {
+                    NSString *end = [@":0" stringByRepeatingCurrentString:8 - leadingCount];
+                    address = [leading stringByAppendingString:end];        
+                }
+            }
+            
+            NSMutableData *result = [NSMutableData dataWithLength:16];
+            uint16_t *bytes = [result mutableBytes];
+            sscanf([address UTF8String], "%hx:%hx:%hx:%hx:%hx:%hx:%hx:%hx",
+                   &bytes[0], &bytes[1], &bytes[2], &bytes[3],
+                   &bytes[4], &bytes[5], &bytes[6], &bytes[7]);
+            return result;
+        }
+        case GSSocksAddressTypeDomain:
+        {
+            return [address dataUsingEncoding:NSUTF8StringEncoding];
+        }
+    }
+}
+
+- (NSString *)addressFromData:(NSData *)aData withType:(GSSocksAddressType)anAddressType
+{
+    switch (anAddressType) {
+        case GSSocksAddressTypeIPv4:
+        {
+            const uint8_t *bytes = [aData bytes];
+            return [NSString stringWithFormat:@"%hhu.%hhu.%hhu.%hhu",
+                    bytes[0], bytes[1], bytes[2], bytes[3]];
+        }
+        case GSSocksAddressTypeIPv6:
+        {
+            const uint16_t *bytes = [aData bytes];
+            return [NSString stringWithFormat:@"%hx:%hx:%hx:%hx:%hx:%hx:%hx:%hx",
+                    bytes[0], bytes[1], bytes[2], bytes[3],
+                    bytes[4], bytes[5], bytes[6], bytes[7]];
+        }
+        case GSSocksAddressTypeDomain:
+        {
+            return [[[NSString alloc] initWithData:aData encoding:NSUTF8StringEncoding] autorelease];
+        }
+    }
+}
+
+
+@end
\ No newline at end of file
diff --git a/Source/GSSorting.h b/Source/GSSorting.h
index dada026..8d6ba03 100644
--- a/Source/GSSorting.h
+++ b/Source/GSSorting.h
@@ -152,8 +152,7 @@ GSCompareUsingDescriptorOrComparator(id first, id second, id descOrComp,
         return CALL_BLOCK(((NSComparator)descOrComp), first, second);
 
       case GSComparisonTypeFunction:
-        return ((NSInteger (*)(id, id, void *))descOrComp)(first,
-          second, context);
+        return (NSComparisonResult)((NSInteger (*)(id, id, void *))descOrComp)(first, second, context);
 
       default:
         [NSException raise: @"NSInternalInconstitencyException"
diff --git a/Source/GSStream.h b/Source/GSStream.h
index d87c4fe..0782fe3 100644
--- a/Source/GSStream.h
+++ b/Source/GSStream.h
@@ -123,11 +123,16 @@ IVARS
 - (void) _schedule;
 
 /**
- * send an event to delegate
+ * schedule an event message to delegate
  */
 - (void) _sendEvent: (NSStreamEvent)event;
 
 /**
+ * actually dispatch event message to delegate
+ */
+- (void) _dispatchEvent: (NSNumber *)anEvent;
+
+/**
  * setter for IO event reference (file descriptor, file handle etc )
  */
 - (void) _setLoopID: (void *)ref;
@@ -181,9 +186,9 @@ IVARS
 @interface GSBufferOutputStream : GSOutputStream
 {
 @private
-  uint8_t	*_buffer;
-  unsigned	_capacity;
-  unsigned long _pointer;
+  uint8_t       *_buffer;
+  NSUInteger	_capacity;
+  NSUInteger    _pointer;
 }
 @end
 
diff --git a/Source/GSStream.m b/Source/GSStream.m
index 7fac3f7..bf4ce80 100644
--- a/Source/GSStream.m
+++ b/Source/GSStream.m
@@ -366,6 +366,10 @@ static RunLoopEventType typeForStream(NSStream *aStream)
 {
 }
 
+- (void) _dispatchEvent: (NSNumber *)anEvent
+{
+}
+
 - (void) _setLoopID: (void *)ref
 {
 }
@@ -428,7 +432,7 @@ static RunLoopEventType typeForStream(NSStream *aStream)
   enumerator = NSEnumerateMapTable(_loops);
   while (NSNextMapEnumeratorPair(&enumerator, (void **)(&k), (void**)&v))
     {
-      unsigned	i = [v count];
+      NSUInteger	i = [v count];
 
       while (i-- > 0)
 	{
@@ -438,94 +442,57 @@ static RunLoopEventType typeForStream(NSStream *aStream)
   NSEndMapTableEnumeration(&enumerator);
 }
 
-- (void) _sendEvent: (NSStreamEvent)event
+- (void) _scheduleEvent: (NSStreamEvent)anEvent
 {
-  if (event == NSStreamEventNone)
-    {
-      return;
-    }
-  else if (event == NSStreamEventOpenCompleted)
-    {
-      if ((_events & event) == 0)
-	{
-	  _events |= NSStreamEventOpenCompleted;
-	  if (_delegateValid == YES)
-	    {
-	      [_delegate stream: self
-		    handleEvent: NSStreamEventOpenCompleted];
-	    }
-	}
-    }
-  else if (event == NSStreamEventHasBytesAvailable)
-    {
-      if ((_events & NSStreamEventOpenCompleted) == 0)
-	{
-	  _events |= NSStreamEventOpenCompleted;
-	  if (_delegateValid == YES)
-	    {
-	      [_delegate stream: self
-		    handleEvent: NSStreamEventOpenCompleted];
-	    }
-	}
-      if ((_events & NSStreamEventHasBytesAvailable) == 0)
-	{
-	  _events |= NSStreamEventHasBytesAvailable;
-	  if (_delegateValid == YES)
-	    {
-	      [_delegate stream: self
-		    handleEvent: NSStreamEventHasBytesAvailable];
-	    }
-	}
-    }
-  else if (event == NSStreamEventHasSpaceAvailable)
-    {
-      if ((_events & NSStreamEventOpenCompleted) == 0)
-	{
-	  _events |= NSStreamEventOpenCompleted;
-	  if (_delegateValid == YES)
-	    {
-	      [_delegate stream: self
-		    handleEvent: NSStreamEventOpenCompleted];
-	    }
-	}
-      if ((_events & NSStreamEventHasSpaceAvailable) == 0)
-	{
-	  _events |= NSStreamEventHasSpaceAvailable;
-	  if (_delegateValid == YES)
-	    {
-	      [_delegate stream: self
-		    handleEvent: NSStreamEventHasSpaceAvailable];
-	    }
-	}
-    }
-  else if (event == NSStreamEventErrorOccurred)
-    {
-      if ((_events & NSStreamEventErrorOccurred) == 0)
-	{
-	  _events |= NSStreamEventErrorOccurred;
-	  if (_delegateValid == YES)
-	    {
-	      [_delegate stream: self
-		    handleEvent: NSStreamEventErrorOccurred];
-	    }
-	}
-    }
-  else if (event == NSStreamEventEndEncountered)
-    {
-      if ((_events & NSStreamEventEndEncountered) == 0)
+  NSRunLoop *currentRunLoop = [NSRunLoop currentRunLoop];
+  NSArray *modes = (NSArray *)NSMapGet(_loops, (void *)currentRunLoop);
+  [currentRunLoop performSelector:@selector(_dispatchEvent:)
+                           target:self
+                         argument:[NSNumber numberWithUnsignedInteger:anEvent]
+                            order:0
+                            modes:modes];
+}
+
+- (void) _dispatchEvent:(NSNumber *)anEvent
+{
+  NSStreamEvent event = (NSStreamEvent)[anEvent unsignedIntegerValue];
+  if ((_events & event) == 0)
 	{
-	  _events |= NSStreamEventEndEncountered;
-	  if (_delegateValid == YES)
+      _events |= event;
+      if (_delegateValid == YES)
 	    {
-	      [_delegate stream: self
-		    handleEvent: NSStreamEventEndEncountered];
+          [_delegate stream:self handleEvent:event];
 	    }
 	}
-    }
-  else
-    {
-      [NSException raise: NSInvalidArgumentException
-		  format: @"Unknown event (%d) passed to _sendEvent:", event];
+}
+
+- (void) _sendEvent: (NSStreamEvent)event
+{
+  switch (event)
+    {
+      case NSStreamEventNone:
+        {
+          break;
+        }
+      case NSStreamEventErrorOccurred:
+      case NSStreamEventOpenCompleted:
+      case NSStreamEventEndEncountered:
+        {
+          [self _scheduleEvent:event];
+          break;
+        }
+      case NSStreamEventHasBytesAvailable:
+      case NSStreamEventHasSpaceAvailable:
+        {
+          [self _scheduleEvent:NSStreamEventOpenCompleted];
+          [self _scheduleEvent:event];
+          break;
+        }
+      default:
+        {
+          [NSException raise:NSInvalidArgumentException
+                      format:@"Unknown event (%lu) passed to _sendEvent:", (unsigned long)event];
+        }
     }
 }
 
@@ -558,7 +525,7 @@ static RunLoopEventType typeForStream(NSStream *aStream)
   enumerator = NSEnumerateMapTable(_loops);
   while (NSNextMapEnumeratorPair(&enumerator, (void **)(&k), (void**)&v))
     {
-      unsigned	i = [v count];
+      NSUInteger	i = [v count];
 
       while (i-- > 0)
 	{
diff --git a/Source/GSString.m b/Source/GSString.m
index ec24e12..fc9b149 100644
--- a/Source/GSString.m
+++ b/Source/GSString.m
@@ -33,6 +33,31 @@
    Boston, MA 02111 USA.
 */
 
+/*
+ * Constant string class references
+ */
+
+#if __APPLE__
+#if __OBJC2__
+Class _NSConstantStringClassReference;
+#else
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
+struct objc_class _NSConstantStringClassReference;
+#pragma GCC diagnostic pop
+#endif /* __OBJC2__ */
+#endif /* __APPLE__ */
+
+#if __LP64__
+int __CFConstantStringClassReference[24] = {0};
+#else
+int __CFConstantStringClassReference[12] = {0};
+#endif
+
+/*
+ * GSString implementation
+ */
+
 #import "common.h"
 #import "Foundation/NSCoder.h"
 #import "Foundation/NSArray.h"
@@ -71,16 +96,21 @@ static BOOL isByteEncoding(NSStringEncoding enc)
 }
 
 #ifdef NeXT_RUNTIME
-/* Used by the Darwin/NeXT ObjC Runtime
-   until Apple Radar 2870817 is fixed. */
-struct objc_class _NSConstantStringClassReference;
+#ifndef __OBJC2__
+  /* Used by the Darwin/NeXT ObjC Runtime
+   * until Apple Radar 2870817 is fixed. 
+   */
+  struct objc_class _NSConstantStringClassReference;
+#else
+  Class _NSConstantStringClassReference;
+#endif
 #endif
 
 /* Determine the length of the UTF-8 string as a unicode (UTF-16) string.
  * sets the ascii flag according to the content found.
  */
 static NSUInteger
-lengthUTF8(const uint8_t *p, unsigned l, BOOL *ascii, BOOL *latin1)
+lengthUTF8(const uint8_t *p, NSUInteger l, BOOL *ascii, BOOL *latin1)
 {
   const uint8_t	*e = p + l;
   BOOL		a = YES;
@@ -201,7 +231,7 @@ lengthUTF8(const uint8_t *p, unsigned l, BOOL *ascii, BOOL *latin1)
  * is zero (meaning there is no second part of a surrogate pair remaining).
  */
 static inline unichar
-nextUTF8(const uint8_t *p, unsigned l, unsigned *o, unichar *n)
+nextUTF8(const uint8_t *p, NSUInteger l, unsigned *o, unichar *n)
 {
   unsigned	i;
 
@@ -297,159 +327,157 @@ nextUTF8(const uint8_t *p, unsigned l, unsigned *o, unichar *n)
 }
 
 static BOOL
-literalIsEqualInternal(NXConstantString *s, GSStr o)
-{
-  unsigned	len = o->_count;
-
-  /* Since UTF-8 is a multibyte character set, it must have at least
-   * as many bytes as another string of the same length. So if the
-   * UTF-8 string is shorter, the two cannot be equal.
-   * A check for this can quickly give us a result in half the cases
-   * where the two strings have different lengths.
-   */
-  if (len > s->nxcslen)
-    {
-      return NO;
-    }
-  else
-    {
-      NSUInteger	pos = 0;
-      unichar		n = 0;
-      unsigned		i = 0;
-      unichar		u;
-
-      if (0 == o->_flags.wide)
-	{
-	  /* If the other string is a buffer containing ascii characters,
-	   * we can perform a bytewise comparison.
-	   */
-	  if (internalEncoding == NSASCIIStringEncoding)
-	    {
-	      if (len == s->nxcslen
-		&& 0 == memcmp(o->_contents.c, s->nxcsptr, len))
-		{
-		  return YES;
-		}
-	      else
-		{
-		  return NO;
-		}
-	    }
-
-	  /* If the other string is a buffer containing latin1 characters,
-	   * we can compare buffer contents with unichar values directly.
-	   */
-	  if (internalEncoding == NSISOLatin1StringEncoding)
-	    {
-	      while (i < s->nxcslen || n > 0)
-		{
-		  u = nextUTF8((const uint8_t *)s->nxcsptr, s->nxcslen, &i, &n);
-		  if (pos >= len || (unichar)o->_contents.c[pos] != u)
-		    {
-		      return NO;
-		    }
-		  pos++;
-		}
-	      if (pos != len)
-		{
-		  return NO;
-		}
-	      return YES;
-	    }
-
-	  /* For any other narrow internal string, we know that ascii is
-	   * a subset of the encoding, so as long as characters are ascii
-	   * (don't have the top bit set) we can do bytewise comparison.
-	   */
-	  if (len == s->nxcslen)
-	    {
-	      unsigned	index;
-
-	      for (index = 0; index < len; index++)
-		{
-		  uint8_t	c = s->nxcsptr[index];
-
-		  if (c != o->_contents.c[index] || c >= 128)
-		    {
-		      /* Characters differ at this point.
-		       */
-		      break;
-		    }
-		}
-	      if (index == len)
-		{
-		  return YES;
-		}
-	      /* The characters were the same up to 'index', so we won't
-	       * need to recheck those first few characters.
-	       */
-	      pos = i = index;
-	    }
-	}
-
-      /* For small strings, or ones where we already have an array of
-       * UTF-16 characters, we can do a UTF-16 comparison directly.
-       * For larger strings, we may do as well with a character by
-       * character comparison.
-       */
-      if (1 == o->_flags.wide || (len < 200 && pos < len))
-	{
-	  unichar	*ptr;
-
-	  if (1 == o->_flags.wide)
-	    {
-	      ptr = o->_contents.u;
-	    }
-	  else
-	    {
-	      ptr = alloca(sizeof(unichar) * len);
-	      if (NO == GSToUnicode(&ptr, &len, o->_contents.c,
-		len, internalEncoding, 0, 0))
-		{
-		  return NO;
-		}
-	    }
-
-	  /* Now we have a UTF-16 buffer, so we can do a UTF-16 comparison.
-	   */
-	  while (i < s->nxcslen || n > 0)
-	    {
-	      u = nextUTF8((const uint8_t *)s->nxcsptr, s->nxcslen, &i, &n);
-	      if (pos >= len || ptr[pos] != u)
-		{
-		  return NO;
-		}
-	      pos++;
-	    }
-	}
-      else
-	{
-	  unichar	(*imp)(id, SEL, NSUInteger);
-
-	  /* Do a character by character comparison using characterAtIndex:
-	   * This will be relatively slow, but how often will we actually
-	   * need to do this for a literal string?  Most string literals will
-	   * either be short or will differ from any other string we are
-	   * doing a comparison with within the first few tens of characters.
-	   */
-	  imp = (unichar(*)(id,SEL,NSUInteger))[(id)o methodForSelector:
-	    @selector(characterAtIndex:)];
-	  while (i < s->nxcslen || n > 0)
-	    {
-	      u = nextUTF8((const uint8_t *)s->nxcsptr, s->nxcslen, &i, &n);
-	      if (pos >= len
-		|| (*imp)((id)o, @selector(characterAtIndex:), pos) != u)
-		{
-		  return NO;
-		}
-	      pos++;
-	    }
-	}
-      if (pos != len)
-	{
-	  return NO;
-	}
-      return YES;
+literalIsEqualInternal(NSConstantString *s, GSStr o)
+{
+    NSUInteger len = o->_count;
+    
+    /* Since UTF-8 is a multibyte character set, it must have at least
+     * as many bytes as another string of the same length. So if the
+     * UTF-8 string is shorter, the two cannot be equal.
+     * A check for this can quickly give us a result in half the cases
+     * where the two strings have different lengths.
+     */
+    if (len > s->numBytes)
+    {
+        return NO;
+    }
+    else
+    {
+        NSUInteger	pos = 0;
+        unichar		n = 0;
+        unsigned		i = 0;
+        unichar		u;
+        
+        if (0 == o->_flags.wide)
+        {
+            /* If the other string is a buffer containing ascii characters,
+             * we can perform a bytewise comparison.
+             */
+            if (internalEncoding == NSASCIIStringEncoding)
+            {
+                if (len == s->numBytes && 0 == memcmp(o->_contents.c, s->bytes, len))
+                {
+                    return YES;
+                }
+                else
+                {
+                    return NO;
+                }
+            }
+            
+            /* If the other string is a buffer containing latin1 characters,
+             * we can compare buffer contents with unichar values directly.
+             */
+            if (internalEncoding == NSISOLatin1StringEncoding)
+            {
+                while (i < s->numBytes || n > 0)
+                {
+                    u = nextUTF8((const uint8_t *)s->bytes, s->numBytes, &i, &n);
+                    if (pos >= len || (unichar)o->_contents.c[pos] != u)
+                    {
+                        return NO;
+                    }
+                    pos++;
+                }
+                if (pos != len)
+                {
+                    return NO;
+                }
+                return YES;
+            }
+            
+            /* For any other narrow internal string, we know that ascii is
+             * a subset of the encoding, so as long as characters are ascii
+             * (don't have the top bit set) we can do bytewise comparison.
+             */
+            if (len == s->numBytes)
+            {
+                unsigned	index;
+                
+                for (index = 0; index < len; index++)
+                {
+                    uint8_t	c = s->bytes[index];
+                    
+                    if (c != o->_contents.c[index] || c >= 128)
+                    {
+                        /* Characters differ at this point.
+                         */
+                        break;
+                    }
+                }
+                if (index == len)
+                {
+                    return YES;
+                }
+                /* The characters were the same up to 'index', so we won't
+                 * need to recheck those first few characters.
+                 */
+                pos = i = index;
+            }
+        }
+        
+        /* For small strings, or ones where we already have an array of
+         * UTF-16 characters, we can do a UTF-16 comparison directly.
+         * For larger strings, we may do as well with a character by
+         * character comparison.
+         */
+        if (1 == o->_flags.wide || (len < 200 && pos < len))
+        {
+            unichar	*ptr;
+            
+            if (1 == o->_flags.wide)
+            {
+                ptr = o->_contents.u;
+            }
+            else
+            {
+                ptr = alloca(sizeof(unichar) * len);
+                if (NO == GSToUnicode(&ptr, &len, o->_contents.c,
+                                      len, internalEncoding, 0, 0))
+                {
+                    return NO;
+                }
+            }
+            
+            /* Now we have a UTF-16 buffer, so we can do a UTF-16 comparison.
+             */
+            while (i < s->numBytes || n > 0)
+            {
+                u = nextUTF8((const uint8_t *)s->bytes, s->numBytes, &i, &n);
+                if (pos >= len || ptr[pos] != u)
+                {
+                    return NO;
+                }
+                pos++;
+            }
+        }
+        else
+        {
+            unichar	(*imp)(id, SEL, NSUInteger);
+            
+            /* Do a character by character comparison using characterAtIndex:
+             * This will be relatively slow, but how often will we actually
+             * need to do this for a literal string?  Most string literals will
+             * either be short or will differ from any other string we are
+             * doing a comparison with within the first few tens of characters.
+             */
+            imp = (unichar(*)(id,SEL,NSUInteger))[(id)o methodForSelector:@selector(characterAtIndex:)];
+            while (i < s->numBytes || n > 0)
+            {
+                u = nextUTF8((const uint8_t *)s->bytes, s->numBytes, &i, &n);
+                if (pos >= len
+                    || (*imp)((id)o, @selector(characterAtIndex:), pos) != u)
+                {
+                    return NO;
+                }
+                pos++;
+            }
+        }
+        if (pos != len)
+        {
+            return NO;
+        }
+        return YES;
     }
 }
 
@@ -665,7 +693,7 @@ setup(BOOL rerun)
       GSCSubStringClass = [GSCSubString class];
       GSUnicodeSubStringClass = [GSUnicodeSubString class];
       GSMutableStringClass = [GSMutableString class];
-      NSConstantStringClass = [NXConstantString class];
+      NSConstantStringClass = [NSConstantString class];
 
       /*
        * Cache some selectors and method implementations for
@@ -690,7 +718,7 @@ setup(BOOL rerun)
 }
 
 static GSCInlineString*
-newCInline(unsigned length, NSZone *zone)
+newCInline(NSUInteger length, NSZone *zone)
 {
   GSCInlineString *me;
 
@@ -705,7 +733,7 @@ newCInline(unsigned length, NSZone *zone)
 }
 
 static GSUInlineString*
-newUInline(unsigned length, NSZone *zone)
+newUInline(NSUInteger length, NSZone *zone)
 {
   GSUInlineString *me;
 
@@ -722,7 +750,7 @@ newUInline(unsigned length, NSZone *zone)
 /* Predeclare a few functions
  */
 static void GSStrWiden(GSStr s);
-static void getCString_u(GSStr self, char *buffer, unsigned int maxLength,
+static void getCString_u(GSStr self, char *buffer, NSUInteger maxLength,
   NSRange aRange, NSRange *leftoverRange);
 
 #if defined(OBJC_SMALL_OBJECT_SHIFT) && (OBJC_SMALL_OBJECT_SHIFT == 3)
@@ -837,9 +865,9 @@ static void logTinyStringCount(void)
  * Constructs a tiny string.
  */
 static id
-createTinyString(const char *str, int length)
+createTinyString(const char *str, NSUInteger length)
 {
-  unsigned int i;
+  NSUInteger i;
   uintptr_t s = TINY_STRING_MASK;
 
   /* No tiny string support detected at run time, give up
@@ -877,7 +905,7 @@ createTinyString(const char *str, int length)
 }
 #else
 static id
-createTinyString(const char *str, int length)
+createTinyString(const char *str, NSUInteger length)
 {
   return nil;
 }
@@ -931,7 +959,7 @@ fixBOM(unsigned char **bytes, NSUInteger*length, BOOL *owned,
   NSStringEncoding encoding)
 {
   unsigned char	*b = *bytes;
-  unsigned	len = *length;
+  NSUInteger	len = *length;
 
   if (encoding == NSUnicodeStringEncoding && *length >= 2
     && ((b[0] == 0xFE && b[1] == 0xFF) || (b[0] == 0xFF && b[1] == 0xFE)))
@@ -1217,11 +1245,10 @@ fixBOM(unsigned char **bytes, NSUInteger*length, BOOL *owned,
    */
   if (encoding != NSUnicodeStringEncoding)
     {
-      unichar	*u = 0;
-      unsigned	l = 0;
+      unichar   *u = 0;
+      NSUInteger l = 0;
 
-      if (GSToUnicode(&u, &l, chars.c, length, encoding,
-	[self zone], 0) == NO)
+      if (GSToUnicode(&u, &l, chars.c, length, encoding, [self zone], 0) == NO)
 	{
 	  if (flag == YES && chars.c != 0)
 	    {
@@ -1350,7 +1377,9 @@ fixBOM(unsigned char **bytes, NSUInteger*length, BOOL *owned,
    * Now set up 'f' as a GSMutableString object whose initial buffer is
    * allocated on the stack.  The GSPrivateFormat function can write into it.
    */
-  f = (GSStr)alloca(class_getInstanceSize(GSMutableStringClass));
+  size_t instanceSize = class_getInstanceSize(GSMutableStringClass);
+  f = (GSStr)alloca(instanceSize);
+  memset(f, 0, instanceSize);
   object_setClass(f, GSMutableStringClass);
   f->_zone = NSDefaultMallocZone();
   f->_contents.c = buf;
@@ -1400,9 +1429,9 @@ fixBOM(unsigned char **bytes, NSUInteger*length, BOOL *owned,
  */
 - (id) initWithString: (NSString*)string
 {
-  unsigned	length;
-  Class		c;
-  GSStr		me;
+  NSUInteger  length;
+  Class       c;
+  GSStr       me;
 
   if (string == nil)
     [NSException raise: NSInvalidArgumentException
@@ -1493,7 +1522,7 @@ UTF8String_c(GSStr self)
     }
   if (internalEncoding == NSASCIIStringEncoding)
     {
-      unsigned	i = self->_count;
+      NSUInteger i = self->_count;
 
       r = (unsigned char*)GSAutoreleasedBuffer(self->_count+1);
       while (i-- > 0)
@@ -1504,9 +1533,9 @@ UTF8String_c(GSStr self)
     }
   else
     {
-      unichar	*u = 0;
-      unsigned	l = 0;
-      unsigned	s = 0;
+      unichar   *u = 0;
+      NSUInteger l = 0;
+      NSUInteger s = 0;
 
       /*
        * We must convert from internal format to unicode and then to
@@ -1534,7 +1563,7 @@ UTF8String_c(GSStr self)
 static inline const char*
 UTF8String_u(GSStr self)
 {
-  unsigned	c = self->_count;
+  NSUInteger c = self->_count;
 
   if (c == 0)
     {
@@ -1542,7 +1571,7 @@ UTF8String_u(GSStr self)
     }
   else
     {
-      unsigned int	l = 0;
+      NSUInteger     l = 0;
       unsigned char	*r = 0;
 
       if (GSFromUnicode(&r, &l, self->_contents.u, c, NSUTF8StringEncoding,
@@ -1558,8 +1587,8 @@ UTF8String_u(GSStr self)
 static inline BOOL
 boolValue_c(GSStr self)
 {
-  unsigned  c = self->_count;
-  unsigned  i;
+  NSUInteger c = self->_count;
+  NSUInteger i;
 
   for (i = 0; i < c; i++)
     {
@@ -1580,8 +1609,8 @@ boolValue_c(GSStr self)
 static inline BOOL
 boolValue_u(GSStr self)
 {
-  unsigned  c = self->_count;
-  unsigned  i;
+  NSUInteger c = self->_count;
+  NSUInteger i;
 
   for (i = 0; i < c; i++)
     {
@@ -1606,7 +1635,7 @@ boolValue_u(GSStr self)
 static inline BOOL
 canBeConvertedToEncoding_c(GSStr self, NSStringEncoding enc)
 {
-  unsigned	c = self->_count;
+  NSUInteger c = self->_count;
   BOOL		result = YES;
 
   /*
@@ -1622,8 +1651,8 @@ canBeConvertedToEncoding_c(GSStr self, NSStringEncoding enc)
     && enc != NSUnicodeStringEncoding
     && ((internalEncoding != NSASCIIStringEncoding) || !isByteEncoding(enc)))
     {
-      unsigned	l = 0;
-      unichar	*r = 0;
+      NSUInteger l = 0;
+      unichar   *r = 0;
 
       /*
        * To check whether conversion is possible, we first convert to
@@ -1670,7 +1699,7 @@ canBeConvertedToEncoding_c(GSStr self, NSStringEncoding enc)
 	    }
 	  else
 	    {
-	      unsigned	dummy = 0;	// Hold returned length.
+	      NSUInteger dummy = 0;	// Hold returned length.
 
 	      result = GSFromUnicode(0, &dummy, r, l, enc, 0, GSUniStrict);
 	    }
@@ -1685,7 +1714,7 @@ canBeConvertedToEncoding_c(GSStr self, NSStringEncoding enc)
 static inline BOOL
 canBeConvertedToEncoding_u(GSStr self, NSStringEncoding enc)
 {
-  unsigned	c = self->_count;
+  NSUInteger c = self->_count;
   BOOL		result = YES;
 
   if (c > 0)
@@ -1735,7 +1764,7 @@ canBeConvertedToEncoding_u(GSStr self, NSStringEncoding enc)
 	    }
 	  else
 	    {
-	      unsigned	dummy = 0;	// Hold returned length.
+	      NSUInteger dummy = 0;	// Hold returned length.
 
 	      result = GSFromUnicode(0, &dummy, self->_contents.u, c, enc,
 		0, GSUniStrict);
@@ -1746,7 +1775,7 @@ canBeConvertedToEncoding_u(GSStr self, NSStringEncoding enc)
 }
 
 static inline unichar
-characterAtIndex_c(GSStr self, unsigned index)
+characterAtIndex_c(GSStr self, NSUInteger index)
 {
   unichar	u;
 
@@ -1756,8 +1785,8 @@ characterAtIndex_c(GSStr self, unsigned index)
   if (u > 127)
     {
       unsigned char	c = (unsigned char)u;
-      unsigned int	s = 1;
-      unichar		*d = &u;
+      NSUInteger    s = 1;
+      unichar      *d = &u;
 
       GSToUnicode(&d, &s, &c, 1, internalEncoding, 0, 0);
     }
@@ -1765,7 +1794,7 @@ characterAtIndex_c(GSStr self, unsigned index)
 }
 
 static inline unichar
-characterAtIndex_u(GSStr self,unsigned index)
+characterAtIndex_u(GSStr self, NSUInteger index)
 {
   if (index >= self->_count)
     [NSException raise: NSRangeException format: @"Invalid index."];
@@ -1773,7 +1802,7 @@ characterAtIndex_u(GSStr self,unsigned index)
 }
 
 static inline NSComparisonResult
-compare_c(GSStr self, NSString *aString, unsigned mask, NSRange aRange)
+compare_c(GSStr self, NSString *aString, NSUInteger mask, NSRange aRange)
 {
   Class	c;
 
@@ -1789,7 +1818,7 @@ compare_c(GSStr self, NSString *aString, unsigned mask, NSRange aRange)
 }
 
 static inline NSComparisonResult
-compare_u(GSStr self, NSString *aString, unsigned mask, NSRange aRange)
+compare_u(GSStr self, NSString *aString, NSUInteger mask, NSRange aRange)
 {
   Class	c;
 
@@ -1825,7 +1854,7 @@ cString_c(GSStr self, NSStringEncoding enc)
     }
   else if (enc == NSUnicodeStringEncoding)
     {
-      unsigned	l = 0;
+      NSUInteger l = 0;
 
       /*
        * The external C string encoding  is unicode ... convert to it.
@@ -1840,9 +1869,9 @@ cString_c(GSStr self, NSStringEncoding enc)
     }
   else
     {
-      unichar	*u = 0;
-      unsigned	l = 0;
-      unsigned	s = 0;
+      unichar   *u = 0;
+      NSUInteger l = 0;
+      NSUInteger s = 0;
 
       /*
        * The external C string encoding is not compatible with the internal
@@ -1871,7 +1900,7 @@ cString_c(GSStr self, NSStringEncoding enc)
 static inline const char*
 cString_u(GSStr self, NSStringEncoding enc)
 {
-  unsigned	c = self->_count;
+  NSUInteger c = self->_count;
 
   if (c == 0)
     {
@@ -1880,12 +1909,12 @@ cString_u(GSStr self, NSStringEncoding enc)
   else if (enc == NSUnicodeStringEncoding)
     {
       unichar	*tmp;
-      unsigned	l;
+      NSUInteger l;
 
       if ((l = GSUnicode(self->_contents.u, c, 0, 0)) != c)
 	{
 	  [NSException raise: NSCharacterConversionException
-		      format: @"NSString is not legal UTF-16 at %u", l];
+		      format: @"NSString is not legal UTF-16 at %lu", (unsigned long)l];
 	}
       tmp = (unichar*)NSZoneMalloc(NSDefaultMallocZone(), (c + 1)*2);
       memcpy(tmp, self->_contents.u, c*2);
@@ -1897,7 +1926,7 @@ cString_u(GSStr self, NSStringEncoding enc)
     }
   else
     {
-      unsigned int	l = 0;
+      NSUInteger     l = 0;
       unsigned char	*r = 0;
 
       if (GSFromUnicode(&r, &l, self->_contents.u, c, enc,
@@ -1910,7 +1939,7 @@ cString_u(GSStr self, NSStringEncoding enc)
     }
 }
 
-static inline unsigned int
+static inline NSUInteger
 cStringLength_c(GSStr self, NSStringEncoding enc)
 {
   if (enc == internalEncoding)
@@ -1931,8 +1960,8 @@ cStringLength_c(GSStr self, NSStringEncoding enc)
       else
 	{
 	  unichar	*u = 0;
-	  unsigned	l = 0;
-	  unsigned	s = 0;
+	  NSUInteger l = 0;
+	  NSUInteger s = 0;
 
 	  if (GSToUnicode(&u, &l, self->_contents.c, self->_count,
 	    internalEncoding, NSDefaultMallocZone(), 0) == NO)
@@ -1952,10 +1981,10 @@ cStringLength_c(GSStr self, NSStringEncoding enc)
     }
 }
 
-static inline unsigned int
+static inline NSUInteger
 cStringLength_u(GSStr self, NSStringEncoding enc)
 {
-  unsigned	c = self->_count;
+  NSUInteger c = self->_count;
 
   if (c == 0)
     {
@@ -1963,7 +1992,7 @@ cStringLength_u(GSStr self, NSStringEncoding enc)
     }
   else
     {
-      unsigned	l = 0;
+      NSUInteger l = 0;
 
       if (GSFromUnicode(0, &l, self->_contents.u, c, enc, 0, GSUniStrict) == NO)
 	{
@@ -1977,7 +2006,7 @@ cStringLength_u(GSStr self, NSStringEncoding enc)
 static inline NSData*
 dataUsingEncoding_c(GSStr self, NSStringEncoding encoding, BOOL lossy)
 {
-  unsigned	len = self->_count;
+  NSUInteger len = self->_count;
 
   if (len == 0)
     {
@@ -1996,7 +2025,7 @@ dataUsingEncoding_c(GSStr self, NSStringEncoding encoding, BOOL lossy)
     }
   else if (encoding == NSUnicodeStringEncoding)
     {
-      unsigned int	l = 0;
+      NSUInteger l = 0;
       unichar		*r = 0;
       unsigned int	options = GSUniBOM;
 
@@ -2014,10 +2043,10 @@ dataUsingEncoding_c(GSStr self, NSStringEncoding encoding, BOOL lossy)
     }
   else
     {
-      unichar		*u = 0;
-      unsigned		l = 0;
+      unichar       *u = 0;
+      NSUInteger     l = 0;
       unsigned char	*r = 0;
-      unsigned		s = 0;
+      NSUInteger     s = 0;
 
       if (GSToUnicode(&u, &l, self->_contents.c, self->_count, internalEncoding,
 	NSDefaultMallocZone(), 0) == NO)
@@ -2039,7 +2068,7 @@ dataUsingEncoding_c(GSStr self, NSStringEncoding encoding, BOOL lossy)
 static inline NSData*
 dataUsingEncoding_u(GSStr self, NSStringEncoding encoding, BOOL lossy)
 {
-  unsigned	len = self->_count;
+  NSUInteger len = self->_count;
 
   if (len == 0)
     {
@@ -2049,9 +2078,9 @@ dataUsingEncoding_u(GSStr self, NSStringEncoding encoding, BOOL lossy)
   if (encoding == NSUnicodeStringEncoding)
     {
       unichar	*buff;
-      unsigned	l;
-      unsigned	from = 0;
-      unsigned	to = 1;
+      NSUInteger l;
+      NSUInteger from = 0;
+      NSUInteger to = 1;
 
       if ((l = GSUnicode(self->_contents.u, len, 0, 0)) != len)
         {
@@ -2090,7 +2119,7 @@ dataUsingEncoding_u(GSStr self, NSStringEncoding encoding, BOOL lossy)
   else
     {
       unsigned char	*r = 0;
-      unsigned int	l = 0;
+      NSUInteger     l = 0;
 
       if (GSFromUnicode(&r, &l, self->_contents.u, self->_count, encoding,
 	NSDefaultMallocZone(), (lossy == NO) ? GSUniStrict : 0) == NO)
@@ -2101,8 +2130,6 @@ dataUsingEncoding_u(GSStr self, NSStringEncoding encoding, BOOL lossy)
     }
 }
 
-extern BOOL GSScanDouble(unichar*, unsigned, double*);
-
 static inline double
 doubleValue_c(GSStr self)
 {
@@ -2119,10 +2146,10 @@ doubleValue_c(GSStr self)
     }
   else
     {
-      unsigned	s = 99;
-      unichar	b[100];
-      unichar	*u = b;
-      double	d = 0.0;
+      NSUInteger  s = 99;
+      unichar     b[100];
+      unichar     *u = b;
+      double      d = 0.0;
 
       /* use static buffer unless string is really long, in which case
        * we use the stack to allocate a bigger one.
@@ -2161,7 +2188,7 @@ doubleValue_u(GSStr self)
 }
 
 static inline void
-fillHole(GSStr self, unsigned index, unsigned size)
+fillHole(GSStr self, NSUInteger index, NSUInteger size)
 {
   NSCAssert(size > 0, @"size <= zero");
   NSCAssert(index + size <= self->_count, @"index + size > length");
@@ -2184,7 +2211,7 @@ fillHole(GSStr self, unsigned index, unsigned size)
 static inline void
 getCharacters_c(GSStr self, unichar *buffer, NSRange aRange)
 {
-  unsigned	len = aRange.length;
+  NSUInteger len = aRange.length;
 
   if (!len)
     return;
@@ -2205,11 +2232,11 @@ getCharacters_u(GSStr self, unichar *buffer, NSRange aRange)
 }
 
 static void
-getCString_c(GSStr self, char *buffer, unsigned int maxLength,
+getCString_c(GSStr self, char *buffer, NSUInteger maxLength,
   NSRange aRange, NSRange *leftoverRange)
 {
   GSMutableString *o;
-  int len;
+  NSUInteger      len;
 
   if (maxLength > self->_count)
     {
@@ -2294,13 +2321,13 @@ getCString_c(GSStr self, char *buffer, unsigned int maxLength,
 }
 
 static void
-getCString_u(GSStr self, char *buffer, unsigned int maxLength,
+getCString_u(GSStr self, char *buffer, NSUInteger maxLength,
   NSRange aRange, NSRange *leftoverRange)
 {
   /* The primitive we have for converting from unicode, GSFromUnicode,
   can't deal with our leftoverRange case, so we need to use a bit of
   complexity instead. */
-  unsigned int len;
+  NSUInteger len;
 
   /* TODO: this is an extremely ugly hack to work around buggy iconvs
   that return -1/E2BIG for buffers larger than 0x40000acf */
@@ -2334,7 +2361,7 @@ getCString_u(GSStr self, char *buffer, unsigned int maxLength,
   /* The string can be converted, but not all of it. Do a binary search
   to find the longest subrange that fits in the buffer. */
   {
-    unsigned int lo, hi, mid;
+    NSUInteger lo, hi, mid;
 
     lo = 0;
     hi = aRange.length;
@@ -2376,7 +2403,7 @@ getCString_u(GSStr self, char *buffer, unsigned int maxLength,
 }
 
 static inline BOOL
-getCStringE_c(GSStr self, char *buffer, unsigned int maxLength,
+getCStringE_c(GSStr self, char *buffer, NSUInteger maxLength,
   NSStringEncoding enc)
 {
   if (buffer == 0)
@@ -2387,8 +2414,8 @@ getCStringE_c(GSStr self, char *buffer, unsigned int maxLength,
     {
       if (maxLength >= sizeof(unichar))
 	{
-	  unsigned	bytes = maxLength - sizeof(unichar);
-	  unichar	*u = (unichar*)(void*)buffer;
+	  NSUInteger  bytes = maxLength - sizeof(unichar);
+	  unichar     *u = (unichar*)(void*)buffer;
 
 	  if (GSToUnicode(&u, &bytes, self->_contents.c, self->_count,
 	    internalEncoding, NSDefaultMallocZone(), GSUniTerminate) == NO)
@@ -2408,7 +2435,7 @@ getCStringE_c(GSStr self, char *buffer, unsigned int maxLength,
     {
       if (maxLength > sizeof(char))
 	{
-	  unsigned	bytes = maxLength - sizeof(char);
+	  NSUInteger bytes = maxLength - sizeof(char);
 
 	  if (enc == internalEncoding)
 	    {
@@ -2488,9 +2515,9 @@ getCStringE_c(GSStr self, char *buffer, unsigned int maxLength,
 	    }
 	  else
 	    {
-	      unichar		*u = 0;
+	      unichar   *u = 0;
 	      unsigned char	*c = (unsigned char*)buffer;
-	      unsigned		l = 0;
+	      NSUInteger l = 0;
 
 	      /*
 	       * The specified C string encoding is not compatible with
@@ -2526,14 +2553,14 @@ getCStringE_c(GSStr self, char *buffer, unsigned int maxLength,
 }
 
 static inline BOOL
-getCStringE_u(GSStr self, char *buffer, unsigned int maxLength,
+getCStringE_u(GSStr self, char *buffer, NSUInteger maxLength,
   NSStringEncoding enc)
 {
   if (enc == NSUnicodeStringEncoding)
     {
       if (maxLength >= sizeof(unichar))
 	{
-	  unsigned	bytes = maxLength - sizeof(unichar);
+	  NSUInteger bytes = maxLength - sizeof(unichar);
 
 	  if (bytes/sizeof(unichar) > self->_count)
 	    {
@@ -2555,8 +2582,8 @@ getCStringE_u(GSStr self, char *buffer, unsigned int maxLength,
 	{
 	  if (enc == NSISOLatin1StringEncoding)
 	    {
-	      unsigned	bytes = maxLength - sizeof(char);
-	      unsigned	i;
+	      NSUInteger bytes = maxLength - sizeof(char);
+	      NSUInteger i;
 
 	      if (bytes > self->_count)
 		{
@@ -2581,8 +2608,8 @@ getCStringE_u(GSStr self, char *buffer, unsigned int maxLength,
 	    }
 	  else if (enc == NSASCIIStringEncoding)
 	    {
-	      unsigned	bytes = maxLength - sizeof(char);
-	      unsigned	i;
+	      NSUInteger bytes = maxLength - sizeof(char);
+	      NSUInteger i;
 
 	      if (bytes > self->_count)
 		{
@@ -2638,12 +2665,12 @@ intValue_c(GSStr self)
     }
   else
     {
-      unsigned int	l = (end - ptr) < 32 ? (end - ptr) : 31;
-      char		buf[32];
+      NSUInteger len = (end - ptr) < 32 ? (end - ptr) : 31;
+      char buf[32];
 
-      memcpy(buf, ptr, l);
-      buf[l] = '\0';
-      return atol((const char*)buf);
+      memcpy(buf, ptr, len);
+      buf[len] = '\0';
+      return atoi((const char*)buf);
     }
 }
 
@@ -2663,12 +2690,12 @@ intValue_u(GSStr self)
     }
   else
     {
-      unsigned int	l = (end - ptr) < 32 ? (end - ptr) : 31;
-      unsigned char	buf[32];
+      NSUInteger    l = (end - ptr) < 32 ? (end - ptr) : 31;
+      unsigned char buf[32];
       unsigned char	*b = buf;
 
       GSFromUnicode(&b, &l, ptr, l, internalEncoding, 0, GSUniTerminate);
-      return atol((const char*)buf);
+      return atoi((const char*)buf);
     }
 }
 
@@ -2690,9 +2717,9 @@ isEqual_c(GSStr self, id anObject)
       return NO;
     }
   c = object_getClass(anObject);
-  if (c == NSConstantStringClass)
+  if (GSObjCIsKindOf(c, NSConstantStringClass))
     {
-      return literalIsEqualInternal((NXConstantString*)anObject, (GSStr)self);
+      return literalIsEqualInternal((NSConstantString *)anObject, (GSStr)self);
     }
   if (c == GSMutableStringClass || GSObjCIsKindOf(c, GSStringClass) == YES)
     {
@@ -2703,9 +2730,9 @@ isEqual_c(GSStr self, id anObject)
        * First see if the hash is the same - if not, we can't be equal.
        */
       if (self->_flags.hash == 0)
-        self->_flags.hash = (*hashImp)((id)self, hashSel);
+        self->_flags.hash = (unsigned)(*hashImp)((id)self, hashSel);
       if (other->_flags.hash == 0)
-        other->_flags.hash = (*hashImp)((id)other, hashSel);
+        other->_flags.hash = (unsigned)(*hashImp)((id)other, hashSel);
       if (self->_flags.hash != other->_flags.hash)
 	return NO;
 
@@ -2753,9 +2780,9 @@ isEqual_u(GSStr self, id anObject)
       return NO;
     }
   c = object_getClass(anObject);
-  if (c == NSConstantStringClass)
+  if (GSObjCIsKindOf(c, NSConstantStringClass))
     {
-      return literalIsEqualInternal((NXConstantString*)anObject, (GSStr)self);
+      return literalIsEqualInternal((NSConstantString *)anObject, (GSStr)self);
     }
   if (c == GSMutableStringClass || GSObjCIsKindOf(c, GSStringClass) == YES)
     {
@@ -2766,9 +2793,9 @@ isEqual_u(GSStr self, id anObject)
        * First see if the hash is the same - if not, we can't be equal.
        */
       if (self->_flags.hash == 0)
-        self->_flags.hash = (*hashImp)((id)self, hashSel);
+        self->_flags.hash = (unsigned)(*hashImp)((id)self, hashSel);
       if (other->_flags.hash == 0)
-        other->_flags.hash = (*hashImp)((id)other, hashSel);
+        other->_flags.hash = (unsigned)(*hashImp)((id)other, hashSel);
       if (self->_flags.hash != other->_flags.hash)
 	return NO;
 
@@ -2818,9 +2845,9 @@ lossyCString_c(GSStr self)
     }
   else
     {
-      unichar	*u = 0;
-      unsigned	l = 0;
-      unsigned	s = 0;
+      unichar   *u = 0;
+      NSUInteger l = 0;
+      NSUInteger s = 0;
 
       /*
        * The external C string encoding is not compatible with the internal
@@ -2849,7 +2876,7 @@ lossyCString_c(GSStr self)
 static inline const char*
 lossyCString_u(GSStr self)
 {
-  unsigned	l = 0;
+  NSUInteger     l = 0;
   unsigned char	*r = 0;
 
   GSFromUnicode(&r, &l, self->_contents.u, self->_count, externalEncoding,
@@ -2857,9 +2884,9 @@ lossyCString_u(GSStr self)
   return (const char*)r;
 }
 
-static void GSStrMakeSpace(GSStr s, unsigned size)
+static void GSStrMakeSpace(GSStr s, NSUInteger size)
 {
-  unsigned	want;
+  NSUInteger want;
 
   want = size + s->_count + 1;
   s->_capacity += s->_capacity/2;
@@ -2924,8 +2951,8 @@ static void GSStrMakeSpace(GSStr s, unsigned size)
 
 static void GSStrWiden(GSStr s)
 {
-  unichar	*tmp = 0;
-  unsigned	len = 0;
+  unichar   *tmp = 0;
+  NSUInteger len = 0;
 
   NSCAssert(s->_flags.wide == 0, @"string is not wide");
 
@@ -2980,7 +3007,7 @@ static void GSStrWiden(GSStr s)
 }
 
 static inline void
-makeHole(GSStr self, unsigned int index, unsigned int size)
+makeHole(GSStr self, NSUInteger index, NSUInteger size)
 {
   NSCAssert(size > 0, @"size < zero");
   NSCAssert(index <= self->_count, @"index > length");
@@ -3011,43 +3038,43 @@ makeHole(GSStr self, unsigned int index, unsigned int size)
 }
 
 static inline NSRange
-rangeOfSequence_c(GSStr self, unsigned anIndex)
+rangeOfSequence_c(const char *buffer, NSUInteger size, NSUInteger anIndex)
 {
-  if (anIndex >= self->_count)
+  if (anIndex >= size)
     [NSException raise: NSRangeException format:@"Invalid location."];
 
   return (NSRange){anIndex, 1};
 }
 
 static inline NSRange
-rangeOfSequence_u(GSStr self, unsigned anIndex)
+rangeOfSequence_u(unichar *buffer, NSUInteger size, NSUInteger anIndex)
 {
-  unsigned	start;
-  unsigned	end;
+  NSUInteger start;
+  NSUInteger end;
 
-  if (anIndex >= self->_count)
+  if (anIndex >= size)
     [NSException raise: NSRangeException format:@"Invalid location."];
 
   start = anIndex;
-  while (uni_isnonsp(self->_contents.u[start]) && start > 0)
+  while (uni_isnonsp(buffer[start]) && start > 0)
     start--;
   end = start + 1;
-  if (end < self->_count)
-    while ((end < self->_count) && (uni_isnonsp(self->_contents.u[end])))
+  if (end < size)
+    while ((end < size) && (uni_isnonsp(buffer[end])))
       end++;
   return (NSRange){start, end-start};
 }
 
 static inline NSRange
-rangeOfCharacter_c(GSStr self, NSCharacterSet *aSet, unsigned mask,
+rangeOfCharacter_c(GSStr self, NSCharacterSet *aSet, NSUInteger mask,
   NSRange aRange)
 {
-  int		i;
-  int		start;
-  int		stop;
-  int		step;
-  NSRange	range;
-  BOOL		(*mImp)(id, SEL, unichar);
+  NSUInteger  i;
+  NSUInteger  start;
+  NSUInteger  stop;
+  NSUInteger  step;
+  NSRange     range;
+  BOOL (*mImp)(id, SEL, unichar);
 
   if (aSet == nil)
     [NSException raise: NSInvalidArgumentException format: @"range of nil"];
@@ -3055,56 +3082,62 @@ rangeOfCharacter_c(GSStr self, NSCharacterSet *aSet, unsigned mask,
   if ((mask & NSBackwardsSearch) == NSBackwardsSearch)
     {
       start = NSMaxRange(aRange) - 1;
-      stop = aRange.location - 1;
+      stop = aRange.location;
       step = -1;
     }
   else
     {
       start = aRange.location;
-      stop = NSMaxRange(aRange);
+      stop = NSMaxRange(aRange) - 1;
       step = 1;
     }
   range.location = NSNotFound;
   range.length = 0;
-
-  mImp = (BOOL(*)(id,SEL,unichar))
-    [aSet methodForSelector: cMemberSel];
-
-  for (i = start; i != stop; i += step)
+  
+  if (aRange.length)
     {
-      unichar u = self->_contents.c[i];
+      mImp = (BOOL(*)(id,SEL,unichar)) [aSet methodForSelector: cMemberSel];
 
-      if (u > 127 && internalEncoding != NSISOLatin1StringEncoding)
-	{
-	  unsigned char	c = (unsigned char)u;
-	  unsigned int	s = 1;
-	  unichar	*d = &u;
+      for (i = start; ; i += step)
+        {
+          unichar u = self->_contents.c[i];
 
-	  GSToUnicode(&d, &s, &c, 1, internalEncoding, 0, 0);
-	}
-      /* FIXME ... what about UTF-16 sequences of more than one 16bit value
-       * corresponding to a single UCS-32 codepoint?
-       */
-      if ((*mImp)(aSet, cMemberSel, u))
-	{
-	  range = NSMakeRange(i, 1);
-	  break;
-	}
+          if (u > 127 && internalEncoding != NSISOLatin1StringEncoding)
+            {
+              unsigned char	c = (unsigned char)u;
+              NSUInteger    s = 1;
+              unichar	*d = &u;
+
+              GSToUnicode(&d, &s, &c, 1, internalEncoding, 0, 0);
+            }
+          /* FIXME ... what about UTF-16 sequences of more than one 16bit value
+           * corresponding to a single UCS-32 codepoint?
+           */
+          if ((*mImp)(aSet, cMemberSel, u))
+            {
+              range = NSMakeRange(i, 1);
+              break;
+            }
+          if (i == stop)
+            {
+              break;
+            }
+        }
     }
 
   return range;
 }
 
 static inline NSRange
-rangeOfCharacter_u(GSStr self, NSCharacterSet *aSet, unsigned mask,
+rangeOfCharacter_u(GSStr self, NSCharacterSet *aSet, NSUInteger mask,
   NSRange aRange)
 {
-  int		i;
-  int		start;
-  int		stop;
-  int		step;
-  NSRange	range;
-  BOOL		(*mImp)(id, SEL, unichar);
+  NSUInteger  i;
+  NSUInteger  start;
+  NSUInteger  stop;
+  NSUInteger  step;
+  NSRange     range;
+  BOOL (*mImp)(id, SEL, unichar);
 
   if (aSet == nil)
     [NSException raise: NSInvalidArgumentException format: @"range of nil"];
@@ -3112,33 +3145,39 @@ rangeOfCharacter_u(GSStr self, NSCharacterSet *aSet, unsigned mask,
   if ((mask & NSBackwardsSearch) == NSBackwardsSearch)
     {
       start = NSMaxRange(aRange) - 1;
-      stop = aRange.location - 1;
+      stop = aRange.location;
       step = -1;
     }
   else
     {
       start = aRange.location;
-      stop = NSMaxRange(aRange);
+      stop = NSMaxRange(aRange) - 1;
       step = 1;
     }
   range.location = NSNotFound;
   range.length = 0;
-
-  mImp = (BOOL(*)(id,SEL,unichar))
-    [aSet methodForSelector: cMemberSel];
-
-  /* FIXME ... what about UTF-16 sequences of more than one 16bit value
-   * corresponding to a single UCS-32 codepoint?
-   */
-  for (i = start; i != stop; i += step)
+  
+  if (aRange.length)
     {
-      unichar letter = self->_contents.u[i];
+      mImp = (BOOL(*)(id,SEL,unichar)) [aSet methodForSelector: cMemberSel];
 
-      if ((*mImp)(aSet, cMemberSel, letter))
-	{
-	  range = NSMakeRange(i, 1);
-	  break;
-	}
+      /* FIXME ... what about UTF-16 sequences of more than one 16bit value
+       * corresponding to a single UCS-32 codepoint?
+       */
+      for (i = start; ; i += step)
+        {
+          unichar letter = self->_contents.u[i];
+
+          if ((*mImp)(aSet, cMemberSel, letter))
+            {
+              range = NSMakeRange(i, 1);
+              break;
+            }
+          if (i == stop)
+            {
+              break;
+            }
+        }
     }
 
   return range;
@@ -3183,7 +3222,7 @@ GSPrivateRangeOfString(NSString *receiver, NSString *target)
 }
 
 static inline NSRange
-rangeOfString_c(GSStr self, NSString *aString, unsigned mask, NSRange aRange)
+rangeOfString_c(GSStr self, NSString *aString, NSUInteger mask, NSRange aRange)
 {
   Class	c;
 
@@ -3199,7 +3238,7 @@ rangeOfString_c(GSStr self, NSString *aString, unsigned mask, NSRange aRange)
 }
 
 static inline NSRange
-rangeOfString_u(GSStr self, NSString *aString, unsigned mask, NSRange aRange)
+rangeOfString_u(GSStr self, NSString *aString, NSUInteger mask, NSRange aRange)
 {
   Class	c;
 
@@ -3369,8 +3408,8 @@ transmute(GSStr self, NSString *aString)
 {
   if (self->_flags.hash == 0)
     {
-      uint32_t	ret = 0;
-      int	len = (int)self->_count;
+      uint32_t      ret = 0;
+      NSUInteger    len = (int)self->_count;
 
       if (len > 0)
 	{
@@ -3382,12 +3421,12 @@ transmute(GSStr self, NSString *aString)
 	    }
 	  else if (len > 64)
             {
-              return (self->_flags.hash = [super hash]);
+              return (self->_flags.hash = (unsigned int)[super hash]);
             }
           else
 	    {
               unichar                   buf[64];
-              unsigned	                index;
+              NSUInteger	                index;
 	      const unsigned char	*p = self->_contents.c;
 
 	      if (internalEncoding == NSISOLatin1StringEncoding)
@@ -3405,7 +3444,7 @@ transmute(GSStr self, NSString *aString)
 
                       if (u > 127)
                         {
-                          return (self->_flags.hash = [super hash]);
+                          return (self->_flags.hash = (unsigned int)[super hash]);
                         }
                       buf[index] = u;
                     }
@@ -3427,7 +3466,7 @@ transmute(GSStr self, NSString *aString)
 	{
 	  ret = 0x0ffffffe;	/* Hash for an empty string.	*/
 	}
-      self->_flags.hash = ret;
+      self->_flags.hash = (unsigned)ret;
     }
 
   return self->_flags.hash;
@@ -3720,7 +3759,7 @@ agree, create a new GSCInlineString otherwise.
 
 - (NSRange) rangeOfComposedCharacterSequenceAtIndex: (NSUInteger)anIndex
 {
-  return rangeOfSequence_c((GSStr)self, anIndex);
+    return rangeOfSequence_c((const char *)((GSStr)self)->_contents.c, ((GSStr)self)->_count, anIndex);
 }
 
 - (NSRange) rangeOfCharacterFromSet: (NSCharacterSet*)aSet
@@ -3804,7 +3843,7 @@ agree, create a new GSCInlineString otherwise.
 }
 
 // private method for Unicode level 3 implementation
-- (int) _baseLength
+- (NSUInteger) _baseLength
 {
   return _count;
 }
@@ -4052,7 +4091,7 @@ agree, create a new GSCInlineString otherwise.
 - (id) lowercaseString
 {
   GSUInlineString	*o;
-  unsigned		i;
+  NSUInteger      i;
 
   o = [newUInline(_count, [self zone]) autorelease];
   i = _count;
@@ -4088,7 +4127,7 @@ agree, create a new GSCInlineString otherwise.
 
 - (NSRange) rangeOfComposedCharacterSequenceAtIndex: (NSUInteger)anIndex
 {
-  return rangeOfSequence_u((GSStr)self, anIndex);
+  return rangeOfSequence_u(((GSStr)self)->_contents.u, ((GSStr)self)->_count, anIndex);
 }
 
 - (NSRange) rangeOfCharacterFromSet: (NSCharacterSet*)aSet
@@ -4169,7 +4208,7 @@ agree, create a new GSCInlineString otherwise.
 - (id) uppercaseString
 {
   GSUInlineString	*o;
-  unsigned		i;
+  NSUInteger      i;
 
   o = [newUInline(_count, [self zone]) autorelease];
   i = _count;
@@ -4181,10 +4220,10 @@ agree, create a new GSCInlineString otherwise.
 }
 
 // private method for Unicode level 3 implementation
-- (int) _baseLength
+- (NSUInteger) _baseLength
 {
-  unsigned int count = 0;
-  unsigned int blen = 0;
+  NSUInteger count = 0;
+  NSUInteger blen = 0;
 
   while (count < _count)
     if (!uni_isnonsp(_contents.u[count++]))
@@ -4685,8 +4724,8 @@ NSAssert(_flags.owned == 1 && _zone != 0, NSInternalInconsistencyException);
    */
   if (encoding != NSUnicodeStringEncoding)
     {
-      unichar	*u = 0;
-      unsigned	l = 0;
+      unichar   *u = 0;
+      NSUInteger l = 0;
 
       if (GSToUnicode(&u, &l, (unsigned char*)chars, length, encoding,
 	_zone, 0) == NO)
@@ -4881,7 +4920,7 @@ NSAssert(_flags.owned == 1 && _zone != 0, NSInternalInconsistencyException);
   if (_flags.wide == 1)
     {
       GSUInlineString	*o;
-      unsigned          i;
+      NSUInteger      i;
 
       o = newUInline(_count, [self zone]);
       i = _count;
@@ -4894,7 +4933,7 @@ NSAssert(_flags.owned == 1 && _zone != 0, NSInternalInconsistencyException);
   return [super lowercaseString];
 }
 
-- (id) makeImmutableCopyOnFail: (BOOL)force
+- (id) makeImmutable
 {
 NSAssert(_flags.owned == 1 && _zone != 0, NSInternalInconsistencyException);
   if (_flags.wide == 1)
@@ -4946,9 +4985,9 @@ NSAssert(_flags.owned == 1 && _zone != 0, NSInternalInconsistencyException);
 - (NSRange) rangeOfComposedCharacterSequenceAtIndex: (NSUInteger)anIndex
 {
   if (_flags.wide == 1)
-    return rangeOfSequence_u((GSStr)self, anIndex);
+    return rangeOfSequence_u(((GSStr)self)->_contents.u, ((GSStr)self)->_count, anIndex);
   else
-    return rangeOfSequence_c((GSStr)self, anIndex);
+    return rangeOfSequence_c((const char *)((GSStr)self)->_contents.c, ((GSStr)self)->_count, anIndex);
 }
 
 - (NSRange) rangeOfCharacterFromSet: (NSCharacterSet*)aSet
@@ -4988,9 +5027,9 @@ NSAssert(_flags.owned == 1 && _zone != 0, NSInternalInconsistencyException);
 - (void) replaceCharactersInRange: (NSRange)aRange
 		       withString: (NSString*)aString
 {
-  GSStr		other = 0;
-  int		offset;
-  unsigned	length = 0;
+  GSStr       other = 0;
+  intptr_t    offset;
+  NSUInteger  length = 0;
 
   GS_RANGE_CHECK(aRange, _count);
   if (aString != nil)
@@ -5005,7 +5044,7 @@ NSAssert(_flags.owned == 1 && _zone != 0, NSInternalInconsistencyException);
 	  length = (aString == nil) ? 0 : [aString length];
 	}
     }
-  offset = length - aRange.length;
+  offset = (intptr_t)length - aRange.length;
 
   /*
    * We must change into a unicode string (if necessary) *before*
@@ -5065,8 +5104,8 @@ NSAssert(_flags.owned == 1 && _zone != 0, NSInternalInconsistencyException);
 		}
 	      else
 		{
-		  unsigned int	l = length - 1;
-		  unsigned int  size = 1;
+		  NSUInteger l = length - 1;
+		  NSUInteger size = 1;
 		  unichar	u;
 		  unsigned char *dst = &_contents.c[aRange.location + l];
 
@@ -5095,7 +5134,7 @@ NSAssert(_flags.owned == 1 && _zone != 0, NSInternalInconsistencyException);
 
 - (void) setString: (NSString*)aString
 {
-  unsigned int	len = (aString == nil) ? 0 : [aString length];
+  NSUInteger len = (aString == nil) ? 0 : [aString length];
   GSStr	other;
 
   if (len == 0)
@@ -5129,9 +5168,9 @@ NSAssert(_flags.owned == 1 && _zone != 0, NSInternalInconsistencyException);
     {
       if (other == 0)
 	{
-	  unsigned	l;
-	  unsigned	s = 1;
-	  unichar	u;
+	  NSUInteger  l;
+	  NSUInteger  s = 1;
+	  unichar     u;
 	  unsigned char	*d;
 
 	  /*
@@ -5250,7 +5289,7 @@ NSAssert(_flags.owned == 1 && _zone != 0, NSInternalInconsistencyException);
   if (_flags.wide == 1)
     {
       GSUInlineString	*o;
-      unsigned		i;
+      NSUInteger      i;
 
       o = [newUInline(_count, [self zone]) autorelease];
       i = _count;
@@ -5264,12 +5303,12 @@ NSAssert(_flags.owned == 1 && _zone != 0, NSInternalInconsistencyException);
 }
 
 // private method for Unicode level 3 implementation
-- (int) _baseLength
+- (NSUInteger) _baseLength
 {
   if (_flags.wide == 1)
     {
-      unsigned int count = 0;
-      unsigned int blen = 0;
+      NSUInteger count = 0;
+      NSUInteger blen = 0;
 
       while (count < _count)
 	if (!uni_isnonsp(_contents.u[count++]))
@@ -5285,582 +5324,734 @@ NSAssert(_flags.owned == 1 && _zone != 0, NSInternalInconsistencyException);
 
 
 static BOOL
-literalIsEqual(NXConstantString *self, id anObject)
+literalIsEqual(NSConstantString *self, id anObject)
 {
-  Class	c;
-
-  if (anObject == (id)self)
+    Class	c;
+    
+    if (anObject == (id)self)
     {
-      return YES;
+        return YES;
     }
-  if (anObject == nil)
+    if (anObject == nil)
     {
-      return NO;
+        return NO;
     }
-  if (GSObjCIsInstance(anObject) == NO)
+    if (GSObjCIsInstance(anObject) == NO)
     {
-      return NO;
+        return NO;
     }
-  c = object_getClass(anObject);
-  if (c == NSConstantStringClass)
+    c = object_getClass(anObject);
+    if (GSObjCIsKindOf(c, NSConstantStringClass))
     {
-      NXConstantString	*other = (NXConstantString*)anObject;
-
-      if (other->nxcslen != self->nxcslen
-	|| strcmp(other->nxcsptr, self->nxcsptr) != 0)
-	{
-	  return NO;
-	}
-      return YES;
+        NSConstantString *other = (NSConstantString *)anObject;
+        if (other->numBytes != self->numBytes || strcmp(other->bytes, self->bytes) != 0)
+        {
+            return NO;
+        }
+        return YES;
     }
-  else if (c == GSMutableStringClass || GSObjCIsKindOf(c, GSStringClass) == YES)
+    else if (c == GSMutableStringClass || GSObjCIsKindOf(c, GSStringClass) == YES)
     {
-      return literalIsEqualInternal(self, (GSStr)anObject);
+        return literalIsEqualInternal(self, (GSStr)anObject);
     }
-  else if (YES == [anObject isKindOfClass: NSStringClass]) // may be proxy
+    else if (YES == [anObject isKindOfClass: NSStringClass]) // may be proxy
+    {
+        unichar		(*imp)(id, SEL, NSUInteger);
+        NSUInteger	len = [anObject length];
+        NSUInteger	pos = 0;
+        unichar		n = 0;
+        unsigned		i = 0;
+        unichar		u;
+        
+        if (len > self->numBytes)
+        {
+            /* Since UTF-8 is a multibyte character set, it must have at least
+             * as many bytes as another string of the same length. So if the
+             * UTF-8 string is shorter, the two cannot be equal.
+             */
+            return NO;
+        }
+        
+        /* Do a character by character comparison using characterAtIndex:
+         */
+        imp = (unichar(*)(id,SEL,NSUInteger))[anObject methodForSelector:@selector(characterAtIndex:)];
+        while (i < self->numBytes || n > 0)
+        {
+            u = nextUTF8((const uint8_t *)self->bytes, self->numBytes, &i, &n);
+            if (pos >= len || (*imp)(anObject, @selector(characterAtIndex:), pos) != u)
+            {
+                return NO;
+            }
+            pos++;
+        }
+        if (pos != len)
+        {
+            return NO;
+        }
+        return YES;
+    }
+    return NO;
+}
+
+/**
+ * Append characters to a string.
+ */
+void
+GSPrivateStrAppendUnichars(GSStr s, const unichar *u, NSUInteger l)
+{
+  /*
+   * Make the string wide if necessary.
+   */
+  if (s->_flags.wide == 0)
     {
-      unichar		(*imp)(id, SEL, NSUInteger);
-      NSUInteger	len = [anObject length];
-      NSUInteger	pos = 0;
-      unichar		n = 0;
-      unsigned		i = 0;
-      unichar		u;
+      BOOL	widen = NO;
 
-      if (len > self->nxcslen)
+      if (internalEncoding == NSISOLatin1StringEncoding)
 	{
-	  /* Since UTF-8 is a multibyte character set, it must have at least
-	   * as many bytes as another string of the same length. So if the
-	   * UTF-8 string is shorter, the two cannot be equal.
-	   */
-	  return NO;
-	}
+	  NSUInteger	i;
 
-      /* Do a character by character comparison using characterAtIndex:
-       */
-      imp = (unichar(*)(id,SEL,NSUInteger))[anObject methodForSelector:
-	@selector(characterAtIndex:)];
-      while (i < self->nxcslen || n > 0)
+	  for (i = 0; i < l; i++)
+	    {
+	      if (u[i] > 255)
+		{
+		  widen = YES;
+		  break;
+		}
+	    }
+	}
+      else
 	{
-	  u = nextUTF8((const uint8_t *)self->nxcsptr,
-	    self->nxcslen, &i, &n);
-	  if (pos >= len
-	    || (*imp)(anObject, @selector(characterAtIndex:), pos) != u)
+	  NSUInteger	i;
+
+	  for (i = 0; i < l; i++)
 	    {
-	      return NO;
+	      if (u[i] > 127)
+		{
+		  widen = YES;
+		  break;
+		}
 	    }
-	  pos++;
 	}
-      if (pos != len)
+      if (widen == YES)
 	{
-	  return NO;
+	  GSStrWiden(s);
 	}
-      return YES;
     }
-  return NO;
-}
-
-/**
- * <p>The NXConstantString class is used by the compiler for constant
- * strings, as such its ivar layout is determined by the compiler
- * and consists of a pointer (_contents.c) and a character count
- * (_count). 
- */
-@implementation NXConstantString
 
-+ (void) initialize
-{
-  if (self == [NXConstantString class])
+  /*
+   * Make room for the characters we are appending.
+   */
+  if (s->_count + l + 1 >= s->_capacity)
+    {
+      GSStrMakeSpace(s, l);
+    }
+
+  /*
+   * Copy the characters into place.
+   */
+  if (s->_flags.wide == 1)
     {
-      NSConstantStringClass = self;
+      NSUInteger 	i;
+
+      for (i = 0; i < l; i++)
+	{
+	  s->_contents.u[s->_count++] = u[i];
+	}
+    }
+  else
+    {
+      NSUInteger 	i;
+
+      for (i = 0; i < l; i++)
+	{
+	  s->_contents.c[s->_count++] = u[i];
+	}
     }
 }
 
-- (const char*) UTF8String
+
+void
+GSPrivateStrExternalize(GSStr s)
 {
-  return nxcsptr;
+  if (s->_flags.wide == 0 && internalEncoding != externalEncoding)
+    {
+      GSStrWiden(s);
+    }
 }
 
-- (unichar) characterAtIndex: (NSUInteger)index
+
+
+
+/*
+ *
+ * Constant string implementation. todo: decouple it from GSString
+ *
+ */
+
+
+
+
+@implementation NSSimpleCString
+
+- (id)initWithBytes:(const void *)bytes
+             length:(NSUInteger)length
+           encoding:(NSStringEncoding)encoding
 {
-  NSUInteger	l = 0;
-  unichar	u;
-  unichar	n = 0;
-  unsigned	i = 0;
+    [NSException raise:NSGenericException format:@"Attempt to init a constant string"];
+    return nil;
+}
 
-  while (i < nxcslen || n > 0)
-    {
-      u = nextUTF8((const uint8_t *)nxcsptr, nxcslen, &i, &n);
-      if (l++ == index)
-	{
-	  return u;
-	}
-    }
+- (id)initWithBytesNoCopy:(void *)bytes
+                   length:(NSUInteger)length
+                 encoding:(NSStringEncoding)encoding
+             freeWhenDone:(BOOL)flag
+{
+    [NSException raise:NSGenericException format:@"Attempt to init a constant string"];
+    return nil;
+}
 
-  [NSException raise: NSInvalidArgumentException
-	      format: @"-characterAtIndex: index out of range"];
-  return 0;
+- (void)dealloc
+{
+    GSNOSUPERDEALLOC;
 }
 
-- (BOOL) canBeConvertedToEncoding: (NSStringEncoding)encoding
+- (id)retain
 {
-  /* If the string contains bad (non-utf8) data, the lengthUTF8() function
-   * will raise an exception ... we catch it and return NO in that case
-   * since this method is not expected to raise exceptions.
-   */
-  NS_DURING
+    return self;
+}
+
+- (oneway void)release
+{
+    return;
+}
+
+- (id)autorelease
+{
+    return self;
+}
+
+- (id)copyWithZone:(NSZone *)z
+{
+    return self;
+}
+
+- (NSZone*)zone
+{
+    return NSDefaultMallocZone();
+}
+
+@end
+
+@implementation NSConstantString
+
++ (void)load
+{
+#if __APPLE__
+#if __OBJC2__
+    _NSConstantStringClassReference = self;
+#else
+    memcpy(&_NSConstantStringClassReference, self, sizeof(_NSConstantStringClassReference));
+#endif /* __OBJC2__ */
+#endif /* __APPLE__ */
+}
+
+- (const char *)UTF8String
+{
+    return bytes;
+}
+
+- (NSStringEncoding)fastestEncoding
+{
+    return NSUTF8StringEncoding;
+}
+
+- (NSStringEncoding)smallestEncoding
+{
+    return NSUTF8StringEncoding;
+}
+
+- (NSUInteger)length
+{
+    return lengthUTF8((const uint8_t *)bytes, numBytes, 0, 0);
+}
+
+- (BOOL)isEqual:(id)anObject
+{
+    return literalIsEqual(self, anObject);
+}
+
+- (BOOL)isEqualToString:(NSString *)other
+{
+    return literalIsEqual(self, other);
+}
+
+- (unichar)characterAtIndex:(NSUInteger)index
+{
+    NSUInteger	l = 0;
+    unichar	u;
+    unichar	n = 0;
+    unsigned	i = 0;
+    
+    while (i < numBytes || n > 0)
     {
-      if (NSASCIIStringEncoding == encoding)
+        u = nextUTF8((const uint8_t *)bytes, numBytes, &i, &n);
+        if (l++ == index)
         {
-          BOOL	ascii;
+            return u;
+        }
+    }
+    
+    [NSException raise:NSInvalidArgumentException format:@"-characterAtIndex: index out of range"];
+    return 0;
+}
 
-          lengthUTF8((const uint8_t*)nxcsptr, nxcslen, &ascii, 0);
-          NS_VALRETURN(ascii);
+- (BOOL)canBeConvertedToEncoding:(NSStringEncoding)encoding
+{
+    /* If the string contains bad (non-utf8) data, the lengthUTF8() function
+     * will raise an exception ... we catch it and return NO in that case
+     * since this method is not expected to raise exceptions.
+     */
+    NS_DURING
+    {
+        if (NSASCIIStringEncoding == encoding)
+        {
+            BOOL	ascii;
+            
+            lengthUTF8((const uint8_t *)bytes, numBytes, &ascii, 0);
+            NS_VALRETURN(ascii);
         }
-      else if (NSISOLatin1StringEncoding == encoding)
+        else if (NSISOLatin1StringEncoding == encoding)
         {
-          BOOL	latin1;
-
-          lengthUTF8((const uint8_t*)nxcsptr, nxcslen, 0, &latin1);
-          NS_VALRETURN(latin1);
+            BOOL	latin1;
+            
+            lengthUTF8((const uint8_t *)bytes, numBytes, 0, &latin1);
+            NS_VALRETURN(latin1);
         }
-      else if (NSUTF8StringEncoding == encoding
-        || NSUnicodeStringEncoding == encoding)
+        else if (NSUTF8StringEncoding == encoding || NSUnicodeStringEncoding == encoding)
         {
-          lengthUTF8((const uint8_t*)nxcsptr, nxcslen, 0, 0);
-          NS_VALRETURN(YES);
+            lengthUTF8((const uint8_t *)bytes, numBytes, 0, 0);
+            NS_VALRETURN(YES);
         }
-      else
+        else
         {
-          id d = [self dataUsingEncoding: encoding allowLossyConversion: NO];
-
-          NS_VALRETURN(d != nil ? YES : NO);
+            id d = [self dataUsingEncoding: encoding allowLossyConversion: NO];
+            
+            NS_VALRETURN(d != nil ? YES : NO);
         }
     }
-  NS_HANDLER
+    NS_HANDLER
     {
-      return NO;
+        return NO;
     }
-  NS_ENDHANDLER
+    NS_ENDHANDLER
 }
 
-- (NSData*) dataUsingEncoding: (NSStringEncoding)encoding
-	 allowLossyConversion: (BOOL)flag
+- (NSData *)dataUsingEncoding:(NSStringEncoding)encoding allowLossyConversion:(BOOL)flag
 {
-  BOOL	        ascii;
-  BOOL	        latin1;
-  unsigned	length;
-
-  if (0 == nxcslen)
+    BOOL        ascii;
+    BOOL        latin1;
+    NSUInteger  length;
+    
+    if (0 == numBytes)
     {
-      return [NSDataClass data];
+        return [NSDataClass data];
     }
-
-  /* Check what is actually in this string ... if it's corrupt an exception
-   * is raised.
-   */
-  length = lengthUTF8((const uint8_t*)nxcsptr, nxcslen, &ascii, &latin1);
-
-  if (NSUTF8StringEncoding == encoding)
+    
+    /* Check what is actually in this string ... if it's corrupt an exception
+     * is raised.
+     */
+    length = lengthUTF8((const uint8_t *)bytes, numBytes, &ascii, &latin1);
+    
+    if (NSUTF8StringEncoding == encoding)
     {
-      /* We want utf-8, so we can just return an object pointing to the
-       * constant string data since e just checked that it's UTF8 in
-       * lengthUTF8().
-       */
-      return [NSDataClass dataWithBytesNoCopy: (void*)nxcsptr
-				       length: nxcslen
-				 freeWhenDone: NO];
+        /* We want utf-8, so we can just return an object pointing to the
+         * constant string data since e just checked that it's UTF8 in
+         * lengthUTF8().
+         */
+        return [NSDataClass dataWithBytesNoCopy:(void *)bytes length:numBytes freeWhenDone:NO];
     }
-
-  if (YES == ascii && GSPrivateIsByteEncoding(encoding))
+    
+    if (YES == ascii && GSPrivateIsByteEncoding(encoding))
     {
-      /* The constant string data is just ascii, so we can return a
-       * pointer to it directly for any encoding which has ascii as
-       * a subset.
-       */
-      return [NSDataClass dataWithBytesNoCopy: (void*)nxcsptr
-                                       length: nxcslen
-                                 freeWhenDone: NO];
+        /* The constant string data is just ascii, so we can return a
+         * pointer to it directly for any encoding which has ascii as
+         * a subset.
+         */
+        return [NSDataClass dataWithBytesNoCopy:(void *)bytes length:numBytes freeWhenDone:NO];
     }
-
-  if (YES == latin1 && NSISOLatin1StringEncoding == encoding)
+    
+    if (YES == latin1 && NSISOLatin1StringEncoding == encoding)
     {
-      unsigned	i = 0;
-      unichar	n = 0;
-      uint8_t	*b;
-
-      /* If all the characters are latin1 we can copy them efficiently.
-       */
-      b = NSAllocateCollectable(length, 0);
-      while (i < length)
+        unsigned	i = 0;
+        unichar	n = 0;
+        uint8_t	*buffer;
+        
+        /* If all the characters are latin1 we can copy them efficiently.
+         */
+        buffer = NSAllocateCollectable(length, 0);
+        while (i < length)
         {
-          b[i] = nextUTF8((const uint8_t *)nxcsptr, nxcslen, &i, &n);
+            buffer[i] = nextUTF8((const uint8_t *)bytes, numBytes, &i, &n);
         }
-      return [NSDataClass dataWithBytesNoCopy: (void*)b
-                                       length: length
-                                 freeWhenDone: YES];
+        return [NSDataClass dataWithBytesNoCopy:(void *)buffer length:length freeWhenDone:YES];
     }
-
-  return [super dataUsingEncoding: encoding allowLossyConversion: flag];
-}
-
-- (void) dealloc
-{
-  GSNOSUPERDEALLOC;
+    
+    return [super dataUsingEncoding:encoding allowLossyConversion:flag];
 }
 
-- (void) getCharacters: (unichar*)buffer
-		 range: (NSRange)aRange
+- (void)getCharacters:(unichar *)buffer range:(NSRange)aRange
 {
-  unichar	n = 0;
-  unsigned	i = 0;
-  NSUInteger	max = NSMaxRange(aRange);
-  NSUInteger	index = 0;
-
-  if (NSNotFound == aRange.location)
-    [NSException raise: NSRangeException
-                format: @"in %s, range { %u, %u } extends beyond string",
-     GSNameFromSelector(_cmd), aRange.location, aRange.length];
-
-  while (index < aRange.location && (i < nxcslen || n > 0))
+    unichar	n = 0;
+    unsigned	i = 0;
+    NSUInteger	max = NSMaxRange(aRange);
+    NSUInteger	index = 0;
+    
+    if (NSNotFound == aRange.location)
+        [NSException raise: NSRangeException
+                    format: @"in %s, range { %lu, %lu } extends beyond string",
+         GSNameFromSelector(_cmd), (unsigned long)aRange.location, (unsigned long)aRange.length];
+    
+    while (index < aRange.location && (i < numBytes || n > 0))
     {
-      nextUTF8((const uint8_t *)nxcsptr, nxcslen, &i, &n);
-      index++;
+        nextUTF8((const uint8_t *)bytes, numBytes, &i, &n);
+        index++;
     }
-  if (index == aRange.location)
+    if (index == aRange.location)
     {
-      while (index < max && (i < nxcslen || n > 0))
-	{
-	  *buffer++ = nextUTF8((const uint8_t *)nxcsptr, nxcslen, &i, &n);
-	  index++;
-	}
+        while (index < max && (i < numBytes || n > 0))
+        {
+            *buffer++ = nextUTF8((const uint8_t *)bytes, numBytes, &i, &n);
+            index++;
+        }
     }
-  if (index != max)
+    if (index != max)
     {
-      [NSException raise: NSRangeException
-		  format: @"in %s, range { %u, %u } extends beyond string",
-       GSNameFromSelector(_cmd), aRange.location, aRange.length];
+        [NSException raise: NSRangeException
+                    format: @"in %s, range { %lu, %lu } extends beyond string",
+         GSNameFromSelector(_cmd), (unsigned long)aRange.location, (unsigned long)aRange.length];
     }
 }
 
-/* Must match the implementation in NSString
+/* 
+ * Must match the implementation in NSString
  * To avoid allocating memory, we build the hash incrementally.
  */
-- (NSUInteger) hash
-{
-  if (nxcslen > 0)
-    {
-      uint32_t  s0 = 0;
-      uint32_t  s1 = 0;
-      unichar   chunk[64];
-      uint32_t	ret;
-      unichar	n = 0;
-      unsigned	i = 0;
-      int       l = 0;
-      uint32_t  t = 0;
-
-      while (i < nxcslen)
+- (NSUInteger)hash
+{
+    if (numBytes > 0)
+    {
+        uint32_t    s0 = 0;
+        uint32_t    s1 = 0;
+        unichar     chunk[64];
+        uint32_t    ret;
+        unichar     n = 0;
+        unsigned    i = 0;
+        int         l = 0;
+        uint32_t    t = 0;
+        
+        while (i < numBytes)
 	{
-	  chunk[l++] = nextUTF8((const uint8_t *)nxcsptr, nxcslen, &i, &n);
-	  if (64 == l)
+            chunk[l++] = nextUTF8((const uint8_t *)bytes, numBytes, &i, &n);
+            if (64 == l)
             {
-              GSPrivateIncrementalHash(&s0, &s1, chunk, l * sizeof(unichar));
-              t += l;
-              l = 0;
+                GSPrivateIncrementalHash(&s0, &s1, chunk, l * sizeof(unichar));
+                t += l;
+                l = 0;
             }
 	}
-      if (0 != n)
+        if (0 != n)
 	{
-	  chunk[l++] = n;	// Add final character
+            chunk[l++] = n; /* add final character */
 	}
-      if (l > 0)
+        if (l > 0)
         {
-          GSPrivateIncrementalHash(&s0, &s1, chunk, l * sizeof(unichar));
-          t += l;
+            GSPrivateIncrementalHash(&s0, &s1, chunk, l * sizeof(unichar));
+            t += l;
         }
-      ret = GSPrivateFinishHash(s0, s1, t * sizeof(unichar));
-      ret &= 0x0fffffff;
-      if (ret == 0)
+        ret = GSPrivateFinishHash(s0, s1, t * sizeof(unichar));
+        ret &= 0x0fffffff;
+        if (ret == 0)
 	{
-	  ret = 0x0fffffff;
+            ret = 0x0fffffff;
 	}
-      return ret;
-    }
-  else
-    {
-      return 0x0ffffffe;	/* Hash for an empty string.	*/
+        return ret;
+    }
+    else
+    {
+        return 0x0ffffffe; /* hash for an empty string */
+    }
+}
+
+- (NSRange)rangeOfCharacterFromSet:(NSCharacterSet *)aSet
+                           options:(NSUInteger)mask
+                             range:(NSRange)aRange
+{
+    NSUInteger	index;
+    NSUInteger	start;
+    NSUInteger	stop;
+    NSRange	range;
+    BOOL		ascii;
+    
+    index = lengthUTF8((const uint8_t *)bytes, numBytes, &ascii, 0);
+    GS_RANGE_CHECK(aRange, index);
+    
+    start = aRange.location;
+    stop = NSMaxRange(aRange);
+    
+    range.location = NSNotFound;
+    range.length = 0;
+    
+    if (stop  > start)
+    {
+        BOOL	(*mImp)(id, SEL, unichar);
+        unichar	n = 0;
+        unsigned	i = 0;
+        
+        mImp = (BOOL(*)(id,SEL,unichar))
+        [aSet methodForSelector:@selector(characterIsMember:)];
+        
+        for (index = 0; index < start; index++)
+        {
+            nextUTF8((const uint8_t *)bytes, numBytes, &i, &n);
+        }
+        if ((mask & NSBackwardsSearch) == NSBackwardsSearch)
+        {
+            unichar	buf[stop - start];
+            NSUInteger	pos = 0;
+            
+            for (pos = 0; pos + start < stop; pos++)
+            {
+                buf[pos] = nextUTF8((const uint8_t *)bytes, numBytes, &i, &n);
+            }
+            index = stop;
+            while (index-- > start)
+            {
+                if ((*mImp)(aSet, @selector(characterIsMember:), buf[--pos]))
+                {
+                    range = NSMakeRange(index, 1);
+                    break;
+                }
+            }
+        }
+        else
+        {
+            while (index < stop)
+            {
+                unichar letter;
+                
+                letter = nextUTF8((const uint8_t *)bytes, numBytes, &i, &n);
+                if ((*mImp)(aSet, @selector(characterIsMember:), letter))
+                {
+                    range = NSMakeRange(index, 1);
+                    break;
+                }
+                index++;
+            }
+        }
     }
+    
+    return range;
 }
 
-- (id) initWithBytes: (const void*)bytes
-	      length: (NSUInteger)length
-	    encoding: (NSStringEncoding)encoding
+- (NSRange)rangeOfComposedCharacterSequenceAtIndex:(NSUInteger)anIndex
 {
-  [NSException raise: NSGenericException
-	      format: @"Attempt to init a constant string"];
-  return nil;
+    NSUInteger	start = 0;
+    NSUInteger	pos = 0;
+    unichar	n = 0;
+    unsigned	i = 0;
+    unichar	u;
+    
+    /* A composed character sequence consists of a single base character
+     * followed by zero or more non-base characters.
+     */
+    while (i < numBytes || n > 0)
+    {
+        u = nextUTF8((const uint8_t *)bytes, numBytes, &i, &n);
+        if (!uni_isnonsp(u))
+        {
+            /* This may be the base character at the start of the sequence.
+             */
+            start = pos;
+        }
+        if (pos++ == anIndex)
+        {
+            /* Look ahead to see if the character at the specified index is
+             * followed by one or more non-base characters. If it is, we
+             * make the range longer before returning it.
+             */
+            while (i < numBytes || n > 0)
+            {
+                u = nextUTF8((const uint8_t *)bytes, numBytes, &i, &n);
+                if (!uni_isnonsp(u))
+                {
+                    break;
+                }
+                pos++;
+            }
+            return NSMakeRange(start, pos - start);
+        }
+    }
+    
+    [NSException raise:NSInvalidArgumentException format:@"-rangeOfComposedCharacterSequenceAtIndex: index out of range"];
+    return NSMakeRange(NSNotFound, 0);
 }
 
-- (id) initWithBytesNoCopy: (void*)bytes
-		    length: (NSUInteger)length
-		  encoding: (NSStringEncoding)encoding
-	      freeWhenDone: (BOOL)flag
-{
-  [NSException raise: NSGenericException
-	      format: @"Attempt to init a constant string"];
-  return nil;
-}
+@end
 
-- (BOOL) isEqual: (id)anObject
-{
-  return literalIsEqual(self, anObject);
-}
+@implementation NXConstantString
 
-- (BOOL) isEqualToString: (NSString*)other
-{
-  return literalIsEqual(self, other);
-}
+@end
 
-- (NSUInteger) length
+NS_INLINE BOOL
+NSCFStringIsUnicode(NSCFConstantString *self)
 {
-  return lengthUTF8((const uint8_t*)nxcsptr, nxcslen, 0, 0);
+    /* return self->flags != 1992 */
+    return ((uint8_t *)&self->flags)[0] == 0xd0;
 }
 
-- (NSRange) rangeOfCharacterFromSet: (NSCharacterSet*)aSet
-			    options: (NSUInteger)mask
-			      range: (NSRange)aRange
-{
-  NSUInteger	index;
-  NSUInteger	start;
-  NSUInteger	stop;
-  NSRange	range;
-  BOOL		ascii;
-
-  index = lengthUTF8((const uint8_t*)nxcsptr, nxcslen, &ascii, 0);
-  GS_RANGE_CHECK(aRange, index);
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wcast-align"
 
-  start = aRange.location;
-  stop = NSMaxRange(aRange);
-
-  range.location = NSNotFound;
-  range.length = 0;
-
-  if (stop  > start)
-    {
-      BOOL	(*mImp)(id, SEL, unichar);
-      unichar	n = 0;
-      unsigned	i = 0;
+NS_INLINE unichar
+NSCFStringCharacterAtIndex(NSCFConstantString *self, NSUInteger index)
+{
+    return NSCFStringIsUnicode(self) ? *(unichar *)(self->bytes + index * 2) : (unichar)self->bytes[index];
+}
 
-      mImp = (BOOL(*)(id,SEL,unichar))
-	[aSet methodForSelector: @selector(characterIsMember:)];
+#pragma GCC diagnostic pop
 
-      for (index = 0; index < start; index++)
-	{
-	  nextUTF8((const uint8_t *)nxcsptr, nxcslen, &i, &n);
-	}
-      if ((mask & NSBackwardsSearch) == NSBackwardsSearch)
-	{
-	  unichar	buf[stop - start];
-	  NSUInteger	pos = 0;
-	  
-	  for (pos = 0; pos + start < stop; pos++)
-	    {
-	      buf[pos] = nextUTF8((const uint8_t *)nxcsptr, nxcslen, &i, &n);
-	    }
-	  index = stop;
-	  while (index-- > start)
-	    {
-	      if ((*mImp)(aSet, @selector(characterIsMember:), buf[--pos]))
-		{
-		  range = NSMakeRange(index, 1);
-		  break;
-		}
-	    }
-	}
-      else
-	{
-	  while (index < stop)
-	    {
-	      unichar letter;
-
-	      letter = nextUTF8((const uint8_t *)nxcsptr, nxcslen, &i, &n);
-	      if ((*mImp)(aSet, @selector(characterIsMember:), letter))
-		{
-		  range = NSMakeRange(index, 1);
-		  break;
-		}
-	      index++;
-	    }
-	}
-    }
+@implementation NSCFConstantString
 
-  return range;
++ (void)load
+{
+    memcpy(__CFConstantStringClassReference, self, sizeof(__CFConstantStringClassReference));
 }
 
-- (NSRange) rangeOfComposedCharacterSequenceAtIndex: (NSUInteger)anIndex
+- (const char *)UTF8String
 {
-  NSUInteger	start = 0;
-  NSUInteger	pos = 0;
-  unichar	n = 0;
-  unsigned	i = 0;
-  unichar	u;
-
-  /* A composed character sequence consists of a single base character
-   * followed by zero or more non-base characters.
-   */
-  while (i < nxcslen || n > 0)
-    {
-      u = nextUTF8((const uint8_t *)nxcsptr, nxcslen, &i, &n);
-      if (!uni_isnonsp(u))
-	{
-	  /* This may be the base character at the start of the sequence.
-	   */
-	  start = pos;
-	}
-      if (pos++ == anIndex)
-	{
-	  /* Look ahead to see if the character at the specified index is
-	   * followed by one or more non-base characters. If it is, we
-	   * make the range longer before returning it.
-	   */
-	  while (i < nxcslen || n > 0)
-	    {
-	      u = nextUTF8((const uint8_t *)nxcsptr, nxcslen, &i, &n);
-	      if (!uni_isnonsp(u))
-		{
-		  break;
-		}
-	      pos++;
-	    }
-	  return NSMakeRange(start, pos - start);
-	}
-    }
-
-  [NSException raise: NSInvalidArgumentException
-    format: @"-rangeOfComposedCharacterSequenceAtIndex: index out of range"];
-  return NSMakeRange(NSNotFound, 0);
+    return NSCFStringIsUnicode(self) ? [super UTF8String] : bytes;
 }
 
-- (id) retain
+- (NSUInteger)length
 {
-  return self;
+    return numBytes; /* it contains length, but not a size */ 
 }
 
-- (oneway void) release
+- (unichar)characterAtIndex:(NSUInteger)index
 {
-  return;
+    if (index >= numBytes) {
+        [NSException raise:NSInvalidArgumentException format:@"-characterAtIndex: index out of range: %ld", (long)index];
+    }
+    return NSCFStringCharacterAtIndex(self, index);
 }
 
-- (id) autorelease
-{
-  return self;
+/* 
+ * Must match the implementation in NSString
+ * To avoid allocating memory, we build the hash incrementally.
+ */
+- (NSUInteger)hash
+{
+    if (numBytes == 0)
+    {
+        return 0x0ffffffe; /* hash for an empty string */
+    }
+    
+    NSUInteger  result;
+    unsigned    index = 0;
+    unsigned    length = 0;
+    unsigned    totalLength = 0;
+    
+    uint32_t    s0 = 0;
+    uint32_t    s1 = 0;
+    unichar     chunk[64];
+    
+    while (index < numBytes)
+    {
+        chunk[length++] = NSCFStringCharacterAtIndex(self, index);
+        if (64 == length)
+        {
+            GSPrivateIncrementalHash(&s0, &s1, chunk, length * sizeof(unichar));
+            totalLength += length;
+            length = 0;
+        }
+        ++index;
+    }
+    if (length > 0)
+    {
+        GSPrivateIncrementalHash(&s0, &s1, chunk, length * sizeof(unichar));
+        totalLength += length;
+    }
+    result = GSPrivateFinishHash(s0, s1, totalLength * sizeof(unichar));
+    
+    result &= 0x0fffffff;
+    if (result == 0)
+    {
+        result = 0x0fffffff;
+    }
+    return result;
 }
 
-- (id) copyWithZone: (NSZone*)z
+- (void)getCharacters:(unichar *)buffer range:(NSRange)aRange
 {
-  return self;
+    if (NSNotFound == aRange.location || NSMaxRange(aRange) > numBytes) {
+        [NSException raise:NSRangeException
+                    format:@"in %s, range { %lu, %lu } extends beyond string", GSNameFromSelector(_cmd), (unsigned long)aRange.location, (unsigned long)aRange.length];
+    }
+    if (NSCFStringIsUnicode(self)) {
+        memcpy(buffer, bytes + aRange.location * 2, aRange.length * 2);
+        return;
+    }
+    for (NSUInteger index = 0; index < aRange.length; ++index) {
+        buffer[index] = (unichar)bytes[aRange.location + index];
+    }
 }
 
-- (NSZone*) zone
+- (NSData *)dataUsingEncoding:(NSStringEncoding)encoding allowLossyConversion:(BOOL)flag
 {
-  return NSDefaultMallocZone();
+    if (NSCFStringIsUnicode(self)) {
+        if (encoding == NSUnicodeStringEncoding) {
+            return [NSData dataWithBytesNoCopy:(void *)bytes length:numBytes * 2 freeWhenDone:NO];
+        } 
+    } else if (GSPrivateIsByteEncoding(encoding)) {
+        return [NSData dataWithBytesNoCopy:(void *)bytes length:numBytes freeWhenDone:NO];
+    }
+    return [super dataUsingEncoding:encoding allowLossyConversion:flag];
 }
 
-- (NSStringEncoding) fastestEncoding
+- (NSStringEncoding)fastestEncoding
 {
-  return NSUTF8StringEncoding;
+    return NSCFStringIsUnicode(self) ? NSUnicodeStringEncoding : NSMacOSRomanStringEncoding;
 }
 
-- (NSStringEncoding) smallestEncoding
+- (NSStringEncoding)smallestEncoding
 {
-  return NSUTF8StringEncoding;
+    return NSCFStringIsUnicode(self) ? NSUTF8StringEncoding : NSMacOSRomanStringEncoding;
 }
 
-@end
-
-
-/**
- * Append characters to a string.
- */
-void
-GSPrivateStrAppendUnichars(GSStr s, const unichar *u, unsigned l)
+- (BOOL)isEqualToString:(NSString *)aString
 {
-  /*
-   * Make the string wide if necessary.
-   */
-  if (s->_flags.wide == 0)
-    {
-      BOOL	widen = NO;
-
-      if (internalEncoding == NSISOLatin1StringEncoding)
-	{
-	  unsigned	i;
-
-	  for (i = 0; i < l; i++)
-	    {
-	      if (u[i] > 255)
-		{
-		  widen = YES;
-		  break;
-		}
-	    }
-	}
-      else
-	{
-	  unsigned	i;
-
-	  for (i = 0; i < l; i++)
-	    {
-	      if (u[i] > 127)
-		{
-		  widen = YES;
-		  break;
-		}
-	    }
-	}
-      if (widen == YES)
-	{
-	  GSStrWiden(s);
-	}
-    }
-
-  /*
-   * Make room for the characters we are appending.
-   */
-  if (s->_count + l + 1 >= s->_capacity)
-    {
-      GSStrMakeSpace(s, l);
-    }
-
-  /*
-   * Copy the characters into place.
-   */
-  if (s->_flags.wide == 1)
-    {
-      unsigned 	i;
-
-      for (i = 0; i < l; i++)
-	{
-	  s->_contents.u[s->_count++] = u[i];
-	}
-    }
-  else
-    {
-      unsigned 	i;
-
-      for (i = 0; i < l; i++)
-	{
-	  s->_contents.c[s->_count++] = u[i];
-	}
+    if (!NSCFStringIsUnicode(self)) {
+        if (object_getClass(aString) == object_getClass(self)) {
+            NSCFConstantString *string = (NSCFConstantString *)aString;
+            if (!NSCFStringIsUnicode(string)) {
+                return string->numBytes == self->numBytes && strcmp(string->bytes, self->bytes) == 0;
+            }
+        }
     }
+    return [super isEqualToString:aString];
 }
 
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wcast-align"
 
-void
-GSPrivateStrExternalize(GSStr s)
+- (NSRange)rangeOfComposedCharacterSequenceAtIndex:(NSUInteger)anIndex
 {
-  if (s->_flags.wide == 0 && internalEncoding != externalEncoding)
-    {
-      GSStrWiden(s);
-    }
+    if (NSCFStringIsUnicode(self)) {
+        return rangeOfSequence_u((unichar *)bytes, numBytes, anIndex);
+    } else
+        return rangeOfSequence_c(bytes, numBytes, anIndex);
 }
 
+#pragma GCC diagnostic pop
+
+@end
diff --git a/Source/GSTimSort.m b/Source/GSTimSort.m
index 5e6ef79..8de53bc 100644
--- a/Source/GSTimSort.m
+++ b/Source/GSTimSort.m
@@ -96,7 +96,7 @@ internalBinarySort(id *buffer,
       NSUInteger left = min;
       NSUInteger right = start;
       id pivot = buffer[right];
-      int i = 0;
+      NSUInteger i = 0;
 
       do
         {
diff --git a/Source/GSValue.m b/Source/GSValue.m
index 7f2ca5a..e809c68 100644
--- a/Source/GSValue.m
+++ b/Source/GSValue.m
@@ -93,7 +93,7 @@ typeSize(const char* type)
   self = [super init];
   if (self != nil)
     {
-      int	size = typeSize(type);
+      ssize_t	size = typeSize(type);
 
       if (size < 0)
 	{
@@ -256,7 +256,7 @@ typeSize(const char* type)
 - (void) encodeWithCoder: (NSCoder *)coder
 {
   NSUInteger	tsize;
-  unsigned	size;
+  NSUInteger	size;
   NSMutableData	*d;
 
   size = strlen(objctype)+1;
diff --git a/Source/KVO/NSArray+KVO.m b/Source/KVO/NSArray+KVO.m
new file mode 100644
index 0000000..d1175e3
--- /dev/null
+++ b/Source/KVO/NSArray+KVO.m
@@ -0,0 +1,61 @@
+/*
+ * Implementation of GNUSTEP key value observing
+ * Copyright (C) 2013 Free Software Foundation, Inc.
+ *
+ * Written by Marat Ibadinov <ibadinov@me.com>
+ * Date: 2013
+ *
+ * This file is part of the GNUstep Base Library.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free
+ * Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110 USA.
+ *
+ * $Date$ $Revision$
+ */
+
+#import "Foundation/NSKeyValueObserving.h"
+#import "Foundation/NSException.h"
+#import "GNUstepBase/NSObject+GNUstepBase.h" /* for notImplemented: */
+
+@implementation NSArray (NSKeyValueObserverRegistration)
+
+- (void)addObserver:(NSObject *)anObserver forKeyPath:(NSString *)aPath options:(NSKeyValueObservingOptions)options context:(void *)aContext
+{
+    [NSException raise:NSInvalidArgumentException format:@"[%@ %s] is not supported. Key path: %@", self, sel_getName(_cmd), aPath];
+}
+
+- (void)removeObserver:(NSObject *)anObserver forKeyPath:(NSString *)keyPath
+{
+    [NSException raise:NSInvalidArgumentException format:@"[%@ %s] is not supported. Key path: %@", self, sel_getName(_cmd), keyPath];
+}
+
+- (void)removeObserver:(NSObject *)anObserver forKeyPath:(NSString *)keyPath context:(void *)context
+{
+    [NSException raise:NSInvalidArgumentException format:@"[%@ %s] is not supported. Key path: %@", self, sel_getName(_cmd), keyPath];
+}
+
+- (void)addObserver:(NSObject *)anObserver toObjectsAtIndexes:(NSIndexSet *)indexes forKeyPath:(NSString *)aPath options:(NSKeyValueObservingOptions)options context:(void *)aContext
+{
+    /* todo: impelement */
+    [self notImplemented:_cmd];
+}
+
+- (void)removeObserver:(NSObject *)anObserver fromObjectsAtIndexes:(NSIndexSet *)indexes forKeyPath:(NSString *)aPath
+{
+    /* todo: implement */
+    [self notImplemented:_cmd];
+}
+
+@end
\ No newline at end of file
diff --git a/Source/KVO/NSKVONotifying.h b/Source/KVO/NSKVONotifying.h
new file mode 100644
index 0000000..7adeb4a
--- /dev/null
+++ b/Source/KVO/NSKVONotifying.h
@@ -0,0 +1,34 @@
+/*
+ * Implementation of GNUSTEP key value observing
+ * Copyright (C) 2013 Free Software Foundation, Inc.
+ *
+ * Written by Marat Ibadinov <ibadinov@me.com>
+ * Date: 2013
+ *
+ * This file is part of the GNUstep Base Library.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free
+ * Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110 USA.
+ *
+ * $Date$ $Revision$
+ */
+
+#import <Foundation/Foundation.h>
+
+@interface NSKVONotifying : NSObject
+
+- (BOOL)_isNSKVONotifying;
+
+@end
\ No newline at end of file
diff --git a/Source/KVO/NSKVONotifying.m b/Source/KVO/NSKVONotifying.m
new file mode 100644
index 0000000..55a3a93
--- /dev/null
+++ b/Source/KVO/NSKVONotifying.m
@@ -0,0 +1,170 @@
+/*
+ * Implementation of GNUSTEP key value observing
+ * Copyright (C) 2013 Free Software Foundation, Inc.
+ *
+ * Written by Marat Ibadinov <ibadinov@me.com>
+ * Date: 2013
+ *
+ * This file is part of the GNUstep Base Library.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free
+ * Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110 USA.
+ *
+ * $Date$ $Revision$
+ */
+
+#import "NSKVONotifying.h"
+#import "NSKeyValueObservingPrivate.h"
+
+static NSString *CreateKeyFromSelector(SEL selector)
+{
+    const char *name = sel_getName(selector);
+    size_t prefixLength = name[0] == '_' ? 4 : 3;
+    size_t length = strlen(name) - prefixLength - 1;
+    char *key = alloca(length);
+    memcpy(key, name + prefixLength, length);
+    key[0] = tolower(key[0]);
+    return [[NSString alloc] initWithBytes:key length:length encoding:NSUTF8StringEncoding];
+}
+
+#if defined (NeXT_RUNTIME)
+
+static struct objc_super GetSuper(id self)
+{
+    return (struct objc_super){ self, class_getSuperclass(object_getClass(self)) };
+}
+
+#define InvokeSuperSetter(value)                                                \
+    do {                                                                        \
+        typedef void(*ImpType)(struct objc_super *, SEL, __typeof__(value));    \
+        struct objc_super super = GetSuper(self);                               \
+        ((ImpType)&objc_msgSendSuper)(&super, _cmd, value);                     \
+    } while (0)
+
+#else /* NeXT_RUNTIME */
+
+#define InvokeSuperSetter(value)                                                \
+    do {                                                                        \
+        typedef void(*ImpType)(id, SEL, __typeof__(value));                     \
+        ImpType imp = (ImpType)[[self class] instanceMethodForSelector:_cmd];   \
+        imp(self, _cmd, value);                                                 \
+    } while (0)
+
+#endif /* NeXT_RUNTIME */
+
+#define Setter(value)                               \
+do {                                                \
+    NSString *key = CreateKeyFromSelector(_cmd);    \
+    [self willChangeValueForKey:key];               \
+                                                    \
+    InvokeSuperSetter(value);                       \
+                                                    \
+    [self didChangeValueForKey:key];                \
+    [key release];                                  \
+} while (0)
+
+
+@implementation NSKVONotifying
+
+- (void)dealloc
+{
+    _NSKVOObjectDeallocate(self);
+    
+    object_setClass(self, [self class]);
+    [self dealloc];
+    
+    if (NO) {
+        [super dealloc];
+    }
+}
+
+- (Class)class
+{
+    return class_getSuperclass(object_getClass(self));
+}
+
+- (Class)superclass
+{
+    return class_getSuperclass(class_getSuperclass(object_getClass(self)));
+}
+
+- (BOOL)_isNSKVONotifying
+{
+    return YES;
+}
+
+- (void)_setter:(void *)value
+{
+    Setter(value);
+}
+
+- (void)_setterChar:(unsigned char)value
+{
+    Setter(value);
+}
+
+- (void)_setterDouble:(double)value
+{
+    Setter(value);
+}
+
+- (void)_setterFloat:(float)value
+{
+    Setter(value);
+}
+
+- (void)_setterInt:(unsigned int)value
+{
+    Setter(value);
+}
+
+- (void)_setterLong:(unsigned long)value
+{
+    Setter(value);
+}
+
+#if defined (_C_LNG_LNG)
+- (void)_setterLongLong:(unsigned long long)value
+{
+    Setter(value);
+}
+#endif
+
+- (void)_setterShort:(unsigned short)value
+{
+    Setter(value);
+}
+
+- (void)_setterRange:(NSRange)value
+{
+    Setter(value);
+}
+
+- (void)_setterPoint:(NSPoint)value
+{
+    Setter(value);
+}
+
+- (void)_setterSize:(NSSize)value
+{
+    Setter(value);
+}
+
+- (void)_setterRect:(NSRect)value
+{
+    Setter(value);
+}
+
+@end
\ No newline at end of file
diff --git a/Source/KVO/NSKeyValueNestedProperty.h b/Source/KVO/NSKeyValueNestedProperty.h
new file mode 100644
index 0000000..5dcd431
--- /dev/null
+++ b/Source/KVO/NSKeyValueNestedProperty.h
@@ -0,0 +1,35 @@
+/*
+ * Implementation of GNUSTEP key value observing
+ * Copyright (C) 2013 Free Software Foundation, Inc.
+ *
+ * Written by Marat Ibadinov <ibadinov@me.com>
+ * Date: 2013
+ *
+ * This file is part of the GNUstep Base Library.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free
+ * Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110 USA.
+ *
+ * $Date$ $Revision$
+ */
+
+#import "NSKeyValueProperty.h"
+
+@interface NSKeyValueNestedProperty : NSKeyValueProperty {
+    NSString *key;
+    NSString *keyPathTail;
+}
+
+@end
\ No newline at end of file
diff --git a/Source/KVO/NSKeyValueNestedProperty.m b/Source/KVO/NSKeyValueNestedProperty.m
new file mode 100644
index 0000000..b13a4dd
--- /dev/null
+++ b/Source/KVO/NSKeyValueNestedProperty.m
@@ -0,0 +1,98 @@
+/*
+ * Implementation of GNUSTEP key value observing
+ * Copyright (C) 2013 Free Software Foundation, Inc.
+ *
+ * Written by Marat Ibadinov <ibadinov@me.com>
+ * Date: 2013
+ *
+ * This file is part of the GNUstep Base Library.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free
+ * Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110 USA.
+ *
+ * $Date$ $Revision$
+ */
+
+#import "NSKeyValueNestedProperty.h"
+#import "NSKeyValueUnnestedProperty.h"
+#import "NSKeyValueObservingPrivate.h"
+
+static NSKeyValueObservingOptions const ObservingOptions = NSKeyValueObservingOptionPrior | NSKeyValueObservingOptionOld | NSKeyValueObservingOptionNew;
+
+@implementation NSKeyValueNestedProperty
+
+- (id)initWithClass:(Class)aClass keyPath:(NSString *)aPath
+{
+    if (self = [super initWithClass:aClass keyPath:aPath]) {
+        NSRange range = [aPath rangeOfString:@"."];
+        key = [[aPath substringToIndex:range.location] retain];
+        
+        NSKeyValueUnnestedProperty *property = (NSKeyValueUnnestedProperty *)_NSKVOGetPropertyWithKeyPath(aClass, key);
+        if (![property hasDependencies]) {
+            keyPathTail = [[aPath substringFromIndex:NSMaxRange(range)] retain];
+        } else
+            keyPathTail = nil;
+    }
+    return self;
+}
+
+- (void)object:(NSObject *)object didAddObservance:(NSKeyValueObservance *)observance
+{
+    [object addObserver:self forKeyPath:key options:ObservingOptions context:observance];
+    if (keyPathTail) {
+        object = [object valueForKey:key];
+        [object addObserver:self forKeyPath:keyPathTail options:ObservingOptions context:observance];
+    }
+}
+
+- (void)object:(NSObject *)object didRemoveObservance:(NSKeyValueObservance *)observance
+{
+    [object removeObserver:self forKeyPath:key context:observance];
+    if (keyPathTail) {
+        object = [object valueForKey:key];
+        [object removeObserver:self forKeyPath:keyPathTail context:observance];
+    }    
+}
+
+- (void)object:(NSObject *)object withObservance:(NSKeyValueObservance *)observance willChangeValue:(NSDictionary *)change forKeyPath:(NSString *)aPath
+{
+    observance = [observance context];
+    
+    /* if value for self.key will change, take a value of tail, otherwise it's already there */
+    if (object == [observance observable]) {
+        change = [[change mutableCopy] autorelease];
+        [(NSMutableDictionary *)change setObject:[object valueForKeyPath:keyPath] forKey:NSKeyValueChangeOldKey];
+    }
+    
+    [super object:[observance observable] withObservance:observance willChangeValue:change forKeyPath:keyPath];
+}
+
+- (void)object:(NSObject *)object withObservance:(NSKeyValueObservance *)observance didChangeValue:(NSDictionary *)change forKeyPath:(NSString *)aPath
+{
+    observance = [observance context];
+    /* if value for self.key has changed, register self as tail observer once again and take it's value */
+    if (object == [observance observable]) {
+        if (keyPathTail) {
+            [[change objectForKey:NSKeyValueChangeOldKey] removeObserver:self forKeyPath:keyPathTail context:observance];
+            [[change objectForKey:NSKeyValueChangeNewKey] addObserver:self forKeyPath:keyPathTail options:ObservingOptions context:observance];
+        }
+        change = [[change mutableCopy] autorelease];
+        [(NSMutableDictionary *)change setObject:[object valueForKeyPath:keyPath] forKey:NSKeyValueChangeNewKey];
+    }
+    
+    [super object:[observance observable] withObservance:observance didChangeValue:change forKeyPath:keyPath];
+}
+
+@end
\ No newline at end of file
diff --git a/Source/KVO/NSKeyValueObservance.h b/Source/KVO/NSKeyValueObservance.h
new file mode 100644
index 0000000..2d2b475
--- /dev/null
+++ b/Source/KVO/NSKeyValueObservance.h
@@ -0,0 +1,57 @@
+/*
+ * Implementation of GNUSTEP key value observing
+ * Copyright (C) 2013 Free Software Foundation, Inc.
+ *
+ * Written by Marat Ibadinov <ibadinov@me.com>
+ * Date: 2013
+ *
+ * This file is part of the GNUstep Base Library.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free
+ * Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110 USA.
+ *
+ * $Date$ $Revision$
+ */
+
+#import <Foundation/Foundation.h>
+
+@class NSKeyValueProperty;
+
+@interface NSKeyValueObservance : NSObject<NSLocking> {
+    NSRecursiveLock     *lock;
+    NSObject            *observer;
+    NSKeyValueProperty  *property;
+    NSObject            *observable;
+    void                *context;
+    NSMutableArray      *prior;
+    NSUInteger          options;
+    BOOL                isValid;
+}
+
+- (id)initWithObserver:(NSObject *)anObserver ofProperty:(NSKeyValueProperty *)aProperty ofObservable:(NSObject *)anObservable options:(NSKeyValueObservingOptions)someOptions context:(void *)aContext;
+
+- (NSObject *)observer;
+- (NSKeyValueProperty *)property;
+- (NSObject *)observable;
+- (void *)context;
+- (NSUInteger)options;
+
+- (BOOL)isValid;
+- (void)invalidate;
+
+- (void)pushChange:(NSDictionary *)aChange;
+- (NSDictionary *)popChange;
+
+@end
\ No newline at end of file
diff --git a/Source/KVO/NSKeyValueObservance.m b/Source/KVO/NSKeyValueObservance.m
new file mode 100644
index 0000000..4f6bfe4
--- /dev/null
+++ b/Source/KVO/NSKeyValueObservance.m
@@ -0,0 +1,130 @@
+/*
+ * Implementation of GNUSTEP key value observing
+ * Copyright (C) 2013 Free Software Foundation, Inc.
+ *
+ * Written by Marat Ibadinov <ibadinov@me.com>
+ * Date: 2013
+ *
+ * This file is part of the GNUstep Base Library.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free
+ * Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110 USA.
+ *
+ * $Date$ $Revision$
+ */
+
+#import "NSKeyValueObservance.h"
+
+NS_INLINE NSString *BooleanDescription(BOOL value)
+{
+    return value ? @"YES" : @"NO";
+}
+
+@implementation NSKeyValueObservance
+
+- (id)initWithObserver:(NSObject *)anObserver ofProperty:(NSKeyValueProperty *)aProperty ofObservable:(NSObject *)anObservable options:(NSKeyValueObservingOptions)someOptions context:(void *)aContext
+{
+    if (self = [super init]) {
+        lock = [NSRecursiveLock new];
+        observer = anObserver;
+        property = aProperty;
+        observable = anObservable;
+        options = someOptions;
+        context = aContext;
+        prior = [NSMutableArray new];
+        isValid = YES;
+    }
+    return self;
+}
+
+- (void)dealloc
+{
+    [prior release];
+    [lock release];
+    [super dealloc];
+}
+
+- (void)lock
+{
+    [lock lock];
+}
+
+- (void)unlock
+{
+    [lock unlock];
+}
+
+- (NSObject *)observer
+{
+    return observer;
+}
+
+- (NSKeyValueProperty *)property
+{
+    return property;
+}
+
+- (NSObject *)observable
+{
+    return observable;
+}
+
+- (void *)context
+{
+    return context;
+}
+
+- (NSUInteger)options
+{
+    return options;
+}
+
+- (BOOL)isValid
+{
+    return isValid;
+}
+
+- (void)invalidate
+{
+    isValid = NO;
+}
+
+- (void)pushChange:(NSDictionary *)aChange
+{
+    [prior addObject:aChange];
+}
+
+- (NSDictionary *)popChange
+{
+    NSDictionary *change = [prior lastObject];
+    if (change) {
+        [prior removeLastObject];
+    }
+    return change;
+}
+
+- (NSString *)description
+{
+    return [NSString stringWithFormat:@"<NSKeyValueObservance 0x%lx: Observer: 0x%lx, Key path: %@, Options: <New: %@, Old: %@, Prior: %@> Context: 0x%lx>",
+            (unsigned long)self,
+            (unsigned long)observer,
+            [property keyPath],
+            BooleanDescription(options & NSKeyValueObservingOptionNew),
+            BooleanDescription(options & NSKeyValueObservingOptionOld),
+            BooleanDescription(options & NSKeyValueObservingOptionPrior),
+            (unsigned long)context];
+}
+
+@end
\ No newline at end of file
diff --git a/Source/KVO/NSKeyValueObservationInfo.h b/Source/KVO/NSKeyValueObservationInfo.h
new file mode 100644
index 0000000..920e974
--- /dev/null
+++ b/Source/KVO/NSKeyValueObservationInfo.h
@@ -0,0 +1,42 @@
+/*
+ * Implementation of GNUSTEP key value observing
+ * Copyright (C) 2013 Free Software Foundation, Inc.
+ *
+ * Written by Marat Ibadinov <ibadinov@me.com>
+ * Date: 2013
+ *
+ * This file is part of the GNUstep Base Library.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free
+ * Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110 USA.
+ *
+ * $Date$ $Revision$
+ */
+
+#import "NSKeyValueObservance.h"
+#import <Foundation/Foundation.h>
+
+@interface NSKeyValueObservationInfo : NSObject {
+    NSMutableDictionary *observances;
+    NSUInteger          observanceCount;
+}
+
+- (NSArray *)observancesForKeyPath:(NSString *)keyPath;
+- (void)addObservance:(NSKeyValueObservance *)anObservance;
+- (NSKeyValueObservance *)extractObservanceWithObserver:(NSObject *)observer keyPath:(NSString *)keyPath;
+- (NSKeyValueObservance *)extractObservanceWithObserver:(NSObject *)observer keyPath:(NSString *)keyPath context:(void *)context;
+- (BOOL)hasObservances;
+
+@end
\ No newline at end of file
diff --git a/Source/KVO/NSKeyValueObservationInfo.m b/Source/KVO/NSKeyValueObservationInfo.m
new file mode 100644
index 0000000..6ae69e5
--- /dev/null
+++ b/Source/KVO/NSKeyValueObservationInfo.m
@@ -0,0 +1,104 @@
+/*
+ * Implementation of GNUSTEP key value observing
+ * Copyright (C) 2013 Free Software Foundation, Inc.
+ *
+ * Written by Marat Ibadinov <ibadinov@me.com>
+ * Date: 2013
+ *
+ * This file is part of the GNUstep Base Library.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free
+ * Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110 USA.
+ *
+ * $Date$ $Revision$
+ */
+
+#import "NSKeyValueObservationInfo.h"
+
+@implementation NSKeyValueObservationInfo
+
+- (id)init
+{
+    if (self = [super init]) {
+        observances = [NSMutableDictionary new];
+    }
+    return self;
+}
+
+- (void)dealloc
+{
+    [observances release];
+    [super dealloc];
+}
+
+- (BOOL)hasObservances
+{
+    return [observances count] != 0;
+}
+
+-(NSArray *)observancesForKeyPath:(NSString *)keyPath
+{
+    return [[[observances objectForKey:keyPath] copy] autorelease];
+}
+
+- (void)addObservance:(NSKeyValueObservance *)anObservance
+{
+    NSString *keyPath = [[anObservance property] keyPath];
+    if (![observances objectForKey:keyPath]) {
+        NSMutableArray *pathObservances = [NSMutableArray new];
+        [observances setObject:pathObservances forKey:keyPath];
+        [pathObservances release];
+    }
+    [[observances objectForKey:keyPath] addObject:anObservance];
+}
+
+- (NSKeyValueObservance *)_extractObservanceWithObserver:(NSObject *)observer keyPath:(NSString *)keyPath context:(void *)context contextMatters:(BOOL)contextMatters
+{
+    NSKeyValueObservance *result = nil;
+    NSMutableArray *pathObservances = [observances objectForKey:keyPath];
+    NSInteger count = [pathObservances count];
+    for (NSInteger index = count - 1; index >= 0; --index) {
+        NSKeyValueObservance *observance = [pathObservances objectAtIndex:index];
+        BOOL match = contextMatters ? ([observance observer] == observer && [observance context] == context) : [observance observer] == observer;
+        
+        if (match) {
+            result = [observance retain];
+            [pathObservances removeObjectAtIndex:index];
+            --count;
+            break;
+        }
+    }
+    if (!count) {
+        [observances removeObjectForKey:keyPath];
+    }
+    return [result autorelease];
+}
+
+- (NSKeyValueObservance *)extractObservanceWithObserver:(NSObject *)observer keyPath:(NSString *)keyPath
+{
+    return [self _extractObservanceWithObserver:observer keyPath:keyPath context:NULL contextMatters:NO];
+}
+
+- (NSKeyValueObservance *)extractObservanceWithObserver:(NSObject *)observer keyPath:(NSString *)keyPath context:(void *)context
+{
+    return [self _extractObservanceWithObserver:observer keyPath:keyPath context:context contextMatters:YES];
+}
+
+- (NSString *)description
+{
+    return [NSString stringWithFormat:@"<NSKeyValueObservationInfo 0x%lx> %@", (unsigned long)self, observances];
+}
+
+@end
\ No newline at end of file
diff --git a/Source/KVO/NSKeyValueObserving.m b/Source/KVO/NSKeyValueObserving.m
new file mode 100644
index 0000000..56afd4d
--- /dev/null
+++ b/Source/KVO/NSKeyValueObserving.m
@@ -0,0 +1,34 @@
+/*
+ * Implementation of GNUSTEP key value observing
+ * Copyright (C) 2013 Free Software Foundation, Inc.
+ *
+ * Written by Marat Ibadinov <ibadinov@me.com>
+ * Date: 2013
+ *
+ * This file is part of the GNUstep Base Library.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free
+ * Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110 USA.
+ *
+ * $Date$ $Revision$
+ */
+
+#import "Foundation/NSKeyValueObserving.h"
+
+NSString *const NSKeyValueChangeKindKey = @"kind";
+NSString *const NSKeyValueChangeNewKey = @"new";
+NSString *const NSKeyValueChangeOldKey = @"old";
+NSString *const NSKeyValueChangeIndexesKey = @"indexes";
+NSString *const NSKeyValueChangeNotificationIsPriorKey = @"notificationIsPrior";
\ No newline at end of file
diff --git a/Source/KVO/NSKeyValueObservingPrivate.h b/Source/KVO/NSKeyValueObservingPrivate.h
new file mode 100644
index 0000000..63dc98c
--- /dev/null
+++ b/Source/KVO/NSKeyValueObservingPrivate.h
@@ -0,0 +1,56 @@
+/*
+ * Implementation of GNUSTEP key value observing
+ * Copyright (C) 2013 Free Software Foundation, Inc.
+ *
+ * Written by Marat Ibadinov <ibadinov@me.com>
+ * Date: 2013
+ *
+ * This file is part of the GNUstep Base Library.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free
+ * Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110 USA.
+ *
+ * $Date$ $Revision$
+ */
+
+#import "NSKeyValueObservationInfo.h"
+#import "NSKeyValueProperty.h"
+
+FOUNDATION_EXPORT void NSKVODeallocateBreak(void);
+
+FOUNDATION_EXPORT void NSKeyValueNotifyObserver(id self, NSKeyValueObservance *observance, NSString *keyPath, NSDictionary *change);
+FOUNDATION_EXPORT void NSKeyValueWillChange(id self, NSString *keyPath, NSDictionary *change);
+FOUNDATION_EXPORT void NSKeyValueDidChange(id self, NSString *keyPath, NSDictionary *change);
+
+
+FOUNDATION_EXPORT void _NSKVOIntialize(void);
+FOUNDATION_EXPORT NSKeyValueProperty *_NSKVOGetPropertyWithKeyPath(Class class, NSString *keyPath);
+
+FOUNDATION_EXPORT void _NSKVOObjectDeallocate(id self);
+
+FOUNDATION_EXPORT void *_NSKVOObjectGetObservationInfo(id self);
+FOUNDATION_EXPORT void _NSKVOObjectSetObservationInfo(id self, void *observationInfo);
+
+/*
+ * has selector as it's second argument just to match a sigature
+ * of -[NSObject addObserver:forKeyPath:options:context:]
+ */
+FOUNDATION_EXPORT void _NSKVOObjectAddObervance(id self, SEL _cmd, NSObject *observer, NSString *keyPath, NSKeyValueObservingOptions options, void *context);
+FOUNDATION_EXPORT void _NSKVOObjectRemoveObservance(id self, BOOL contextMatters, NSObject *observer, NSString *keyPath, void *context);
+
+
+FOUNDATION_EXPORT void _NSKVORegisterUnnestedProperty(Class class, NSString *key, NSArray *affectingKeyPaths);
+FOUNDATION_EXPORT void _NSKVOEnableAutomaticNotificationForKey(Class class, NSString *key);
+FOUNDATION_EXPORT Class _NSKVOGetNotifyingSubclassOfClass(Class class);
\ No newline at end of file
diff --git a/Source/KVO/NSKeyValueObservingPrivate.m b/Source/KVO/NSKeyValueObservingPrivate.m
new file mode 100644
index 0000000..e1a5cc0
--- /dev/null
+++ b/Source/KVO/NSKeyValueObservingPrivate.m
@@ -0,0 +1,409 @@
+/*
+ * Implementation of GNUSTEP key value observing
+ * Copyright (C) 2013 Free Software Foundation, Inc.
+ *
+ * Written by Marat Ibadinov <ibadinov@me.com>
+ * Date: 2013
+ *
+ * This file is part of the GNUstep Base Library.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free
+ * Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110 USA.
+ *
+ * $Date$ $Revision$
+ */
+
+#import "NSKeyValueObservingPrivate.h"
+#import "NSKeyValueProperty.h"
+#import "NSKeyValueUnnestedProperty.h" /* to support deprecated +[NSObject setKeys:triggerChangeNotificationsForDependentKey:] */
+#import "NSKVONotifying.h"
+#import "GNUstepBase/GSObjCRuntime.h" /* for GSSelectorTypesMatch() */
+
+static NSRecursiveLock *kvoLock = nil;
+static NSMapTable *kvoTable = nil;
+static NSMapTable *propertyTable = nil;
+static NSMapTable *replacementTable = nil;
+
+void _NSKVOIntialize(void)
+{
+    if (kvoLock) {
+        return;
+    }
+    kvoLock = [NSRecursiveLock new];
+    kvoTable = NSCreateMapTable(NSNonOwnedPointerMapKeyCallBacks, NSNonRetainedObjectMapValueCallBacks, 1024);
+    propertyTable = NSCreateMapTable(NSNonOwnedPointerMapKeyCallBacks, NSObjectMapValueCallBacks, 1024);
+    replacementTable = NSCreateMapTable(NSNonOwnedPointerMapKeyCallBacks, NSNonOwnedPointerMapValueCallBacks, 64);
+}
+
+NSKeyValueProperty *_NSKVOGetPropertyWithKeyPath(Class class, NSString *keyPath)
+{
+    NSKeyValueProperty *property;
+    [kvoLock lock];
+    
+    NSMapTable *classProperties = [propertyTable objectForKey:class];
+    if (!classProperties) {
+        classProperties = NSCreateMapTable(NSObjectMapKeyCallBacks, NSObjectMapValueCallBacks, 4);
+        [propertyTable setObject:classProperties forKey:class];
+    }
+    property = [classProperties objectForKey:keyPath];
+    if (!property) {
+        property = [[NSKeyValueProperty alloc] initWithClass:class keyPath:keyPath];
+        [classProperties setObject:property forKey:keyPath];
+        [property release];
+    }
+    
+    [kvoLock unlock];
+    return property;
+}
+
+void _NSKVORegisterUnnestedProperty(Class class, NSString *key, NSArray *affectingKeyPaths)
+{
+    NSCParameterAssert([key rangeOfString:@"."].location == NSNotFound);
+    
+    [kvoLock lock];
+    
+    NSKeyValueProperty *property = [[NSKeyValueUnnestedProperty alloc] initWithClass:class keyPath:key affectingKeyPaths:affectingKeyPaths];
+    NSMapTable *classProperties = [propertyTable objectForKey:class];
+    if (!classProperties) {
+        classProperties = NSCreateMapTable(NSObjectMapKeyCallBacks, NSObjectMapValueCallBacks, 4);
+        [propertyTable setObject:classProperties forKey:class];
+    }
+    [classProperties setObject:property forKey:key];
+    [property release];
+    
+    [kvoLock unlock];
+}
+
+void _NSKVOObjectAddObervance(id self, SEL _cmd, NSObject *observer, NSString *keyPath, NSKeyValueObservingOptions options, void *context)
+{
+    [kvoLock lock];
+    
+    NSKeyValueProperty *property = _NSKVOGetPropertyWithKeyPath([self class], keyPath);
+    NSKeyValueObservance *observance = [[NSKeyValueObservance alloc] initWithObserver:observer ofProperty:property ofObservable:self options:options context:context];
+    object_setClass(self, _NSKVOGetNotifyingSubclassOfClass([self class]));
+    
+    NSKeyValueObservationInfo *info = [self observationInfo];
+    if (!info) {
+        info = [NSKeyValueObservationInfo new];
+        [self setObservationInfo:info];
+    }
+    [info addObservance:observance];
+    
+    [kvoLock unlock];
+    [[observance property] object:self didAddObservance:observance];
+    
+    
+    if (options & NSKeyValueObservingOptionInitial) {
+        NSMutableDictionary *change = [[NSMutableDictionary alloc] initWithCapacity:2];
+        [change setObject:[NSNumber numberWithUnsignedInteger:NSKeyValueChangeSetting] forKey:NSKeyValueChangeKindKey];
+        if (options & NSKeyValueObservingOptionNew) {
+            id value = [self valueForKey:keyPath];
+            [change setObject:(value ? value : [NSNull null]) forKey:NSKeyValueChangeNewKey];
+        }
+        NSKeyValueNotifyObserver(self, observance, keyPath, change);
+        [change release];
+    }
+    [observance release];
+}
+
+/* 
+ * NOTE: observance should never ever be locked while holding kvoLock,
+ * locking it will cause a deadlock: oLock->kvoLock vs. kvoLock->oLock
+ */
+void _NSKVOObjectRemoveObservance(id self, BOOL contextMatters, NSObject *observer, NSString *keyPath, void *context)
+{
+    NSKeyValueObservance *observance;
+    [kvoLock lock];
+    
+    NSKeyValueObservationInfo *info = [self observationInfo];
+    if (contextMatters) {
+        observance = [info extractObservanceWithObserver:observer keyPath:keyPath context:context];
+    } else
+        observance = [info extractObservanceWithObserver:observer keyPath:keyPath];
+    
+    if (![info hasObservances]) {
+        [self setObservationInfo:nil];
+        [info release];
+        object_setClass(self, [self class]);
+    }
+    
+    [kvoLock unlock];
+    
+    [[observance property] object:self didRemoveObservance:observance];
+    [observance lock];
+    [observance invalidate];
+    [observance unlock];
+}
+
+void _NSKVOObjectDeallocate(id self)
+{
+    [kvoLock lock];
+    NSKeyValueObservationInfo *info = [self observationInfo];
+    if ([info hasObservances]) {
+        NSLog(@"An instance %lu of class %@ was deallocated while key value observers were still registered with it. "
+              @"Observation info was leaked, and may even become mistakenly attached to some other object. "
+              @"Set a breakpoint on NSKVODeallocateBreak to stop here in the debugger. "
+              @"Here's the current observation info:\n%@", (unsigned long)self, NSStringFromClass([self class]),info);
+        NSKVODeallocateBreak();
+    }
+    [kvoLock unlock];
+}
+
+void NSKVODeallocateBreak()
+{
+    abort();
+}
+
+/**
+ * WARNING!
+ * KVO is inherently NOT thread safe. Retaining lock on observance mutex while
+ * notifying an observer would interfere with application layer locking strategy
+ * and cause deadlocks.
+ *
+ * Apple's implementation is also NOT thread safe. It can be easy tested by two
+ * infinite loops on multicore machine: one setting any value for some key and
+ * triggering notification process, another one adding/removing observance
+ * and changing observation status accordingly. Observer will be notified
+ * while not observing the key.
+ */
+void NSKeyValueNotifyObserver(id self, NSKeyValueObservance *observance, NSString *keyPath, NSDictionary *change)
+{
+    [observance lock];
+    BOOL valid = [observance isValid];
+    [observance unlock];
+    
+    if (valid) {
+        [[observance observer] observeValueForKeyPath:keyPath ofObject:self change:change context:[observance context]];
+    }
+}
+
+void NSKeyValueWillChange(id self, NSString *keyPath, NSDictionary *change)
+{
+    [self retain];
+    NSArray *observances;
+    [kvoLock lock];
+    NSKeyValueObservationInfo *info = [self observationInfo];
+    observances = [[info observancesForKeyPath:keyPath] retain];
+    [kvoLock unlock];
+    
+    NSInteger count = [observances count];
+    for (NSInteger index = 0; index < count; ++index) {
+        NSKeyValueObservance *observance = [observances objectAtIndex:index];
+        NSKeyValueProperty *property = [observance property];
+        [property object:self withObservance:observance willChangeValue:change forKeyPath:keyPath];
+    }
+    [observances release];
+    [self release];
+}
+
+void NSKeyValueDidChange(id self, NSString *keyPath, NSDictionary *change)
+{
+    [self retain];
+    NSArray *observances;
+    [kvoLock lock];
+    NSKeyValueObservationInfo *info = [self observationInfo];
+    observances = [[info observancesForKeyPath:keyPath] retain];
+    [kvoLock unlock];
+    
+    NSInteger count = [observances count];
+    for (NSInteger index = count - 1; index >= 0; --index) {
+        NSKeyValueObservance *observance = [observances objectAtIndex:index];
+        NSKeyValueProperty *property = [observance property];
+        [property object:self withObservance:observance didChangeValue:change forKeyPath:keyPath];
+    }
+    
+    [observances release];
+    [self release];
+}
+
+void *_NSKVOObjectGetObservationInfo(id self)
+{
+    return [kvoTable objectForKey:self];
+}
+
+void _NSKVOObjectSetObservationInfo(id self, void *observationInfo)
+{
+    if (observationInfo) {
+        [kvoTable setObject:observationInfo forKey:self];
+    } else
+        [kvoTable removeObjectForKey:self];
+}
+
+static BOOL NSKVOGetNotifyingSetterForKey(Class class, NSString *key, SEL *originalSetter, SEL *notifyingSetter)
+{
+    NSUInteger length = [key length];
+    NSUInteger size = length + 6;
+    char *setter = alloca(size);
+    memcpy(setter + 4, [key UTF8String], length);
+    setter[0] = '_';
+    setter[1] = 's';
+    setter[2] = 'e';
+    setter[3] = 't';
+    setter[4] = toupper(setter[4]);
+    setter[size - 2] = ':';
+    setter[size - 1] = '\0';
+    
+    const char *type = NULL;
+    
+    SEL selector = sel_getUid(setter + 1);
+    NSMethodSignature *signature = [class instanceMethodSignatureForSelector:selector];
+    if (!signature) {
+        selector = sel_getUid(setter);
+        signature = [class instanceMethodSignatureForSelector:selector];
+    }
+    if (!signature) {
+        /* if direct access is enables for this property, KVC will notify */
+        return NO;
+    }
+    type = [signature getArgumentTypeAtIndex:2];
+    const char *selectorName;
+    switch (type[0]) {
+        case GSObjCTypeChar:
+        case GSObjCTypeUnsignedChar:
+            selectorName = "_setterChar:";
+            break;
+        case GSObjCTypeShort:
+        case GSObjCTypeUnsignedShort:
+            selectorName = "_setterShort:";
+            break;
+        case GSObjCTypeInt:
+        case GSObjCTypeUnsignedInt:
+            selectorName = "_setterInt:";
+            break;
+        case GSObjCTypeLong:
+        case GSObjCTypeUnsignedLong:
+            selectorName = "_setterLong:";
+            break;
+        case GSObjCTypeLongLong:
+        case GSObjCTypeUnsignedLongLong:
+            selectorName = "_setterLongLong:";
+            break;
+        case GSObjCTypeId:
+        case GSObjCTypePointer:
+        case GSObjCTypeCharPointer:
+            selectorName = "_setter:";
+            break;
+        case GSObjCTypeFloat:
+            selectorName = "_setterFloat:";
+            break;
+        case GSObjCTypeDouble:
+            selectorName = "_setterDouble:";
+            break;
+        case GSObjCTypeStructureBegin:
+            if (GSSelectorTypesMatch(type, @encode(NSRange))) {
+                selectorName = "_setterRange:";
+                break;
+            }
+            if (GSSelectorTypesMatch(type, @encode(NSPoint))) {
+                selectorName = "_setterPoint:";
+                break;
+            }
+            if (GSSelectorTypesMatch(type, @encode(NSSize))) {
+                selectorName = "_setterSize:";
+                break;
+            }
+            if (GSSelectorTypesMatch(type, @encode(NSRect))) {
+                selectorName = "_setterRect:";
+                break;
+            }
+        default:
+            return NO;
+    }
+    if (originalSetter) {
+        *originalSetter = selector;
+    }
+    if (notifyingSetter) {
+        *notifyingSetter = sel_getUid(selectorName);
+    }
+    return YES;
+}
+
+/*
+ * NOTE!
+ * From "Ensuring KVC compliance": (... requires that your class:) Implement a method
+ * named -<key>, -is<Key>,  or have an instance variable <key> or _<key>
+ */
+static BOOL NSKVOGetIvarNameForKey(Class class, NSString *key, NSString **ivarName)
+{
+    NSUInteger length = [key length];
+    char *name = alloca(length + 2);
+    memcpy(name + 1, [key UTF8String], length);
+    name[0] = '_';
+    name[length + 1] = '\0';
+    
+    for (int probe = 0; probe < 2; ++probe) {
+        for (int offset = 0; offset < 2; ++offset) {
+            if (class_getInstanceVariable(class, name + offset)) {
+                if (ivarName) {
+                    *ivarName = [NSString stringWithUTF8String:name + offset];
+                }
+                return YES;
+            }
+        }
+        name[1] = tolower(name[1]);
+    }
+    
+    return NO;
+}
+
+/*
+ * NOTE!
+ * Should only be called while holding kvoLock
+ */
+static Class NSKVOMakeNotifyingSubclassOfClass(Class class)
+{
+    Class prototype = [NSKVONotifying class];
+    Class subclass = NSMapGet(replacementTable, class);
+    
+    if (!subclass) {
+        subclass = objc_allocateClassPair(class, [[NSString stringWithFormat:@"NSKVONotifying_%s", class_getName(class)] UTF8String], 0);
+        
+        static int const SelectorCount = 4;
+        SEL selectors[SelectorCount] = {@selector(dealloc), @selector(class), @selector(superclass), @selector(_isNSKVONotifying)};
+        for (int index = 0; index < SelectorCount; ++index) {
+            Method method = class_getInstanceMethod(prototype, selectors[index]);
+            class_replaceMethod(subclass, selectors[index], method_getImplementation(method), method_getTypeEncoding(method));
+        }
+        
+        objc_registerClassPair(subclass);
+        NSMapInsert(replacementTable, class, subclass);
+    }
+    return subclass;
+}
+
+Class _NSKVOGetNotifyingSubclassOfClass(Class class)
+{
+    Class subclass;
+    [kvoLock lock];
+    subclass = NSMapGet(replacementTable, class);
+    [kvoLock unlock];
+    return subclass ? subclass : class;
+}
+
+void _NSKVOEnableAutomaticNotificationForKey(Class class, NSString *key)
+{
+    [kvoLock lock];
+    SEL originalSetter, notifyingSetter;
+    if (NSKVOGetNotifyingSetterForKey(class, key, &originalSetter, &notifyingSetter)) {
+        Class subclass = NSKVOMakeNotifyingSubclassOfClass(class);
+        Method notifyingMethod = class_getInstanceMethod([NSKVONotifying class], notifyingSetter);
+        Method originalMethod = class_getInstanceMethod(class, originalSetter); /* to preserve type encoding */
+        class_replaceMethod(subclass, originalSetter, method_getImplementation(notifyingMethod), method_getTypeEncoding(originalMethod));
+    } else if (NSKVOGetIvarNameForKey(class, key, nil)) {
+        /* a hack in KVC relies on _isKVONotifying method presence */
+        NSKVOMakeNotifyingSubclassOfClass(class);
+    }
+    [kvoLock unlock];
+}
\ No newline at end of file
diff --git a/Source/KVO/NSKeyValueProperty.h b/Source/KVO/NSKeyValueProperty.h
new file mode 100644
index 0000000..7797c68
--- /dev/null
+++ b/Source/KVO/NSKeyValueProperty.h
@@ -0,0 +1,46 @@
+/*
+ * Implementation of GNUSTEP key value observing
+ * Copyright (C) 2013 Free Software Foundation, Inc.
+ *
+ * Written by Marat Ibadinov <ibadinov@me.com>
+ * Date: 2013
+ *
+ * This file is part of the GNUstep Base Library.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free
+ * Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110 USA.
+ *
+ * $Date$ $Revision$
+ */
+
+#import "NSKeyValueObservance.h"
+#import <Foundation/Foundation.h>
+
+@interface NSKeyValueProperty : NSObject {
+    Class containingClass;
+    NSString *keyPath;
+}
+
+- (id)initWithClass:(Class)aClass keyPath:(NSString *)aPath;
+
+- (NSString *)keyPath;
+
+- (void)object:(NSObject *)object didAddObservance:(NSKeyValueObservance *)observance;
+- (void)object:(NSObject *)object didRemoveObservance:(NSKeyValueObservance *)observance;
+
+- (void)object:(NSObject *)object withObservance:(NSKeyValueObservance *)observance willChangeValue:(NSDictionary *)change forKeyPath:(NSString *)aPath;
+- (void)object:(NSObject *)object withObservance:(NSKeyValueObservance *)observance didChangeValue:(NSDictionary *)change forKeyPath:(NSString *)aPath;
+
+@end
\ No newline at end of file
diff --git a/Source/KVO/NSKeyValueProperty.m b/Source/KVO/NSKeyValueProperty.m
new file mode 100644
index 0000000..88e34ee
--- /dev/null
+++ b/Source/KVO/NSKeyValueProperty.m
@@ -0,0 +1,130 @@
+/*
+ * Implementation of GNUSTEP key value observing
+ * Copyright (C) 2013 Free Software Foundation, Inc.
+ *
+ * Written by Marat Ibadinov <ibadinov@me.com>
+ * Date: 2013
+ *
+ * This file is part of the GNUstep Base Library.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free
+ * Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110 USA.
+ *
+ * $Date$ $Revision$
+ */
+
+#import "NSKeyValueProperty.h"
+#import "NSKeyValueNestedProperty.h"
+#import "NSKeyValueUnnestedProperty.h"
+#import "NSKeyValueObservingPrivate.h"
+
+@implementation NSKeyValueProperty
+
+- (id)initWithClass:(Class)aClass keyPath:(NSString *)aPath
+{
+    if ([self class] != [NSKeyValueProperty class]) {
+        if (self = [super init]) {
+            containingClass = aClass;
+            keyPath = [aPath retain];
+        }
+        return self;
+    }
+    
+    [self release];
+    NSRange range = [aPath rangeOfString:@"."];
+    if (range.location == NSNotFound) {
+        return [[NSKeyValueUnnestedProperty alloc] initWithClass:aClass keyPath:aPath];
+    } else
+        return [[NSKeyValueNestedProperty alloc] initWithClass:aClass keyPath:aPath];
+}
+
+- (void)dealloc
+{
+    [keyPath release];
+    [super dealloc];
+}
+
+- (NSString *)keyPath
+{
+    return keyPath;
+}
+
+- (void)object:(NSObject *)object didAddObservance:(NSKeyValueObservance *)observance
+{
+    [self doesNotRecognizeSelector:_cmd];
+}
+
+- (void)object:(NSObject *)object didRemoveObservance:(NSKeyValueObservance *)observance
+{
+    [self doesNotRecognizeSelector:_cmd];
+}
+
+- (void)object:(NSObject *)object withObservance:(NSKeyValueObservance *)observance willChangeValue:(NSDictionary *)change forKeyPath:(NSString *)aPath
+{
+    [observance lock];
+    [observance pushChange:change];
+    [observance unlock];
+    
+    NSKeyValueObservingOptions options = [observance options];
+    NSObject *observer = [observance observer];
+    /* if observer is a property, call appropriate method */
+    if (![observer isKindOfClass:[NSKeyValueProperty class]]) {
+        if (options & NSKeyValueObservingOptionPrior) {
+            if (!(options & NSKeyValueObservingOptionOld)) {
+                change = [change mutableCopy];
+                [(NSMutableDictionary *)change removeObjectForKey:NSKeyValueChangeOldKey];
+            } else 
+                [change retain];
+            
+            NSKeyValueNotifyObserver(object, observance, keyPath, change);
+            [change release];
+        }
+    } else {
+        [(NSKeyValueProperty *)observer object:object withObservance:observance willChangeValue:change forKeyPath:aPath];
+    }
+}
+
+- (void)object:(NSObject *)object withObservance:(NSKeyValueObservance *)observance didChangeValue:(NSDictionary *)change forKeyPath:(NSString *)aPath
+{
+    [observance lock];
+    NSDictionary *prior = [observance popChange];
+    [observance unlock];
+    
+    if (prior) {
+        NSMutableDictionary *prepared = [[NSMutableDictionary alloc] initWithDictionary:change];
+        
+        id value;
+        NSKeyValueObservingOptions options = [observance options];
+        if (!(options & NSKeyValueObservingOptionNew)) {
+            [prepared removeObjectForKey:NSKeyValueChangeNewKey];
+        } else if (![prepared objectForKey:NSKeyValueChangeNewKey] && (value = [prior objectForKey:NSKeyValueChangeNewKey])) {
+            [prepared setObject:value forKey:NSKeyValueChangeNewKey];
+        }
+        if (options & NSKeyValueObservingOptionOld && (value = [prior objectForKey:NSKeyValueChangeOldKey])) {
+            [prepared setObject:value forKey:NSKeyValueChangeOldKey];
+        }
+        
+        /* if observer is a property, call appropriate method */
+        NSObject *observer = [observance observer];
+        if ([observer isKindOfClass:[NSKeyValueProperty class]]) {
+            [(NSKeyValueProperty *)observer object:object withObservance:observance didChangeValue:prepared forKeyPath:aPath];
+        } else
+            NSKeyValueNotifyObserver(object, observance, keyPath, prepared);
+        
+        [prepared release];
+    }   
+}
+
+@end
\ No newline at end of file
diff --git a/Source/KVO/NSKeyValueUnnestedProperty.h b/Source/KVO/NSKeyValueUnnestedProperty.h
new file mode 100644
index 0000000..9296679
--- /dev/null
+++ b/Source/KVO/NSKeyValueUnnestedProperty.h
@@ -0,0 +1,39 @@
+/*
+ * Implementation of GNUSTEP key value observing
+ * Copyright (C) 2013 Free Software Foundation, Inc.
+ *
+ * Written by Marat Ibadinov <ibadinov@me.com>
+ * Date: 2013
+ *
+ * This file is part of the GNUstep Base Library.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free
+ * Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110 USA.
+ *
+ * $Date$ $Revision$
+ */
+
+#import "NSKeyValueProperty.h"
+
+@interface NSKeyValueUnnestedProperty : NSKeyValueProperty {
+    NSArray *affectingKeyPaths;
+}
+
+/* intended to support the deprecated +[NSObject setKeys:triggerChangeNotificationsForDependentKey:] */
+- (id)initWithClass:(Class)aClass keyPath:(NSString *)aPath affectingKeyPaths:(NSArray *)paths;
+
+- (BOOL)hasDependencies;
+
+@end
\ No newline at end of file
diff --git a/Source/KVO/NSKeyValueUnnestedProperty.m b/Source/KVO/NSKeyValueUnnestedProperty.m
new file mode 100644
index 0000000..d09ff13
--- /dev/null
+++ b/Source/KVO/NSKeyValueUnnestedProperty.m
@@ -0,0 +1,110 @@
+/*
+ * Implementation of GNUSTEP key value observing
+ * Copyright (C) 2013 Free Software Foundation, Inc.
+ *
+ * Written by Marat Ibadinov <ibadinov@me.com>
+ * Date: 2013
+ *
+ * This file is part of the GNUstep Base Library.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free
+ * Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110 USA.
+ *
+ * $Date$ $Revision$
+ */
+
+#import "NSKeyValueUnnestedProperty.h"
+#import "NSKeyValueObservingPrivate.h"
+
+@implementation NSKeyValueUnnestedProperty
+
+- (id)initWithClass:(Class)aClass keyPath:(NSString *)aPath affectingKeyPaths:(NSArray *)paths
+{
+    if (self = [super initWithClass:aClass keyPath:aPath]) {
+        affectingKeyPaths = [paths retain];
+        if ([aClass automaticallyNotifiesObserversForKey:aPath]) {
+            _NSKVOEnableAutomaticNotificationForKey(containingClass, keyPath);
+        }
+    }
+    return self;
+}
+
+- (id)initWithClass:(Class)aClass keyPath:(NSString *)aPath
+{
+    NSSet *paths = [aClass keyPathsForValuesAffectingValueForKey:aPath];
+    
+    SEL propertySpecificSelector = sel_getUid([[NSString stringWithFormat:@"keyPathsForValuesAffecting%@", [aPath capitalizedString]] UTF8String]);
+    if (class_respondsToSelector(object_getClass(aClass), propertySpecificSelector)) {
+        paths = [paths setByAddingObjectsFromSet:objc_msgSend(aClass, propertySpecificSelector)];
+    }
+    
+    return [self initWithClass:aClass keyPath:aPath affectingKeyPaths:[paths allObjects]];
+}
+
+- (void)dealloc
+{
+    [affectingKeyPaths dealloc];
+    [super dealloc];
+}
+
+- (BOOL)hasDependencies
+{
+    return [affectingKeyPaths count] != 0;
+}
+
+- (void)object:(NSObject *)object didAddObservance:(NSKeyValueObservance *)observance
+{
+    NSKeyValueObservingOptions options = [observance options] & NSKeyValueObservingOptionPrior;
+    for (NSUInteger index = 0, count = [affectingKeyPaths count]; index < count; ++index) {
+        [object addObserver:self forKeyPath:[affectingKeyPaths objectAtIndex:index] options:options context:observance];
+    }
+}
+
+- (void)object:(NSObject *)object didRemoveObservance:(NSKeyValueObservance *)observance
+{
+    for (NSUInteger index = 0, count = [affectingKeyPaths count]; index < count; ++index) {
+        [object removeObserver:self forKeyPath:[affectingKeyPaths objectAtIndex:index] context:observance];
+    }
+}
+
+- (void)object:(NSObject *)object withObservance:(NSKeyValueObservance *)observance willChangeValue:(NSDictionary *)change forKeyPath:(NSString *)aPath
+{
+    /* forward notifications from affecting keys */
+    if ([observance observer] == self) {
+        observance = [observance context];
+        object = [observance observable];
+        aPath = keyPath;
+        change = [[change mutableCopy] autorelease];
+        [(NSMutableDictionary *)change setObject:[object valueForKeyPath:keyPath] forKey:NSKeyValueChangeOldKey];
+    }
+    
+    [super object:object withObservance:observance willChangeValue:change forKeyPath:aPath];
+}
+
+- (void)object:(NSObject *)object withObservance:(NSKeyValueObservance *)observance didChangeValue:(NSDictionary *)change forKeyPath:(NSString *)aPath
+{
+    /* forward notifications from affecting keys */
+    if ([observance observer] == self) {
+        observance = [observance context];
+        object = [observance observable];
+        aPath = keyPath;
+        change = [[change mutableCopy] autorelease];
+        [(NSMutableDictionary *)change setObject:[object valueForKeyPath:keyPath] forKey:NSKeyValueChangeNewKey];
+    }
+    
+    [super object:object withObservance:observance didChangeValue:change forKeyPath:aPath];
+}
+
+@end
\ No newline at end of file
diff --git a/Source/KVO/NSObject+KVO.m b/Source/KVO/NSObject+KVO.m
new file mode 100644
index 0000000..e97a960
--- /dev/null
+++ b/Source/KVO/NSObject+KVO.m
@@ -0,0 +1,228 @@
+/*
+ * Implementation of GNUSTEP key value observing
+ * Copyright (C) 2013 Free Software Foundation, Inc.
+ *
+ * Written by Marat Ibadinov <ibadinov@me.com>
+ * Date: 2013
+ *
+ * This file is part of the GNUstep Base Library.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free
+ * Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110 USA.
+ *
+ * $Date$ $Revision$
+ */
+
+#import "Foundation/NSKeyValueObserving.h"
+#import "NSKeyValueObservingPrivate.h"
+
+@implementation NSObject (NSKeyValueObserving)
+
+- (void)observeValueForKeyPath:(NSString *)aPath ofObject:(id)anObject change:(NSDictionary *)aChange context:(void *)aContext
+{
+    [NSException raise:NSInternalInconsistencyException format:
+     @"%@: An -%s message was received but not handled.\n"
+     @"Key path: %@\n"
+     @"Observed object: %@\n"
+     @"Change: %@\n"
+     @"Context: 0x%lx", self, sel_getName(_cmd), aPath, anObject, aChange, (unsigned long)aContext];
+}
+
+@end
+
+
+@implementation NSObject (NSKeyValueObserverRegistration)
+
+- (void)addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(void *)context
+{
+    _NSKVOObjectAddObervance(self, _cmd, observer, keyPath, options, context);
+}
+
+- (void)removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath
+{
+    _NSKVOObjectRemoveObservance(self, NO, observer, keyPath, NULL);
+}
+
+- (void)removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath context:(void *)context
+{
+    _NSKVOObjectRemoveObservance(self, YES, observer, keyPath, context);
+}
+
+@end
+
+
+@implementation NSObject (NSKeyValueObserverNotification)
+
+- (void)willChangeValueForKey:(NSString *)key
+{
+    id value = [self valueForKey:key];
+    NSDictionary *change = [NSDictionary dictionaryWithObjectsAndKeys:
+                            [NSNumber numberWithUnsignedInteger:NSKeyValueChangeSetting], NSKeyValueChangeKindKey,
+                            [NSNumber numberWithBool:YES], NSKeyValueChangeNotificationIsPriorKey,
+                            (value ? value : [NSNull null]), NSKeyValueChangeOldKey,
+                            nil];
+    NSKeyValueWillChange(self, key, change);
+}
+
+- (void)didChangeValueForKey:(NSString *)key
+{
+    id value = [self valueForKey:key];
+    NSDictionary *change = [NSDictionary dictionaryWithObjectsAndKeys:
+                            [NSNumber numberWithUnsignedInteger:NSKeyValueChangeSetting], NSKeyValueChangeKindKey,
+                            (value ? value : [NSNull null]), NSKeyValueChangeNewKey,
+                            nil];
+    NSKeyValueDidChange(self, key, change);
+}
+
+- (void)willChange:(NSKeyValueChange)changeKind valuesAtIndexes:(NSIndexSet *)indexes forKey:(NSString *)key
+{
+    NSMutableDictionary *change = [NSMutableDictionary dictionaryWithObjectsAndKeys:
+                                   [NSNumber numberWithUnsignedInteger:changeKind], NSKeyValueChangeKindKey,
+                                   [NSNumber numberWithBool:YES], NSKeyValueChangeNotificationIsPriorKey,
+                                   indexes, NSKeyValueChangeIndexesKey,
+                                   nil];
+    if (changeKind == NSKeyValueChangeRemoval || changeKind == NSKeyValueChangeReplacement) {
+        [change setValue:[[self valueForKey:key] objectsAtIndexes:indexes] forKey:NSKeyValueChangeOldKey];
+    }
+    NSKeyValueWillChange(self, key, change);
+}
+
+- (void)didChange:(NSKeyValueChange)changeKind valuesAtIndexes:(NSIndexSet *)indexes forKey:(NSString *)key
+{
+    NSMutableDictionary *change = [NSMutableDictionary dictionaryWithObjectsAndKeys:
+                                   [NSNumber numberWithUnsignedInteger:changeKind], NSKeyValueChangeKindKey,
+                                   indexes, NSKeyValueChangeIndexesKey,
+                                   nil];
+    if (changeKind == NSKeyValueChangeInsertion || changeKind == NSKeyValueChangeReplacement) {
+        [change setObject:[[self valueForKey:key] objectsAtIndexes:indexes] forKey:NSKeyValueChangeNewKey];
+    }
+    NSKeyValueDidChange(self, key, change);
+}
+
+- (void)willChangeValueForKey:(NSString *)key withSetMutation:(NSKeyValueSetMutationKind)mutationKind usingObjects:(NSSet *)objects
+{
+    NSMutableDictionary *change = [NSMutableDictionary dictionaryWithCapacity:4];
+    NSKeyValueChange changeKind;
+    switch (mutationKind) {
+        case NSKeyValueUnionSetMutation:
+            if (objects) {
+                NSSet *old = [self valueForKey:key];
+                if (old) {
+                    objects = [objects mutableCopy];
+                    [(NSMutableSet *)objects minusSet:old];
+                    [change setObject:objects forKey:NSKeyValueChangeNewKey];
+                    [objects release];
+                }
+            }
+            changeKind = NSKeyValueChangeInsertion;
+            break;
+        case NSKeyValueMinusSetMutation:
+            if (objects) {
+                NSMutableSet *old = [[self valueForKey:key] mutableCopy];
+                if (old) {
+                    [old intersectSet:objects];
+                    [change setObject:old forKey:NSKeyValueChangeOldKey];
+                }
+                [old release];
+            }
+            changeKind = NSKeyValueChangeRemoval;
+            break;
+        case NSKeyValueIntersectSetMutation:
+            if (objects) {
+                NSMutableSet *old = [[self valueForKey:key] mutableCopy];
+                if (old) {
+                    [old minusSet:objects];
+                    [change setObject:old forKey:NSKeyValueChangeOldKey];
+                }
+                [old release];
+            }
+            changeKind = NSKeyValueChangeRemoval;
+            break;
+        case NSKeyValueSetSetMutation:
+            if (objects) {
+                [change setObject:objects forKey:NSKeyValueChangeNewKey];
+            }
+            if ((objects = [self valueForKey:key])) {
+                [change setObject:objects forKey:NSKeyValueChangeOldKey];
+            }
+            changeKind = NSKeyValueChangeReplacement;
+            break;
+        default:
+            [NSException raise:NSInvalidArgumentException format:@"Unsupported set mutation kind: %lu", (unsigned long)mutationKind];
+            return;
+    }
+    [change setObject:[NSNumber numberWithUnsignedInteger:changeKind] forKey:NSKeyValueChangeKindKey];
+    [change setObject:[NSNumber numberWithBool:YES]  forKey:NSKeyValueChangeNotificationIsPriorKey];
+    
+    NSKeyValueWillChange(self, key, change);
+}
+
+- (void)didChangeValueForKey:(NSString *)key withSetMutation:(NSKeyValueSetMutationKind)mutationKind usingObjects:(NSSet *)objects
+{
+    NSMutableDictionary *change = [NSMutableDictionary dictionaryWithCapacity:2];
+    NSKeyValueChange changeKind;
+    switch (mutationKind) {
+        case NSKeyValueUnionSetMutation:
+            changeKind = NSKeyValueChangeInsertion;
+            break;
+        case NSKeyValueMinusSetMutation:
+            changeKind = NSKeyValueChangeRemoval;
+            break;
+        case NSKeyValueIntersectSetMutation:
+            changeKind = NSKeyValueChangeRemoval;
+            break;
+        case NSKeyValueSetSetMutation:
+            changeKind = NSKeyValueChangeReplacement;
+            break;
+        default:
+            [NSException raise:NSInvalidArgumentException format:@"Unsupported set mutation kind: %lu", (unsigned long)mutationKind];
+            return;
+    }
+    [change setObject:[NSNumber numberWithUnsignedInteger:changeKind] forKey:NSKeyValueChangeKindKey];
+    
+    NSKeyValueDidChange(self, key, change);
+}
+
+@end
+
+
+@implementation NSObject (NSKeyValueObservingCustomization)
+
++ (BOOL)automaticallyNotifiesObserversForKey:(NSString *)aKey
+{
+    return YES;
+}
+
++ (NSSet *)keyPathsForValuesAffectingValueForKey:(NSString *)aKey
+{
+    return [NSSet set];
+}
+
+- (void *)observationInfo
+{
+    return _NSKVOObjectGetObservationInfo(self);
+}
+
+- (void)setObservationInfo:(void *)observationInfo
+{
+    return _NSKVOObjectSetObservationInfo(self, observationInfo);
+}
+
++ (void)setKeys:(NSArray *)keys triggerChangeNotificationsForDependentKey:(NSString *)dependentKey
+{
+    _NSKVORegisterUnnestedProperty(self, dependentKey, keys);
+}
+
+@end
\ No newline at end of file
diff --git a/Source/KVO/NSSet+KVO.m b/Source/KVO/NSSet+KVO.m
new file mode 100644
index 0000000..127f161
--- /dev/null
+++ b/Source/KVO/NSSet+KVO.m
@@ -0,0 +1,49 @@
+/*
+ * Implementation of GNUSTEP key value observing
+ * Copyright (C) 2013 Free Software Foundation, Inc.
+ *
+ * Written by Marat Ibadinov <ibadinov@me.com>
+ * Date: 2013
+ *
+ * This file is part of the GNUstep Base Library.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free
+ * Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110 USA.
+ *
+ * $Date$ $Revision$
+ */
+
+#import "Foundation/NSSet.h"
+#import "Foundation/NSException.h"
+#import "Foundation/NSKeyValueObserving.h"
+
+@implementation NSSet (NSKeyValueObserverRegistration)
+
+- (void)addObserver:(NSObject *)anObserver forKeyPath:(NSString *)aPath options:(NSKeyValueObservingOptions)options context:(void *)aContext
+{
+    [NSException raise:NSInvalidArgumentException format:@"[%@ %s] is not supported. Key path: %@", self, sel_getName(_cmd), aPath];
+}
+
+- (void)removeObserver:(NSObject *)anObserver forKeyPath:(NSString *)keyPath
+{
+    [NSException raise:NSInvalidArgumentException format:@"[%@ %s] is not supported. Key path: %@", self, sel_getName(_cmd), keyPath];
+}
+
+- (void)removeObserver:(NSObject *)anObserver forKeyPath:(NSString *)keyPath context:(void *)context
+{
+    [NSException raise:NSInvalidArgumentException format:@"[%@ %s] is not supported. Key path: %@", self, sel_getName(_cmd), keyPath];
+}
+
+@end
\ No newline at end of file
diff --git a/Source/NSAffineTransform.m b/Source/NSAffineTransform.m
index 6d716a9..fc78697 100644
--- a/Source/NSAffineTransform.m
+++ b/Source/NSAffineTransform.m
@@ -605,7 +605,7 @@ static NSAffineTransformStruct identityTransform = {
 	  NSUInteger length;
 	  const uint8_t *data;
           NSData *d;
-          unsigned int cursor = 0;
+          NSUInteger cursor = 0;
 
           data = [aCoder decodeBytesForKey: @"NSTransformStruct"
                               returnedLength: &length]; 
@@ -639,7 +639,8 @@ static NSAffineTransformStruct identityTransform = {
                 {
                   // FIXME
                   NSLog(@"Got type %d for affine transform", data[0]);
-                  return [self notImplemented: _cmd];
+                  [self notImplemented: _cmd];
+                  return nil;
                 }
             }
           else if (16 == length)
@@ -674,7 +675,8 @@ static NSAffineTransformStruct identityTransform = {
             {
               // FIXME
               NSLog(@"Got data %@ len %d for affine transform", d, (int)length);
-              return [self notImplemented: _cmd];
+              [self notImplemented: _cmd];
+              return nil;
             }
         }
       else
diff --git a/Source/NSArchiver.m b/Source/NSArchiver.m
index f3e7eb0..0b9e8f0 100644
--- a/Source/NSArchiver.m
+++ b/Source/NSArchiver.m
@@ -27,7 +27,7 @@
 
 #import "common.h"
 
-#if !defined (__GNU_LIBOBJC__)
+#if !defined (__GNU_LIBOBJC__) && !defined(NeXT_RUNTIME)
 #  include <objc/encoding.h>
 #endif
 
@@ -292,7 +292,7 @@ static Class	NSMutableDataMallocClass;
     }
   else
     {
-      c = count;
+      c = (uint32_t)count;
     }
 
   switch (*type)
@@ -420,6 +420,7 @@ static Class	NSMutableDataMallocClass;
 
 	      (*_eValImp)(self, eValSel, ftype, (char*)buf + offset);
 	    }
+    objc_layout_finish_structure(&layout, NULL, NULL);
 	}
 	return;
 
@@ -799,7 +800,7 @@ static Class	NSMutableDataMallocClass;
 
 - (void) encodeDataObject: (NSData*)anObject
 {
-  unsigned	l = [anObject length];
+  NSUInteger	l = [anObject length];
 
   (*_eValImp)(self, eValSel, @encode(unsigned int), &l);
   if (l)
@@ -1080,18 +1081,19 @@ static Class	NSMutableDataMallocClass;
 /**
  *  Writes out header for GNUstep archive format.
  */
-- (void) serializeHeaderAt: (unsigned)positionInData
+- (void) serializeHeaderAt: (NSUInteger)positionInData
 		   version: (unsigned)systemVersion
-		   classes: (unsigned)classCount
-		   objects: (unsigned)objectCount
-		  pointers: (unsigned)pointerCount
+		   classes: (NSUInteger)classCount
+		   objects: (NSUInteger)objectCount
+		  pointers: (NSUInteger)pointerCount
 {
-  unsigned	headerLength = strlen(PREFIX)+36;
-  char		header[headerLength+1];
-  unsigned	dataLength = [_data length];
+  NSUInteger	headerLength = strlen(PREFIX)+36;
+  char          header[headerLength+1];
+  NSUInteger	dataLength = [_data length];
 
+  NSAssert(classCount < INT_MAX && objectCount < INT_MAX && pointerCount < INT_MAX, @"Counts are limited to size of int");
   snprintf(header, sizeof(header), "%s%08x:%08x:%08x:%08x:",
-    PREFIX, systemVersion, classCount, objectCount, pointerCount);
+    PREFIX, systemVersion, (int)classCount, (int)objectCount, (int)pointerCount);
 
   if (positionInData + headerLength <= dataLength)
     {
diff --git a/Source/NSArray.m b/Source/NSArray.m
index 72dd29d..9c16f1d 100644
--- a/Source/NSArray.m
+++ b/Source/NSArray.m
@@ -286,7 +286,7 @@ static SEL	rlSel;
 - (NSArray*) arrayByAddingObject: (id)anObject
 {
   id na;
-  unsigned	c = [self count];
+  NSUInteger	c = [self count];
 
   if (anObject == nil)
     [NSException raise: NSInvalidArgumentException
@@ -317,9 +317,9 @@ static SEL	rlSel;
 - (NSArray*) arrayByAddingObjectsFromArray: (NSArray*)anotherArray
 {
   id		na;
-  unsigned	c;
-  unsigned	l;
-  unsigned	e;
+  NSUInteger	c;
+  NSUInteger	l;
+  NSUInteger	e;
 
   c = [self count];
   l = [anotherArray count];
@@ -331,8 +331,8 @@ static SEL	rlSel;
     [self getObjects: objects];
     if ([anotherArray isProxy])
       {
-	unsigned	i = c;
-	unsigned	j = 0;
+	NSUInteger	i = c;
+	NSUInteger	j = 0;
 
 	while (i < e)
 	  {
@@ -407,8 +407,8 @@ static SEL	rlSel;
   if (count > 0)
     {
       IMP	imp = [self methodForSelector: @selector(objectAtIndex:)];
-      int	p = state->state;
-      int	i;
+      NSUInteger	p = state->state;
+      NSUInteger	i;
 
       for (i = 0; i < count; i++, p++)
 	{
@@ -430,7 +430,7 @@ static SEL	rlSel;
  */
 - (void) encodeWithCoder: (NSCoder*)aCoder
 {
-  unsigned	count = [self count];
+  NSUInteger	count = [self count];
 
   if ([aCoder allowsKeyedCoding])
     {
@@ -444,13 +444,13 @@ static SEL	rlSel;
 	}
       else
 	{
-	  unsigned	i;
+	  NSUInteger	i;
 
 	  for (i = 0; i < count; i++)
 	    {
 	      NSString	*key;
 
-	      key = [NSString stringWithFormat: @"NS.object.%u", i];
+	      key = [NSString stringWithFormat: @"NS.object.%lu", (unsigned long)i];
 	      [(NSKeyedArchiver*)aCoder encodeObject: [self objectAtIndex: i]
 					      forKey: key];
 	    }
@@ -480,7 +480,7 @@ static SEL	rlSel;
  */
 - (void) getObjects: (__unsafe_unretained id[])aBuffer
 {
-  unsigned i, c = [self count];
+  NSUInteger i, c = [self count];
   IMP	get = [self methodForSelector: oaiSel];
 
   for (i = 0; i < c; i++)
@@ -493,7 +493,7 @@ static SEL	rlSel;
  */
 - (void) getObjects: (__unsafe_unretained id[])aBuffer range: (NSRange)aRange
 {
-  unsigned i, j = 0, c = [self count], e = aRange.location + aRange.length;
+  NSUInteger i, j = 0, c = [self count], e = aRange.location + aRange.length;
   IMP	get = [self methodForSelector: oaiSel];
 
   GS_RANGE_CHECK(aRange, c);
@@ -516,12 +516,12 @@ static SEL	rlSel;
  */
 - (NSUInteger) indexOfObjectIdenticalTo: (id)anObject
 {
-  unsigned c = [self count];
+  NSUInteger c = [self count];
 
   if (c > 0)
     {
       IMP	get = [self methodForSelector: oaiSel];
-      unsigned	i;
+      NSUInteger	i;
 
       for (i = 0; i < c; i++)
 	if (anObject == (*get)(self, oaiSel, i))
@@ -536,7 +536,7 @@ static SEL	rlSel;
  */
 - (NSUInteger) indexOfObjectIdenticalTo: anObject inRange: (NSRange)aRange
 {
-  unsigned i, e = aRange.location + aRange.length, c = [self count];
+  NSUInteger i, e = aRange.location + aRange.length, c = [self count];
   IMP	get = [self methodForSelector: oaiSel];
 
   GS_RANGE_CHECK(aRange, c);
@@ -554,11 +554,11 @@ static SEL	rlSel;
  */
 - (NSUInteger) indexOfObject: (id)anObject
 {
-  unsigned	c = [self count];
+  NSUInteger	c = [self count];
 
   if (c > 0 && anObject != nil)
     {
-      unsigned	i;
+      NSUInteger	i;
       IMP	get = [self methodForSelector: oaiSel];
       BOOL	(*eq)(id, SEL, id)
 	= (BOOL (*)(id, SEL, id))[anObject methodForSelector: eqSel];
@@ -577,7 +577,7 @@ static SEL	rlSel;
  */
 - (NSUInteger) indexOfObject: (id)anObject inRange: (NSRange)aRange
 {
-  unsigned i, e = aRange.location + aRange.length, c = [self count];
+  NSUInteger i, e = aRange.location + aRange.length, c = [self count];
   IMP	get = [self methodForSelector: oaiSel];
   BOOL	(*eq)(id, SEL, id)
     = (BOOL (*)(id, SEL, id))[anObject methodForSelector: eqSel];
@@ -631,12 +631,12 @@ static SEL	rlSel;
  */
 - (id) initWithArray: (NSArray*)array copyItems: (BOOL)shouldCopy
 {
-  unsigned	c = [array count];
+  NSUInteger	c = [array count];
   GS_BEGINIDBUF(objects, c);
 
   if ([array isProxy])
     {
-      unsigned	i;
+      NSUInteger	i;
 
       for (i = 0; i < c; i++)
 	{
@@ -649,7 +649,7 @@ static SEL	rlSel;
     }
   if (shouldCopy == YES)
     {
-      unsigned	i;
+      NSUInteger	i;
 
       for (i = 0; i < c; i++)
 	{
@@ -678,12 +678,12 @@ static SEL	rlSel;
  */
 - (id) initWithArray: (NSArray*)array
 {
-  unsigned	c = [array count];
+  NSUInteger	c = [array count];
   GS_BEGINIDBUF(objects, c);
 
   if ([array isProxy])
     {
-      unsigned	i;
+      NSUInteger	i;
 
       for (i = 0; i < c; i++)
 	{
@@ -713,19 +713,19 @@ static SEL	rlSel;
 						@"NS.objects"];
       if (array == nil)
 	{
-	  unsigned	i = 0;
+	  NSUInteger	i = 0;
 	  NSString	*key;
 	  id		val;
 
 	  array = [NSMutableArray arrayWithCapacity: 2];
-	  key = [NSString stringWithFormat: @"NS.object.%u", i];
+	  key = [NSString stringWithFormat: @"NS.object.%lu", (unsigned long)i];
 	  val = [(NSKeyedUnarchiver*)aCoder decodeObjectForKey: key];
 
 	  while (val != nil)
 	    {
 	      [array addObject: val];
 	      i++;
-	      key = [NSString stringWithFormat: @"NS.object.%u", i];
+	      key = [NSString stringWithFormat: @"NS.object.%lu", (unsigned long)i];
 	      val = [(NSKeyedUnarchiver*)aCoder decodeObjectForKey: key];
 	    }
 	}
@@ -734,7 +734,7 @@ static SEL	rlSel;
     }
   else
     {
-      unsigned    count;
+      NSUInteger    count;
 
       [aCoder decodeValueOfObjCType: @encode(unsigned)
 	                         at: &count];
@@ -916,7 +916,7 @@ static SEL	rlSel;
 - (NSArray *) objectsAtIndexes: (NSIndexSet *)indexes
 {
   //FIXME: probably slow!
-  NSMutableArray *group = [NSMutableArray arrayWithCapacity: [indexes count]];
+  NSMutableArray *group = [[NSMutableArray alloc] initWithCapacity: [indexes count]];
 
   NSUInteger i = [indexes firstIndex];
   while (i != NSNotFound)
@@ -925,7 +925,7 @@ static SEL	rlSel;
       i = [indexes indexGreaterThanIndex: i];
     }
 
-  return [group makeImmutableCopyOnFail: NO];
+  return [[group makeImmutable] autorelease];
 }
 
 - (BOOL) isEqual: (id)anObject
@@ -943,7 +943,7 @@ static SEL	rlSel;
  */
 - (BOOL) isEqualToArray: (NSArray*)otherArray
 {
-  unsigned i, c;
+  NSUInteger i, c;
 
   if (self == (id)otherArray)
     return YES;
@@ -967,7 +967,7 @@ static SEL	rlSel;
  */
 - (id) lastObject
 {
-  unsigned count = [self count];
+  NSUInteger count = [self count];
   if (count == 0)
     return nil;
   return [self objectAtIndex: count-1];
@@ -979,12 +979,12 @@ static SEL	rlSel;
  */
 - (void) makeObjectsPerformSelector: (SEL)aSelector
 {
-  unsigned	c = [self count];
+  NSUInteger	c = [self count];
 
   if (c > 0)
     {
       IMP	get = [self methodForSelector: oaiSel];
-      unsigned	i = 0;
+      NSUInteger	i = 0;
 
       while (i < c)
 	{
@@ -1007,12 +1007,12 @@ static SEL	rlSel;
  */
 - (void) makeObjectsPerformSelector: (SEL)aSelector withObject: (id)arg
 {
-  unsigned	c = [self count];
+  NSUInteger	c = [self count];
 
   if (c > 0)
     {
       IMP	get = [self methodForSelector: oaiSel];
-      unsigned	i = 0;
+      NSUInteger	i = 0;
 
       while (i < c)
 	{
@@ -1096,11 +1096,11 @@ compare(id elem1, id elem2, void* context)
 {
   NSMutableArray	*sortedArray;
 
-  sortedArray = [[[NSMutableArrayClass allocWithZone:
-    NSDefaultMallocZone()] initWithArray: self copyItems: NO] autorelease];
+  sortedArray = [[NSMutableArrayClass allocWithZone:
+    NSDefaultMallocZone()] initWithArray: self copyItems: NO];
   [sortedArray sortUsingFunction: comparator context: context];
 
-  return [sortedArray makeImmutableCopyOnFail: NO];
+  return [[sortedArray makeImmutable] autorelease];
 }
 
 
@@ -1109,11 +1109,11 @@ compare(id elem1, id elem2, void* context)
 {
   NSMutableArray	*sortedArray;
 
-  sortedArray = [[[NSMutableArrayClass allocWithZone:
-    NSDefaultMallocZone()] initWithArray: self copyItems: NO] autorelease];
+  sortedArray = [[NSMutableArrayClass allocWithZone:
+    NSDefaultMallocZone()] initWithArray: self copyItems: NO];
   [sortedArray sortWithOptions: options usingComparator: comparator];
 
-  return [sortedArray makeImmutableCopyOnFail: NO];
+  return [[sortedArray makeImmutable] autorelease];
 }
 
 - (NSArray*) sortedArrayUsingComparator: (NSComparator)comparator
@@ -1209,14 +1209,14 @@ compare(id elem1, id elem2, void* context)
  */
 - (NSString*) componentsJoinedByString: (NSString*)separator
 {
-  unsigned int		c = [self count];
+  NSUInteger		c = [self count];
   NSMutableString	*s;
 
-  s = [[[NSMutableString alloc] initWithCapacity: c] autorelease];
+  s = [[NSMutableString alloc] initWithCapacity: c];
   if (c > 0)
     {
-      unsigned	l = [separator length];
-      unsigned	i;
+      NSUInteger	l = [separator length];
+      NSUInteger	i;
 
       [s appendString: [[self objectAtIndex: 0] description]];
       for (i = 1; i < c; i++)
@@ -1228,7 +1228,7 @@ compare(id elem1, id elem2, void* context)
 	  [s appendString: [[self objectAtIndex: i] description]];
 	}
     }
-  return [s makeImmutableCopyOnFail: NO];
+  return [[s makeImmutable] autorelease];
 }
 
 /**
@@ -1238,8 +1238,8 @@ compare(id elem1, id elem2, void* context)
  */
 - (NSArray*) pathsMatchingExtensions: (NSArray*)extensions
 {
-  unsigned i, c = [self count];
-  NSMutableArray *a = [[[NSMutableArray alloc] initWithCapacity: 1] autorelease];
+  NSUInteger i, c = [self count];
+  NSMutableArray *a = [[NSMutableArray alloc] initWithCapacity: 1];
   Class	cls = [NSString class];
   IMP	get = [self methodForSelector: oaiSel];
   IMP	add = [a methodForSelector: addSel];
@@ -1256,7 +1256,7 @@ compare(id elem1, id elem2, void* context)
 	    }
 	}
     }
-  return [a makeImmutableCopyOnFail: NO];
+  return [[a makeImmutable] autorelease];
 }
 
 /**
@@ -1266,7 +1266,7 @@ compare(id elem1, id elem2, void* context)
  */
 - (id) firstObjectCommonWithArray: (NSArray*)otherArray
 {
-  unsigned i, c = [self count];
+  NSUInteger i, c = [self count];
   id o;
 
   for (i = 0; i < c; i++)
@@ -1286,7 +1286,7 @@ compare(id elem1, id elem2, void* context)
 - (NSArray*) subarrayWithRange: (NSRange)aRange
 {
   id na;
-  unsigned c = [self count];
+  NSUInteger c = [self count];
 
   GS_RANGE_CHECK(aRange, c);
 
@@ -1458,20 +1458,20 @@ compare(id elem1, id elem2, void* context)
 
   if ([key isEqualToString: @"@count"] == YES)
     {
-      result = [NSNumber numberWithUnsignedInt: [self count]];
+      result = [NSNumber numberWithUnsignedInteger: [self count]];
     }
   else if ([key isEqualToString: @"count"] == YES)
     {
       GSOnceMLog(
 @"[NSArray-valueForKey:] called wth 'count' is deprecated .. use '@count'");
-      result = [NSNumber numberWithUnsignedInt: [self count]];
+      result = [NSNumber numberWithUnsignedInteger: [self count]];
     }
   else
     {
       NSMutableArray	*results = nil;
       static NSNull	*null = nil;
-      unsigned		i;
-      unsigned		count = [self count];
+      NSUInteger		i;
+      NSUInteger		count = [self count];
       volatile id	object = nil;
 
       results = [NSMutableArray arrayWithCapacity: count];
@@ -1512,7 +1512,7 @@ compare(id elem1, id elem2, void* context)
         {
           if ([path isEqualToString: @"@count"] == YES)
             {
-              result = [NSNumber numberWithUnsignedInt: [self count]];
+              result = [NSNumber numberWithUnsignedInteger: [self count]];
             }
           else
             {
@@ -1523,11 +1523,11 @@ compare(id elem1, id elem2, void* context)
         {
           NSString      *op = [path substringToIndex: r.location];
           NSString      *rem = [path substringFromIndex: NSMaxRange(r)];
-          unsigned      count = [self count];
+          NSUInteger      count = [self count];
 
           if ([op isEqualToString: @"@count"] == YES)
             {
-              result = [NSNumber numberWithUnsignedInt: count];
+              result = [NSNumber numberWithUnsignedInteger: count];
             }
           else if ([op isEqualToString: @"@avg"] == YES)
             {
@@ -1665,13 +1665,13 @@ compare(id elem1, id elem2, void* context)
                   NSEnumerator  *e = [self objectEnumerator];
                   id            o;
 
-                  result = [GSMutableArray array];
+                  result = [[GSMutableArray alloc] init];
                   while ((o = [e nextObject]) != nil)
                     {
                       o = [o valueForKeyPath: rem];
                       [result addObjectsFromArray: o];
                     }
-                  [result makeImmutableCopyOnFail: NO];
+                  result = [[result makeImmutable] autorelease];
                 }
               else
                 {
@@ -1685,13 +1685,13 @@ compare(id elem1, id elem2, void* context)
                   NSEnumerator  *e = [self objectEnumerator];
                   id            o;
 
-                  result = [GSMutableArray array];
+                  result = [[GSMutableArray alloc] init];
                   while ((o = [e nextObject]) != nil)
                     {
                       o = [o valueForKeyPath: rem];
                       [result addObject: o];
                     }
-                  [result makeImmutableCopyOnFail: NO];
+                  result = [[result makeImmutable] autorelease];
                 }
               else
                 {
@@ -1705,13 +1705,13 @@ compare(id elem1, id elem2, void* context)
                   NSEnumerator  *e = [self objectEnumerator];
                   id            o;
 
-                  result = [GSMutableArray array];
+                  result = [[GSMutableArray alloc] init];
                   while ((o = [e nextObject]) != nil)
                     {
                       o = [o valueForKeyPath: rem];
                       [result addObjectsFromArray: [o allObjects]];
                     }
-                  [result makeImmutableCopyOnFail: NO];
+                  result = [[result makeImmutable] autorelease];
                 }
               else
                 {
@@ -2115,7 +2115,7 @@ compare(id elem1, id elem2, void* context)
  */
 - (void) removeLastObject
 {
-  unsigned	count = [self count];
+  NSUInteger	count = [self count];
 
   if (count == 0)
     [NSException raise: NSRangeException
@@ -2129,7 +2129,7 @@ compare(id elem1, id elem2, void* context)
  */
 - (void) removeObjectIdenticalTo: (id)anObject
 {
-  unsigned	i;
+  NSUInteger	i;
 
   if (anObject == nil)
     {
@@ -2164,9 +2164,9 @@ compare(id elem1, id elem2, void* context)
  */
 - (void) removeObject: (id)anObject inRange: (NSRange)aRange
 {
-  unsigned	c;
-  unsigned	s;
-  unsigned	i;
+  NSUInteger	c;
+  NSUInteger	s;
+  NSUInteger	i;
 
   if (anObject == nil)
     {
@@ -2221,9 +2221,9 @@ compare(id elem1, id elem2, void* context)
  */
 - (void) removeObjectIdenticalTo: (id)anObject inRange: (NSRange)aRange
 {
-  unsigned	c;
-  unsigned	s;
-  unsigned	i;
+  NSUInteger	c;
+  NSUInteger	s;
+  NSUInteger	i;
 
   if (anObject == nil)
     {
@@ -2264,7 +2264,7 @@ compare(id elem1, id elem2, void* context)
  */
 - (void) removeObject: (id)anObject
 {
-  unsigned	i;
+  NSUInteger	i;
 
   if (anObject == nil)
     {
@@ -2312,7 +2312,7 @@ compare(id elem1, id elem2, void* context)
  */
 - (void) removeAllObjects
 {
-  unsigned	c = [self count];
+  NSUInteger	c = [self count];
 
   if (c > 0)
     {
@@ -2330,7 +2330,7 @@ compare(id elem1, id elem2, void* context)
  */
 - (void) addObjectsFromArray: (NSArray*)otherArray
 {
-  unsigned c = [otherArray count];
+  NSUInteger c = [otherArray count];
 
   if (c > 0)
     {
@@ -2380,14 +2380,14 @@ compare(id elem1, id elem2, void* context)
 {
   if (count > 0)
     {
-      unsigned	to = 0;
-      unsigned	from = 0;
-      unsigned	i;
+      NSUInteger	to = 0;
+      NSUInteger	from = 0;
+      NSUInteger	i;
       GS_BEGINITEMBUF(sorted, count, NSUInteger);
 
       while (from < count)
 	{
-	  unsigned	val = indices[from++];
+	  NSUInteger	val = indices[from++];
 
 	  i = to;
 	  while (i > 0 && sorted[i-1] > val)
@@ -2400,7 +2400,7 @@ compare(id elem1, id elem2, void* context)
 	    }
 	  else if (sorted[i] != val)
 	    {
-	      unsigned	j = to++;
+	      NSUInteger	j = to++;
 
 	      if (sorted[i] < val)
 		{
@@ -2434,11 +2434,11 @@ compare(id elem1, id elem2, void* context)
  */
 - (void) removeObjectsInArray: (NSArray*)otherArray
 {
-  unsigned	c = [otherArray count];
+  NSUInteger	c = [otherArray count];
 
   if (c > 0)
     {
-      unsigned	i;
+      NSUInteger	i;
       IMP	get = [otherArray methodForSelector: oaiSel];
       IMP	rem = [self methodForSelector: @selector(removeObject:)];
 
@@ -2452,9 +2452,9 @@ compare(id elem1, id elem2, void* context)
  */
 - (void) removeObjectsInRange: (NSRange)aRange
 {
-  unsigned	i;
-  unsigned	s = aRange.location;
-  unsigned	c = [self count];
+  NSUInteger	i;
+  NSUInteger	s = aRange.location;
+  NSUInteger	c = [self count];
 
   i = aRange.location + aRange.length;
 
@@ -2560,8 +2560,8 @@ compare(id elem1, id elem2, void* context)
  */
 - (void) setValue: (id)value forKey: (NSString*)key
 {
-  unsigned	i;
-  unsigned	count = [self count];
+  NSUInteger	i;
+  NSUInteger	count = [self count];
   volatile id	object = nil;
 
   for (i = 0; i < count; i++)
diff --git a/Source/NSAssertionHandler.m b/Source/NSAssertionHandler.m
index b53f185..c98428d 100644
--- a/Source/NSAssertionHandler.m
+++ b/Source/NSAssertionHandler.m
@@ -97,8 +97,8 @@ NSString *const NSAssertionHandlerKey = @"NSAssertionHandler";
   va_start(ap, format);
   message =
     [NSString
-      stringWithFormat: @"%@:%d  Assertion failed in %@.  %@",
-      fileName, line, functionName, format];
+      stringWithFormat: @"%@:%ld  Assertion failed in %@.  %@",
+      fileName, (long)line, functionName, format];
   NSLogv(message, ap);
 
   [NSException raise: NSInternalInconsistencyException
@@ -125,8 +125,8 @@ NSString *const NSAssertionHandlerKey = @"NSAssertionHandler";
   va_start(ap, format);
   message =
     [NSString
-      stringWithFormat: @"%@:%d  Assertion failed in %@(%@), method %@.  %@",
-      fileName, line, NSStringFromClass([object class]),
+      stringWithFormat: @"%@:%ld  Assertion failed in %@(%@), method %@.  %@",
+      fileName, (long)line, NSStringFromClass([object class]),
       class_isMetaClass([object class]) ? @"class" : @"instance",
       NSStringFromSelector(aSelector), format];
   NSLogv(message, ap);
diff --git a/Source/NSAttributedString.m b/Source/NSAttributedString.m
index 0cd57a1..3c134e2 100644
--- a/Source/NSAttributedString.m
+++ b/Source/NSAttributedString.m
@@ -34,19 +34,6 @@
    $Date$ $Revision$
 */
 
-/* Warning -	[-initWithString:attributes:] is the designated initialiser,
- *		but it doesn't provide any way to perform the function of the
- *		[-initWithAttributedString:] initialiser.
- *		In order to work round this, the string argument of the
- *		designated initialiser has been overloaded such that it
- *		is expected to accept an NSAttributedString here instead of
- *		a string.  If you create an NSAttributedString subclass, you
- *		must make sure that your implementation of the initialiser
- *		copes with either an NSString or an NSAttributedString.
- *		If it receives an NSAttributedString, it should ignore the
- *		attributes argument and use the values from the string.
- */
-
 #import "common.h"
 #import "GNUstepBase/Unicode.h"
 
@@ -154,8 +141,8 @@ static Class GSMutableAttributedStringClass;
 static void
 appendUIntData(NSMutableData *d, NSUInteger i)
 {
-  unsigned int aux = i;
-  unsigned int len = 1;
+  NSUInteger aux = i;
+  NSUInteger len = 1;
 
   while (aux >= 128)
     {
@@ -220,8 +207,8 @@ appendUIntData(NSMutableData *d, NSUInteger i)
   else
     {
       NSRange		r = NSMakeRange(0, 0);
-      unsigned		index = NSMaxRange(r);
-      unsigned		length = [self length];
+      NSUInteger		index = NSMaxRange(r);
+      NSUInteger		length = [self length];
       NSString		*string = [self string];
       NSDictionary	*attrs;
 
@@ -230,7 +217,7 @@ appendUIntData(NSMutableData *d, NSUInteger i)
 	{
 	  attrs = [self attributesAtIndex: index effectiveRange: &r];
 	  index = NSMaxRange(r);
-	  [aCoder encodeValueOfObjCType: @encode(unsigned) at: &index];
+	  [aCoder encodeValueOfObjCType: @encode(NSUInteger) at: &index];
 	  [aCoder encodeObject: attrs];
 	}
     }
@@ -251,7 +238,7 @@ appendUIntData(NSMutableData *d, NSUInteger i)
         {
           NSArray *attributes = [aDecoder decodeObjectForKey: @"NSAttributes"];
           NSData *info = [aDecoder decodeObjectForKey: @"NSAttributeInfo"];
-          unsigned int pos = 0;
+          NSUInteger pos = 0;
           const unsigned char *p = [info bytes];
           const unsigned char *end = p + [info length];
           NSMutableAttributedString *m = [[NSMutableAttributedString alloc] 
@@ -260,9 +247,9 @@ appendUIntData(NSMutableData *d, NSUInteger i)
 
           while (p < end)
             {
-              unsigned int idx;
-              unsigned int len;
-	      unsigned int shift;
+              NSUInteger idx;
+              NSUInteger len;
+	      unsigned shift;
               NSRange r;
 
 	      len = shift = 0;
@@ -286,14 +273,15 @@ appendUIntData(NSMutableData *d, NSUInteger i)
               pos = NSMaxRange(r);
             }
           DESTROY(self);
-          self = [m copy];
+          id result = [m copy];
           RELEASE(m);
+          return result;
         }
     }
   else
     {
       NSString	*string = [aDecoder decodeObject];
-      unsigned	length = [string length];
+      NSUInteger	length = [string length];
 
       if (length == 0)
         {
@@ -301,10 +289,10 @@ appendUIntData(NSMutableData *d, NSUInteger i)
 	}
       else
         {
-	  unsigned	index;
+	  NSUInteger	index;
 	  NSDictionary	*attrs;
 	
-	  [aDecoder decodeValueOfObjCType: @encode(unsigned) at: &index];
+	  [aDecoder decodeValueOfObjCType: @encode(NSUInteger) at: &index];
 	  attrs = [aDecoder decodeObject];
 	  if (index == length)
 	    {
@@ -313,7 +301,7 @@ appendUIntData(NSMutableData *d, NSUInteger i)
 	  else
 	    {
 	      NSRange	r = NSMakeRange(0, index);
-	      unsigned	last = index;
+	      NSUInteger	last = index;
 	      NSMutableAttributedString	*m;
 	
 	      m = [NSMutableAttributedString alloc];
@@ -321,7 +309,7 @@ appendUIntData(NSMutableData *d, NSUInteger i)
 	      [m setAttributes: attrs range: r];
 	      while (index < length)
 	        {
-		  [aDecoder decodeValueOfObjCType: @encode(unsigned)
+		  [aDecoder decodeValueOfObjCType: @encode(NSUInteger)
 			 		       at: &index];
 		  attrs = [aDecoder decodeObject];
 		  r = NSMakeRange(last, index - last);
@@ -329,8 +317,9 @@ appendUIntData(NSMutableData *d, NSUInteger i)
 		  last = index;
 		}
 	      DESTROY(self);
-	      self = [m copy];
+	      id result = [m copy];
 	      RELEASE(m);
+	      return result;
 	    }
 	}
     }
@@ -380,27 +369,55 @@ appendUIntData(NSMutableData *d, NSUInteger i)
 /**
  *  Initialize to copy of attributedString.
  */
-- (id) initWithAttributedString: (NSAttributedString*)attributedString
+- (id)initWithAttributedString:(NSAttributedString *)attributedString
 {
-  return [self initWithString: (NSString*)attributedString attributes: nil];
+    if (nil == attributedString)
+    {
+        [NSException raise: NSInvalidArgumentException
+                    format: @"attributedString object passed to -[NSAttributedString initWithAttributedString:] is nil"];
+    }
+    if (![attributedString isKindOfClass: [NSAttributedString class]])
+    {
+        [NSException raise: NSInvalidArgumentException
+                    format: @"attributedString object passed to -[NSAttributedString initWithAttributedString:] is not NSAttributedString instance"];
+    }
+    if ([self class] == NSAttributedStringClass)
+    {
+        [self subclassResponsibility: _cmd]; /* Primitive method! */
+        return nil;
+    }
+    return [super init];
 }
 
 /**
  *  Initialize to aString with given attributes applying over full range of
  *  string.
  */
-- (id) initWithString: (NSString*)aString attributes: (NSDictionary*)attributes
+- (id)initWithString:(NSString *)aString attributes:(NSDictionary *)attributes
 {
-  //This is the designated initializer
-  [self subclassResponsibility: _cmd];/* Primitive method! */
-  return nil;
+    if (nil == aString)
+    {
+        [NSException raise: NSInvalidArgumentException
+                    format: @"aString object passed to -[NSAttributedString initWithString:attributes:] is nil"];
+    }
+    if (![aString respondsToSelector: @selector(length)]) /* todo: correct type check or remove it */
+    {
+        [NSException raise: NSInvalidArgumentException
+                    format: @"aString object passed to -[NSAttributedString initWithString:attributes:] does not respond to -length"];
+    }
+    if ([self class] == NSAttributedStringClass)
+    {
+        [self subclassResponsibility: _cmd]; /* Primitive method! */
+        return nil;
+    }
+    return [super init];
 }
 
 - (NSString*) description
 {
   NSRange		r = NSMakeRange(0, 0);
-  unsigned		index = NSMaxRange(r);
-  unsigned		length = [self length];
+  NSUInteger		index = NSMaxRange(r);
+  NSUInteger		length = [self length];
   NSString		*string = [self string];
   NSDictionary		*attrs;
   NSMutableString	*desc;
@@ -613,7 +630,7 @@ appendUIntData(NSMutableData *d, NSUInteger i)
 - (BOOL) isEqualToAttributedString: (NSAttributedString*)otherString
 {
   NSRange ownEffectiveRange,otherEffectiveRange;
-  unsigned int length;
+  NSUInteger length;
   NSDictionary *ownDictionary,*otherDictionary;
   BOOL result;
 
@@ -679,7 +696,7 @@ appendUIntData(NSMutableData *d, NSUInteger i)
   NSString		*newSubstring;
   NSDictionary		*attrs;
   NSRange		range;
-  unsigned		len = [self length];
+  NSUInteger		len = [self length];
 
   GS_RANGE_CHECK(aRange, len);
 
@@ -733,6 +750,33 @@ appendUIntData(NSMutableData *d, NSUInteger i)
     return NSAllocateObject(self, 0, z);
 }
 
+/**
+ *  Initialize to copy of attributedString.
+ */
+- (id)initWithAttributedString:(NSAttributedString *)attributedString
+{
+    if ([self class] == NSMutableAttributedStringClass)
+    {
+        [self subclassResponsibility: _cmd]; /* Primitive method! */
+        return nil;
+    }
+    return [super initWithAttributedString:attributedString];
+}
+
+/**
+ *  Initialize to aString with given attributes applying over full range of
+ *  string.
+ */
+- (id)initWithString:(NSString *)aString attributes:(NSDictionary *)attributes
+{
+    if ([self class] == NSMutableAttributedStringClass)
+    {
+        [self subclassResponsibility: _cmd]; /* Primitive method! */
+        return nil;
+    }
+    return [super initWithString:aString attributes:attributes];
+}
+
 - (Class) classForCoder
 {
   return NSMutableAttributedStringClass;
@@ -753,16 +797,16 @@ appendUIntData(NSMutableData *d, NSUInteger i)
         {
           NSArray *attributes = [aDecoder decodeObjectForKey: @"NSAttributes"];
           NSData *info = [aDecoder decodeObjectForKey: @"NSAttributeInfo"];
-          unsigned int pos = 0;
+          NSUInteger pos = 0;
           const unsigned char *p = [info bytes];
           const unsigned char *end = p + [info length];
 
 	  self = [self initWithString: string attributes: nil];
           while (p < end)
             {
-              unsigned int idx;
-              unsigned int len;
-	      unsigned int shift;
+              NSUInteger idx;
+              NSUInteger len;
+	      unsigned shift;
               NSRange r;
 
 	      len = shift = 0;
@@ -790,7 +834,7 @@ appendUIntData(NSMutableData *d, NSUInteger i)
   else
     {
       NSString	*string = [aDecoder decodeObject];
-      unsigned	length = [string length];
+      NSUInteger	length = [string length];
 
       if (length == 0)
 	{
@@ -798,10 +842,10 @@ appendUIntData(NSMutableData *d, NSUInteger i)
 	}
       else
 	{
-	  unsigned	index;
+	  NSUInteger	index;
 	  NSDictionary	*attrs;
 
-	  [aDecoder decodeValueOfObjCType: @encode(unsigned) at: &index];
+	  [aDecoder decodeValueOfObjCType: @encode(NSUInteger) at: &index];
 	  attrs = [aDecoder decodeObject];
 	  if (index == length)
 	    {
@@ -810,13 +854,13 @@ appendUIntData(NSMutableData *d, NSUInteger i)
 	  else
 	    {
 	      NSRange	r = NSMakeRange(0, index);
-	      unsigned	last = index;
+	      NSUInteger	last = index;
 	      
 	      self = [self initWithString: string attributes: nil];
 	      [self setAttributes: attrs range: r];
 	      while (index < length)
 		{
-		  [aDecoder decodeValueOfObjCType: @encode(unsigned)
+		  [aDecoder decodeValueOfObjCType: @encode(NSUInteger)
 					   at: &index];
 		  attrs = [aDecoder decodeObject];
 		  r = NSMakeRange(last, index - last);
@@ -865,7 +909,7 @@ appendUIntData(NSMutableData *d, NSUInteger i)
   NSRange		effectiveRange;
   NSDictionary		*attrDict;
   NSMutableDictionary	*newDict;
-  unsigned int		tmpLength;
+  NSUInteger		tmpLength;
   IMP			getImp;
 
   tmpLength = [self length];
@@ -914,7 +958,7 @@ appendUIntData(NSMutableData *d, NSUInteger i)
   NSRange		effectiveRange;
   NSDictionary		*attrDict;
   NSMutableDictionary	*newDict;
-  unsigned int		tmpLength;
+  NSUInteger		tmpLength;
   IMP			getImp;
 
   if (!attributes)
@@ -974,7 +1018,7 @@ appendUIntData(NSMutableData *d, NSUInteger i)
   NSRange		effectiveRange;
   NSDictionary		*attrDict;
   NSMutableDictionary	*newDict;
-  unsigned int		tmpLength;
+  NSUInteger		tmpLength;
   IMP			getImp;
 
   tmpLength = [self length];
@@ -1043,7 +1087,7 @@ appendUIntData(NSMutableData *d, NSUInteger i)
 {
   NSDictionary	*attrDict;
   NSString	*tmpStr;
-  unsigned	max;
+  NSUInteger	max;
 
   if (attributedString == nil)
     {
@@ -1058,7 +1102,7 @@ appendUIntData(NSMutableData *d, NSUInteger i)
 
   if (max > 0)
     {
-      unsigned	loc = 0;
+      NSUInteger	loc = 0;
       NSRange	effectiveRange = NSMakeRange(0, loc);
       NSRange	clipRange = NSMakeRange(0, max);
       IMP	getImp;
@@ -1182,7 +1226,7 @@ appendUIntData(NSMutableData *d, NSUInteger i)
   return [[_owner string] smallestEncoding];
 }
 
-- (int) _baseLength
+- (NSUInteger) _baseLength
 {
   return [[_owner string] _baseLength];
 }
diff --git a/Source/NSAutoreleasePool.m b/Source/NSAutoreleasePool.m
index 2230e4a..3d46499 100644
--- a/Source/NSAutoreleasePool.m
+++ b/Source/NSAutoreleasePool.m
@@ -241,7 +241,7 @@ static unsigned pool_number_warning_threshhold = 10000;
 
 
 @interface NSAutoreleasePool (Private)
-+ (unsigned) autoreleaseCountForObject: (id)anObject;
++ (NSUInteger) autoreleaseCountForObject: (id)anObject;
 - (void) _reallyDealloc;
 @end
 
@@ -378,17 +378,17 @@ pop_pool_from_cache (struct autorelease_thread_vars *tv)
   return self;
 }
 
-- (unsigned) autoreleaseCountForObject: (id)anObject
+- (NSUInteger) autoreleaseCountForObject: (id)anObject
 {
   return objc_arc_autorelease_count_for_object_np(anObject);
 }
 
-+ (unsigned) autoreleaseCountForObject: (id)anObject
++ (NSUInteger) autoreleaseCountForObject: (id)anObject
 {
   return objc_arc_autorelease_count_for_object_np(anObject);
 }
 
-- (unsigned) autoreleaseCount
+- (NSUInteger) autoreleaseCount
 {
   return objc_arc_autorelease_count_np();
 }
@@ -472,9 +472,9 @@ pop_pool_from_cache (struct autorelease_thread_vars *tv)
   return self;
 }
 
-- (unsigned) autoreleaseCount
+- (NSUInteger) autoreleaseCount
 {
-  unsigned count = 0;
+  NSUInteger count = 0;
   struct autorelease_array_list *released = _released_head;
   while (released != 0)
     {
@@ -484,11 +484,11 @@ pop_pool_from_cache (struct autorelease_thread_vars *tv)
   return count;
 }
 
-- (unsigned) autoreleaseCountForObject: (id)anObject
+- (NSUInteger) autoreleaseCountForObject: (id)anObject
 {
-  unsigned count = 0;
+  NSUInteger count = 0;
   struct autorelease_array_list *released = _released_head;
-  unsigned int i;
+  NSUInteger i;
 
   while (released != 0)
     {
@@ -500,9 +500,9 @@ pop_pool_from_cache (struct autorelease_thread_vars *tv)
   return count;
 }
 
-+ (unsigned) autoreleaseCountForObject: (id)anObject
++ (NSUInteger) autoreleaseCountForObject: (id)anObject
 {
-  unsigned count = 0;
+  NSUInteger count = 0;
   NSAutoreleasePool *pool = ARP_THREAD_VARS->current_pool;
 
   while (pool)
diff --git a/Source/NSBundle.m b/Source/NSBundle.m
index 8f12f8f..d978959 100644
--- a/Source/NSBundle.m
+++ b/Source/NSBundle.m
@@ -244,7 +244,7 @@ static NSString	*library_combo =
 
 /*
  * Try to find the absolute path of an executable.
- * Search all the directoried in the PATH.
+ * Search all the directories in the PATH.
  * The atLaunch flag determines whether '.' is considered to be
  * the  current working directory or the working directory at the
  * time when the program was launched (technically the directory
@@ -429,7 +429,8 @@ static NSString *
 bundle_object_name(NSString *path, NSString* executable)
 {
   NSFileManager	*mgr = manager();
-  NSString	*name, *path0, *path1, *path2;
+  NSString      *name;
+  NSArray       *paths;
 
   if (executable)
     {
@@ -438,48 +439,48 @@ bundle_object_name(NSString *path, NSString* executable)
       name = [executable lastPathComponent];
       exepath = [executable stringByDeletingLastPathComponent];
       if ([exepath isEqualToString: @""] == NO)
-	{
-	  if ([exepath isAbsolutePath] == YES)
-	    path = exepath;
-	  else
-	    path = [path stringByAppendingPathComponent: exepath];
-	}
+        {
+          if ([exepath isAbsolutePath] == YES)
+            path = exepath;
+          else
+            path = [path stringByAppendingPathComponent: exepath];
+        }
     }
   else
     {
       name = [[path lastPathComponent] stringByDeletingPathExtension];
       path = [path stringByDeletingLastPathComponent];
     }
-  path0 = [path stringByAppendingPathComponent: name];
-  path = [path stringByAppendingPathComponent: gnustep_target_dir];
-  path1 = [path stringByAppendingPathComponent: name];
-  path = [path stringByAppendingPathComponent: library_combo];
-  path2 = [path stringByAppendingPathComponent: name];
-
-  if ([mgr isReadableFileAtPath: path2] == YES)
-    return path2;
-  else if ([mgr isReadableFileAtPath: path1] == YES)
-    return path1;
-  else if ([mgr isReadableFileAtPath: path0] == YES)
-    return path0;
-#if defined(__MINGW__)
-  /* If we couldn't find the binary, and we are on windows, and the name
-   * has no path extension, then let's try looking for a dll.
-   */
-  if ([name pathExtension] == nil)
-    {
-      if ([mgr isReadableFileAtPath:
-	[path2 stringByAppendingPathExtension: @"dll"]] == YES)
-	return [path2 stringByAppendingPathExtension: @"dll"];
-      else if ([mgr isReadableFileAtPath:
-	[path1 stringByAppendingPathExtension: @"dll"]] == YES)
-	return [path1 stringByAppendingPathExtension: @"dll"];
-      else if ([mgr isReadableFileAtPath:
-	[path0 stringByAppendingPathExtension: @"dll"]] == YES)
-	return [path0 stringByAppendingPathExtension: @"dll"];
+  
+  NSString *pathWithTargetDirectory = [path stringByAppendingPathComponent:gnustep_target_dir];
+  paths = [NSArray arrayWithObjects:path,
+           [path stringByAppendingPathComponent:@"Contents/MacOS"],
+           pathWithTargetDirectory,
+           [pathWithTargetDirectory stringByAppendingPathComponent:library_combo],
+           nil];
+  
+  NSEnumerator *enumerator = [paths reverseObjectEnumerator];
+  while ((path = [enumerator nextObject])) {
+    path = [path stringByAppendingPathComponent:name];
+    if ([mgr isReadableFileAtPath:path]) {
+      return path;
     }
+#if defined(__MINGW__)
+    /* If we couldn't find the binary, and we are on windows, and the name
+     * has no path extension, then let's try looking for a dll.
+     */
+    if ([name pathExtension] == nil)
+      {
+        path = [path stringByAppendingPathExtension: @"dll"];
+        if ([mgr isReadableFileAtPath:path])
+          {
+            return path;
+          }
+      }
 #endif
-  return path0;
+  }
+  
+  return [paths objectAtIndex:0];
 }
 
 /* Construct a path from components */
@@ -623,7 +624,7 @@ _find_main_bundle_for_tool(NSString *toolName)
 @interface NSBundle (Private)
 + (NSString *) _absolutePathOfExecutable: (NSString *)path;
 + (NSBundle*) _addFrameworkFromClass: (Class)frameworkClass;
-+ (NSMutableArray*) _addFrameworks;
++ (NSUInteger) _addFrameworks;
 + (NSString*) _gnustep_target_cpu;
 + (NSString*) _gnustep_target_dir;
 + (NSString*) _gnustep_target_os;
@@ -688,8 +689,8 @@ _find_main_bundle_for_tool(NSString *toolName)
   NSBundle	*bundle = nil;
   NSString	**fmClasses;
   NSString	*bundlePath = nil;
-  unsigned int	len;
-  const char    *frameworkClassName;
+  size_t    len;
+  const char *frameworkClassName;
 
   if (frameworkClass == Nil)
     {
@@ -920,7 +921,7 @@ _find_main_bundle_for_tool(NSString *toolName)
        */
       if (_loadingBundle != nil && _loadingBundle != bundle)
 	{
-	  int i, j;
+	  NSUInteger i, j;
           id b = bundle->_bundleClasses;
           id l = _loadingBundle->_bundleClasses;
 
@@ -946,16 +947,96 @@ _find_main_bundle_for_tool(NSString *toolName)
 	    }
 	}
     }
-  return bundle;
+  return [bundle autorelease];
+}
+
+#if defined (NeXT_RUNTIME)
+
+static NSString * RealPath(NSString *path)
+{
+    char result[PATH_MAX + 1];
+    if (realpath([path UTF8String], result) == NULL) {
+        return nil;
+    }
+    return [NSString stringWithUTF8String:result];
+}
+
+static NSString * StripLastPathComponentIfEqual(NSString *path, NSString *component)
+{
+    if ([[path lastPathComponent] isEqualToString:component]) {
+        return [path stringByDeletingLastPathComponent];
+    }
+    return path;
+}
+
++ (NSBundle *) _createBundleWithExecutablePath:(NSString *)path
+{
+    path = RealPath(path);
+    if (!path) {
+        [NSException raise:NSInternalInconsistencyException format:@"Could not resolve real path for: %@", path];
+    }
+    NSString *bundlePath = [path stringByDeletingLastPathComponent];
+    bundlePath = StripLastPathComponentIfEqual(bundlePath, library_combo);
+    bundlePath = StripLastPathComponentIfEqual(bundlePath, gnustep_target_os);
+    bundlePath = StripLastPathComponentIfEqual(bundlePath, gnustep_target_cpu);
+
+    NSString *version = nil;
+    if ([[[bundlePath stringByDeletingLastPathComponent] lastPathComponent] isEqualToString:@"Versions"]) {
+        version = [bundlePath lastPathComponent];
+        bundlePath = [[bundlePath stringByDeletingLastPathComponent] stringByDeletingLastPathComponent];
+    }
+    NSBundle *result = [[self alloc] initWithPath:bundlePath];
+    result->_codeLoaded = YES;
+    result->_frameworkVersion = version;
+    return [result autorelease];
+}
+
++ (NSUInteger) _addFrameworks
+{
+    static unsigned classCount = 0;
+    static unsigned imageCount = 0;
+
+    [load_lock lock];
+
+    unsigned currentClassCount = objc_getClassList(NULL, 0);
+    unsigned currentImageCount = imageCount;
+    if (classCount != currentClassCount) {
+        classCount = currentClassCount;
+
+        const char **images = objc_copyImageNames(&currentImageCount);
+        for (unsigned imageIndex = imageCount; imageIndex < currentImageCount; ++imageIndex) {
+            NSBundle *bundle = [self _createBundleWithExecutablePath:[NSString stringWithUTF8String:images[imageIndex]]];
+            if (!bundle) {
+                continue;
+            }
+            unsigned int classCount;
+            const char **classes = objc_copyClassNamesForImage(images[imageIndex], &classCount);
+            bundle->_bundleClasses = [[NSMutableArray alloc] initWithCapacity:classCount];
+            for (unsigned classIndex = 0; classIndex < classCount; ++classIndex) {
+                Class class = objc_getClass(classes[classIndex]);
+                NSMapInsert(_byClass, class, bundle);
+                [bundle->_bundleClasses addObject:[NSValue valueWithPointer:(void*)class]];
+            }
+            free(classes);
+        }
+        free(images);
+    }
+
+    NSUInteger result = currentImageCount - imageCount;
+    imageCount = currentImageCount;
+
+    [load_lock unlock];
+    return result;
 }
 
-+ (NSMutableArray*) _addFrameworks
+#else /* NeXT_RUNTIME */
+
++ (NSUInteger) _addFrameworks
 {
-  int                   i;
-  int                   numClasses = 0;
-  int                   newNumClasses;
-  Class                 *classes = NULL;
-  NSMutableArray        *added = nil;
+  unsigned loaded = 0;
+  unsigned numClasses = 0;
+  unsigned newNumClasses;
+  Class *classes = NULL;
 
   newNumClasses = objc_getClassList(NULL, 0);
   while (numClasses < newNumClasses)
@@ -964,23 +1045,21 @@ _find_main_bundle_for_tool(NSString *toolName)
       classes = realloc(classes, sizeof(Class) * numClasses);
       newNumClasses = objc_getClassList(classes, numClasses);
     }
-  for (i = 0; i < numClasses; i++)
+  for (unsigned index = 0; index < numClasses; ++index)
     {
-      NSBundle  *bundle = [self _addFrameworkFromClass: classes[i]];
+      NSBundle  *bundle = [self _addFrameworkFromClass: classes[index]];
 
       if (nil != bundle)
         {
-          if (nil == added)
-            {
-              added = [NSMutableArray arrayWithCapacity: 100];
-            }
-          [added addObject: bundle];
+          ++loaded;
         }
     }
   free(classes);
-  return added;
+  return loaded;
 }
 
+#endif /* NeXT_RUNTIME */
+
 + (NSString*) _gnustep_target_cpu
 {
   return gnustep_target_cpu;
@@ -1058,7 +1137,6 @@ _bundle_load_callback(Class theClass, struct objc_category *theCategory)
 {
   if (self == [NSBundle class])
     {
-      extern const char	*GSPathHandling(const char *);
       NSAutoreleasePool *pool = [NSAutoreleasePool new];
       NSString          *file;
       const char	*mode;
@@ -1567,7 +1645,7 @@ _bundle_load_callback(Class theClass, struct objc_category *theCategory)
 	   * and return the mainBundle instead.
 	   */
 	  bundle = [NSBundle bundleForLibrary: lib];
-          if (nil == bundle && [[self _addFrameworks] count] > 0)
+          if (nil == bundle && [self _addFrameworks] > 0)
             {
               bundle = (NSBundle *)NSMapGet(_byClass, aClass);
               if ((id)bundle == (id)[NSNull null])
@@ -1876,8 +1954,8 @@ IF_NO_GC(
 
 - (Class) classNamed: (NSString *)className
 {
-  int     i, j;
-  Class   theClass = Nil;
+  NSUInteger  i, j;
+  Class       theClass = Nil;
 
   if (!_codeLoaded)
     {
@@ -2099,48 +2177,39 @@ IF_NO_GC(
   NSArray		*languages;
   NSArray		*contents;
   NSMutableArray	*array;
-  NSEnumerator		*enumerate;
+  NSEnumerator		*enumerator;
 
   array = [NSMutableArray arrayWithCapacity: 8];
   languages = [[NSUserDefaults standardUserDefaults]
     stringArrayForKey: @"NSLanguages"];
-
-  primary = [rootPath stringByAppendingPathComponent: @"Resources"];
-  contents = bundle_directory_readable(primary);
-  addBundlePath(array, contents, primary, subPath, nil);
-  /* If we have been asked for a specific localization, we add it.
-   */
-  if (localization != nil)
-    {
-      addBundlePath(array, contents, primary, subPath, localization);
-    }
-  else
-    {
-      /* This matches OS X behavior, which only searches languages that
-       * are in the user's preference. Don't use -preferredLocalizations -
-       * that would cause a recursive loop.
-       */
-      enumerate = [languages objectEnumerator];
-      while ((language = [enumerate nextObject]))
-	{
-	  addBundlePath(array, contents, primary, subPath, language);
-	}
-    }
-  primary = rootPath;
-  contents = bundle_directory_readable(primary);
-  addBundlePath(array, contents, primary, subPath, nil);
-  if (localization != nil)
-    {
-      addBundlePath(array, contents, primary, subPath, localization);
-    }
-  else
-    {
-      enumerate = [languages objectEnumerator];
-      while ((language = [enumerate nextObject]))
-	{
-	  addBundlePath(array, contents, primary, subPath, language);
-	}
-    }
+  
+  NSArray *pathsToExamine = [NSArray arrayWithObjects:rootPath, 
+                             [rootPath stringByAppendingPathComponent:@"Resources"],
+                             [rootPath stringByAppendingPathComponent:@"Contents"],
+                             [rootPath stringByAppendingPathComponent:@"Contents/Resources"],
+                             nil];
+  
+  for (primary in pathsToExamine) {
+    contents = bundle_directory_readable(primary);
+    addBundlePath(array, contents, primary, subPath, nil);
+    /* If we have been asked for a specific localization, we add it. */
+    if (localization != nil)
+      {
+        addBundlePath(array, contents, primary, subPath, localization);
+      }
+    else
+      {
+        /* This matches OS X behavior, which only searches languages that
+         * are in the user's preference. Don't use -preferredLocalizations -
+         * that would cause a recursive loop.
+         */
+        enumerator = [languages objectEnumerator];
+        while ((language = [enumerator nextObject]))
+          {
+            addBundlePath(array, contents, primary, subPath, language);
+          }
+      }
+  }
   return array;
 }
 
@@ -2433,7 +2502,7 @@ IF_NO_GC(
   NSMutableArray	*array;
   NSEnumerator	*enumerate;
 
-  array = [NSMutableArray arrayWithCapacity: 2];
+  array = [[NSMutableArray alloc] initWithCapacity: 2];
   enumerate = [preferencesArray objectEnumerator];
   while ((locale = [enumerate nextObject]))
     {
@@ -2443,7 +2512,7 @@ IF_NO_GC(
   /* I guess this is arbitrary if we can't find a match? */
   if ([array count] == 0 && [localizationsArray count] > 0)
     [array addObject: [localizationsArray objectAtIndex: 0]];
-  return [array makeImmutableCopyOnFail: NO];
+  return [[array makeImmutable] autorelease];
 }
 
 - (NSDictionary*) localizedInfoDictionary
@@ -2497,7 +2566,7 @@ IF_NO_GC(
   NSString *locale;
   NSArray *localizations;
   NSEnumerator* enumerate;
-  NSMutableArray *array = [NSMutableArray arrayWithCapacity: 2];
+  NSMutableArray *array = [[NSMutableArray alloc] initWithCapacity: 2];
 
   localizations = [self pathsForResourcesOfType: @"lproj"
 	                            inDirectory: nil];
@@ -2507,7 +2576,7 @@ IF_NO_GC(
       locale = [[locale lastPathComponent] stringByDeletingPathExtension];
       [array addObject: locale];
     }
-  return [array makeImmutableCopyOnFail: NO];
+  return [[array makeImmutable] autorelease];
 }
 
 - (NSArray *) preferredLocalizations
@@ -2555,7 +2624,7 @@ IF_NO_GC(
           NSString		*tableContent;
           NSData		*tableData;
           const unsigned char	*bytes;
-          unsigned		length;
+          NSUInteger length;
 
           tableData = [[NSData alloc] initWithContentsOfFile: tablePath];
           bytes = [tableData bytes];
diff --git a/Source/NSCalendar.m b/Source/NSCalendar.m
index 987b5c9..4a12ab5 100644
--- a/Source/NSCalendar.m
+++ b/Source/NSCalendar.m
@@ -123,7 +123,7 @@ typedef struct {
 #define	UCAL_DEFAULT UCAL_TRADITIONAL
 #endif
   my->cal = 
-    ucal_open ((const UChar *)cTzId, tzLen, cLocaleId, UCAL_DEFAULT, &err);
+    ucal_open ((const UChar *)cTzId, (int32_t)tzLen, cLocaleId, UCAL_DEFAULT, &err);
 
   if (NSNotFound == my->firstWeekday)
     {
@@ -533,7 +533,7 @@ static NSRecursiveLock *classLock = nil;
 {
   my->firstWeekday = weekday;
 #if GS_USE_ICU == 1
-  ucal_setAttribute (my->cal, UCAL_FIRST_DAY_OF_WEEK, my->firstWeekday);
+  ucal_setAttribute (my->cal, UCAL_FIRST_DAY_OF_WEEK, (int32_t)my->firstWeekday);
 #endif
 }
 
@@ -546,8 +546,7 @@ static NSRecursiveLock *classLock = nil;
 {
   my->minimumDaysInFirstWeek = (int32_t)mdw;
 #if GS_USE_ICU == 1
-  ucal_setAttribute (my->cal, UCAL_MINIMAL_DAYS_IN_FIRST_WEEK,
-    my->minimumDaysInFirstWeek);
+  ucal_setAttribute (my->cal, UCAL_MINIMAL_DAYS_IN_FIRST_WEEK, (int32_t)my->minimumDaysInFirstWeek);
 #endif
 }
 
@@ -691,10 +690,12 @@ static NSRecursiveLock *classLock = nil;
 {
   NSString	*s = [decoder decodeObject];
 
-  [self initWithCalendarIdentifier: s];
-  [self _setLocaleIdentifier: [decoder decodeObject]];
-  [self setTimeZone: [decoder decodeObject]];
-  
+  if (self = [self initWithCalendarIdentifier: s])
+  {
+      [self _setLocaleIdentifier: [decoder decodeObject]];
+      [self setTimeZone: [decoder decodeObject]];
+  }
+
   return self;
 }
 
diff --git a/Source/NSCalendarDate.m b/Source/NSCalendarDate.m
index e8c5c23..508e488 100644
--- a/Source/NSCalendarDate.m
+++ b/Source/NSCalendarDate.m
@@ -87,7 +87,7 @@ static NSString* (*dstAbrIMP)(id, SEL, id);
  * Optimize for the local timezone, and less so for the other
  * base library time zone classes.
  */
-static inline int
+static inline NSInteger
 offset(NSTimeZone *tz, NSDate *d)
 {
   if (tz == nil)
@@ -187,21 +187,19 @@ absoluteGregorianDay(NSUInteger day, NSUInteger month, NSUInteger year)
      + year/400);   // ...plus prior years divisible by 400
 }
 
-static inline int
+static inline NSInteger
 dayOfCommonEra(NSTimeInterval when)
 {
-  int r;
-
   // Get reference date in terms of days
   when /= 86400.0;
   // Offset by Gregorian reference
   when += GREGORIAN_REFERENCE;
-  r = (NSInteger)when;
-  return r;
+  return (NSInteger)when;
 }
 
 static void
-gregorianDateFromAbsolute(NSInteger abs, int *day, int *month, int *year)
+gregorianDateFromAbsolute(NSInteger abs, 
+                          NSInteger *day, NSInteger *month, NSInteger *year)
 {
   // Search forward year by year from approximate year
   *year = abs/366;
@@ -224,7 +222,8 @@ gregorianDateFromAbsolute(NSInteger abs, int *day, int *month, int *year)
  * since the reference date.
  */
 static NSTimeInterval
-GSTime(unsigned day, unsigned month, unsigned year, unsigned hour, unsigned minute, unsigned second, unsigned mil)
+GSTime(NSUInteger day, NSUInteger month, NSUInteger year, NSUInteger hour, 
+       NSUInteger minute, NSUInteger second, NSUInteger mil)
 {
   NSTimeInterval	a;
 
@@ -246,10 +245,11 @@ GSTime(unsigned day, unsigned month, unsigned year, unsigned hour, unsigned minu
  * External - so NSTimeZone  can use it ... but should really be static.
  */
 void
-GSBreakTime(NSTimeInterval when, int *year, int *month, int *day,
-  int *hour, int *minute, int *second, int *mil)
+GSBreakTime(NSTimeInterval when, 
+            NSInteger *year, NSInteger *month, NSInteger *day,
+            NSInteger *hour, NSInteger *minute, NSInteger *second, NSInteger *mil)
 {
-  int h, m, dayOfEra;
+  NSInteger h, m, dayOfEra;
   double a, b, c, d;
 
   // Get reference date in terms of days
@@ -284,7 +284,7 @@ GSBreakTime(NSTimeInterval when, int *year, int *month, int *day,
  * Returns the current time (seconds since reference date) as an NSTimeInterval.
  */
 NSTimeInterval
-GSPrivateTimeNow(void)
+GSPrivateTimeNow()
 {
   NSTimeInterval t;
 #if !defined(__MINGW__)
@@ -302,7 +302,7 @@ GSPrivateTimeNow(void)
  * system time to make sure we don't have a temporary glitch.
  */
 {
-  static int	old = 0;
+  static time_t	old = 0;
 
   if (old == 0)
     {
@@ -310,15 +310,15 @@ GSPrivateTimeNow(void)
     }
   else
     {
-      int	diff = tp.tv_sec - old;
+      time_t diff = tp.tv_sec - old;
 
       old = tp.tv_sec;
       if (diff < -1 || diff > 3000)
 	{
 	  time_t	now = (time_t)tp.tv_sec;
 
-	  fprintf(stderr, "WARNING: system time changed by %d seconds: %s\n",
-	    diff, ctime(&now));
+	  fprintf(stderr, "WARNING: system time changed by %jd seconds: %s\n",
+	    (intmax_t)diff, ctime(&now));
 	  /* Get time again ... should be OK now.
 	   */
 	  t = GSPrivateTimeNow();
@@ -684,33 +684,33 @@ static inline int getDigits(const char *from, char *to, int limit, BOOL *error)
        calendarFormat: (NSString*)fmt
                locale: (NSDictionary*)locale
 {
-  int		milliseconds = 0;
-  int		year = 1;
-  int		month = 1;
-  int		day = 1;
-  int		hour = 0;
-  int		min = 0;
-  int		sec = 0;
+  NSInteger		milliseconds = 0;
+  NSInteger		year = 1;
+  NSInteger		month = 1;
+  NSInteger		day = 1;
+  NSInteger		hour = 0;
+  NSInteger		min = 0;
+  NSInteger   sec = 0;
   NSTimeZone	*tz = nil;
-  BOOL		ampm = NO;
-  BOOL		isPM = NO;
-  BOOL		twelveHrClock = NO;
-  int		julianWeeks = -1, weekStartsMonday = 0, dayOfWeek = -1;
+  BOOL        ampm = NO;
+  BOOL        isPM = NO;
+  BOOL        twelveHrClock = NO;
+  NSInteger		julianWeeks = -1, weekStartsMonday = 0, dayOfWeek = -1;
   const char	*source;
-  unsigned	sourceLen;
-  unichar	*format;
-  unsigned	formatLen;
-  unsigned	formatIdx = 0;
-  unsigned	sourceIdx = 0;
-  char		tmpStr[120];
-  unsigned int	tmpIdx;
-  unsigned int	tmpEnd;
-  unsigned	had = 0;
-  unsigned int	pos;
-  BOOL		hadPercent = NO;
+  size_t      sourceLen;
+  unichar     *format;
+  size_t      formatLen;
+  size_t      formatIdx = 0;
+  size_t      sourceIdx = 0;
+  char        tmpStr[120];
+  int         tmpIdx;
+  size_t      tmpEnd;
+  unsigned    had = 0;
+  unsigned int pos;
+  BOOL        hadPercent = NO;
   NSMutableData	*fd;
-  BOOL		changedFormat = NO;
-  BOOL		error = NO;
+  BOOL        changedFormat = NO;
+  BOOL        error = NO;
 
   if (description == nil)
     {
@@ -808,8 +808,8 @@ static inline int getDigits(const char *from, char *to, int limit, BOOL *error)
 
 	      if (sub != nil)
 		{
-		  unsigned	sLen = [sub length];
-		  int	i;
+		  size_t sLen = [sub length];
+		  size_t i;
 
 		  if (sLen > 2)
 		    {
@@ -848,7 +848,6 @@ static inline int getDigits(const char *from, char *to, int limit, BOOL *error)
     {
       fmt = [NSString stringWithCharacters: format length: formatLen];
     }
-  ASSIGN(_calendar_format, fmt);
 
   //
   // WARNING:
@@ -917,8 +916,7 @@ static inline int getDigits(const char *from, char *to, int limit, BOOL *error)
 			error = YES;
 			NSDebugMLog(
 			  @"Expected literal '%%' but got end of string parsing"
-			  @"'%@' using '%@'", source[sourceIdx],
-			  description, fmt);
+			  @"'%@' using '%@'", description, fmt);
 		      }
 		    break;
 
@@ -1380,9 +1378,9 @@ static inline int getDigits(const char *from, char *to, int limit, BOOL *error)
 
       if (julianWeeks != -1)
 	{
-	  NSTimeZone		*gmtZone;
+	  NSTimeZone      *gmtZone;
 	  NSCalendarDate	*d;
-	  int			currDay;
+	  NSInteger       currDay;
 
 	  gmtZone = [NSTimeZone timeZoneForSecondsFromGMT: 0];
 
@@ -1455,14 +1453,14 @@ static inline int getDigits(const char *from, char *to, int limit, BOOL *error)
 		       timeZone: tz];
       if (self != nil)
 	{
+	  ASSIGN(_calendar_format, fmt);
 	  _seconds_since_ref += ((NSTimeInterval)milliseconds) / 1000.0;
 	}
-    }
-
-  if (error == YES)
+    } else
     {
-      DESTROY(self);
+        DESTROY(self);
     }
+
   return self;
 }
 
@@ -1523,7 +1521,7 @@ static inline int getDigits(const char *from, char *to, int limit, BOOL *error)
 	     second: (NSUInteger)second
 	   timeZone: (NSTimeZone *)aTimeZone
 {
-  unsigned int		c;
+  NSUInteger      c;
   NSTimeInterval	s;
   NSTimeInterval	oldOffset;
   NSTimeInterval	newOffset;
@@ -1562,10 +1560,7 @@ static inline int getDigits(const char *from, char *to, int limit, BOOL *error)
     {
       _time_zone = RETAIN(aTimeZone);
     }
-  if (_calendar_format == nil)
-    {
-      _calendar_format = cformat;
-    }
+  _calendar_format = cformat;
   _seconds_since_ref = s;
 
   /*
@@ -1611,14 +1606,8 @@ static inline int getDigits(const char *from, char *to, int limit, BOOL *error)
 	NSStringFromClass([self class]), NSStringFromSelector(_cmd)];
     }
   _seconds_since_ref = seconds;
-  if (_calendar_format == nil)
-    {
-      _calendar_format = cformat;
-    }
-  if (_time_zone == nil)
-    {
-      _time_zone = localTZ;	// retain is a no-op for the local timezone.
-    }
+  _calendar_format = cformat;
+  _time_zone = localTZ;	// retain is a no-op for the local timezone.
   return self;
 }
 
@@ -1639,7 +1628,7 @@ static inline int getDigits(const char *from, char *to, int limit, BOOL *error)
  */
 - (NSInteger) dayOfMonth
 {
-  int m, d, y;
+  NSInteger m, d, y;
   NSTimeInterval	when;
 
   when = _seconds_since_ref + offset(_time_zone, self);
@@ -1662,8 +1651,8 @@ static inline int getDigits(const char *from, char *to, int limit, BOOL *error)
  */
 - (NSInteger) dayOfWeek
 {
-  int	d;
-  NSTimeInterval	when;
+  NSInteger       d;
+  NSTimeInterval  when;
 
   when = _seconds_since_ref + offset(_time_zone, self);
   d = dayOfCommonEra(when);
@@ -1683,7 +1672,7 @@ static inline int getDigits(const char *from, char *to, int limit, BOOL *error)
  */
 - (NSInteger) dayOfYear
 {
-  int m, d, y, days, i;
+  NSInteger m, d, y, days, i;
   NSTimeInterval	when;
 
   when = _seconds_since_ref + offset(_time_zone, self);
@@ -1700,7 +1689,7 @@ static inline int getDigits(const char *from, char *to, int limit, BOOL *error)
  */
 - (NSInteger) hourOfDay
 {
-  int h;
+  NSInteger h;
   double a, d;
   NSTimeInterval	when;
 
@@ -1725,7 +1714,7 @@ static inline int getDigits(const char *from, char *to, int limit, BOOL *error)
  */
 - (NSInteger) minuteOfHour
 {
-  int h, m;
+  NSInteger h, m;
   double a, b, d;
   NSTimeInterval	when;
 
@@ -1749,7 +1738,7 @@ static inline int getDigits(const char *from, char *to, int limit, BOOL *error)
  */
 - (NSInteger) monthOfYear
 {
-  int m, d, y;
+  NSInteger m, d, y;
   NSTimeInterval	when;
 
   when = _seconds_since_ref + offset(_time_zone, self);
@@ -1763,7 +1752,7 @@ static inline int getDigits(const char *from, char *to, int limit, BOOL *error)
  */
 - (NSInteger) secondOfMinute
 {
-  int h, m, s;
+  NSInteger h, m, s;
   double a, b, c, d;
   NSTimeInterval	when;
 
@@ -1791,7 +1780,7 @@ static inline int getDigits(const char *from, char *to, int limit, BOOL *error)
  */
 - (NSInteger) yearOfCommonEra
 {
-  int m, d, y;
+  NSInteger m, d, y;
   NSTimeInterval	when;
 
   when = _seconds_since_ref + offset(_time_zone, self);
@@ -1846,16 +1835,17 @@ typedef struct {
   unichar	*t;
   unsigned	length;
   unsigned	offset;
-  int		yd;
-  int		md;
-  int		dom;
-  int		hd;
-  int		mnd;
-  int		sd;
-  int		mil;
+  NSInteger yd;
+  NSInteger md;
+  NSInteger dom;
+  NSInteger hd;
+  NSInteger mnd;
+  NSInteger sd;
+  NSInteger mil;
 } DescriptionInfo;
 
-static void Grow(DescriptionInfo *info, unsigned size)
+static void 
+Grow(DescriptionInfo *info, size_t size)
 {
   if (info->offset + size >= info->length)
     {
@@ -1878,7 +1868,8 @@ static void Grow(DescriptionInfo *info, unsigned size)
 
 #define MAX_FLD_WIDTH 99
 
-static void outputValueWithFormat(int v, char *fldfmt, DescriptionInfo *info)
+static void 
+outputValueWithFormat(NSInteger v, char *fldfmt, DescriptionInfo *info)
 {
   char	cbuf[MAX_FLD_WIDTH + 1];
   int	idx = 0;
@@ -1895,11 +1886,11 @@ static void outputValueWithFormat(int v, char *fldfmt, DescriptionInfo *info)
 	  locale: (NSDictionary*)locale
 	    info: (DescriptionInfo*)info
 {
-  unichar	fbuf[512];
-  unichar	*f = fbuf;
-  unsigned	lf = [fmt length];
-  unsigned	i = 0;
-  int		v;
+  unichar     fbuf[512];
+  unichar     *f = fbuf;
+  NSUInteger  lf = [fmt length];
+  NSUInteger  i = 0;
+  NSInteger   v;
 
   if (lf == 0)
     {
@@ -2283,7 +2274,7 @@ static void outputValueWithFormat(int v, char *fldfmt, DescriptionInfo *info)
 
 	      case 'z':
 		{
-		  int	z;
+		  NSInteger	z;
 
 		  Grow(info, 5);
 		  z = offset(_time_zone, self);
@@ -2581,7 +2572,7 @@ static void outputValueWithFormat(int v, char *fldfmt, DescriptionInfo *info)
 			     month: (NSInteger *)month
 			      year: (NSInteger *)year
 {
-  int   dd, mm, yy;
+  NSInteger dd, mm, yy;
 
   gregorianDateFromAbsolute(d, &dd, &mm, &yy);
   *day = dd;
@@ -2608,7 +2599,7 @@ static void outputValueWithFormat(int v, char *fldfmt, DescriptionInfo *info)
   NSTimeInterval	s;
   NSTimeInterval	oldOffset;
   NSTimeInterval	newOffset;
-  int			i, year, month, day, hour, minute, second, mil;
+  NSInteger i, year, month, day, hour, minute, second, mil;
 
   /* Apply timezone offset to _seconds_since_ref from GMT to local time,
    * then break into components in local time zone.
@@ -2765,12 +2756,12 @@ static void outputValueWithFormat(int v, char *fldfmt, DescriptionInfo *info)
   NSCalendarDate	*start;
   NSCalendarDate	*end;
   NSCalendarDate	*tmp;
-  int			diff;
-  int			extra;
-  int			sign;
-  int			mil;
-  int			syear, smonth, sday, shour, sminute, ssecond;
-  int			eyear, emonth, eday, ehour, eminute, esecond;
+  NSInteger diff;
+  NSInteger extra;
+  NSInteger sign;
+  NSInteger mil;
+  NSInteger syear, smonth, sday, shour, sminute, ssecond;
+  NSInteger eyear, emonth, eday, ehour, eminute, esecond;
 
   /* FIXME What if the two dates are in different time zones?
     How about daylight savings time?
@@ -2866,8 +2857,8 @@ static void outputValueWithFormat(int v, char *fldfmt, DescriptionInfo *info)
     {
       while (diff-- > 0)
 	{
-	  int tmpmonth = emonth - diff - 1;
-	  int tmpyear = eyear;
+	  NSInteger tmpmonth = emonth - diff - 1;
+	  NSInteger tmpyear = eyear;
 
           while (tmpmonth < 1)
 	    {
diff --git a/Source/NSCallBacks.m b/Source/NSCallBacks.m
index 4dbad5b..402f4c1 100644
--- a/Source/NSCallBacks.m
+++ b/Source/NSCallBacks.m
@@ -100,7 +100,7 @@ _NS_owned_void_p_release(void *table, void *p)
 NSString *
 _NS_owned_void_p_describe(void *table, void *p)
 {
-  return [NSString stringWithFormat: @"%#x", p];
+  return [NSString stringWithFormat: @"%#lx", (unsigned long)p];
 }
 
 /** For non-retained Objective-C objects **/
@@ -199,7 +199,7 @@ _NS_non_owned_void_p_release(void *table, void *p)
 NSString *
 _NS_non_owned_void_p_describe(void *table, void *p)
 {
-  return [NSString stringWithFormat: @"%0x", p];
+  return [NSString stringWithFormat: @"%0lx", (unsigned long)p];
 }
 
 /** For pointers to structures and `int *' **/
@@ -232,5 +232,5 @@ NSString *
 _NS_int_p_describe(void *table, int *p)
 {
   /* Is this useful? */
-  return [NSString stringWithFormat: @"%d(%#x)", *p, p];
+  return [NSString stringWithFormat: @"%d(%#lx)", *p, (unsigned long)p];
 }
diff --git a/Source/NSCharacterSet.m b/Source/NSCharacterSet.m
index 983cd24..1dc7f95 100644
--- a/Source/NSCharacterSet.m
+++ b/Source/NSCharacterSet.m
@@ -88,7 +88,7 @@
 @interface NSBitmapCharSet : NSCharacterSet
 {
   const unsigned char	*_data;
-  unsigned		_length;
+  NSUInteger		_length;
   NSData		*_obj;
   unsigned		_known;
   unsigned		_present;
@@ -99,7 +99,7 @@
 @interface NSMutableBitmapCharSet : NSMutableCharacterSet
 {
   unsigned char		*_data;
-  unsigned		_length;
+  NSUInteger		_length;
   NSMutableData		*_obj;
   unsigned		_known;
   unsigned		_present;
@@ -200,7 +200,7 @@
 
 - (id) initWithBitmap: (NSData*)bitmap
 {
-  unsigned	length = [bitmap length];
+  NSUInteger	length = [bitmap length];
 
   if ((length % GSBITMAP_SIZE) != 0 || length > GSBITMAP_MAX)
     {
@@ -320,7 +320,7 @@
 
 - (void) addCharactersInString: (NSString*)aString
 {
-  unsigned   length;
+  NSUInteger   length;
 
   if (!aString)
     {
@@ -383,9 +383,9 @@
 
 - (void) formIntersectionWithCharacterSet: (NSCharacterSet *)otherSet
 {
-  unsigned		i;
+  NSUInteger		i;
   NSData		*otherData = [otherSet bitmapRepresentation];
-  unsigned		other_length = [otherData length];
+  NSUInteger		other_length = [otherData length];
   const unsigned char	*other_bytes = [otherData bytes];
 
   if (_length > other_length)
@@ -403,9 +403,9 @@
 
 - (void) formUnionWithCharacterSet: (NSCharacterSet*)otherSet
 {
-  unsigned		i;
+  NSUInteger		i;
   NSData		*otherData = [otherSet bitmapRepresentation];
-  unsigned		other_length = [otherData length];
+  NSUInteger		other_length = [otherData length];
   const unsigned char	*other_bytes = [otherData bytes];
 
   if (other_length > _length)
@@ -423,7 +423,7 @@
 
 - (id) initWithBitmap: (NSData*)bitmap
 {
-  unsigned	length = [bitmap length];
+  NSUInteger	length = [bitmap length];
   id		tmp;
 
   if ((length % GSBITMAP_SIZE) != 0 || length > GSBITMAP_MAX)
@@ -467,8 +467,8 @@
 
 - (void) removeCharactersInRange: (NSRange)aRange
 {
-  unsigned	i;
-  unsigned	limit = NSMaxRange(aRange);
+  NSUInteger	i;
+  NSUInteger	limit = NSMaxRange(aRange);
 
   if (NSMaxRange(aRange) > GSUNICODE_MAX)
     {
@@ -490,7 +490,7 @@
 
 - (void) removeCharactersInString: (NSString*)aString
 {
-  unsigned	length;
+  NSUInteger	length;
 
   if (!aString)
     {
@@ -587,7 +587,7 @@ static Class concreteMutableClass = nil;
 @interface _GSStaticCharSet : NSCharacterSet
 {
   const unsigned char	*_data;
-  unsigned		_length;
+  NSUInteger		_length;
   NSData		*_obj;
   unsigned		_known;
   unsigned		_present;
@@ -923,8 +923,8 @@ static Class concreteMutableClass = nil;
 
 - (NSCharacterSet*) invertedSet
 {
-  unsigned	i;
-  unsigned	length;
+  NSUInteger	i;
+  NSUInteger	length;
   unsigned char	*bytes;
   NSMutableData	*bitmap;
 
@@ -1299,9 +1299,9 @@ static Class concreteMutableClass = nil;
 - (id) initWithBitmap: (NSData*)bitmap
 {
   const unsigned char	*bytes = [bitmap bytes];
-  unsigned		length = [bitmap length];
-  unsigned		index = 0;
-  unsigned		i;
+  NSUInteger		length = [bitmap length];
+  NSUInteger		index = 0;
+  NSUInteger		i;
   NSRange		r;
   BOOL			findingLocation = YES;
 
@@ -1405,7 +1405,7 @@ static Class concreteMutableClass = nil;
 
 - (void) addCharactersInString: (NSString*)aString
 {
-  unsigned   length;
+  NSUInteger   length;
 
   if (!aString)
     {
@@ -1602,7 +1602,7 @@ static Class concreteMutableClass = nil;
 
 - (void) removeCharactersInString: (NSString*)aString
 {
-  unsigned	length;
+  NSUInteger	length;
 
   if (!aString)
     {
diff --git a/Source/NSCoder.m b/Source/NSCoder.m
index b93f9a7..44a73bd 100644
--- a/Source/NSCoder.m
+++ b/Source/NSCoder.m
@@ -28,7 +28,7 @@
 
 #import "common.h"
 
-#if !defined (__GNU_LIBOBJC__)
+#if !defined (__GNU_LIBOBJC__) && !defined (NeXT_RUNTIME)
 #  include <objc/encoding.h>
 #endif
 
@@ -54,24 +54,21 @@
  */
 #define	MAX_SUPPORTED_SYSTEM_VERSION	1000000
 
-static unsigned	systemVersion = MAX_SUPPORTED_SYSTEM_VERSION;
+static unsigned systemVersion = MAX_SUPPORTED_SYSTEM_VERSION;
 
 + (void) initialize
 {
-  if (self == [NSCoder class])
+    if (self == [NSCoder class])
     {
-      unsigned	sv;
-
-      /* The GSCoderSystemVersion user default is provided for testing
-       * and to allow new code to communicate (via Distributed Objects)
-       * with systems running older versions.
-       */
-      sv = [[NSUserDefaults standardUserDefaults]
-	integerForKey: @"GSCoderSystemVersion"];
-      if (sv > 0 && sv <= MAX_SUPPORTED_SYSTEM_VERSION)
-	{
-	  systemVersion = sv;
-	} 
+        /* The GSCoderSystemVersion user default is provided for testing
+         * and to allow new code to communicate (via Distributed Objects)
+         * with systems running older versions.
+         */
+        NSInteger sv = [[NSUserDefaults standardUserDefaults] integerForKey: @"GSCoderSystemVersion"];
+        if (sv > 0 && sv <= MAX_SUPPORTED_SYSTEM_VERSION)
+        {
+            systemVersion = (unsigned)sv;
+        } 
     }
 }
 
@@ -106,17 +103,16 @@ static unsigned	systemVersion = MAX_SUPPORTED_SYSTEM_VERSION;
 
 // Encoding Data
 
-- (void) encodeArrayOfObjCType: (const char*)type
-			 count: (NSUInteger)count
-			    at: (const void*)array
+- (void) encodeArrayOfObjCType: (const char *)type
+                         count: (NSUInteger)count
+                            at: (const void *)array
 {
-  unsigned	i;
-  unsigned	size = objc_sizeof_type(type);
-  const char	*where = array;
-  IMP		imp;
+  size_t size = objc_sizeof_type(type);
+  const char *where = array;
 
-  imp = [self methodForSelector: @selector(encodeValueOfObjCType:at:)];
-  for (i = 0; i < count; i++, where += size)
+  IMP imp = [self methodForSelector: @selector(encodeValueOfObjCType:at:)];
+    
+  for (NSUInteger i = 0; i < count; i++, where += size)
     {
       (*imp)(self, @selector(encodeValueOfObjCType:at:), type, where);
     }
@@ -201,18 +197,16 @@ static unsigned	systemVersion = MAX_SUPPORTED_SYSTEM_VERSION;
 
 // Decoding Data
 
-- (void) decodeArrayOfObjCType: (const char*)type
-			 count: (NSUInteger)count
-			    at: (void*)address
+- (void) decodeArrayOfObjCType: (const char *)type
+                         count: (NSUInteger)count
+                            at: (void *)address
 {
-  unsigned	i;
-  unsigned	size = objc_sizeof_type(type);
-  char		*where = address;
-  IMP		imp;
+  size_t size = objc_sizeof_type(type);
+  char *where = address;
 
-  imp = [self methodForSelector: @selector(decodeValueOfObjCType:at:)];
-
-  for (i = 0; i < count; i++, where += size)
+  IMP imp = [self methodForSelector: @selector(decodeValueOfObjCType:at:)];
+    
+  for (NSUInteger i = 0; i < count; i++, where += size)
     {
       (*imp)(self, @selector(decodeValueOfObjCType:at:), type, where);
     }
@@ -472,49 +466,57 @@ static unsigned	systemVersion = MAX_SUPPORTED_SYSTEM_VERSION;
 }
 - (id) initWithCoder: (NSCoder*)aCoder
 {
-  id		o;
-  void		*address;
-  unsigned	i;
-
-  _c = [aCoder decodeIntForKey: @"NS.count"];
-  _t[0] = (char)[aCoder decodeIntForKey: @"NS.type"];
-  _t[1] = '\0';
-
-  /*
-   * We decode the size from the remote end, but discard it as we
-   * are probably safer to use the local size of the datatype involved.
-   */
-  _s = [aCoder decodeIntForKey: @"NS.size"];
-  _s = objc_sizeof_type(_t);
-
-  _d = o = [[NSMutableData alloc] initWithLength: _c * _s];
-  _a = address = [o mutableBytes];
-  for (i = 0; i < _c; i++)
+    if (!(self = [super init]))
     {
-      [aCoder decodeValueOfObjCType: _t at: address];
-      address += _s;
+        return nil;
     }
-  return self;
+    id		o;
+    void		*address;
+    unsigned	i;
+    
+    _c = [aCoder decodeIntForKey: @"NS.count"];
+    _t[0] = (char)[aCoder decodeIntForKey: @"NS.type"];
+    _t[1] = '\0';
+    
+    /*
+     * We decode the size from the remote end, but discard it as we
+     * are probably safer to use the local size of the datatype involved.
+     */
+    _s = [aCoder decodeIntForKey: @"NS.size"];
+    _s = objc_sizeof_type(_t);
+    
+    _d = o = [[NSMutableData alloc] initWithLength: _c * _s];
+    _a = address = [o mutableBytes];
+    for (i = 0; i < _c; i++)
+    {
+        [aCoder decodeValueOfObjCType: _t at: address];
+        address += _s;
+    }
+    return self;
 }
 
 - (id) initWithObjCType: (const char*)t count: (NSInteger)c at: (const void*)a
 {
-  t = GSSkipTypeQualifierAndLayoutInfo(t);
-  _t[0] = *t;
-  _t[1] = '\0';
-  _s = objc_sizeof_type(_t);
-  _c = c;
-  _a = a;
-  return self;
+    if (!(self = [super init]))
+    {
+        return nil;
+    }
+    t = GSSkipTypeQualifierAndLayoutInfo(t);
+    _t[0] = *t;
+    _t[1] = '\0';
+    _s = objc_sizeof_type(_t);
+    _c = c;
+    _a = a;
+    return self;
 }
 
 - (void) encodeWithCoder: (NSCoder*)aCoder
 {
   int	i;
 
-  [aCoder encodeInt: _c forKey: @"NS.count"];
+  [aCoder encodeInteger: _c forKey: @"NS.count"];
   [aCoder encodeInt: *_t forKey: @"NS.type"];
-  [aCoder encodeInt: _s forKey: @"NS.size"];
+  [aCoder encodeInteger: _s forKey: @"NS.size"];
   for (i = 0; i < _c; i++)
     {
       [aCoder encodeValueOfObjCType: _t at: _a];
diff --git a/Source/NSConcreteHashTable.m b/Source/NSConcreteHashTable.m
index a3b10a6..51d3851 100644
--- a/Source/NSConcreteHashTable.m
+++ b/Source/NSConcreteHashTable.m
@@ -369,6 +369,15 @@ NSEndHashTableEnumeration(NSHashEnumerator *enumerator)
     }
 }
 
+/*
+ * It exists only to tame static analyzer
+ */
+NS_INLINE void
+NSHashEnumeratorSetNode(NSHashEnumerator *enumerator, id node)
+{
+    enumerator->node = [node retain];
+}
+
 /**
  * Return an enumerator for stepping through a hash table using the
  * NSNextHashEnumeratorPair() function.
@@ -390,8 +399,7 @@ NSEnumerateHashTable(NSHashTable *table)
   else
     {
       NSHashEnumerator	v = {0, 0, 0};
-
-      v.node = (void*)[[table objectEnumerator] retain];
+      NSHashEnumeratorSetNode(&v, [table objectEnumerator]);
       return v;
     }
 }
@@ -974,6 +982,10 @@ const NSHashTableCallBacks NSPointerToStructHashCallBacks =
 - (id) initWithPointerFunctions: (NSPointerFunctions*)functions
 		       capacity: (NSUInteger)initialCapacity
 {
+    if (!(self = [super initWithPointerFunctions:functions capacity:initialCapacity]))
+    {
+        return nil;
+    }
   legacy = NO;
   if (![functions isKindOfClass: [NSConcretePointerFunctions class]])
     {
diff --git a/Source/NSConcreteMapTable.m b/Source/NSConcreteMapTable.m
index 75eb27b..5a16e50 100644
--- a/Source/NSConcreteMapTable.m
+++ b/Source/NSConcreteMapTable.m
@@ -1253,6 +1253,10 @@ const NSMapTableValueCallBacks NSOwnedPointerMapValueCallBacks =
 	     valuePointerFunctions: (NSPointerFunctions*)valueFunctions
 			  capacity: (NSUInteger)initialCapacity
 {
+    if (!(self = [super initWithKeyPointerFunctions:keyFunctions valuePointerFunctions:valueFunctions capacity:initialCapacity]))
+    {
+        return nil;
+    }
   static NSConcretePointerFunctions	*defaultFunctions = nil;
 
   if (defaultFunctions == nil)
diff --git a/Source/NSConcretePointerFunctions.h b/Source/NSConcretePointerFunctions.h
index 2bf24f0..92b9aa0 100644
--- a/Source/NSConcretePointerFunctions.h
+++ b/Source/NSConcretePointerFunctions.h
@@ -89,7 +89,7 @@ typedef struct
 
 } PFInfo;
 
-inline static BOOL memoryType(int options, int flag)
+inline static BOOL memoryType(NSUInteger options, int flag)
 {
 	return (options & 0xff) == flag;
 }
diff --git a/Source/NSConcretePointerFunctions.m b/Source/NSConcretePointerFunctions.m
index e1ed734..eb6d835 100644
--- a/Source/NSConcretePointerFunctions.m
+++ b/Source/NSConcretePointerFunctions.m
@@ -129,8 +129,8 @@ hashObject(const void *item, NSUInteger (*size)(const void *item))
 static NSUInteger
 hashMemory(const void *item, NSUInteger (*size)(const void *item))
 {
-  unsigned	len = (*size)(item);
-  NSUInteger	hash = 0;
+  NSUInteger len = (*size)(item);
+  NSUInteger hash = 0;
 
   while (len-- > 0)
     {
diff --git a/Source/NSConnection.m b/Source/NSConnection.m
index 5de98af..704b1c4 100644
--- a/Source/NSConnection.m
+++ b/Source/NSConnection.m
@@ -31,7 +31,7 @@
 
 #import "common.h"
 
-#if !defined (__GNU_LIBOBJC__)
+#if !defined (__GNU_LIBOBJC__) && !defined (NeXT_RUNTIME)
 #  include <objc/encoding.h>
 #endif
 
@@ -340,15 +340,15 @@ GS_PRIVATE_INTERNAL(NSConnection)
 - (void) addLocalObject: (NSDistantObject*)anObj;
 - (void) removeLocalObject: (NSDistantObject*)anObj;
 
-- (void) _doneInReply: (NSPortCoder*)c;
-- (void) _doneInRmc: (NSPortCoder*)c;
-- (void) _failInRmc: (NSPortCoder*)c;
-- (void) _failOutRmc: (NSPortCoder*)c;
+- (void) _doneInReply: (NSPortCoder*) NS_CONSUMED c;
+- (void) _doneInRmc: (NSPortCoder*) NS_CONSUMED c;
+- (void) _failInRmc: (NSPortCoder*) NS_CONSUMED c;
+- (void) _failOutRmc: (NSPortCoder*) NS_CONSUMED c;
 - (NSPortCoder*) _getReplyRmc: (int)sn;
-- (NSPortCoder*) _makeInRmc: (NSMutableArray*)components;
-- (NSPortCoder*) _makeOutRmc: (int)sequence generate: (int*)sno reply: (BOOL)f;
+- (NSPortCoder*) _makeInRmc: (NSMutableArray*)components NS_RETURNS_RETAINED;
+- (NSPortCoder*) _makeOutRmc: (int)sequence generate: (int*)sno reply: (BOOL)f NS_RETURNS_RETAINED;
 - (void) _portIsInvalid: (NSNotification*)notification;
-- (void) _sendOutRmc: (NSPortCoder*)c type: (int)msgid;
+- (void) _sendOutRmc: (NSPortCoder*) NS_CONSUMED c type: (int)msgid;
 
 - (void) _service_forwardForProxy: (NSPortCoder*)rmc;
 - (void) _service_release: (NSPortCoder*)rmc;
@@ -797,7 +797,7 @@ static NSLock	*cached_proxies_gate = nil;
 + (void) _timeout: (NSTimer*)t
 {
   NSArray	*cached_locals;
-  int	i;
+  NSUInteger i;
 
   GS_M_LOCK(cached_proxies_gate);
   cached_locals = NSAllMapTableValues(targetToCached);
@@ -978,6 +978,10 @@ static NSLock	*cached_proxies_gate = nil;
 - (id) initWithReceivePort: (NSPort*)r
 		  sendPort: (NSPort*)s
 {
+    if (!(self = [super init]))
+    {
+        return nil;
+    }
   NSNotificationCenter	*nCenter;
   NSConnection		*parent;
   NSConnection		*conn;
@@ -996,7 +1000,7 @@ static NSLock	*cached_proxies_gate = nil;
 	  NSLog(@"Asked to create connection with nil receive port");
 	}
       DESTROY(self);
-      return self;
+      return nil;
     }
 
   /*
@@ -1016,14 +1020,13 @@ static NSLock	*cached_proxies_gate = nil;
    */
   if (conn != nil)
     {
-      DESTROY(self);
-      self = RETAIN(conn);
       if (debug_connection > 2)
 	{
 	  NSLog(@"Found existing connection (%@) for \n\t%@\n\t%@",
 	    conn, r, s);
 	}
-      return self;
+        DESTROY(self);
+      return RETAIN(conn);
     }
 
   /* Create our private data structure.
@@ -1198,13 +1201,6 @@ static NSLock	*cached_proxies_gate = nil;
 	  return nil;
 	}
     }
-  /* Here is the GNUstep version, which allows the delegate to specify
-     a substitute.  Note: The delegate is responsible for freeing
-     newConn if it returns something different. */
-  if ([del respondsToSelector: @selector(connection:didConnect:)])
-    {
-      self = [del connection: parent didConnect: self];
-    }
 
   nCenter = [NSNotificationCenter defaultCenter];
   /*
@@ -1851,16 +1847,16 @@ static NSLock	*cached_proxies_gate = nil;
   /*
    *	These are GNUstep extras
    */
-  o = [NSNumber numberWithUnsignedInt:
+  o = [NSNumber numberWithUnsignedLong:
     IlocalTargets ? IlocalTargets->nodeCount : 0];
   [d setObject: o forKey: NSConnectionLocalCount];
-  o = [NSNumber numberWithUnsignedInt:
+  o = [NSNumber numberWithUnsignedLong:
     IremoteProxies ? IremoteProxies->nodeCount : 0];
   [d setObject: o forKey: NSConnectionProxyCount];
-  o = [NSNumber numberWithUnsignedInt:
+  o = [NSNumber numberWithUnsignedLong:
     IreplyMap ? IreplyMap->nodeCount : 0];
   [d setObject: o forKey: @"NSConnectionReplyQueue"];
-  o = [NSNumber numberWithUnsignedInt: [IrequestQueue count]];
+  o = [NSNumber numberWithUnsignedLong: [IrequestQueue count]];
   [d setObject: o forKey: @"NSConnectionRequestQueue"];
 
   GSM_UNLOCK(IrefGate);
@@ -2023,7 +2019,7 @@ static NSLock	*cached_proxies_gate = nil;
 
       needsResponse = NO;
       flags = objc_get_type_qualifiers(type);
-      if ((flags & _F_ONEWAY) == 0)
+      if ((flags & GSObjCQualifierOneWay) == 0)
 	{
 	  needsResponse = YES;
 	}
@@ -2039,8 +2035,8 @@ static NSLock	*cached_proxies_gate = nil;
     }
 
   [self _sendOutRmc: op type: METHOD_REQUEST];
-  NSDebugMLLog(@"NSConnection", @"Sent message %s RMC %d to 0x%x",
-    sel_getName([inv selector]), seq, (uintptr_t)self);
+  NSDebugMLLog(@"NSConnection", @"Sent message %s RMC %d to 0x%lx",
+    sel_getName([inv selector]), seq, (unsigned long)self);
 
   if (needsResponse == NO)
     {
@@ -2106,7 +2102,7 @@ static NSLock	*cached_proxies_gate = nil;
       /* Decode the return value and pass-by-reference values, if there
 	 are any.  OUT_PARAMETERS should be the value returned by
 	 cifframe_dissect_call(). */
-      if (outParams || *tmptype != _C_VOID || (flags & _F_ONEWAY) == 0)
+      if (outParams || *tmptype != _C_VOID || (flags & GSObjCQualifierOneWay) == 0)
 	/* xxx What happens with method declared "- (oneway) foo: (out int*)ip;" */
 	/* xxx What happens with method declared "- (in char *) bar;" */
 	/* xxx Is this right?  Do we also have to check _F_ONEWAY? */
@@ -2114,7 +2110,7 @@ static NSLock	*cached_proxies_gate = nil;
 	  id	obj;
 
 	  /* If there is a return value, decode it, and put it in datum. */
-	  if (*tmptype != _C_VOID || (flags & _F_ONEWAY) == 0)
+	  if (*tmptype != _C_VOID || (flags & GSObjCQualifierOneWay) == 0)
 	    {	
 	      switch (*tmptype)
 		{
@@ -2166,7 +2162,7 @@ static NSLock	*cached_proxies_gate = nil;
 		  tmptype = objc_skip_type_qualifiers(tmptype);
 
 		  if (*tmptype == _C_PTR
-		    && ((flags & _F_OUT) || !(flags & _F_IN)))
+		    && ((flags & GSObjCQualifierOut) || !(flags & GSObjCQualifierIn)))
 		    {
 		      /* If the arg was byref, we obtain its address
 		       * and decode the data directly to it.
@@ -2180,7 +2176,7 @@ static NSLock	*cached_proxies_gate = nil;
 			}
 		    }
 		  else if (*tmptype == _C_CHARPTR
-		    && ((flags & _F_OUT) || !(flags & _F_IN)))
+		    && ((flags & GSObjCQualifierOut) || !(flags & GSObjCQualifierIn)))
 		    {
 		      [aRmc decodeValueOfObjCType: tmptype at: &datum];
 		      [inv setArgument: datum atIndex: argnum];
@@ -2215,9 +2211,9 @@ static NSLock	*cached_proxies_gate = nil;
 
 /* Class-wide stats and collections. */
 
-+ (unsigned) connectionsCount
++ (NSUInteger) connectionsCount
 {
-  unsigned	result;
+  NSUInteger result;
 
   GS_M_LOCK(connection_table_gate);
   result = NSCountHashTable(connection_table);
@@ -2225,11 +2221,11 @@ static NSLock	*cached_proxies_gate = nil;
   return result;
 }
 
-+ (unsigned) connectionsCountWithInPort: (NSPort*)aPort
++ (NSUInteger) connectionsCountWithInPort: (NSPort*)aPort
 {
-  unsigned		count = 0;
-  NSHashEnumerator	enumerator;
-  NSConnection		*o;
+  NSUInteger        count = 0;
+  NSHashEnumerator  enumerator;
+  NSConnection      *o;
 
   GS_M_LOCK(connection_table_gate);
   enumerator = NSEnumerateHashTable(connection_table);
@@ -2641,7 +2637,7 @@ static NSLock	*cached_proxies_gate = nil;
 		   have to get this char* again after the method is run,
 		   because the method may have changed it.  Set
 		   OUT_PARAMETERS accordingly. */
-		if ((flags & _F_OUT) || !(flags & _F_IN))
+		if ((flags & GSObjCQualifierOut) || !(flags & GSObjCQualifierIn))
 		  out_parameters = YES;
 		/* If the char* is qualified as an IN parameter, or not
 		   explicity qualified as an OUT parameter, then decode it.
@@ -2649,7 +2645,7 @@ static NSLock	*cached_proxies_gate = nil;
 		   string, and it is also responsible for making sure that
 		   the memory gets freed eventually, (usually through the
 		   autorelease of NSData object). */
-		if ((flags & _F_IN) || !(flags & _F_OUT))
+		if ((flags & GSObjCQualifierIn) || !(flags & GSObjCQualifierOut))
 		  {
 		    datum = alloca (sizeof(char*));
 		    [decoder decodeValueOfObjCType: tmptype at: datum];
@@ -2663,7 +2659,7 @@ static NSLock	*cached_proxies_gate = nil;
 		   then we will have to get the value pointed to again after
 		   the method is run, because the method may have changed
 		   it.  Set OUT_PARAMETERS accordingly. */
-		if ((flags & _F_OUT) || !(flags & _F_IN))
+		if ((flags & GSObjCQualifierOut) || !(flags & GSObjCQualifierIn))
 		  out_parameters = YES;
 
 		/* Handle an argument that is a pointer to a non-char.  But
@@ -2674,7 +2670,7 @@ static NSLock	*cached_proxies_gate = nil;
 		/* If the pointer's value is qualified as an IN parameter,
 		   or not explicity qualified as an OUT parameter, then
 		   decode it. */
-		if ((flags & _F_IN) || !(flags & _F_OUT))
+		if ((flags & GSObjCQualifierIn) || !(flags & GSObjCQualifierOut))
 		  {
 		    datum = alloca (objc_sizeof_type (tmptype));
 		    [decoder decodeValueOfObjCType: tmptype at: datum];
@@ -2732,7 +2728,7 @@ static NSLock	*cached_proxies_gate = nil;
       /* If this is a oneway void with no out parameters, we don't need to
        * send back any response.
        */
-      if (*tmptype == _C_VOID && (flags & _F_ONEWAY) && !out_parameters)
+      if (*tmptype == _C_VOID && (flags & GSObjCQualifierOneWay) && !out_parameters)
         {
 	  tmp = inv;
 	  inv = nil;
@@ -2752,7 +2748,7 @@ static NSLock	*cached_proxies_gate = nil;
 
       if (*tmptype == _C_VOID)
 	{
-	  if ((flags & _F_ONEWAY) == 0)
+	  if ((flags & GSObjCQualifierOneWay) == 0)
 	    {
 	      int	dummy = 0;
 
@@ -2804,7 +2800,7 @@ static NSLock	*cached_proxies_gate = nil;
 
 	      /* Decide how, (or whether or not), to encode the argument
 		 depending on its FLAGS and TMPTYPE. */
-	      if (((flags & _F_OUT) || !(flags & _F_IN))
+	      if (((flags & GSObjCQualifierOut) || !(flags & GSObjCQualifierIn))
 		&& (*tmptype == _C_PTR || *tmptype == _C_CHARPTR))
 		{
 		  void	*datum;
@@ -3230,7 +3226,7 @@ static NSLock	*cached_proxies_gate = nil;
     }
   NS_ENDHANDLER
 
-  NSDebugMLLog(@"NSConnection", @"Consuming reply RMC %d on %x", sn, self);
+  NSDebugMLLog(@"NSConnection", @"Consuming reply RMC %d on %lx", sn, (unsigned long)self);
   return rmc;
 }
 
@@ -3453,7 +3449,7 @@ static NSLock	*cached_proxies_gate = nil;
 	}
       if (raiseException == YES)
 	{
-	  [NSException raise: NSPortTimeoutException format: text];
+	  [NSException raise: NSPortTimeoutException format: @"%@", text];
 	}
       else
 	{
diff --git a/Source/NSCountedSet.m b/Source/NSCountedSet.m
index 5e7b3a6..9c3985f 100644
--- a/Source/NSCountedSet.m
+++ b/Source/NSCountedSet.m
@@ -157,24 +157,24 @@ static Class NSCountedSet_concrete_class;
 
 - (void) encodeWithCoder: (NSCoder*)aCoder
 {
-  unsigned	count = [self count];
+  NSUInteger	count = [self count];
   NSEnumerator	*e = [self objectEnumerator];
   id		o;
 
-  [aCoder encodeValueOfObjCType: @encode(unsigned) at: &count];
+  [aCoder encodeValueOfObjCType: @encode(NSUInteger) at: &count];
   while ((o = [e nextObject]) != nil)
     {
       [aCoder encodeValueOfObjCType: @encode(id) at: &o];
       count = [self countForObject: o];
-      [aCoder encodeValueOfObjCType: @encode(unsigned) at: &count];
+      [aCoder encodeValueOfObjCType: @encode(NSUInteger) at: &count];
     }
 }
 
 - (id) initWithSet: (NSSet*)other copyItems: (BOOL)flag
 {
-  unsigned	c = [other count];
+  NSUInteger	c = [other count];
   id		os[c], o, e = [other objectEnumerator];
-  unsigned	i = 0;
+  NSUInteger	i = 0;
   NSZone	*z = [self zone];
   IMP		next = [e methodForSelector: @selector(nextObject)];
 
@@ -189,12 +189,12 @@ static Class NSCountedSet_concrete_class;
   self = [self initWithObjects: os count: c];
   if ([other isKindOfClass: NSCountedSet_abstract_class])
     {
-      unsigned	j;
+      NSUInteger	j;
       IMP	addImp = [self methodForSelector: @selector(addObject:)];
 
       for (j = 0; j < i; j++)
 	{
-          unsigned	extra = [(NSCountedSet*)other countForObject: os[j]];
+          NSUInteger	extra = [(NSCountedSet*)other countForObject: os[j]];
 
 	  while (extra-- > 1)
 	    (*addImp)(self, @selector(addObject:), os[j]);
@@ -245,21 +245,18 @@ static Class NSCountedSet_concrete_class;
 
 - (id) unique: (id)anObject
 {
-  id	o = [self member: anObject];
-
-  [self addObject: anObject];
-  if (o == nil)
+    id member = [self member:anObject];
+    if (member != anObject)
     {
-      o = anObject;
+        if (member == nil)
+        {
+            [self addObject:anObject];
+            member = anObject;
+        }
+        RELEASE(anObject);
+        return RETAIN(member);
     }
-#if	!GS_WITH_GC
-  if (o != anObject)
-    {
-      [anObject release];
-      [o retain];
-    }
-#endif
-  return o;
+    return anObject;
 }
 @end
 
diff --git a/Source/NSData.m b/Source/NSData.m
index d5b6ae8..5c015c8 100644
--- a/Source/NSData.m
+++ b/Source/NSData.m
@@ -69,7 +69,7 @@
 
 #import "common.h"
 
-#if !defined (__GNU_LIBOBJC__)
+#if !defined (__GNU_LIBOBJC__) && !defined (NeXT_RUNTIME)
 #  include <objc/encoding.h>
 #endif
 
@@ -150,8 +150,8 @@ readContentsOfFile(NSString* path, void** buf, long* len, NSZone* zone)
 #endif	
   FILE		*theFile = 0;
   void		*tmp = 0;
-  int		c;
-  long		fileLength;
+  ssize_t		c;
+  ssize_t		fileLength;
 	
 #if defined(__MINGW__)
   thePath = (const unichar*)[path fileSystemRepresentation];
@@ -905,7 +905,7 @@ failure:
  *  Copies data from buffer starting from cursor.  <strong>Deprecated</strong>.
  *  Use [-getBytes:] and related methods instead.
  */
-- (unsigned int) deserializeAlignedBytesLengthAtCursor: (unsigned int*)cursor
+- (unsigned int) deserializeAlignedBytesLengthAtCursor: (NSUInteger*)cursor
 {
   return (unsigned)[self deserializeIntAtCursor: cursor];
 }
@@ -915,8 +915,8 @@ failure:
  *  Use [-getBytes:] and related methods instead.
  */
 - (void) deserializeBytes: (void*)buffer
-		   length: (unsigned int)bytes
-		 atCursor: (unsigned int*)cursor
+		   length: (NSUInteger)bytes
+		 atCursor: (NSUInteger*)cursor
 {
   NSRange	range = { *cursor, bytes };
 
@@ -926,7 +926,7 @@ failure:
 
 - (void) deserializeDataAt: (void*)data
 	        ofObjCType: (const char*)type
-		  atCursor: (unsigned int*)cursor
+		  atCursor: (NSUInteger*)cursor
 		   context: (id <NSObjCTypeSerializationCallBack>)callback
 {
   if (!type || !data)
@@ -979,8 +979,8 @@ failure:
 	}
       case _C_ARY_B:
 	{
-	  unsigned	offset = 0;
-	  unsigned	size;
+	  size_t	offset = 0;
+	  size_t	size;
 	  unsigned	count = atoi(++type);
 	  unsigned	i;
 
@@ -1018,11 +1018,12 @@ failure:
 			     atCursor: cursor
 			      context: callback];
 	    }
+    objc_layout_finish_structure(&layout, NULL, NULL);
 	  return;
         }
       case _C_PTR:
 	{
-	  unsigned	len = objc_sizeof_type(++type);
+	  size_t	len = objc_sizeof_type(++type);
 
 #if	GS_WITH_GC
 	  *(char**)data = (char*)NSAllocateCollectable(len, 0);
@@ -1204,7 +1205,7 @@ failure:
  *  Retrieve an int from this data, which is assumed to be in network
  *  (big-endian) byte order.  Cursor refers to byte position.
  */
-- (int) deserializeIntAtCursor: (unsigned int*)cursor
+- (int) deserializeIntAtCursor: (NSUInteger*)cursor
 {
   unsigned ni, result;
 
@@ -1217,7 +1218,7 @@ failure:
  *  Retrieve an int from this data, which is assumed to be in network
  *  (big-endian) byte order.  Index refers to byte position.
  */
-- (int) deserializeIntAtIndex: (unsigned int)index
+- (int) deserializeIntAtIndex: (NSUInteger)index
 {
   unsigned ni, result;
 
@@ -1232,8 +1233,8 @@ failure:
  *  position.
  */
 - (void) deserializeInts: (int*)intBuffer
-		   count: (unsigned int)numInts
-	        atCursor: (unsigned int*)cursor
+		   count: (NSUInteger)numInts
+	        atCursor: (NSUInteger*)cursor
 {
   unsigned i;
 
@@ -1250,8 +1251,8 @@ failure:
  *  position.
  */
 - (void) deserializeInts: (int*)intBuffer
-		   count: (unsigned int)numInts
-		 atIndex: (unsigned int)index
+		   count: (NSUInteger)numInts
+		 atIndex: (NSUInteger)index
 {
   unsigned i;
 
@@ -1324,7 +1325,7 @@ failure:
   char		thePath[BUFSIZ*2+8];
   char		theRealPath[BUFSIZ*2];
 #endif
-  int		c;
+  ssize_t		c;
   FILE		*theFile;
   BOOL		useAuxiliaryFile = NO;
   BOOL		error_BadPath = YES;
@@ -1698,7 +1699,7 @@ failure:
 
 - (void) deserializeTypeTag: (unsigned char*)tag
 		andCrossRef: (unsigned int*)ref
-		   atCursor: (unsigned int*)cursor
+		   atCursor: (NSUInteger*)cursor
 {
   [self deserializeDataAt: (void*)tag
 	       ofObjCType: @encode(uint8_t)
@@ -2180,9 +2181,10 @@ failure:
  *  Does not act as the name suggests.  Instead, serializes length itself
  *  as an int into buffer.
  */
-- (void) serializeAlignedBytesLength: (unsigned int)length
+- (void) serializeAlignedBytesLength: (NSUInteger)length
 {
-  [self serializeInt: length];
+    NSAssert1(length <= INT_MAX, @"Currently, serializeAlignedBytesLength: is limited to size of int, provided length: %lu", (unsigned long)length);
+    [self serializeInt: (int)length];
 }
 
 - (void) serializeDataAt: (const void*)data
@@ -2220,8 +2222,8 @@ failure:
 	}
       case _C_ARY_B:
 	{
-	  unsigned	offset = 0;
-	  unsigned	size;
+	  size_t	offset = 0;
+	  size_t	size;
 	  unsigned	count = atoi(++type);
 	  unsigned	i;
 
@@ -2257,6 +2259,7 @@ failure:
 			 ofObjCType: ftype
 			    context: callback];
 	    }
+    objc_layout_finish_structure(&layout, NULL, NULL);
 	  return;
         }
       case _C_PTR:
@@ -2369,7 +2372,7 @@ failure:
  * anything there currently), swapping it to network (big-endian) byte order
  * first.
  */
-- (void) serializeInt: (int)value atIndex: (unsigned int)index
+- (void) serializeInt: (int)value atIndex: (NSUInteger)index
 {
   unsigned ni = NSSwapHostIntToBig(value);
   NSRange range = { index, sizeof(int) };
@@ -2382,7 +2385,7 @@ failure:
  * network (big-endian) byte order first.
  */
 - (void) serializeInts: (int*)intBuffer
-		 count: (unsigned int)numInts
+		 count: (NSUInteger)numInts
 {
   unsigned	i;
   SEL		sel = @selector(serializeInt:);
@@ -2400,10 +2403,10 @@ failure:
  * byte order first.
  */
 - (void) serializeInts: (int*)intBuffer
-		 count: (unsigned int)numInts
-	       atIndex: (unsigned int)index
+		 count: (NSUInteger)numInts
+	       atIndex: (NSUInteger)index
 {
-  unsigned	i;
+  NSUInteger	i;
   SEL		sel = @selector(serializeInt:atIndex:);
   IMP		imp = [self methodForSelector: sel];
 
@@ -2603,13 +2606,13 @@ failure:
 }
 
 static inline void
-getBytes(void* dst, void* src, unsigned len, unsigned limit, unsigned *pos)
+getBytes(void* dst, void* src, NSUInteger len, NSUInteger limit, NSUInteger *pos)
 {
   if (*pos > limit || len > limit || len+*pos > limit)
     {
       [NSException raise: NSRangeException
-		  format: @"Range: (%u, %u) Size: %d",
-			*pos, len, limit];
+		  format: @"Range: (%lu, %lu) Size: %lu",
+			(unsigned long)*pos, (unsigned long)len, (unsigned long)limit];
     }
   memcpy(dst, src + *pos, len);
   *pos += len;
@@ -2617,7 +2620,7 @@ getBytes(void* dst, void* src, unsigned len, unsigned limit, unsigned *pos)
 
 - (void) deserializeDataAt: (void*)data
 	        ofObjCType: (const char*)type
-		  atCursor: (unsigned int*)cursor
+		  atCursor: (NSUInteger *)cursor
 		   context: (id <NSObjCTypeSerializationCallBack>)callback
 {
   if (data == 0 || type == 0)
@@ -2675,8 +2678,8 @@ getBytes(void* dst, void* src, unsigned len, unsigned limit, unsigned *pos)
 	}
       case _C_ARY_B:
 	{
-	  unsigned	offset = 0;
-	  unsigned	size;
+	  size_t	offset = 0;
+	  size_t	size;
 	  unsigned	count = atoi(++type);
 	  unsigned	i;
 
@@ -2714,11 +2717,12 @@ getBytes(void* dst, void* src, unsigned len, unsigned limit, unsigned *pos)
 			     atCursor: cursor
 			      context: callback];
 	    }
+    objc_layout_finish_structure(&layout, NULL, NULL);
 	  return;
         }
       case _C_PTR:
 	{
-	  unsigned	len = objc_sizeof_type(++type);
+	  size_t	len = objc_sizeof_type(++type);
 
 #if	GS_WITH_GC
 	  *(char**)data = (char*)NSAllocateCollectable(len, 0);
@@ -2872,12 +2876,12 @@ getBytes(void* dst, void* src, unsigned len, unsigned limit, unsigned *pos)
 
 - (void) deserializeTypeTag: (unsigned char*)tag
 		andCrossRef: (unsigned int*)ref
-		   atCursor: (unsigned int*)cursor
+		   atCursor: (NSUInteger*)cursor
 {
   if (*cursor >= length)
     {
       [NSException raise: NSRangeException
-		  format: @"Range: (%u, 1) Size: %d", *cursor, length];
+		  format: @"Range: (%lu, 1) Size: %lu", (unsigned long)*cursor, (unsigned long)length];
     }
   *tag = *((unsigned char*)bytes + (*cursor)++);
   if (*tag & _GSC_MAYX)
@@ -2893,8 +2897,8 @@ getBytes(void* dst, void* src, unsigned len, unsigned limit, unsigned *pos)
 	      if (*cursor >= length)
 		{
 		  [NSException raise: NSRangeException
-			      format: @"Range: (%u, 1) Size: %d",
-			  *cursor, length];
+			      format: @"Range: (%lu, 1) Size: %lu",
+			  (unsigned long)*cursor, (unsigned long)length];
 		}
 	      *ref = (unsigned int)*((unsigned char*)bytes + (*cursor)++);
 	      return;
@@ -2906,8 +2910,8 @@ getBytes(void* dst, void* src, unsigned len, unsigned limit, unsigned *pos)
 	      if (*cursor >= length-1)
 		{
 		  [NSException raise: NSRangeException
-			      format: @"Range: (%u, 1) Size: %d",
-			  *cursor, length];
+			      format: @"Range: (%lu, 1) Size: %lu",
+			  (unsigned long)*cursor, (unsigned long)length];
 		}
 #if NEED_WORD_ALIGNMENT
 	      if ((*cursor % __alignof__(uint16_t)) != 0)
@@ -2926,8 +2930,8 @@ getBytes(void* dst, void* src, unsigned len, unsigned limit, unsigned *pos)
 	      if (*cursor >= length-3)
 		{
 		  [NSException raise: NSRangeException
-			      format: @"Range: (%u, 1) Size: %d",
-			  *cursor, length];
+			      format: @"Range: (%lu, 1) Size: %lu",
+			  (unsigned long)*cursor, (unsigned long)length];
 		}
 #if NEED_WORD_ALIGNMENT
 	      if ((*cursor % __alignof__(uint32_t)) != 0)
@@ -3479,9 +3483,9 @@ getBytes(void* dst, void* src, unsigned len, unsigned limit, unsigned *pos)
 
       case _C_CHARPTR:
 	{
-	  unsigned	len;
+	  size_t	len;
 	  int32_t	ni;
-	  uint32_t	minimum;
+	  size_t	minimum;
 
 	  if (!*(void**)data)
 	    {
@@ -3491,7 +3495,8 @@ getBytes(void* dst, void* src, unsigned len, unsigned limit, unsigned *pos)
 	      return;
 	    }
 	  len = strlen(*(void**)data);
-	  ni = GSSwapHostI32ToBig(len);
+	  NSAssert1(len < INT32_MAX, @"Serialized string too long, length: %lu", (unsigned long)len);
+	  ni = GSSwapHostI32ToBig((int32_t)len);
 	  minimum = length + len + sizeof(ni);
 	  if (minimum > capacity)
 	    {
@@ -3508,11 +3513,11 @@ getBytes(void* dst, void* src, unsigned len, unsigned limit, unsigned *pos)
 	}
       case _C_ARY_B:
 	{
-	  unsigned	offset = 0;
-	  unsigned	size;
-	  unsigned	count = atoi(++type);
-	  unsigned	i;
-	  uint32_t	minimum;
+	  size_t	offset = 0;
+	  size_t	size;
+	  size_t	count = atoi(++type);
+	  size_t	i;
+	  size_t	minimum;
 
 	  while (isdigit(*type))
 	    {
@@ -3557,6 +3562,7 @@ getBytes(void* dst, void* src, unsigned len, unsigned limit, unsigned *pos)
 			 ofObjCType: ftype
 			    context: callback];
 	    }
+    objc_layout_finish_structure(&layout, NULL, NULL);
 	  return;
 	}
       case _C_PTR:
@@ -3614,7 +3620,7 @@ getBytes(void* dst, void* src, unsigned len, unsigned limit, unsigned *pos)
 	{
 	  const char  *name = *(Class*)data?class_getName(*(Class*)data):"";
 	  uint16_t	ln = (uint16_t)strlen(name);
-	  uint32_t	minimum = length + ln + sizeof(uint16_t);
+	  size_t	minimum = length + ln + sizeof(uint16_t);
 	  uint16_t	ni;
 
 	  if (minimum > capacity)
@@ -3637,7 +3643,7 @@ getBytes(void* dst, void* src, unsigned len, unsigned limit, unsigned *pos)
 	  uint16_t	ln = (name == 0) ? 0 : (uint16_t)strlen(name);
 	  const char  *types = *(SEL*)data?GSTypesFromSelector(*(SEL*)data):"";
 	  uint16_t	lt = (types == 0) ? 0 : (uint16_t)strlen(types);
-	  uint32_t	minimum = length + ln + lt + 2*sizeof(uint16_t);
+	  size_t	minimum = length + ln + lt + 2*sizeof(uint16_t);
 	  uint16_t	ni;
 
 	  if (minimum > capacity)
@@ -3761,7 +3767,7 @@ getBytes(void* dst, void* src, unsigned len, unsigned limit, unsigned *pos)
       if (tmp == 0)
 	{
 	  [NSException raise: NSMallocException
-	    format: @"Unable to set data capacity to '%d'", size];
+	    format: @"Unable to set data capacity to '%lu'", (unsigned long)size];
 	}
       if (bytes)
 	{
@@ -3955,8 +3961,8 @@ getBytes(void* dst, void* src, unsigned len, unsigned limit, unsigned *pos)
       if (newid == -1)			/* Created memory? */
 	{
 	  [NSException raise: NSMallocException
-	    format: @"Unable to create shared memory segment (size:%u) - %@.",
-	    size, [NSError _last]];
+	    format: @"Unable to create shared memory segment (size:%lu) - %@.",
+	    (unsigned long)size, [NSError _last]];
 	}
       tmp = shmat(newid, 0, 0);
       if ((intptr_t)tmp == -1)			/* Attached memory? */
diff --git a/Source/NSDate.m b/Source/NSDate.m
index 42f88f0..8931047 100644
--- a/Source/NSDate.m
+++ b/Source/NSDate.m
@@ -85,16 +85,18 @@ static id _distantFuture = nil;
 static NSString*
 findInArray(NSArray *array, unsigned pos, NSString *str)
 {
-  unsigned	index;
-  unsigned	limit = [array count];
+  NSUInteger index;
+  NSUInteger limit = [array count];
 
   for (index = pos; index < limit; index++)
     {
       NSString	*item;
-
+      
       item = [array objectAtIndex: index];
       if ([str caseInsensitiveCompare: item] == NSOrderedSame)
-	return item;
+        {
+          return item;
+        }
     }
   return nil;
 }
@@ -232,16 +234,16 @@ otherTime(NSDate* other)
 + (id) dateWithNaturalLanguageString: (NSString*)string
                               locale: (NSDictionary*)locale
 {
-  NSCharacterSet	*ws;
-  NSCharacterSet	*digits;
-  NSScanner		*scanner;
-  NSString		*tmp;
-  NSString		*dto;
-  NSArray		*ymw;
-  NSMutableArray	*words;
-  unsigned		index;
-  unsigned		length;
-  NSCalendarDate	*theDate;
+  NSCharacterSet  *ws;
+  NSCharacterSet  *digits;
+  NSScanner       *scanner;
+  NSString        *tmp;
+  NSString        *dto;
+  NSArray         *ymw;
+  NSMutableArray  *words;
+  NSUInteger      index;
+  NSUInteger      length;
+  NSCalendarDate  *theDate;
   BOOL			hadHour = NO;
   BOOL			hadMinute = NO;
   BOOL			hadSecond = NO;
@@ -249,16 +251,16 @@ otherTime(NSDate* other)
   BOOL			hadMonth = NO;
   BOOL			hadYear = NO;
   BOOL			hadWeekDay = NO;
-  int			weekDay = 0;
-  int			dayOfWeek = 0;
-  int			modMonth = 0;
-  int			modYear = 0;
-  int			modDay = 0;
-  int			D, M, Y;
-  int			h = 12;
-  int			m = 0;
-  int			s = 0;
-  unsigned		dtoIndex;
+  NSInteger			weekDay = 0;
+  NSInteger			dayOfWeek = 0;
+  NSInteger			modMonth = 0;
+  NSInteger			modYear = 0;
+  NSInteger			modDay = 0;
+  NSInteger			D, M, Y;
+  NSInteger			h = 12;
+  NSInteger			m = 0;
+  NSInteger			s = 0;
+  NSUInteger		dtoIndex;
 
   if (locale == nil)
     {
@@ -394,7 +396,7 @@ otherTime(NSDate* other)
   ymw = [locale objectForKey: NSYearMonthWeekDesignations];
   if (ymw != nil && [ymw count] > 0)
     {
-      unsigned	c = [ymw count];
+      NSUInteger c = [ymw count];
       NSString	*yname = [ymw objectAtIndex: 0];
       NSString	*mname = c > 1 ? [ymw objectAtIndex: 1] : nil;
       NSArray	*early = [locale objectForKey: NSEarlierTimeDesignations];
@@ -497,8 +499,8 @@ otherTime(NSDate* other)
   if (hadHour == NO)
     {
       NSArray	*hours = [locale objectForKey: NSHourNameDesignations];
-      unsigned	hLimit = [hours count];
-      unsigned	hIndex;
+      NSUInteger hLimit = [hours count];
+      NSUInteger hIndex;
 
       for (index = 0; hadHour == NO && index < [words count]; index++)
 	{
@@ -796,7 +798,7 @@ otherTime(NSDate* other)
 		      }
 		    if (debug)
 		      {
-			NSLog(@"year (%d) adjusted to %d.", num, Y);
+			NSLog(@"year (%d) adjusted to %ld.", num, (long)Y);
 		      }
 		  }
 		else
@@ -955,6 +957,12 @@ otherTime(NSDate* other)
   return AUTORELEASE([[self alloc] initWithTimeIntervalSinceNow: seconds]);
 }
 
++ (id) dateWithTimeInterval:(NSTimeInterval)seconds sinceDate:(NSDate *)date
+{
+    return AUTORELEASE([[self allocWithZone:NSDefaultMallocZone()] 
+                                initWithTimeInterval:seconds sinceDate:date]);
+}
+
 /**
  * Returns an autoreleased instance with the offset from the unix system
  * reference date of 1 January 1970, GMT.
@@ -1089,7 +1097,7 @@ otherTime(NSDate* other)
  * Returns an instance with the given offset from anotherDate.
  */
 - (id) initWithTimeInterval: (NSTimeInterval)secsToBeAdded
-		  sinceDate: (NSDate*)anotherDate
+                  sinceDate: (NSDate*)anotherDate
 {
   if (anotherDate == nil)
     {
diff --git a/Source/NSDateFormatter.m b/Source/NSDateFormatter.m
index fb006fe..0faac8a 100644
--- a/Source/NSDateFormatter.m
+++ b/Source/NSDateFormatter.m
@@ -346,7 +346,7 @@ static NSDateFormatterBehavior _defaultBehavior = 0;
   NSDate *result = nil;
   UDate date;
   UChar *text;
-  int32_t textLength;
+  NSUInteger textLength;
   UErrorCode err = U_ZERO_ERROR;
   int32_t pPos = 0;
   
@@ -357,7 +357,7 @@ static NSDateFormatterBehavior _defaultBehavior = 0;
   
   [string getCharacters: text range: NSMakeRange (0, textLength)];
   
-  date = udat_parse (internal->_formatter, text, textLength, &pPos, &err);
+  date = udat_parse (internal->_formatter, text, (int32_t)textLength, &pPos, &err);
   if (U_SUCCESS(err))
     result =
       [NSDate dateWithTimeIntervalSince1970: (NSTimeInterval)(date / 1000.0)];
@@ -412,13 +412,13 @@ static NSDateFormatterBehavior _defaultBehavior = 0;
 {
 #if GS_USE_ICU == 1
   UChar *pattern;
-  int32_t patternLength;
+  NSUInteger patternLength;
   
   patternLength = [string length];
   pattern = NSZoneMalloc ([self zone], sizeof(UChar) * patternLength);
   [string getCharacters: pattern range: NSMakeRange(0, patternLength)];
   
-  udat_applyPattern (internal->_formatter, 0, pattern, patternLength);
+  udat_applyPattern (internal->_formatter, 0, pattern, (int32_t)patternLength);
   
   NSZoneFree ([self zone], pattern);
 #endif
@@ -925,8 +925,8 @@ static NSDateFormatterBehavior _defaultBehavior = 0;
 #if GS_USE_ICU == 1
   unichar pat[BUFFER_SIZE];
   unichar skel[BUFFER_SIZE];
-  int32_t patLen;
-  int32_t skelLen;
+  NSUInteger  patLen;
+  int32_t     skelLen;
   UDateTimePatternGenerator *datpg;
   UErrorCode err = U_ZERO_ERROR;
   
@@ -938,7 +938,7 @@ static NSDateFormatterBehavior _defaultBehavior = 0;
     patLen = BUFFER_SIZE;
   [aTemplate getCharacters: pat range: NSMakeRange(0, patLen)];
   
-  skelLen = udatpg_getSkeleton (datpg, pat, patLen, skel, BUFFER_SIZE, &err);
+  skelLen = udatpg_getSkeleton (datpg, pat, (int32_t)patLen, skel, BUFFER_SIZE, &err);
   if (U_FAILURE(err))
     return nil;
   
@@ -968,7 +968,7 @@ static NSDateFormatterBehavior _defaultBehavior = 0;
 {
 #if GS_USE_ICU == 1
   UChar *tzID;
-  int32_t tzIDLength;
+  NSUInteger tzIDLength;
   UErrorCode err = U_ZERO_ERROR;
   
   if (internal->_formatter)
@@ -978,11 +978,11 @@ static NSDateFormatterBehavior _defaultBehavior = 0;
   tzID = NSZoneMalloc ([self zone], sizeof(UChar) * tzIDLength);
   [[internal->_tz name] getCharacters: tzID range: NSMakeRange (0, tzIDLength)];
   
-  internal->_formatter = udat_open (NSToUDateFormatStyle(internal->_timeStyle),
-                          NSToUDateFormatStyle(internal->_dateStyle),
+  internal->_formatter = udat_open ((UDateFormatStyle)NSToUDateFormatStyle(internal->_timeStyle),
+                          (UDateFormatStyle)NSToUDateFormatStyle(internal->_dateStyle),
                           [[internal->_locale localeIdentifier] UTF8String],
                           tzID,
-                          tzIDLength,
+                          (int32_t)tzIDLength,
                           NULL,
                           0,
                           &err);
@@ -999,14 +999,14 @@ static NSDateFormatterBehavior _defaultBehavior = 0;
 {
 #if GS_USE_ICU == 1
   int idx = 0;
-  int count = udat_countSymbols (internal->_formatter, symbol);
+  int count = udat_countSymbols (internal->_formatter, (UDateFormatSymbolType)symbol);
   
   if ([array count] != count)
     return;
   
   while (idx < count)
     {
-      int length;
+      NSUInteger length;
       UChar *value;
       UErrorCode err = U_ZERO_ERROR;
       NSString *string = [array objectAtIndex: idx];
@@ -1015,7 +1015,7 @@ static NSDateFormatterBehavior _defaultBehavior = 0;
       value = NSZoneMalloc ([self zone], sizeof(unichar) * length);
       [string getCharacters: value range: NSMakeRange(0, length)];
       
-      udat_setSymbols (internal->_formatter, symbol, idx, value, length, &err);
+      udat_setSymbols (internal->_formatter, (int32_t)symbol, idx, value, (int32_t)length, &err);
       
       NSZoneFree ([self zone], value);
       
@@ -1031,22 +1031,22 @@ static NSDateFormatterBehavior _defaultBehavior = 0;
 #if GS_USE_ICU == 1
   NSMutableArray *mArray;
   int idx = 0;
-  int count = udat_countSymbols (internal->_formatter, symbol);
+  int count = udat_countSymbols (internal->_formatter, (UDateFormatSymbolType)symbol);
   
   mArray = [NSMutableArray arrayWithCapacity: count];
   while (idx < count)
     {
-      int length;
+      int32_t length;
       unichar *value;
       NSString *str;
       NSZone *z = [self zone];
       UErrorCode err = U_ERROR_LIMIT;
       
       length
-	= udat_getSymbols (internal->_formatter, symbol, idx, NULL, 0, &err);
+	= udat_getSymbols (internal->_formatter, (int32_t)symbol, idx, NULL, 0, &err);
       value = NSZoneMalloc (z, sizeof(unichar) * (length + 1));
       err = U_ZERO_ERROR;
-      udat_getSymbols (internal->_formatter, symbol, idx, value, length, &err);
+      udat_getSymbols (internal->_formatter, (int32_t)symbol, idx, value, length, &err);
       if (U_SUCCESS(err))
         {
           str = AUTORELEASE([[NSString allocWithZone: z]
diff --git a/Source/NSDebug.m b/Source/NSDebug.m
index 0f4b068..89be81c 100644
--- a/Source/NSDebug.m
+++ b/Source/NSDebug.m
@@ -1197,18 +1197,23 @@ GSPrivateStackAddresses(void)
   return stack;
 }
 
-
+/*
+ * Functions used by GDB
+ */
+const char *_NSPrintForDebugger(id object);
 const char *_NSPrintForDebugger(id object)
 {
-  if (object && [object respondsToSelector: @selector(description)])
-    return [[object description] cString];
-
-  return NULL;
+    if (object && [object respondsToSelector: @selector(description)])
+    {
+        return [[object description] cString];
+    }
+    
+    return NULL;
 }
 
+NSString *_NSNewStringFromCString(const char *cstring);
 NSString *_NSNewStringFromCString(const char *cstring)
 {
-  return [NSString stringWithCString: cstring
-			    encoding: [NSString defaultCStringEncoding]];
-}
-
+    return [NSString stringWithCString: cstring
+                              encoding: [NSString defaultCStringEncoding]];
+}
\ No newline at end of file
diff --git a/Source/NSDecimal.m b/Source/NSDecimal.m
index b1e09a0..abf28c4 100644
--- a/Source/NSDecimal.m
+++ b/Source/NSDecimal.m
@@ -250,11 +250,11 @@ static NSComparisonResult
 NSSimpleCompare(const NSDecimal *leftOperand, const NSDecimal *rightOperand);
 
 static void
-GSDecimalRound(GSDecimal *result, int scale, NSRoundingMode mode)
+GSDecimalRound(GSDecimal *result, NSInteger scale, NSRoundingMode mode)
 {
-  int i;
+  NSInteger i;
   // last valid digit in number
-  int l = scale + result->exponent + result->length;
+  NSInteger l = scale + result->exponent + result->length;
 
   if (NSDecimalNoScale == scale)
       return;
@@ -761,7 +761,7 @@ NSCalculationError
 NSDecimalPower(NSDecimal *result, const NSDecimal *n, NSUInteger power, NSRoundingMode mode)
 {
   NSCalculationError error = NSCalculationNoError;
-  unsigned int e = power;
+  NSUInteger e = power;
   NSDecimal n1;
   BOOL neg = (n->isNegative && (power % 2));
 
diff --git a/Source/NSDictionary.m b/Source/NSDictionary.m
index 29ce4b5..c293fe3 100644
--- a/Source/NSDictionary.m
+++ b/Source/NSDictionary.m
@@ -284,12 +284,12 @@ static SEL	appSel;
 
 - (void) encodeWithCoder: (NSCoder*)aCoder
 {
-  unsigned	count = [self count];
+  NSUInteger count = [self count];
 
   if ([aCoder allowsKeyedCoding])
     {
       id	key;
-      unsigned	i;
+      NSUInteger i;
 
       if ([aCoder class] == [NSKeyedArchiver class])
 	{
@@ -315,9 +315,9 @@ static SEL	appSel;
 	    {
 	      NSString	*s;
 
-	      s = [NSString stringWithFormat: @"NS.key.%u", i];
+	      s = [NSString stringWithFormat: @"NS.key.%lu", (unsigned long)i];
 	      [aCoder encodeObject: key forKey: s];
-	      s = [NSString stringWithFormat: @"NS.object.%u", i];
+	      s = [NSString stringWithFormat: @"NS.object.%lu", (unsigned long)i];
 	      [aCoder encodeObject: [self objectForKey: key] forKey: s];
 	      i++;
 	    }
@@ -465,7 +465,7 @@ static SEL	appSel;
  */
 - (id) initWithObjects: (NSArray*)objects forKeys: (NSArray*)keys
 {
-  unsigned	objectCount = [objects count];
+  NSUInteger objectCount = [objects count];
 
   if (objectCount != [keys count])
     {
@@ -478,7 +478,7 @@ static SEL	appSel;
 
       if ([objects isProxy])
 	{
-	  unsigned	i;
+	  NSUInteger i;
 
 	  for (i = 0; i < objectCount; i++)
 	    {
@@ -580,13 +580,13 @@ static SEL	appSel;
 - (id) initWithDictionary: (NSDictionary*)other
 		copyItems: (BOOL)shouldCopy
 {
-  unsigned	c = [other count];
+  NSUInteger c = [other count];
 
   if (c > 0)
     {
       id		k;
-      NSEnumerator	*e = [other keyEnumerator];
-      unsigned		i = 0;
+      NSEnumerator  *e = [other keyEnumerator];
+      NSUInteger    i = 0;
       IMP		nxtObj = [e methodForSelector: nxtSel];
       IMP		otherObj = [other methodForSelector: objSel];
       GS_BEGINIDBUF(o, c*2);
@@ -769,7 +769,7 @@ static SEL	appSel;
  */
 - (BOOL) isEqualToDictionary: (NSDictionary*)other
 {
-  unsigned	count;
+  NSUInteger count;
 
   if (other == self)
     {
@@ -807,7 +807,7 @@ static SEL	appSel;
  */
 - (NSArray*) allKeys
 {
-  unsigned	c = [self count];
+  NSUInteger c = [self count];
 
   if (c == 0)
     {
@@ -815,10 +815,10 @@ static SEL	appSel;
     }
   else
     {
-      NSEnumerator	*e = [self keyEnumerator];
-      IMP		nxtObj = [e methodForSelector: nxtSel];
-      unsigned		i;
-      id		result;
+      NSEnumerator  *e = [self keyEnumerator];
+      IMP           nxtObj = [e methodForSelector: nxtSel];
+      NSUInteger    i;
+      id            result;
       GS_BEGINIDBUF(k, c);
 
       for (i = 0; i < c; i++)
@@ -838,7 +838,7 @@ static SEL	appSel;
  */
 - (NSArray*) allValues
 {
-  unsigned	c = [self count];
+  NSUInteger c = [self count];
 
   if (c == 0)
     {
@@ -846,10 +846,10 @@ static SEL	appSel;
     }
   else
     {
-      NSEnumerator	*e = [self objectEnumerator];
-      IMP		nxtObj = [e methodForSelector: nxtSel];
-      id		result;
-      unsigned		i;
+      NSEnumerator  *e = [self objectEnumerator];
+      IMP           nxtObj = [e methodForSelector: nxtSel];
+      id            result;
+      NSUInteger    i;
       GS_BEGINIDBUF(k, c);
 
       for (i = 0; i < c; i++)
@@ -879,7 +879,7 @@ static SEL	appSel;
  */
 - (NSArray*) allKeysForObject: (id)anObject
 {
-  unsigned	c;
+  NSUInteger c;
 
   if (anObject == nil || (c = [self count]) == 0)
     {
@@ -922,13 +922,13 @@ static SEL	appSel;
 
 struct foo { NSDictionary *d; SEL s; IMP i; };
 
-static int
+static NSComparisonResult
 compareIt(id o1, id o2, void* context)
 {
   struct foo	*f = (struct foo*)context;
   o1 = (*f->i)(f->d, @selector(objectForKey:), o1);
   o2 = (*f->i)(f->d, @selector(objectForKey:), o2);
-  return (NSInteger)(intptr_t)[o1 performSelector: f->s withObject: o2];
+  return (NSComparisonResult)[o1 performSelector: f->s withObject: o2];
 }
 
 /**
@@ -959,7 +959,7 @@ compareIt(id o1, id o2, void* context)
  */
 - (NSArray*) objectsForKeys: (NSArray*)keys notFoundMarker: (id)marker
 {
-  unsigned	c = [keys count];
+  NSUInteger c = [keys count];
 
   if (c == 0)
     {
@@ -967,7 +967,7 @@ compareIt(id o1, id o2, void* context)
     }
   else
     {
-      unsigned	i;
+      NSUInteger i;
       IMP	myObj = [self methodForSelector: objSel];
       id	result;
       GS_BEGINIDBUF(obuf, c);
@@ -1262,9 +1262,9 @@ compareIt(id o1, id o2, void* context)
 - (id) copyWithZone: (NSZone*)z
 {
   /* a deep copy */
-  unsigned	count = [self count];
+  NSUInteger count = [self count];
   NSDictionary	*newDictionary;
-  unsigned	i;
+  NSUInteger i;
   id		key;
   NSEnumerator	*enumerator = [self keyEnumerator];
   IMP		nxtImp = [enumerator methodForSelector: nxtSel];
@@ -1398,7 +1398,7 @@ compareIt(id o1, id o2, void* context)
  */
 - (void) removeObjectsForKeys: (NSArray*)keyArray
 {
-  unsigned	c = [keyArray count];
+  NSUInteger c = [keyArray count];
 
   if (c > 0)
     {
@@ -1407,7 +1407,7 @@ compareIt(id o1, id o2, void* context)
 
       if ([keyArray isProxy])
 	{
-	  unsigned	i;
+	  NSUInteger i;
 
 	  for (i = 0; i < c; i++)
 	    {
diff --git a/Source/NSDistantObject.m b/Source/NSDistantObject.m
index 770a970..74f3356 100644
--- a/Source/NSDistantObject.m
+++ b/Source/NSDistantObject.m
@@ -67,19 +67,36 @@ static int	debug_proxy = 0;
 static Class	placeHolder = 0;
 static Class	distantObjectClass = 0;
 
-#ifndef __GNUSTEP_RUNTIME__
+#if !defined (__GNUSTEP_RUNTIME__) && (!defined (TARGET_OS_MAC) || MAC_OS_X_VERSION_MAX_ALLOWED < 1080)
+#  define SHOULD_IMPLEMENT_OBJECT_ADDITIONS 1
+#else
+#  define SHOULD_IMPLEMENT_OBJECT_ADDITIONS 0
+#endif
+
+#if SHOULD_IMPLEMENT_OBJECT_ADDITIONS
+
+#if defined (__OBJC2__)
+@interface Object (NSConformsTo)
+- (BOOL) conformsTo: (Protocol *)aProtocolObject;
++ (BOOL) conformsTo: (Protocol *)aProtocolObject;
+@end
+#endif /* __OBJC2__ */
+
 @interface Object (NSConformsToProtocolNamed)
 - (BOOL) _conformsToProtocolNamed: (const char*)aName;
 @end
-#endif
+
+#endif /* __GNUSTEP_RUNTIME__ */
+
 @interface NSObject (NSConformsToProtocolNamed)
 - (BOOL) _conformsToProtocolNamed: (const char*)aName;
 @end
+
 /*
  * Evil hack ... if a remote system wants to know if we conform
  * to a protocol we usa a local protocol with the same name.
  */
-#ifndef __GNUSTEP_RUNTIME__
+#if SHOULD_IMPLEMENT_OBJECT_ADDITIONS
 @implementation Object (NSConformsToProtocolNamed)
 - (BOOL) _conformsToProtocolNamed: (const char*)aName
 {
@@ -89,7 +106,8 @@ static Class	distantObjectClass = 0;
   return [self conformsTo: p];
 }
 @end
-#endif
+#endif /* __GNUSTEP_RUNTIME__ */
+
 @implementation NSObject (NSConformsToProtocolNamed)
 - (BOOL) _conformsToProtocolNamed: (const char*)aName
 {
@@ -123,13 +141,13 @@ enum proxyLocation
 
 
 /*
- *	The GSDistantObjectPlaceHolder class is simply used as a placeholder
- *	for an NSDistantObject so we can manage efficient allocation and
- *	initialisation - in most cases when we ask for an NSDistantObject
- *	instance, we will get a pre-existing one, so we don't want to go
- *	allocating the memory for a new instance unless absolutely necessary.
+ * The GSDistantObjectPlaceHolder class is simply used as a placeholder
+ * for an NSDistantObject so we can manage efficient allocation and
+ * initialisation - in most cases when we ask for an NSDistantObject
+ * instance, we will get a pre-existing one, so we don't want to go
+ * allocating the memory for a new instance unless absolutely necessary.
  */
-GS_ROOT_CLASS @interface	GSDistantObjectPlaceHolder
+GS_ROOT_CLASS @interface GSDistantObjectPlaceHolder
 + (id) initWithCoder: (NSCoder*)aCoder;
 + (id) initWithLocal: (id)anObject connection: (NSConnection*)aConnection;
 + (id) initWithTarget: (unsigned)target connection: (NSConnection*)aConnection;
diff --git a/Source/NSError.m b/Source/NSError.m
index 15aabda..5a587f6 100644
--- a/Source/NSError.m
+++ b/Source/NSError.m
@@ -26,6 +26,7 @@
 #define	EXPOSE_NSError_IVARS	1
 #import	"Foundation/NSDictionary.h"
 #import	"Foundation/NSError.h"
+#import "Foundation/NSException.h"
 #import	"Foundation/NSCoder.h"
 
 NSString* const NSFilePathErrorKey = @"NSFilePath";
@@ -94,13 +95,13 @@ NSString* const NSCocoaErrorDomain = @"NSCocoaErrorDomain";
 {
   if ([aCoder allowsKeyedCoding])
     {
-      [aCoder encodeInt: _code forKey: @"NSCode"];
+      [aCoder encodeInteger: _code forKey: @"NSCode"];
       [aCoder encodeObject: _domain forKey: @"NSDomain"];
       [aCoder encodeObject: _userInfo forKey: @"NSUserInfo"];
     }
   else
     {
-      [aCoder encodeValueOfObjCType: @encode(int) at: &_code];
+      [aCoder encodeValueOfObjCType: @encode(NSInteger) at: &_code];
       [aCoder encodeValueOfObjCType: @encode(id) at: &_domain];
       [aCoder encodeValueOfObjCType: @encode(id) at: &_userInfo];
     }
@@ -139,11 +140,9 @@ NSString* const NSCocoaErrorDomain = @"NSCocoaErrorDomain";
 {
   if (aDomain == nil)
     {
-      NSLog(@"[%@-%@] with nil domain",
-	NSStringFromClass([self class]), NSStringFromSelector(_cmd));
-      DESTROY(self);
+      [NSException raise:NSInvalidArgumentException format:@"Invalid domain=nil in -[NSError initWithDomain:code:userInfo:]"];
     }
-  else if ((self = [super init]) != nil)
+  if (self = [super init])
     {
       ASSIGN(_domain, aDomain);
       _code = aCode;
@@ -158,7 +157,7 @@ NSString* const NSCocoaErrorDomain = @"NSCocoaErrorDomain";
 
   if (desc == nil)
     {
-      desc = [NSString stringWithFormat: @"%@ %d", _domain, _code];
+      desc = [NSString stringWithFormat: @"%@ %ld", _domain, (long)_code];
     }
   return desc;
 }
diff --git a/Source/NSException.m b/Source/NSException.m
index 271fa06..97a22bc 100644
--- a/Source/NSException.m
+++ b/Source/NSException.m
@@ -566,8 +566,8 @@ GSListModules()
 {
   NSMutableString *result;
   NSArray *s;
-  int i;
-  int n;
+  NSUInteger i;
+  NSUInteger n;
 
   result = [NSMutableString string];
   s = [self symbols];
@@ -576,7 +576,7 @@ GSListModules()
     {
       NSString	*line = [s objectAtIndex: i];
 
-      [result appendFormat: @"%3d: %@\n", i, line];
+      [result appendFormat: @"%3lu: %@\n", (unsigned long)i, line];
     }
   return result;
 }
@@ -584,6 +584,10 @@ GSListModules()
 // grab the current stack 
 - (id) init
 {
+    if (!(self = [super init]))
+    {
+        return nil;
+    }
 #if	defined(HAVE_BACKTRACE)
   void		**addr;
   id		*vals;
@@ -628,7 +632,7 @@ GSListModules()
 		unsignedIntegerValue];
 	    }
 
-	  strs = backtrace_symbols(addr, count);
+	  strs = backtrace_symbols(addr, (int)count);
 	  symbolArray = alloca(count * sizeof(NSString*));
 	  for (i = 0; i < count; i++)
 	    {
@@ -739,6 +743,7 @@ NSString* const NSParseErrorException
 NSString* const NSRangeException
  = @"NSRangeException";
 
+#if !defined (__APPLE__)
 static void _terminate()
 {
   BOOL			shouldAbort;
@@ -758,24 +763,45 @@ static void _terminate()
       exit(1);
     }
 }
+#else
+static void _terminate()
+{
+    /* Apple's ObjC runtime terminates program after calling uncaught handler */
+}
+#endif
+
+#if defined (__OBJC2__)
+static id
+_NSFoundationExceptionPreprocessor (id exception)
+{
+    CREATE_AUTORELEASE_POOL(pool);
+    
+    if (class_respondsToSelector(object_getClass(exception), @selector(_recordStackTrace))) {
+        objc_msgSend(exception, @selector(_recordStackTrace));
+    }
+    
+    RELEASE(pool);
+    return exception;
+}
+#endif
 
 static void
 _NSFoundationUncaughtExceptionHandler (NSException *exception)
 {
-  NSAutoreleasePool	*pool = [NSAutoreleasePool new];
-
-  fprintf(stderr, "%s: Uncaught exception %s, reason: %s\n",
-    GSPrivateArgZero(),
-    [[exception name] lossyCString], [[exception reason] lossyCString]);
-  fflush(stderr);	/* NEEDED UNDER MINGW */
-  if (GSPrivateEnvironmentFlag("GNUSTEP_STACK_TRACE", NO) == YES)
-    {
-      fprintf(stderr, "Stack\n%s\n",
-	[[[exception _callStack] description] lossyCString]);
+    CREATE_AUTORELEASE_POOL(pool);
+    
+    const char *className = class_getName(object_getClass(exception));
+    if (GSObjCIsKindOf(object_getClass(exception), [NSException class])) {
+        NSLog(@"*** Terminating app due to uncaught exception '%@', reason: '%@'\n"
+              @"*** Call stack at first throw:\n"
+              @"(\n\t%@\n)",
+              [exception name], [exception reason], [[exception callStackSymbols] componentsJoinedByString:@"\n\t"]);   
+    } else {
+        NSLog(@"*** Terminating app due to uncaught exception of class '%s'\n", className);
     }
-  fflush(stderr);	/* NEEDED UNDER MINGW */
-  [pool drain];
-  _terminate();
+    
+    RELEASE(pool);
+    _terminate();
 }
 
 static void
@@ -809,16 +835,24 @@ callUncaughtHandler(id value)
     }
   NSLog(@"WARNING this copy of gnustep-base has been built with libbfd to provide symbolic stacktrace support. This means that the license of this copy of gnustep-base is GPL rather than the normal LGPL license (since libbfd is released under the GPL license).  If this is not what you want, please obtain a copy of gnustep-base which was not configured with the --enable-bfd option");
 #endif	/* USE_BINUTILS */
+  return;
+}
+
++ (void)load
+{
 #if defined(_NATIVE_OBJC_EXCEPTIONS)
 #  ifdef HAVE_SET_UNCAUGHT_EXCEPTION_HANDLER
-  objc_setUncaughtExceptionHandler(callUncaughtHandler);
+    objc_setUncaughtExceptionHandler(callUncaughtHandler);
 #  elif defined(HAVE_UNEXPECTED)
-  _objc_unexpected_exception = callUncaughtHandler;
+    _objc_unexpected_exception = callUncaughtHandler;
 #  elif defined(HAVE_SET_UNEXPECTED)
-  objc_set_unexpected(callUncaughtHandler);
+    objc_set_unexpected(callUncaughtHandler);
 #  endif
 #endif
-  return;
+    
+#if defined (__OBJC2__) && defined (__APPLE__)
+    objc_setExceptionPreprocessor(&_NSFoundationExceptionPreprocessor);
+#endif
 }
 
 + (NSException*) exceptionWithName: (NSString*)name
@@ -829,27 +863,20 @@ callUncaughtHandler(id value)
 				   userInfo: userInfo]);
 }
 
-+ (void) raise: (NSString*)name
-	format: (NSString*)format,...
++ (void)raise:(NSString *)name format:(NSString *)format, ...
 {
-  va_list args;
-
-  va_start(args, format);
-  [self raise: name format: format arguments: args];
-  // This probably doesn't matter, but va_end won't get called
-  va_end(args);
+    va_list args;
+    
+    va_start(args, format);
+    [self raise:name format:format arguments:args];
+    // This probably doesn't matter, but va_end won't get called
+    va_end(args);
 }
 
-+ (void) raise: (NSString*)name
-	format: (NSString*)format
-     arguments: (va_list)argList
++ (void)raise:(NSString *)name format:(NSString *)format arguments:(va_list)argList
 {
-  NSString	*reason;
-  NSException	*except;
-
-  reason = [NSString stringWithFormat: format arguments: argList];
-  except = [self exceptionWithName: name reason: reason userInfo: nil];
-  [except raise];
+    NSString *reason = [NSString stringWithFormat:format arguments:argList];
+    [[self exceptionWithName:name reason:reason userInfo:nil] raise];
 }
 
 /* For OSX compatibility -init returns nil.
@@ -954,17 +981,22 @@ callUncaughtHandler(id value)
   return [result autorelease];
 }
 
-- (void) raise
+- (void) _recordStackTrace
 {
-  if (_reserved == 0)
+    if (_reserved == 0)
     {
-      _reserved = NSZoneCalloc([self zone], 2, sizeof(id));
+        _reserved = NSZoneCalloc([self zone], 2, sizeof(id));
     }
-  if (nil == _e_stack)
+    if (nil == _e_stack)
     {
-      // Only set the stack when first raised
-      _e_stack = [GSStackTrace new];
+        // Only set the stack when first raised
+        _e_stack = [GSStackTrace new];
     }
+}
+
+- (void) raise
+{
+  [self _recordStackTrace];
 
 #if     defined(_NATIVE_OBJC_EXCEPTIONS)
   @throw self;
@@ -1107,6 +1139,7 @@ callUncaughtHandler(id value)
 
 @end
 
+#if !USER_NATIVE_OBJC_EXCEPTIONS && !BASE_NATIVE_OBJC_EXCEPTIONS
 
 void
 _NSAddHandler (NSHandler* handler)
@@ -1157,6 +1190,8 @@ _NSRemoveHandler (NSHandler* handler)
   thread->_exception_handler = handler->next;
 }
 
+#endif /* _NATIVE_OBJC_EXCEPTIONS */
+
 NSUncaughtExceptionHandler *
 NSGetUncaughtExceptionHandler()
 {
diff --git a/Source/NSFileHandle.m b/Source/NSFileHandle.m
index 5b55f25..a66ac22 100644
--- a/Source/NSFileHandle.m
+++ b/Source/NSFileHandle.m
@@ -586,7 +586,7 @@ NSString * const NSFileHandleOperationException
 /**
  * Call -readDataInBackgroundAndNotifyLength:forModes: with nil modes.
  */
-- (void) readDataInBackgroundAndNotifyLength: (unsigned)len
+- (void) readDataInBackgroundAndNotifyLength: (NSUInteger)len
 {
   [self readDataInBackgroundAndNotifyLength: len forModes: nil];
 }
@@ -595,7 +595,7 @@ NSString * const NSFileHandleOperationException
  * Set up an asynchronous read operation which will cause a notification to
  * be sent when the specified amount of data (or end of file) is read.
  */
-- (void) readDataInBackgroundAndNotifyLength: (unsigned)len
+- (void) readDataInBackgroundAndNotifyLength: (NSUInteger)len
 				    forModes: (NSArray*)modes
 {
   [self subclassResponsibility: _cmd];
diff --git a/Source/NSFileManager.m b/Source/NSFileManager.m
index 6e03c9d..8a328d4 100644
--- a/Source/NSFileManager.m
+++ b/Source/NSFileManager.m
@@ -1,45 +1,45 @@
 /**
-   NSFileManager.m
-
-   Copyright (C) 1997-2002 Free Software Foundation, Inc.
-
-   Author: Mircea Oancea <mircea@jupiter.elcom.pub.ro>
-   Author: Ovidiu Predescu <ovidiu@net-community.com>
-   Date: Feb 1997
-   Updates and fixes: Richard Frith-Macdonald
-
-   Author: Nicola Pero <n.pero@mi.flashnet.it>
-   Date: Apr 2001
-   Rewritten NSDirectoryEnumerator
-
-   Author: Richard Frith-Macdonald <rfm@gnu.org>
-   Date: Sep 2002
-   Rewritten attribute handling code
-
-   This file is part of the GNUstep Base Library.
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Library General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with this library; if not, write to the Free
-   Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
-   Boston, MA 02111 USA.
-
-   <title>NSFileManager class reference</title>
-   $Date$ $Revision$
-*/
+ NSFileManager.m
+ 
+ Copyright (C) 1997-2002 Free Software Foundation, Inc.
+ 
+ Author: Mircea Oancea <mircea@jupiter.elcom.pub.ro>
+ Author: Ovidiu Predescu <ovidiu@net-community.com>
+ Date: Feb 1997
+ Updates and fixes: Richard Frith-Macdonald
+ 
+ Author: Nicola Pero <n.pero@mi.flashnet.it>
+ Date: Apr 2001
+ Rewritten NSDirectoryEnumerator
+ 
+ Author: Richard Frith-Macdonald <rfm@gnu.org>
+ Date: Sep 2002
+ Rewritten attribute handling code
+ 
+ This file is part of the GNUstep Base Library.
+ 
+ This library is free software; you can redistribute it and/or
+ modify it under the terms of the GNU Lesser General Public
+ License as published by the Free Software Foundation; either
+ version 2 of the License, or (at your option) any later version.
+ 
+ This library is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ Library General Public License for more details.
+ 
+ You should have received a copy of the GNU Lesser General Public
+ License along with this library; if not, write to the Free
+ Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ Boston, MA 02111 USA.
+ 
+ <title>NSFileManager class reference</title>
+ $Date$ $Revision$
+ */
 
 #define _FILE_OFFSET_BITS 64
 /* The following define is needed for Solaris get(pw/gr)(nam/uid)_r declartions
-   which default to pre POSIX declaration.  */
+ which default to pre POSIX declaration.  */
 #define _POSIX_PTHREAD_SEMANTICS
 
 #import "common.h"
@@ -179,7 +179,7 @@
    recurseIntoSubdirectories: (BOOL)recurse
               followSymlinks: (BOOL)follow
                 justContents: (BOOL)justContents
-			 for: (NSFileManager*)mgr;
+for: (NSFileManager*)mgr;
 @end
 
 /*
@@ -239,11 +239,11 @@
 @interface	GSAttrDictionary : NSDictionary
 {
 @public
-  struct _STATB	statbuf;
-  _CHAR		_path[0];
+    struct _STATB	statbuf;
+    _CHAR		_path[0];
 }
 + (NSDictionary*) attributesAt: (const _CHAR*)lpath
-		  traverseLink: (BOOL)traverse;
+                  traverseLink: (BOOL)traverse;
 @end
 
 static Class	GSAttrDictionaryClass = 0;
@@ -253,8 +253,8 @@ static Class	GSAttrDictionaryClass = 0;
  */
 @interface	GSAttrDictionaryEnumerator : NSEnumerator
 {
-  NSDictionary	*dictionary;
-  NSEnumerator	*enumerator;
+    NSDictionary	*dictionary;
+    NSEnumerator	*enumerator;
 }
 + (NSEnumerator*) enumeratorFor: (NSDictionary*)d;
 @end
@@ -264,27 +264,27 @@ static Class	GSAttrDictionaryClass = 0;
 @interface NSFileManager (PrivateMethods)
 
 /* Copies the contents of source file to destination file. Assumes source
-   and destination are regular files or symbolic links. */
+ and destination are regular files or symbolic links. */
 - (BOOL) _copyFile: (NSString*)source
-	    toFile: (NSString*)destination
-	   handler: (id)handler;
+            toFile: (NSString*)destination
+           handler: (id)handler;
 
 /* Recursively copies the contents of source directory to destination. */
 - (BOOL) _copyPath: (NSString*)source
-	    toPath: (NSString*)destination
-	   handler: (id)handler;
+            toPath: (NSString*)destination
+           handler: (id)handler;
 
 /* Recursively links the contents of source directory to destination. */
 - (BOOL) _linkPath: (NSString*)source
-	    toPath: (NSString*)destination
-	   handler: handler;
+            toPath: (NSString*)destination
+           handler: handler;
 
 /* encapsulates the will Process check for existence of selector. */
 - (void) _sendToHandler: (id) handler
         willProcessPath: (NSString*) path;
 
 /* methods to encapsulates setting up and calling the handler
-   in case of an error */
+ in case of an error */
 - (BOOL) _proceedAccordingToHandler: (id) handler
                            forError: (NSString*) error
                              inPath: (NSString*) path;
@@ -304,7 +304,7 @@ static Class	GSAttrDictionaryClass = 0;
  * and 'FromPath' and 'ToPath' if both path argument are specified.
  */
 - (NSError*) _errorFrom: (NSString*)fromPath to: (NSString*)toPath;
-				   
+
 @end /* NSFileManager (PrivateMethods) */
 
 /**
@@ -323,59 +323,59 @@ static NSStringEncoding	defaultEncoding;
 
 + (NSFileManager*) defaultManager
 {
-  if (defaultManager == nil)
+    if (defaultManager == nil)
     {
-      NS_DURING
-	{
-	  [gnustep_global_lock lock];
-	  if (defaultManager == nil)
-	    {
-	      defaultManager = [[self alloc] init];
-	    }
-	  [gnustep_global_lock unlock];
-	}
-      NS_HANDLER
-	{
-	  // unlock then re-raise the exception
-	  [gnustep_global_lock unlock];
-	  [localException raise];
-	}
-      NS_ENDHANDLER
+        NS_DURING
+        {
+            [gnustep_global_lock lock];
+            if (defaultManager == nil)
+            {
+                defaultManager = [[self alloc] init];
+            }
+            [gnustep_global_lock unlock];
+        }
+        NS_HANDLER
+        {
+            // unlock then re-raise the exception
+            [gnustep_global_lock unlock];
+            [localException raise];
+        }
+        NS_ENDHANDLER
     }
-  return defaultManager;
+    return defaultManager;
 }
 
 + (void) initialize
 {
-  defaultEncoding = [NSString defaultCStringEncoding];
-  GSAttrDictionaryClass = [GSAttrDictionary class];
+    defaultEncoding = [NSString defaultCStringEncoding];
+    GSAttrDictionaryClass = [GSAttrDictionary class];
 }
 
 - (void) dealloc
 {
-  TEST_RELEASE(_lastError);
-  [super dealloc];
+    TEST_RELEASE(_lastError);
+    [super dealloc];
 }
 
 - (BOOL) changeCurrentDirectoryPath: (NSString*)path
 {
-  static Class	bundleClass = 0;
-  const _CHAR	*lpath = [self fileSystemRepresentationWithPath: path];
-
-  /*
-   * On some systems the only way NSBundle can determine the path to the
-   * executable is by searching for it ... so it needs to know what was
-   * the current directory at launch time ... so we must make sure it is
-   * initialised before we change the current directory.
-   */
-  if (bundleClass == 0)
+    static Class	bundleClass = 0;
+    const _CHAR	*lpath = [self fileSystemRepresentationWithPath: path];
+    
+    /*
+     * On some systems the only way NSBundle can determine the path to the
+     * executable is by searching for it ... so it needs to know what was
+     * the current directory at launch time ... so we must make sure it is
+     * initialised before we change the current directory.
+     */
+    if (bundleClass == 0)
     {
-      bundleClass = [NSBundle class];
+        bundleClass = [NSBundle class];
     }
 #if defined(__MINGW__)
-  return SetCurrentDirectoryW(lpath) == TRUE ? YES : NO;
+    return SetCurrentDirectoryW(lpath) == TRUE ? YES : NO;
 #else
-  return (chdir(lpath) == 0) ? YES : NO;
+    return (chdir(lpath) == 0) ? YES : NO;
 #endif
 }
 
@@ -387,208 +387,208 @@ static NSStringEncoding	defaultEncoding;
  */
 - (BOOL) changeFileAttributes: (NSDictionary*)attributes atPath: (NSString*)path
 {
-  NSDictionary  *old;
-  const _CHAR	*lpath = 0;
-  NSUInteger	num;
-  NSString	*str;
-  NSDate	*date;
-  BOOL		allOk = YES;
-
-  if (0 == [attributes count])
+    NSDictionary  *old;
+    const _CHAR	*lpath = 0;
+    NSUInteger	num;
+    NSString	*str;
+    NSDate	*date;
+    BOOL		allOk = YES;
+    
+    if (0 == [attributes count])
     {
-      return YES;
+        return YES;
     }
-  old = [self fileAttributesAtPath: path traverseLink: YES];
-  lpath = [defaultManager fileSystemRepresentationWithPath: path];
-
+    old = [self fileAttributesAtPath: path traverseLink: YES];
+    lpath = [defaultManager fileSystemRepresentationWithPath: path];
+    
 #ifndef __MINGW__
-  if (object_getClass(attributes) == GSAttrDictionaryClass)
+    if (object_getClass(attributes) == GSAttrDictionaryClass)
     {
-      num = ((GSAttrDictionary*)attributes)->statbuf.st_uid;
+        num = ((GSAttrDictionary*)attributes)->statbuf.st_uid;
     }
-  else
+    else
     {
-      NSNumber	*tmpNum = [attributes fileOwnerAccountID];
-
-      num = tmpNum ? [tmpNum unsignedLongValue] : NSNotFound;
+        NSNumber	*tmpNum = [attributes fileOwnerAccountID];
+        
+        num = tmpNum ? [tmpNum unsignedLongValue] : NSNotFound;
     }
-  if (num != NSNotFound && num != [[old fileOwnerAccountID] unsignedLongValue])
+    if (num != NSNotFound && num != [[old fileOwnerAccountID] unsignedLongValue])
     {
-      if (chown(lpath, num, -1) != 0)
-	{
-	  allOk = NO;
-	  str = [NSString stringWithFormat:
-	    @"Unable to change NSFileOwnerAccountID to '%u' - %@",
-	    num, [NSError _last]];
-	  ASSIGN(_lastError, str);
-	}
+        if (chown(lpath, (uid_t)num, -1) != 0)
+        {
+            allOk = NO;
+            str = [NSString stringWithFormat:
+                   @"Unable to change NSFileOwnerAccountID to '%lu' - %@",
+                   (unsigned long)num, [NSError _last]];
+            ASSIGN(_lastError, str);
+        }
     }
-  else
+    else
     {
-      if ((str = [attributes fileOwnerAccountName]) != nil
-        && NO == [str isEqual: [old fileOwnerAccountName]])
-	{
-	  BOOL	ok = NO;
+        if ((str = [attributes fileOwnerAccountName]) != nil
+            && NO == [str isEqual: [old fileOwnerAccountName]])
+        {
+            BOOL	ok = NO;
 #ifdef HAVE_PWD_H
 #if     defined(HAVE_GETPWNAM_R)
-	  struct passwd pw;
-	  struct passwd *p;
-          char buf[BUFSIZ*10];
-
-	  if (getpwnam_r([str cStringUsingEncoding: defaultEncoding],
-            &pw, buf, sizeof(buf), &p) == 0)
-	    {
-	      ok = (chown(lpath, pw.pw_uid, -1) == 0);
-	      chown(lpath, -1, pw.pw_gid);
-	    }
+            struct passwd pw;
+            struct passwd *p;
+            char buf[BUFSIZ*10];
+            
+            if (getpwnam_r([str cStringUsingEncoding: defaultEncoding],
+                           &pw, buf, sizeof(buf), &p) == 0)
+            {
+                ok = (chown(lpath, pw.pw_uid, -1) == 0);
+                chown(lpath, -1, pw.pw_gid);
+            }
 #else
 #if     defined(HAVE_GETPWNAM)
-	  struct passwd *pw;
-
-          [gnustep_global_lock lock];
-	  pw = getpwnam([str cStringUsingEncoding: defaultEncoding]);
-	  if (pw != 0)
-	    {
-	      ok = (chown(lpath, pw->pw_uid, -1) == 0);
-	      chown(lpath, -1, pw->pw_gid);
-	    }
-          [gnustep_global_lock unlock];
+            struct passwd *pw;
+            
+            [gnustep_global_lock lock];
+            pw = getpwnam([str cStringUsingEncoding: defaultEncoding]);
+            if (pw != 0)
+            {
+                ok = (chown(lpath, pw->pw_uid, -1) == 0);
+                chown(lpath, -1, pw->pw_gid);
+            }
+            [gnustep_global_lock unlock];
 #endif
 #endif
 #endif
-	  if (ok == NO)
-	    {
-	      allOk = NO;
-	      str = [NSString stringWithFormat:
-		@"Unable to change NSFileOwnerAccountName to '%@' - %@",
-		str, [NSError _last]];
-	      ASSIGN(_lastError, str);
-	    }
-	}
+            if (ok == NO)
+            {
+                allOk = NO;
+                str = [NSString stringWithFormat:
+                       @"Unable to change NSFileOwnerAccountName to '%@' - %@",
+                       str, [NSError _last]];
+                ASSIGN(_lastError, str);
+            }
+        }
     }
-
-  if (object_getClass(attributes) == GSAttrDictionaryClass)
+    
+    if (object_getClass(attributes) == GSAttrDictionaryClass)
     {
-      num = ((GSAttrDictionary*)attributes)->statbuf.st_gid;
+        num = ((GSAttrDictionary*)attributes)->statbuf.st_gid;
     }
-  else
+    else
     {
-      NSNumber	*tmpNum = [attributes fileGroupOwnerAccountID];
-
-      num = tmpNum ? [tmpNum unsignedLongValue] : NSNotFound;
+        NSNumber	*tmpNum = [attributes fileGroupOwnerAccountID];
+        
+        num = tmpNum ? [tmpNum unsignedLongValue] : NSNotFound;
     }
-  if (num != NSNotFound
-    && num != [[old fileGroupOwnerAccountID] unsignedLongValue])
+    if (num != NSNotFound
+        && num != [[old fileGroupOwnerAccountID] unsignedLongValue])
     {
-      if (chown(lpath, -1, num) != 0)
-	{
-	  allOk = NO;
-	  str = [NSString stringWithFormat:
-	    @"Unable to change NSFileGroupOwnerAccountID to '%u' - %@",
-	    num, [NSError _last]];
-	  ASSIGN(_lastError, str);
-	}
+        if (chown(lpath, -1, (uid_t)num) != 0)
+        {
+            allOk = NO;
+            str = [NSString stringWithFormat:
+                   @"Unable to change NSFileGroupOwnerAccountID to '%lu' - %@",
+                   (unsigned long)num, [NSError _last]];
+            ASSIGN(_lastError, str);
+        }
     }
-  else if ((str = [attributes fileGroupOwnerAccountName]) != nil
-    && NO == [str isEqual: [old fileGroupOwnerAccountName]])
+    else if ((str = [attributes fileGroupOwnerAccountName]) != nil
+             && NO == [str isEqual: [old fileGroupOwnerAccountName]])
     {
-      BOOL	ok = NO;
+        BOOL	ok = NO;
 #ifdef HAVE_GRP_H
 #ifdef HAVE_GETGRNAM_R
-      struct group gp;
-      struct group *p;
-      char buf[BUFSIZ*10];
-
-      if (getgrnam_r([str cStringUsingEncoding: defaultEncoding], &gp,
-        buf, sizeof(buf), &p) == 0)
+        struct group gp;
+        struct group *p;
+        char buf[BUFSIZ*10];
+        
+        if (getgrnam_r([str cStringUsingEncoding: defaultEncoding], &gp,
+                       buf, sizeof(buf), &p) == 0)
         {
-	  if (chown(lpath, -1, gp.gr_gid) == 0)
-	    ok = YES;
+            if (chown(lpath, -1, gp.gr_gid) == 0)
+                ok = YES;
         }
 #else
 #ifdef HAVE_GETGRNAM
-      struct group *gp;
-      
-      [gnustep_global_lock lock];
-      gp = getgrnam([str cStringUsingEncoding: defaultEncoding]);
-      if (gp)
-	{
-	  if (chown(lpath, -1, gp->gr_gid) == 0)
-	    ok = YES;
-	}
-      [gnustep_global_lock unlock];
+        struct group *gp;
+        
+        [gnustep_global_lock lock];
+        gp = getgrnam([str cStringUsingEncoding: defaultEncoding]);
+        if (gp)
+        {
+            if (chown(lpath, -1, gp->gr_gid) == 0)
+                ok = YES;
+        }
+        [gnustep_global_lock unlock];
 #endif
 #endif
 #endif
-      if (ok == NO)
-	{
-	  allOk = NO;
-	  str = [NSString stringWithFormat:
-	    @"Unable to change NSFileGroupOwnerAccountName to '%@' - %@",
-	    str, [NSError _last]];
-	  ASSIGN(_lastError, str);
-	}
+        if (ok == NO)
+        {
+            allOk = NO;
+            str = [NSString stringWithFormat:
+                   @"Unable to change NSFileGroupOwnerAccountName to '%@' - %@",
+                   str, [NSError _last]];
+            ASSIGN(_lastError, str);
+        }
     }
 #endif	/* __MINGW__ */
-
-  num = [attributes filePosixPermissions];
-  if (num != NSNotFound && num != [old filePosixPermissions])
+    
+    num = [attributes filePosixPermissions];
+    if (num != NSNotFound && num != [old filePosixPermissions])
     {
-      if (_CHMOD(lpath, num) != 0)
-	{
-	  allOk = NO;
-	  str = [NSString stringWithFormat:
-	    @"Unable to change NSFilePosixPermissions to '%o' - %@",
-	    num, [NSError _last]];
-	  ASSIGN(_lastError, str);
-	}
+        if (_CHMOD(lpath, num) != 0)
+        {
+            allOk = NO;
+            str = [NSString stringWithFormat:
+                   @"Unable to change NSFilePosixPermissions to '%lo' - %@",
+                   (unsigned long)num, [NSError _last]];
+            ASSIGN(_lastError, str);
+        }
     }
-
-  date = [attributes fileModificationDate];
-  if (date != nil && NO == [date isEqual: [old fileModificationDate]])
+    
+    date = [attributes fileModificationDate];
+    if (date != nil && NO == [date isEqual: [old fileModificationDate]])
     {
-      BOOL		ok = NO;
-      struct _STATB	sb;
-
+        BOOL		ok = NO;
+        struct _STATB	sb;
+        
 #if  defined(__WIN32__) || defined(_POSIX_VERSION)
-      struct _UTIMB ub;
+        struct _UTIMB ub;
 #else
-      time_t ub[2];
+        time_t ub[2];
 #endif
-
-      if (_STAT(lpath, &sb) != 0)
-	{
-	  ok = NO;
-	}
+        
+        if (_STAT(lpath, &sb) != 0)
+        {
+            ok = NO;
+        }
 #if  defined(__WIN32__)
-      else if (sb.st_mode & _S_IFDIR)
-	{
-	  ok = YES;	// Directories don't have modification times.
-	}
+        else if (sb.st_mode & _S_IFDIR)
+        {
+            ok = YES;	// Directories don't have modification times.
+        }
 #endif
-      else
-	{
+        else
+        {
 #if  defined(__WIN32__) || defined(_POSIX_VERSION)
-	  ub.actime = sb.st_atime;
-	  ub.modtime = [date timeIntervalSince1970];
-	  ok = (_UTIME(lpath, &ub) == 0);
+            ub.actime = sb.st_atime;
+            ub.modtime = [date timeIntervalSince1970];
+            ok = (_UTIME(lpath, &ub) == 0);
 #else
-	  ub[0] = sb.st_atime;
-	  ub[1] = [date timeIntervalSince1970];
-	  ok = (_UTIME(lpath, ub) == 0);
+            ub[0] = sb.st_atime;
+            ub[1] = [date timeIntervalSince1970];
+            ok = (_UTIME(lpath, ub) == 0);
 #endif
-	}
-      if (ok == NO)
-	{
-	  allOk = NO;
-	  str = [NSString stringWithFormat:
-	    @"Unable to change NSFileModificationDate to '%@' - %@",
-	    date, [NSError _last]];
-	  ASSIGN(_lastError, str);
-	}
+        }
+        if (ok == NO)
+        {
+            allOk = NO;
+            str = [NSString stringWithFormat:
+                   @"Unable to change NSFileModificationDate to '%@' - %@",
+                   date, [NSError _last]];
+            ASSIGN(_lastError, str);
+        }
     }
-
-  return allOk;
+    
+    return allOk;
 }
 
 /**
@@ -601,7 +601,7 @@ static NSStringEncoding	defaultEncoding;
  */
 - (NSArray*) componentsToDisplayForPath: (NSString*)path
 {
-  return [path pathComponents];
+    return [path pathComponents];
 }
 
 /**
@@ -611,7 +611,7 @@ static NSStringEncoding	defaultEncoding;
  */
 - (NSData*) contentsAtPath: (NSString*)path
 {
-  return [NSData dataWithContentsOfFile: path];
+    return [NSData dataWithContentsOfFile: path];
 }
 
 /**
@@ -625,91 +625,90 @@ static NSStringEncoding	defaultEncoding;
  */
 - (BOOL) contentsEqualAtPath: (NSString*)path1 andPath: (NSString*)path2
 {
-  NSDictionary	*d1;
-  NSDictionary	*d2;
-  NSString	*t;
-
-  if ([path1 isEqual: path2])
-    return YES;
-  d1 = [self fileAttributesAtPath: path1 traverseLink: NO];
-  d2 = [self fileAttributesAtPath: path2 traverseLink: NO];
-  t = [d1 fileType];
-  if ([t isEqual: [d2 fileType]] == NO)
+    NSDictionary	*d1;
+    NSDictionary	*d2;
+    NSString	*t;
+    
+    if ([path1 isEqual: path2])
+        return YES;
+    d1 = [self fileAttributesAtPath: path1 traverseLink: NO];
+    d2 = [self fileAttributesAtPath: path2 traverseLink: NO];
+    t = [d1 fileType];
+    if ([t isEqual: [d2 fileType]] == NO)
     {
-      return NO;
+        return NO;
     }
-  if ([t isEqual: NSFileTypeRegular])
+    if ([t isEqual: NSFileTypeRegular])
     {
-      if ([d1 fileSize] == [d2 fileSize])
-	{
-	  NSData	*c1 = [NSData dataWithContentsOfFile: path1];
-	  NSData	*c2 = [NSData dataWithContentsOfFile: path2];
-
-	  if ([c1 isEqual: c2])
-	    {
-	      return YES;
-	    }
-	}
-      return NO;
+        if ([d1 fileSize] == [d2 fileSize])
+        {
+            NSData	*c1 = [NSData dataWithContentsOfFile: path1];
+            NSData	*c2 = [NSData dataWithContentsOfFile: path2];
+            
+            if ([c1 isEqual: c2])
+            {
+                return YES;
+            }
+        }
+        return NO;
     }
-  else if ([t isEqual: NSFileTypeDirectory])
+    else if ([t isEqual: NSFileTypeDirectory])
     {
-      NSArray	*a1 = [self directoryContentsAtPath: path1];
-      NSArray	*a2 = [self directoryContentsAtPath: path2];
-      unsigned	index, count = [a1 count];
-      BOOL	ok = YES;
-
-      if ([a1 isEqual: a2] == NO)
-	{
-	  return NO;
-	}
-      for (index = 0; ok == YES && index < count; index++)
-	{
-	  NSString	*n = [a1 objectAtIndex: index];
-	  NSString	*p1;
-	  NSString	*p2;
-	  CREATE_AUTORELEASE_POOL(pool);
-
-	  p1 = [path1 stringByAppendingPathComponent: n];
-	  p2 = [path2 stringByAppendingPathComponent: n];
-	  d1 = [self fileAttributesAtPath: p1 traverseLink: NO];
-	  d2 = [self fileAttributesAtPath: p2 traverseLink: NO];
-	  t = [d1 fileType];
-	  if ([t isEqual: [d2 fileType]] == NO)
-	    {
-	      ok = NO;
-	    }
-	  else if ([t isEqual: NSFileTypeDirectory]
-            || [t isEqual: NSFileTypeRegular])
-	    {
-	      ok = [self contentsEqualAtPath: p1 andPath: p2];
-	    }
-	  RELEASE(pool);
-	}
-      return ok;
+        NSArray	*a1 = [self directoryContentsAtPath: path1];
+        NSArray	*a2 = [self directoryContentsAtPath: path2];
+        NSUInteger index, count = [a1 count];
+        BOOL ok = YES;
+        
+        if ([a1 isEqual: a2] == NO)
+        {
+            return NO;
+        }
+        for (index = 0; ok == YES && index < count; index++)
+        {
+            NSString	*n = [a1 objectAtIndex: index];
+            NSString	*p1;
+            NSString	*p2;
+            CREATE_AUTORELEASE_POOL(pool);
+            
+            p1 = [path1 stringByAppendingPathComponent: n];
+            p2 = [path2 stringByAppendingPathComponent: n];
+            d1 = [self fileAttributesAtPath: p1 traverseLink: NO];
+            d2 = [self fileAttributesAtPath: p2 traverseLink: NO];
+            t = [d1 fileType];
+            if ([t isEqual: [d2 fileType]] == NO)
+            {
+                ok = NO;
+            }
+            else if ([t isEqual: NSFileTypeDirectory] || [t isEqual: NSFileTypeRegular])
+            {
+                ok = [self contentsEqualAtPath: p1 andPath: p2];
+            }
+            RELEASE(pool);
+        }
+        return ok;
     }
-  else
+    else
     {
-      return YES;
+        return YES;
     }
 }
 
 - (NSArray*) contentsOfDirectoryAtPath: (NSString*)path error: (NSError**)error
 {
-  NSArray       *result;
-
-  DESTROY(_lastError);
-  result = [self directoryContentsAtPath: path];
-
-  if (error != NULL)
+    NSArray       *result;
+    
+    DESTROY(_lastError);
+    result = [self directoryContentsAtPath: path];
+    
+    if (error != NULL)
     {
-      if (nil == result)
-	{
-	  *error = [self _errorFrom: path to: nil];
-	}
+        if (nil == result)
+        {
+            *error = [self _errorFrom: path to: nil];
+        }
     }
-
-  return result; 
+    
+    return result; 
 }
 
 /**
@@ -721,55 +720,55 @@ static NSStringEncoding	defaultEncoding;
  */
 - (BOOL) createDirectoryAtPath: (NSString *)path
    withIntermediateDirectories: (BOOL)flag
-		    attributes: (NSDictionary *)attributes
-			 error: (NSError **) error
-{
-  BOOL result = NO;
-
-  DESTROY(_lastError);
-  if (YES == flag)
-    {
-      NSEnumerator      *paths = [[path pathComponents] objectEnumerator];
-      NSString          *path = nil;
-      NSString          *dir = [NSString string];
-
-      while ((path = (NSString *)[paths nextObject]) != nil)
-	{
-	  dir = [dir stringByAppendingPathComponent: path];
-	  // create directory only if it doesn't exist
-	  if (NO == [self fileExistsAtPath: dir])
-	    {
-	      result = [self createDirectoryAtPath: dir
-		     			attributes: attributes];
-	    }
-	}
+                    attributes: (NSDictionary *)attributes
+                         error: (NSError **) error
+{
+    BOOL result = NO;
+    
+    DESTROY(_lastError);
+    if (YES == flag)
+    {
+        NSEnumerator      *paths = [[path pathComponents] objectEnumerator];
+        NSString          *path = nil;
+        NSString          *dir = [NSString string];
+        
+        while ((path = (NSString *)[paths nextObject]) != nil)
+        {
+            dir = [dir stringByAppendingPathComponent: path];
+            // create directory only if it doesn't exist
+            if (NO == [self fileExistsAtPath: dir])
+            {
+                result = [self createDirectoryAtPath: dir
+                                          attributes: attributes];
+            }
+        }
     }
-  else
+    else
     {
-      BOOL isDir;
-
-      if ([self fileExistsAtPath: [path stringByDeletingLastPathComponent]
-	isDirectory: &isDir] && isDir)
+        BOOL isDir;
+        
+        if ([self fileExistsAtPath: [path stringByDeletingLastPathComponent]
+                       isDirectory: &isDir] && isDir)
         {
-          result = [self createDirectoryAtPath: path
-                                    attributes: attributes];
+            result = [self createDirectoryAtPath: path
+                                      attributes: attributes];
         }
-      else
+        else
         {
-          result = NO;  
-          ASSIGN(_lastError, @"Could not create directory - intermediate path did not exist or was not a directory");
+            result = NO;  
+            ASSIGN(_lastError, @"Could not create directory - intermediate path did not exist or was not a directory");
         }
     }  
-
-  if (error != NULL)
+    
+    if (error != NULL)
     {
-      if (NO == result)
-	{
-	  *error = [self _errorFrom: path to: nil];
-	}
+        if (NO == result)
+        {
+            *error = [self _errorFrom: path to: nil];
+        }
     }
-
-  return result;
+    
+    return result;
 }
 
 /**
@@ -797,81 +796,81 @@ static NSStringEncoding	defaultEncoding;
  * Returns YES if the directory was created (or already exists), NO otherwise.
  */
 - (BOOL) createDirectoryAtPath: (NSString*)path
-		    attributes: (NSDictionary*)attributes
+                    attributes: (NSDictionary*)attributes
 {
-  BOOL  isDir;
-
-  /* This is consistent with MacOSX - just return NO for an invalid path. */
-  if ([path length] == 0)
+    BOOL  isDir;
+    
+    /* This is consistent with MacOSX - just return NO for an invalid path. */
+    if ([path length] == 0)
     {
-      ASSIGN(_lastError, @"no path given");
-      return NO;
+        ASSIGN(_lastError, @"no path given");
+        return NO;
     }
-
-  if (YES == [self fileExistsAtPath: path isDirectory: &isDir])
+    
+    if (YES == [self fileExistsAtPath: path isDirectory: &isDir])
     {
-      if (NO == isDir)
+        if (NO == isDir)
         {
-          NSString  *e;
-
-          e = [NSString stringWithFormat:
-            @"path %@ exists, but is not a directory", path];
-          ASSIGN(_lastError, e);
-          return NO;
+            NSString  *e;
+            
+            e = [NSString stringWithFormat:
+                 @"path %@ exists, but is not a directory", path];
+            ASSIGN(_lastError, e);
+            return NO;
         }
     }
-  else
+    else
     {
 #if defined(__MINGW__)
-      const _CHAR   *lpath;
-          
-      lpath = [self fileSystemRepresentationWithPath: path];
-      isDir = (CreateDirectoryW(lpath, 0) != FALSE) ? YES : NO;
+        const _CHAR   *lpath;
+        
+        lpath = [self fileSystemRepresentationWithPath: path];
+        isDir = (CreateDirectoryW(lpath, 0) != FALSE) ? YES : NO;
 #else
-      const char    *lpath;
-
-      lpath = [self fileSystemRepresentationWithPath: path];
-      isDir = (mkdir(lpath, 0777) == 0) ? YES : NO;
-      if (YES == isDir)
-        {
-          /*
-           * If there is no file owner specified, and we are running
-           * setuid to root, then we assume we need to change ownership
-           * to the correct user.
-           */
-          if (attributes == nil || ([attributes fileOwnerAccountID] == nil
-            && [attributes fileOwnerAccountName] == nil))
+        const char    *lpath;
+        
+        lpath = [self fileSystemRepresentationWithPath: path];
+        isDir = (mkdir(lpath, 0777) == 0) ? YES : NO;
+        if (YES == isDir)
+        {
+            /*
+             * If there is no file owner specified, and we are running
+             * setuid to root, then we assume we need to change ownership
+             * to the correct user.
+             */
+            if (attributes == nil || ([attributes fileOwnerAccountID] == nil
+                                      && [attributes fileOwnerAccountName] == nil))
             {
-              if (geteuid() == 0
-                && [@"root" isEqualToString: NSUserName()] == NO)
+                if (geteuid() == 0
+                    && [@"root" isEqualToString: NSUserName()] == NO)
                 {
-                  NSMutableDictionary       *m;
-
-                  m = [[attributes mutableCopy] autorelease];
-                  if (nil == m)
+                    NSMutableDictionary       *m;
+                    
+                    m = [[attributes mutableCopy] autorelease];
+                    if (nil == m)
                     {
-                      m = [NSMutableDictionary dictionaryWithCapacity: 1];
+                        m = [NSMutableDictionary dictionaryWithCapacity: 1];
                     }
-                  [m setObject: NSUserName()
-                        forKey: NSFileOwnerAccountName];
-                  attributes = m;
+                    [m setObject: NSUserName()
+                          forKey: NSFileOwnerAccountName];
+                    attributes = m;
                 }
             }
         }
 #endif
-      if (NO == isDir)
+        if (NO == isDir)
         {
-          NSString	*e;
-
-          e = [NSString stringWithFormat:
-            @"Could not create '%@' - '%@'",
-            path, [NSError _last]];
-          ASSIGN(_lastError, e);
-          return NO;
+            NSString	*e;
+            
+            e = [NSString stringWithFormat:
+                 @"Could not create '%@' - '%@'",
+                 path, [NSError _last]];
+            ASSIGN(_lastError, e);
+            return NO;
         }
     }
-
-  return [self changeFileAttributes: attributes atPath: path];
+    
+    return [self changeFileAttributes: attributes atPath: path];
 }
 
 /**
@@ -880,94 +879,94 @@ static NSStringEncoding	defaultEncoding;
  * Returns YES on success, NO on failure.
  */
 - (BOOL) createFileAtPath: (NSString*)path
-		 contents: (NSData*)contents
-	       attributes: (NSDictionary*)attributes
+                 contents: (NSData*)contents
+               attributes: (NSDictionary*)attributes
 {
 #if	defined(__MINGW__)
-  const _CHAR *lpath = [self fileSystemRepresentationWithPath: path];
-  HANDLE fh;
-  DWORD	written = 0;
-  DWORD	len = [contents length];
+    const _CHAR *lpath = [self fileSystemRepresentationWithPath: path];
+    HANDLE fh;
+    DWORD	written = 0;
+    DWORD	len = [contents length];
 #else
-  const char	*lpath;
-  int	fd;
-  int	len;
-  int	written;
+    const char	*lpath;
+    int	fd;
+    NSUInteger len;
+    NSUInteger written;
 #endif
-
-  /* This is consistent with MacOSX - just return NO for an invalid path. */
-  if ([path length] == 0)
+    
+    /* This is consistent with MacOSX - just return NO for an invalid path. */
+    if ([path length] == 0)
     {
-      ASSIGN(_lastError, @"no path given");
-      return NO;
+        ASSIGN(_lastError, @"no path given");
+        return NO;
     }
-
+    
 #if	defined(__MINGW__)
-  fh = CreateFileW(lpath, GENERIC_WRITE, 0, 0, CREATE_ALWAYS,
-    FILE_ATTRIBUTE_NORMAL, 0);
-  if (fh == INVALID_HANDLE_VALUE)
+    fh = CreateFileW(lpath, GENERIC_WRITE, 0, 0, CREATE_ALWAYS,
+                     FILE_ATTRIBUTE_NORMAL, 0);
+    if (fh == INVALID_HANDLE_VALUE)
     {
-      return NO;
+        return NO;
     }
-  else
+    else
     {
-      if (len > 0)
-	{
-	  WriteFile(fh, [contents bytes], len, &written, 0);
-	}
-      CloseHandle(fh);
-      if (attributes != nil
-	&& [self changeFileAttributes: attributes atPath: path] == NO)
-	{
-	  return NO;
-	}
-      return YES;
+        if (len > 0)
+        {
+            WriteFile(fh, [contents bytes], len, &written, 0);
+        }
+        CloseHandle(fh);
+        if (attributes != nil
+            && [self changeFileAttributes: attributes atPath: path] == NO)
+        {
+            return NO;
+        }
+        return YES;
     }
 #else
-  lpath = [self fileSystemRepresentationWithPath: path];
-
-  fd = open(lpath, GSBINIO|O_WRONLY|O_TRUNC|O_CREAT, 0644);
-  if (fd < 0)
+    lpath = [self fileSystemRepresentationWithPath: path];
+    
+    fd = open(lpath, GSBINIO|O_WRONLY|O_TRUNC|O_CREAT, 0644);
+    if (fd < 0)
     {
-      return NO;
+        return NO;
     }
-  if (attributes != nil
-    && [self changeFileAttributes: attributes atPath: path] == NO)
+    if (attributes != nil
+        && [self changeFileAttributes: attributes atPath: path] == NO)
     {
-      close (fd);
-      return NO;
+        close (fd);
+        return NO;
     }
-
-  /*
-   * If there is no file owner specified, and we are running setuid to
-   * root, then we assume we need to change ownership to correct user.
-   */
-  if (attributes == nil || ([attributes fileOwnerAccountID] == nil
-    && [attributes fileOwnerAccountName] == nil))
+    
+    /*
+     * If there is no file owner specified, and we are running setuid to
+     * root, then we assume we need to change ownership to correct user.
+     */
+    if (attributes == nil || ([attributes fileOwnerAccountID] == nil
+                              && [attributes fileOwnerAccountName] == nil))
     {
-      if (geteuid() == 0 && [@"root" isEqualToString: NSUserName()] == NO)
-	{
-	  attributes = [NSDictionary dictionaryWithObjectsAndKeys:
-	    NSFileOwnerAccountName, NSUserName(), nil];
-	  if (![self changeFileAttributes: attributes atPath: path])
-	    {
-	      NSLog(@"Failed to change ownership of '%@' to '%@'",
-		path, NSUserName());
-	    }
-	}
+        if (geteuid() == 0 && [@"root" isEqualToString: NSUserName()] == NO)
+        {
+            attributes = [NSDictionary dictionaryWithObjectsAndKeys:
+                          NSFileOwnerAccountName, NSUserName(), nil];
+            if (![self changeFileAttributes: attributes atPath: path])
+            {
+                NSLog(@"Failed to change ownership of '%@' to '%@'",
+                      path, NSUserName());
+            }
+        }
     }
-  len = [contents length];
-  if (len > 0)
+    len = [contents length];
+    if (len > 0)
     {
-      written = write(fd, [contents bytes], len);
+        written = write(fd, [contents bytes], len);
     }
-  else
+    else
     {
-      written = 0;
+        written = 0;
     }
-  close (fd);
+    close (fd);
 #endif
-  return written == len;
+    return written == len;
 }
 
 /**
@@ -976,42 +975,42 @@ static NSStringEncoding	defaultEncoding;
  */
 - (NSString*) currentDirectoryPath
 {
-  NSString *currentDir = nil;
-
+    NSString *currentDir = nil;
+    
 #if defined(__MINGW__)
-  int len = GetCurrentDirectoryW(0, 0);
-  if (len > 0)
+    int len = GetCurrentDirectoryW(0, 0);
+    if (len > 0)
     {
-      _CHAR *lpath = (_CHAR*)calloc(len+10,sizeof(_CHAR));
-
-      if (lpath != 0)
-	{
-	  if (GetCurrentDirectoryW(len, lpath)>0)
-	    {
-	      NSString	*path;
-
-	      // Windows may count the trailing nul ... we don't want to.
-	      if (len > 0 && lpath[len] == 0) len--;
-	      path = [NSString stringWithCharacters: lpath length: len];
-	      currentDir = path;
-	    }
-	  free(lpath);
-	}
+        _CHAR *lpath = (_CHAR*)calloc(len+10,sizeof(_CHAR));
+        
+        if (lpath != 0)
+        {
+            if (GetCurrentDirectoryW(len, lpath)>0)
+            {
+                NSString	*path;
+                
+                // Windows may count the trailing nul ... we don't want to.
+                if (len > 0 && lpath[len] == 0) len--;
+                path = [NSString stringWithCharacters: lpath length: len];
+                currentDir = path;
+            }
+            free(lpath);
+        }
     }
 #else
-  char path[PATH_MAX];
+    char path[PATH_MAX];
 #ifdef HAVE_GETCWD
-  if (getcwd(path, PATH_MAX-1) == 0)
-    return nil;
+    if (getcwd(path, PATH_MAX-1) == 0)
+        return nil;
 #else
-  if (getwd(path) == 0)
-    return nil;
+    if (getwd(path) == 0)
+        return nil;
 #endif /* HAVE_GETCWD */
-  currentDir = [self stringWithFileSystemRepresentation: path
-						 length: strlen(path)];
+    currentDir = [self stringWithFileSystemRepresentation: path
+                                                   length: strlen(path)];
 #endif /* !MINGW */
-
-  return currentDir;
+    
+    return currentDir;
 }
 
 /**
@@ -1023,116 +1022,116 @@ static NSStringEncoding	defaultEncoding;
  * Will not copy to a destination which already exists.
  */
 - (BOOL) copyPath: (NSString*)source
-	   toPath: (NSString*)destination
-	  handler: (id)handler
+           toPath: (NSString*)destination
+          handler: (id)handler
 {
-  NSDictionary	*attrs;
-  NSString	*fileType;
-
-  if ([self fileExistsAtPath: destination] == YES)
+    NSDictionary	*attrs;
+    NSString	*fileType;
+    
+    if ([self fileExistsAtPath: destination] == YES)
     {
-      return NO;
+        return NO;
     }
-  attrs = [self fileAttributesAtPath: source traverseLink: NO];
-  if (attrs == nil)
+    attrs = [self fileAttributesAtPath: source traverseLink: NO];
+    if (attrs == nil)
     {
-      return NO;
+        return NO;
     }
-  fileType = [attrs fileType];
-  if ([fileType isEqualToString: NSFileTypeDirectory] == YES)
+    fileType = [attrs fileType];
+    if ([fileType isEqualToString: NSFileTypeDirectory] == YES)
     {
-      NSMutableDictionary	*mattrs;
-
-      /* If destination directory is a descendant of source directory copying
-	  isn't possible. */
-      if ([[destination stringByAppendingString: @"/"]
-	hasPrefix: [source stringByAppendingString: @"/"]])
-	{
-	  ASSIGN(_lastError, @"Could not copy - destination is a descendant of source");
-	  return NO;
-	}
-
-      [self _sendToHandler: handler willProcessPath: destination];
-
-      /*
-       * Don't attempt to retain ownership of copy ... we want the copy
-       * to be owned by the current user.
-       */
-      mattrs = [attrs mutableCopy];
-      [mattrs removeObjectForKey: NSFileOwnerAccountID];
-      [mattrs removeObjectForKey: NSFileGroupOwnerAccountID];
-      [mattrs removeObjectForKey: NSFileGroupOwnerAccountName];
-      [mattrs setObject: NSUserName() forKey: NSFileOwnerAccountName];
-      attrs = AUTORELEASE(mattrs);
-
-      if ([self createDirectoryAtPath: destination attributes: attrs] == NO)
-	{
-          return [self _proceedAccordingToHandler: handler
-					 forError: _lastError
-					   inPath: destination
-					 fromPath: source
-					   toPath: destination];
-	}
-
-      if ([self _copyPath: source toPath: destination handler: handler] == NO)
-	{
-	  return NO;
-	}
+        NSMutableDictionary	*mattrs;
+        
+        /* If destination directory is a descendant of source directory copying
+         isn't possible. */
+        if ([[destination stringByAppendingString: @"/"]
+             hasPrefix: [source stringByAppendingString: @"/"]])
+        {
+            ASSIGN(_lastError, @"Could not copy - destination is a descendant of source");
+            return NO;
+        }
+        
+        [self _sendToHandler: handler willProcessPath: destination];
+        
+        /*
+         * Don't attempt to retain ownership of copy ... we want the copy
+         * to be owned by the current user.
+         */
+        mattrs = [attrs mutableCopy];
+        [mattrs removeObjectForKey: NSFileOwnerAccountID];
+        [mattrs removeObjectForKey: NSFileGroupOwnerAccountID];
+        [mattrs removeObjectForKey: NSFileGroupOwnerAccountName];
+        [mattrs setObject: NSUserName() forKey: NSFileOwnerAccountName];
+        attrs = AUTORELEASE(mattrs);
+        
+        if ([self createDirectoryAtPath: destination attributes: attrs] == NO)
+        {
+            return [self _proceedAccordingToHandler: handler
+                                           forError: _lastError
+                                             inPath: destination
+                                           fromPath: source
+                                             toPath: destination];
+        }
+        
+        if ([self _copyPath: source toPath: destination handler: handler] == NO)
+        {
+            return NO;
+        }
     }
-  else if ([fileType isEqualToString: NSFileTypeSymbolicLink] == YES)
+    else if ([fileType isEqualToString: NSFileTypeSymbolicLink] == YES)
     {
-      NSString	*path;
-      BOOL	result;
-
-      [self _sendToHandler: handler willProcessPath: source];
-
-      path = [self pathContentOfSymbolicLinkAtPath: source];
-      result = [self createSymbolicLinkAtPath: destination pathContent: path];
-      if (result == NO)
-	{
-          result = [self _proceedAccordingToHandler: handler
-					   forError: @"cannot link to file"
-					     inPath: source
-					   fromPath: source
-					     toPath: destination];
-
-	  if (result == NO)
-	    {
-	      return NO;
-	    }
-	}
+        NSString	*path;
+        BOOL	result;
+        
+        [self _sendToHandler: handler willProcessPath: source];
+        
+        path = [self pathContentOfSymbolicLinkAtPath: source];
+        result = [self createSymbolicLinkAtPath: destination pathContent: path];
+        if (result == NO)
+        {
+            result = [self _proceedAccordingToHandler: handler
+                                             forError: @"cannot link to file"
+                                               inPath: source
+                                             fromPath: source
+                                               toPath: destination];
+            
+            if (result == NO)
+            {
+                return NO;
+            }
+        }
     }
-  else
+    else
     {
-      [self _sendToHandler: handler willProcessPath: source];
-
-      if ([self _copyFile: source toFile: destination handler: handler] == NO)
-	{
-	  return NO;
-	}
+        [self _sendToHandler: handler willProcessPath: source];
+        
+        if ([self _copyFile: source toFile: destination handler: handler] == NO)
+        {
+            return NO;
+        }
     }
-  [self changeFileAttributes: attrs atPath: destination];
-  return YES;
+    [self changeFileAttributes: attrs atPath: destination];
+    return YES;
 }
 
 - (BOOL) copyItemAtPath: (NSString*)src
-		 toPath: (NSString*)dst
-		  error: (NSError**)error
+                 toPath: (NSString*)dst
+                  error: (NSError**)error
 {
-  BOOL  result;
-
-  DESTROY(_lastError);
-  result = [self copyPath: src toPath: dst handler: nil];
-
-  if (error != NULL)
+    BOOL  result;
+    
+    DESTROY(_lastError);
+    result = [self copyPath: src toPath: dst handler: nil];
+    
+    if (error != NULL)
     {
-      if (NO == result)
-	{
-	  *error = [self _errorFrom: src to: dst];
-	}
+        if (NO == result)
+        {
+            *error = [self _errorFrom: src to: dst];
+        }
     }
-
-  return result;
+    
+    return result;
 }
 
 - (BOOL) copyItemAtURL: (NSURL*)src
@@ -1151,102 +1150,102 @@ static NSStringEncoding	defaultEncoding;
  * Will not move to a destination which already exists.<br />
  */
 - (BOOL) movePath: (NSString*)source
-	   toPath: (NSString*)destination
-	  handler: (id)handler
-{
-  BOOL		sourceIsDir;
-  BOOL		fileExists;
-  NSString	*destinationParent;
-  unsigned int	sourceDevice;
-  unsigned int	destinationDevice;
-  const _CHAR	*sourcePath;
-  const _CHAR	*destPath;
-
-  sourcePath = [self fileSystemRepresentationWithPath: source];
-  destPath = [self fileSystemRepresentationWithPath: destination];
-
-  if ([self fileExistsAtPath: destination] == YES)
-    {
-      return NO;
-    }
-  fileExists = [self fileExistsAtPath: source isDirectory: &sourceIsDir];
-  if (!fileExists)
-    {
-      return NO;
-    }
-
-  /* Check to see if the source and destination's parent are on the same
+           toPath: (NSString*)destination
+          handler: (id)handler
+{
+    BOOL		sourceIsDir;
+    BOOL		fileExists;
+    NSString	*destinationParent;
+    NSUInteger sourceDevice;
+    NSUInteger destinationDevice;
+    const _CHAR	*sourcePath;
+    const _CHAR	*destPath;
+    
+    sourcePath = [self fileSystemRepresentationWithPath: source];
+    destPath = [self fileSystemRepresentationWithPath: destination];
+    
+    if ([self fileExistsAtPath: destination] == YES)
+    {
+        return NO;
+    }
+    fileExists = [self fileExistsAtPath: source isDirectory: &sourceIsDir];
+    if (!fileExists)
+    {
+        return NO;
+    }
+    
+    /* Check to see if the source and destination's parent are on the same
      physical device so we can perform a rename syscall directly. */
-  sourceDevice = [[self fileSystemAttributesAtPath: source] fileSystemNumber];
-  destinationParent = [destination stringByDeletingLastPathComponent];
-  if ([destinationParent isEqual: @""])
-    destinationParent = @".";
-  destinationDevice
+    sourceDevice = [[self fileSystemAttributesAtPath: source] fileSystemNumber];
+    destinationParent = [destination stringByDeletingLastPathComponent];
+    if ([destinationParent isEqual: @""])
+        destinationParent = @".";
+    destinationDevice
     = [[self fileSystemAttributesAtPath: destinationParent] fileSystemNumber];
-
-  if (sourceDevice != destinationDevice)
+    
+    if (sourceDevice != destinationDevice)
     {
-      /* If destination directory is a descendant of source directory moving
-	  isn't possible. */
-      if (sourceIsDir && [[destination stringByAppendingString: @"/"]
-	hasPrefix: [source stringByAppendingString: @"/"]])
-	{
-	  ASSIGN(_lastError, @"Could not move - destination is a descendant of source");
-	  return NO;
-	}
-
-      if ([self copyPath: source toPath: destination handler: handler])
-	{
-	  NSDictionary	*attributes;
-
-	  attributes = [self fileAttributesAtPath: source
-				     traverseLink: NO];
-	  [self changeFileAttributes: attributes atPath: destination];
-	  return [self removeFileAtPath: source handler: handler];
-	}
-      else
-	{
-	  return NO;
-	}
+        /* If destination directory is a descendant of source directory moving
+         isn't possible. */
+        if (sourceIsDir && [[destination stringByAppendingString: @"/"]
+                            hasPrefix: [source stringByAppendingString: @"/"]])
+        {
+            ASSIGN(_lastError, @"Could not move - destination is a descendant of source");
+            return NO;
+        }
+        
+        if ([self copyPath: source toPath: destination handler: handler])
+        {
+            NSDictionary	*attributes;
+            
+            attributes = [self fileAttributesAtPath: source
+                                       traverseLink: NO];
+            [self changeFileAttributes: attributes atPath: destination];
+            return [self removeFileAtPath: source handler: handler];
+        }
+        else
+        {
+            return NO;
+        }
     }
-  else
+    else
     {
-      /* source and destination are on the same device so we can simply
-	 invoke rename on source. */
-      [self _sendToHandler: handler willProcessPath: source];
-
-      if (_RENAME (sourcePath, destPath) == -1)
-	{
-          return [self _proceedAccordingToHandler: handler
-					 forError: @"cannot move file"
-					   inPath: source
-					 fromPath: source
-					   toPath: destination];
-	}
-      return YES;
+        /* source and destination are on the same device so we can simply
+         invoke rename on source. */
+        [self _sendToHandler: handler willProcessPath: source];
+        
+        if (_RENAME (sourcePath, destPath) == -1)
+        {
+            return [self _proceedAccordingToHandler: handler
+                                           forError: @"cannot move file"
+                                             inPath: source
+                                           fromPath: source
+                                             toPath: destination];
+        }
+        return YES;
     }
-
-  return NO;
+    
+    return NO;
 }
 
 - (BOOL) moveItemAtPath: (NSString*)src
-		 toPath: (NSString*)dst
-		  error: (NSError**)error
+                 toPath: (NSString*)dst
+                  error: (NSError**)error
 {
-  BOOL  result;
-
-  DESTROY(_lastError);
-  result = [self movePath: src toPath: dst handler: nil];
-  
-  if (error != NULL)
+    BOOL  result;
+    
+    DESTROY(_lastError);
+    result = [self movePath: src toPath: dst handler: nil];
+    
+    if (error != NULL)
     {
-      if (NO == result)
-	{
-	  *error = [self _errorFrom: src to: dst];
-	}
+        if (NO == result)
+        {
+            *error = [self _errorFrom: src to: dst];
+        }
     }
-
-  return result;
+    
+    return result;
 }
 
 - (BOOL) moveItemAtURL: (NSURL*)src
@@ -1275,220 +1274,220 @@ static NSStringEncoding	defaultEncoding;
  * </p>
  */
 - (BOOL) linkPath: (NSString*)source
-	   toPath: (NSString*)destination
-	  handler: (id)handler
+           toPath: (NSString*)destination
+          handler: (id)handler
 {
 #ifdef HAVE_LINK
-  NSDictionary	*attrs;
-  NSString	*fileType;
-  BOOL		isDir;
-
-  if ([self fileExistsAtPath: destination isDirectory: &isDir] == YES
-    && isDir == YES)
-    {
-      destination = [destination stringByAppendingPathComponent:
-	[source lastPathComponent]];
-    }
-
-  attrs = [self fileAttributesAtPath: source traverseLink: NO];
-  if (attrs == nil)
-    {
-      return NO;
-    }
-
-  [self _sendToHandler: handler willProcessPath: destination];
-
-  fileType = [attrs fileType];
-  if ([fileType isEqualToString: NSFileTypeDirectory] == YES)
-    {
-      /* If destination directory is a descendant of source directory linking
-	  isn't possible because of recursion. */
-      if ([[destination stringByAppendingString: @"/"]
-	hasPrefix: [source stringByAppendingString: @"/"]])
-	{
-	  ASSIGN(_lastError, @"Could not link - destination is a descendant of source");
-	  return NO;
-	}
-
-      if ([self createDirectoryAtPath: destination attributes: attrs] == NO)
-	{
-          return [self _proceedAccordingToHandler: handler
-					 forError: _lastError
-					   inPath: destination
-					 fromPath: source
-					   toPath: destination];
-	}
-
-      if ([self _linkPath: source toPath: destination handler: handler] == NO)
-	{
-	  return NO;
-	}
+    NSDictionary	*attrs;
+    NSString	*fileType;
+    BOOL		isDir;
+    
+    if ([self fileExistsAtPath: destination isDirectory: &isDir] == YES
+        && isDir == YES)
+    {
+        destination = [destination stringByAppendingPathComponent:
+                       [source lastPathComponent]];
+    }
+    
+    attrs = [self fileAttributesAtPath: source traverseLink: NO];
+    if (attrs == nil)
+    {
+        return NO;
+    }
+    
+    [self _sendToHandler: handler willProcessPath: destination];
+    
+    fileType = [attrs fileType];
+    if ([fileType isEqualToString: NSFileTypeDirectory] == YES)
+    {
+        /* If destination directory is a descendant of source directory linking
+         isn't possible because of recursion. */
+        if ([[destination stringByAppendingString: @"/"]
+             hasPrefix: [source stringByAppendingString: @"/"]])
+        {
+            ASSIGN(_lastError, @"Could not link - destination is a descendant of source");
+            return NO;
+        }
+        
+        if ([self createDirectoryAtPath: destination attributes: attrs] == NO)
+        {
+            return [self _proceedAccordingToHandler: handler
+                                           forError: _lastError
+                                             inPath: destination
+                                           fromPath: source
+                                             toPath: destination];
+        }
+        
+        if ([self _linkPath: source toPath: destination handler: handler] == NO)
+        {
+            return NO;
+        }
     }
-  else if ([fileType isEqual: NSFileTypeSymbolicLink])
+    else if ([fileType isEqual: NSFileTypeSymbolicLink])
     {
-      NSString	*path;
-
-      path = [self pathContentOfSymbolicLinkAtPath: source];
-      if ([self createSymbolicLinkAtPath: destination
-			     pathContent: path] == NO)
-	{
-	  if ([self _proceedAccordingToHandler: handler
-				      forError: @"cannot create symbolic link"
-					inPath: source
-				      fromPath: source
-					toPath: destination] == NO)
-	    {
-	      return NO;
-	    }
-	}
+        NSString	*path;
+        
+        path = [self pathContentOfSymbolicLinkAtPath: source];
+        if ([self createSymbolicLinkAtPath: destination
+                               pathContent: path] == NO)
+        {
+            if ([self _proceedAccordingToHandler: handler
+                                        forError: @"cannot create symbolic link"
+                                          inPath: source
+                                        fromPath: source
+                                          toPath: destination] == NO)
+            {
+                return NO;
+            }
+        }
     }
-  else
+    else
     {
-      if (link([self fileSystemRepresentationWithPath: source],
-	[self fileSystemRepresentationWithPath: destination]) < 0)
-	{
-	  if ([self _proceedAccordingToHandler: handler
-				      forError: @"cannot create hard link"
-					inPath: source
-				      fromPath: source
-					toPath: destination] == NO)
-	    {
-	      return NO;
-	    }
-	}
+        if (link([self fileSystemRepresentationWithPath: source],
+                 [self fileSystemRepresentationWithPath: destination]) < 0)
+        {
+            if ([self _proceedAccordingToHandler: handler
+                                        forError: @"cannot create hard link"
+                                          inPath: source
+                                        fromPath: source
+                                          toPath: destination] == NO)
+            {
+                return NO;
+            }
+        }
     }
-  [self changeFileAttributes: attrs atPath: destination];
-  return YES;
+    [self changeFileAttributes: attrs atPath: destination];
+    return YES;
 #else
-  ASSIGN(_lastError, @"Links not supported on this platform");
-  return NO;
+    ASSIGN(_lastError, @"Links not supported on this platform");
+    return NO;
 #endif
 }
 
 - (BOOL) removeFileAtPath: (NSString*)path
-		  handler: handler
+                  handler: handler
 {
-  BOOL		is_dir;
-  const _CHAR	*lpath;
-
-  if ([path isEqualToString: @"."] || [path isEqualToString: @".."])
+    BOOL		is_dir;
+    const _CHAR	*lpath;
+    
+    if ([path isEqualToString: @"."] || [path isEqualToString: @".."])
     {
-      [NSException raise: NSInvalidArgumentException
-		  format: @"Attempt to remove illegal path"];
+        [NSException raise: NSInvalidArgumentException
+                    format: @"Attempt to remove illegal path"];
     }
-
-  [self _sendToHandler: handler willProcessPath: path];
-
-  lpath = [self fileSystemRepresentationWithPath: path];
-  if (lpath == 0 || *lpath == 0)
+    
+    [self _sendToHandler: handler willProcessPath: path];
+    
+    lpath = [self fileSystemRepresentationWithPath: path];
+    if (lpath == 0 || *lpath == 0)
     {
-      ASSIGN(_lastError, @"Could not remove - no path");
-      return NO;
+        ASSIGN(_lastError, @"Could not remove - no path");
+        return NO;
     }
-  else
+    else
     {
 #if defined(__MINGW__)
-      DWORD res;
-
-      res = GetFileAttributesW(lpath);
-
-      if (res == WIN32ERR)
-	{
-	  return NO;
-	}
-      if (res & FILE_ATTRIBUTE_DIRECTORY)
-	{
-	  is_dir = YES;
-	}
-      else
-	{
-	  is_dir = NO;
-	}
+        DWORD res;
+        
+        res = GetFileAttributesW(lpath);
+        
+        if (res == WIN32ERR)
+        {
+            return NO;
+        }
+        if (res & FILE_ATTRIBUTE_DIRECTORY)
+        {
+            is_dir = YES;
+        }
+        else
+        {
+            is_dir = NO;
+        }
 #else
-      struct _STATB statbuf;
-
-      if (lstat(lpath, &statbuf) != 0)
-	{
-	  return NO;
-	}
-      is_dir = ((statbuf.st_mode & S_IFMT) == S_IFDIR);
+        struct _STATB statbuf;
+        
+        if (lstat(lpath, &statbuf) != 0)
+        {
+            return NO;
+        }
+        is_dir = ((statbuf.st_mode & S_IFMT) == S_IFDIR);
 #endif /* MINGW */
     }
-
-  if (!is_dir)
+    
+    if (!is_dir)
     {
 #if defined(__MINGW__)
-      if (DeleteFileW(lpath) == FALSE)
+        if (DeleteFileW(lpath) == FALSE)
 #else
-      if (unlink(lpath) < 0)
+            if (unlink(lpath) < 0)
 #endif
-	{
-	  NSString	*message = [[NSError _last] localizedDescription];
-
-	  return [self _proceedAccordingToHandler: handler
-					 forError: message
-					   inPath: path];
-	}
-      else
-	{
-	  return YES;
-	}
+            {
+                NSString	*message = [[NSError _last] localizedDescription];
+                
+                return [self _proceedAccordingToHandler: handler
+                                               forError: message
+                                                 inPath: path];
+            }
+            else
+            {
+                return YES;
+            }
     }
-  else
+    else
     {
-      NSArray   *contents = [self directoryContentsAtPath: path];
-      unsigned	count = [contents count];
-      unsigned	i;
-
-      for (i = 0; i < count; i++)
-	{
-	  NSString		*item;
-	  NSString		*next;
-	  BOOL			result;
-	  CREATE_AUTORELEASE_POOL(pool);
-
-	  item = [contents objectAtIndex: i];
-	  next = [path stringByAppendingPathComponent: item];
-	  result = [self removeFileAtPath: next handler: handler];
-	  RELEASE(pool);
-	  if (result == NO)
-	    {
-	      return NO;
-	    }
-	}
-
-      if (_RMDIR([self fileSystemRepresentationWithPath: path]) < 0)
-	{
-	  NSString	*message = [[NSError _last] localizedDescription];
-
-	  return [self _proceedAccordingToHandler: handler
-					 forError: message
-					   inPath: path];
-	}
-      else
-	{
-	  return YES;
-	}
+        NSArray     *contents = [self directoryContentsAtPath: path];
+        NSUInteger  count = [contents count];
+        NSUInteger  i;
+        
+        for (i = 0; i < count; i++)
+        {
+            NSString		*item;
+            NSString		*next;
+            BOOL			result;
+            CREATE_AUTORELEASE_POOL(pool);
+            
+            item = [contents objectAtIndex: i];
+            next = [path stringByAppendingPathComponent: item];
+            result = [self removeFileAtPath: next handler: handler];
+            RELEASE(pool);
+            if (result == NO)
+            {
+                return NO;
+            }
+        }
+        
+        if (_RMDIR([self fileSystemRepresentationWithPath: path]) < 0)
+        {
+            NSString	*message = [[NSError _last] localizedDescription];
+            
+            return [self _proceedAccordingToHandler: handler
+                                           forError: message
+                                             inPath: path];
+        }
+        else
+        {
+            return YES;
+        }
     }
 }
 
 - (BOOL) removeItemAtPath: (NSString*)path
-		    error: (NSError**)error
+                    error: (NSError**)error
 {
-  BOOL  result;
-
-  DESTROY(_lastError);
-  result = [self removeFileAtPath: path handler: nil];
-
-  if (error != NULL)
+    BOOL  result;
+    
+    DESTROY(_lastError);
+    result = [self removeFileAtPath: path handler: nil];
+    
+    if (error != NULL)
     {
-      if (NO == result)
-	{
-	  *error = [self _errorFrom: path to: nil];
-	}
+        if (NO == result)
+        {
+            *error = [self _errorFrom: path to: nil];
+        }
     }
-
-  return result;
+    
+    return result;
 }
 
 - (BOOL) removeItemAtURL: (NSURL*)url
@@ -1499,61 +1498,61 @@ static NSStringEncoding	defaultEncoding;
 
 - (BOOL) fileExistsAtPath: (NSString*)path
 {
-  return [self fileExistsAtPath: path isDirectory: 0];
+    return [self fileExistsAtPath: path isDirectory: 0];
 }
 
 - (BOOL) fileExistsAtPath: (NSString*)path isDirectory: (BOOL*)isDirectory
 {
-  const _CHAR *lpath = [self fileSystemRepresentationWithPath: path];
-
-  if (isDirectory != 0)
+    const _CHAR *lpath = [self fileSystemRepresentationWithPath: path];
+    
+    if (isDirectory != 0)
     {
-      *isDirectory = NO;
+        *isDirectory = NO;
     }
-
-  if (lpath == 0 || *lpath == _NUL)
+    
+    if (lpath == 0 || *lpath == _NUL)
     {
-      ASSIGN(_lastError, @"no path given");
-      return NO;
+        ASSIGN(_lastError, @"no path given");
+        return NO;
     }
-
+    
 #if defined(__MINGW__)
     {
-      DWORD res;
-
-      res = GetFileAttributesW(lpath);
-
-      if (res == WIN32ERR)
-	{
-	  return NO;
-	}
-      if (isDirectory != 0)
-	{
-	  if (res & FILE_ATTRIBUTE_DIRECTORY)
-	    {
-	      *isDirectory = YES;
-	    }
-	}
-      return YES;
+        DWORD res;
+        
+        res = GetFileAttributesW(lpath);
+        
+        if (res == WIN32ERR)
+        {
+            return NO;
+        }
+        if (isDirectory != 0)
+        {
+            if (res & FILE_ATTRIBUTE_DIRECTORY)
+            {
+                *isDirectory = YES;
+            }
+        }
+        return YES;
     }
 #else
     {
-      struct _STATB statbuf;
-
-      if (_STAT(lpath, &statbuf) != 0)
-	{
-	  return NO;
-	}
-
-      if (isDirectory)
-	{
-	  if ((statbuf.st_mode & S_IFMT) == S_IFDIR)
-	    {
-	      *isDirectory = YES;
-	    }
-	}
-
-      return YES;
+        struct _STATB statbuf;
+        
+        if (_STAT(lpath, &statbuf) != 0)
+        {
+            return NO;
+        }
+        
+        if (isDirectory)
+        {
+            if ((statbuf.st_mode & S_IFMT) == S_IFDIR)
+            {
+                *isDirectory = YES;
+            }
+        }
+        
+        return YES;
     }
 #endif /* MINGW */
 }
@@ -1564,33 +1563,33 @@ static NSStringEncoding	defaultEncoding;
  */
 - (BOOL) isReadableFileAtPath: (NSString*)path
 {
-  const _CHAR* lpath = [self fileSystemRepresentationWithPath: path];
-
-  if (lpath == 0 || *lpath == _NUL)
+    const _CHAR* lpath = [self fileSystemRepresentationWithPath: path];
+    
+    if (lpath == 0 || *lpath == _NUL)
     {
-      ASSIGN(_lastError, @"no path given");
-      return NO;
+        ASSIGN(_lastError, @"no path given");
+        return NO;
     }
-
+    
 #if defined(__MINGW__)
     {
-      DWORD res;
-
-      res = GetFileAttributesW(lpath);
-
-      if (res == WIN32ERR)
-	{
-	  return NO;
-	}
-      return YES;
+        DWORD res;
+        
+        res = GetFileAttributesW(lpath);
+        
+        if (res == WIN32ERR)
+        {
+            return NO;
+        }
+        return YES;
     }
 #else
     {
-      if (access(lpath, R_OK) == 0)
-	{
-	  return YES;
-	}
-      return NO;
+        if (access(lpath, R_OK) == 0)
+        {
+            return YES;
+        }
+        return NO;
     }
 #endif
 }
@@ -1601,37 +1600,37 @@ static NSStringEncoding	defaultEncoding;
  */
 - (BOOL) isWritableFileAtPath: (NSString*)path
 {
-  const _CHAR* lpath = [self fileSystemRepresentationWithPath: path];
-
-  if (lpath == 0 || *lpath == _NUL)
+    const _CHAR* lpath = [self fileSystemRepresentationWithPath: path];
+    
+    if (lpath == 0 || *lpath == _NUL)
     {
-      ASSIGN(_lastError, @"no path given");
-      return NO;
+        ASSIGN(_lastError, @"no path given");
+        return NO;
     }
-
+    
 #if defined(__MINGW__)
     {
-      DWORD res;
-
-      res = GetFileAttributesW(lpath);
-
-      if (res == WIN32ERR)
-	{
-	  return NO;
-	}
-      if (res & FILE_ATTRIBUTE_READONLY)
-	{
-	  return NO;
-	}
-      return YES;
+        DWORD res;
+        
+        res = GetFileAttributesW(lpath);
+        
+        if (res == WIN32ERR)
+        {
+            return NO;
+        }
+        if (res & FILE_ATTRIBUTE_READONLY)
+        {
+            return NO;
+        }
+        return YES;
     }
 #else
     {
-      if (access(lpath, W_OK) == 0)
-	{
-	  return YES;
-	}
-      return NO;
+        if (access(lpath, W_OK) == 0)
+        {
+            return YES;
+        }
+        return NO;
     }
 #endif
 }
@@ -1643,44 +1642,44 @@ static NSStringEncoding	defaultEncoding;
  */
 - (BOOL) isExecutableFileAtPath: (NSString*)path
 {
-  const _CHAR* lpath = [self fileSystemRepresentationWithPath: path];
-
-  if (lpath == 0 || *lpath == _NUL)
+    const _CHAR* lpath = [self fileSystemRepresentationWithPath: path];
+    
+    if (lpath == 0 || *lpath == _NUL)
     {
-      ASSIGN(_lastError, @"no path given");
-      return NO;
+        ASSIGN(_lastError, @"no path given");
+        return NO;
     }
-
+    
 #if defined(__MINGW__)
     {
-      DWORD res;
-
-      res = GetFileAttributesW(lpath);
-
-      if (res == WIN32ERR)
-	{
-	  return NO;
-	}
-	// TODO: Actually should check all extensions in env var PATHEXT
-      if ([[[path pathExtension] lowercaseString] isEqualToString: @"exe"])
-	{
-	  return YES;
-	}
-      /* FIXME: On unix, directory accessible == executable, so we simulate that
-      here for Windows. Is there a better check for directory access? */
-      if (res & FILE_ATTRIBUTE_DIRECTORY)
-	{
-	  return YES;
-	}
-      return NO;
+        DWORD res;
+        
+        res = GetFileAttributesW(lpath);
+        
+        if (res == WIN32ERR)
+        {
+            return NO;
+        }
+        // TODO: Actually should check all extensions in env var PATHEXT
+        if ([[[path pathExtension] lowercaseString] isEqualToString: @"exe"])
+        {
+            return YES;
+        }
+        /* FIXME: On unix, directory accessible == executable, so we simulate that
+         here for Windows. Is there a better check for directory access? */
+        if (res & FILE_ATTRIBUTE_DIRECTORY)
+        {
+            return YES;
+        }
+        return NO;
     }
 #else
     {
-      if (access(lpath, X_OK) == 0)
-	{
-	  return YES;
-	}
-      return NO;
+        if (access(lpath, X_OK) == 0)
+        {
+            return YES;
+        }
+        return NO;
     }
 #endif
 }
@@ -1691,42 +1690,42 @@ static NSStringEncoding	defaultEncoding;
  */
 - (BOOL) isDeletableFileAtPath: (NSString*)path
 {
-  const _CHAR* lpath = [self fileSystemRepresentationWithPath: path];
-
-  if (lpath == 0 || *lpath == _NUL)
+    const _CHAR* lpath = [self fileSystemRepresentationWithPath: path];
+    
+    if (lpath == 0 || *lpath == _NUL)
     {
-      ASSIGN(_lastError, @"no path given");
-      return NO;
+        ASSIGN(_lastError, @"no path given");
+        return NO;
     }
-
+    
 #if defined(__MINGW__)
-      // TODO - handle directories
+    // TODO - handle directories
     {
-      DWORD res;
-
-      res = GetFileAttributesW(lpath);
-
-      if (res == WIN32ERR)
-	{
-	  return NO;
-	}
-      return (res & FILE_ATTRIBUTE_READONLY) ? NO : YES;
+        DWORD res;
+        
+        res = GetFileAttributesW(lpath);
+        
+        if (res == WIN32ERR)
+        {
+            return NO;
+        }
+        return (res & FILE_ATTRIBUTE_READONLY) ? NO : YES;
     }
 #else
     {
-      // TODO - handle directories
-      path = [path stringByDeletingLastPathComponent];
-      if ([path length] == 0)
-	{
-	  path = @".";
-	}
-      lpath = [self fileSystemRepresentationWithPath: path];
-
-      if (access(lpath, X_OK | W_OK) == 0)
-	{
-	  return YES;
-	}
-      return NO;
+        // TODO - handle directories
+        path = [path stringByDeletingLastPathComponent];
+        if ([path length] == 0)
+        {
+            path = @".";
+        }
+        lpath = [self fileSystemRepresentationWithPath: path];
+        
+        if (access(lpath, X_OK | W_OK) == 0)
+        {
+            return YES;
+        }
+        return NO;
     }
 #endif
 }
@@ -1806,11 +1805,11 @@ static NSStringEncoding	defaultEncoding;
  */
 - (NSDictionary*) fileAttributesAtPath: (NSString*)path traverseLink: (BOOL)flag
 {
-  NSDictionary	*d;
-
-  d = [GSAttrDictionaryClass attributesAt:
-    [self fileSystemRepresentationWithPath: path] traverseLink: flag];
-  return d;
+    NSDictionary	*d;
+    
+    d = [GSAttrDictionaryClass attributesAt:
+         [self fileSystemRepresentationWithPath: path] traverseLink: flag];
+    return d;
 }
 
 /**
@@ -1886,23 +1885,23 @@ static NSStringEncoding	defaultEncoding;
  * </list>
  */
 - (NSDictionary*) attributesOfItemAtPath: (NSString*)path
-				   error: (NSError**)error
+                                   error: (NSError**)error
 {
-  NSDictionary	*d;
-
-  DESTROY(_lastError);
-  d = [GSAttrDictionaryClass attributesAt:
-    [self fileSystemRepresentationWithPath: path] traverseLink: NO];
-  
-  if (error != NULL)
+    NSDictionary	*d;
+    
+    DESTROY(_lastError);
+    d = [GSAttrDictionaryClass attributesAt:
+         [self fileSystemRepresentationWithPath: path] traverseLink: NO];
+    
+    if (error != NULL)
     {
-      if (nil == d)
-	{
-	  *error = [self _errorFrom: path to: nil];
-	}
+        if (nil == d)
+        {
+            *error = [self _errorFrom: path to: nil];
+        }
     }
-  
-  return d;
+    
+    return d;
 }
 
 /**
@@ -1924,111 +1923,111 @@ static NSStringEncoding	defaultEncoding;
 - (NSDictionary*) fileSystemAttributesAtPath: (NSString*)path
 {
 #if defined(__MINGW__)
-  unsigned long long totalsize, freesize;
-  id  values[5];
-  id	keys[5] = {
-    NSFileSystemSize,
-    NSFileSystemFreeSize,
-    NSFileSystemNodes,
-    NSFileSystemFreeNodes,
-    NSFileSystemNumber
-  };
-  DWORD SectorsPerCluster, BytesPerSector, NumberFreeClusters;
-  DWORD TotalNumberClusters;
-  DWORD volumeSerialNumber = 0;
-  const _CHAR *lpath = [self fileSystemRepresentationWithPath: path];
-  _CHAR volumePathName[128];
-
-  if (!GetVolumePathNameW(lpath, volumePathName, 128))
-    {
-      return nil;
-    }
-  GetVolumeInformationW(volumePathName, NULL, 0, &volumeSerialNumber,
-    NULL, NULL, NULL, 0);
-
-  if (!GetDiskFreeSpaceW(volumePathName, &SectorsPerCluster,
-    &BytesPerSector, &NumberFreeClusters, &TotalNumberClusters))
-    {
-      return nil;
-    }
-
-  totalsize = (unsigned long long)TotalNumberClusters
+    unsigned long long totalsize, freesize;
+    id  values[5];
+    id	keys[5] = {
+        NSFileSystemSize,
+        NSFileSystemFreeSize,
+        NSFileSystemNodes,
+        NSFileSystemFreeNodes,
+        NSFileSystemNumber
+    };
+    DWORD SectorsPerCluster, BytesPerSector, NumberFreeClusters;
+    DWORD TotalNumberClusters;
+    DWORD volumeSerialNumber = 0;
+    const _CHAR *lpath = [self fileSystemRepresentationWithPath: path];
+    _CHAR volumePathName[128];
+    
+    if (!GetVolumePathNameW(lpath, volumePathName, 128))
+    {
+        return nil;
+    }
+    GetVolumeInformationW(volumePathName, NULL, 0, &volumeSerialNumber,
+                          NULL, NULL, NULL, 0);
+    
+    if (!GetDiskFreeSpaceW(volumePathName, &SectorsPerCluster,
+                           &BytesPerSector, &NumberFreeClusters, &TotalNumberClusters))
+    {
+        return nil;
+    }
+    
+    totalsize = (unsigned long long)TotalNumberClusters
     * (unsigned long long)SectorsPerCluster
     * (unsigned long long)BytesPerSector;
-  freesize = (unsigned long long)NumberFreeClusters
+    freesize = (unsigned long long)NumberFreeClusters
     * (unsigned long long)SectorsPerCluster
     * (unsigned long long)BytesPerSector;
-
-  values[0] = [NSNumber numberWithUnsignedLongLong: totalsize];
-  values[1] = [NSNumber numberWithUnsignedLongLong: freesize];
-  values[2] = [NSNumber numberWithLong: LONG_MAX];
-  values[3] = [NSNumber numberWithLong: LONG_MAX];
-  values[4] = [NSNumber numberWithUnsignedInt: volumeSerialNumber];
-
-  return [NSDictionary dictionaryWithObjects: values forKeys: keys count: 5];
-
+    
+    values[0] = [NSNumber numberWithUnsignedLongLong: totalsize];
+    values[1] = [NSNumber numberWithUnsignedLongLong: freesize];
+    values[2] = [NSNumber numberWithLong: LONG_MAX];
+    values[3] = [NSNumber numberWithLong: LONG_MAX];
+    values[4] = [NSNumber numberWithUnsignedInt: volumeSerialNumber];
+    
+    return [NSDictionary dictionaryWithObjects: values forKeys: keys count: 5];
+    
 #else
 #if defined(HAVE_SYS_VFS_H) || defined(HAVE_SYS_STATFS_H) \
-  || defined(HAVE_SYS_MOUNT_H)
-  struct _STATB statbuf;
+|| defined(HAVE_SYS_MOUNT_H)
+    struct _STATB statbuf;
 #ifdef HAVE_STATVFS
-  struct statvfs statfsbuf;
+    struct statvfs statfsbuf;
 #else
-  struct statfs statfsbuf;
+    struct statfs statfsbuf;
 #endif
-  unsigned long long totalsize, freesize;
-  unsigned long blocksize;
-  const char* lpath = [self fileSystemRepresentationWithPath: path];
-
-  id  values[5];
-  id	keys[5] = {
-    NSFileSystemSize,
-    NSFileSystemFreeSize,
-    NSFileSystemNodes,
-    NSFileSystemFreeNodes,
-    NSFileSystemNumber
-  };
-
-  if (_STAT(lpath, &statbuf) != 0)
-    {
-      NSDebugMLLog(@"NSFileManager", @"stat failed for '%s' ... %@",
-        lpath, [NSError _last]);
-      return nil;
+    unsigned long long totalsize, freesize;
+    unsigned long blocksize;
+    const char* lpath = [self fileSystemRepresentationWithPath: path];
+    
+    id  values[5];
+    id	keys[5] = {
+        NSFileSystemSize,
+        NSFileSystemFreeSize,
+        NSFileSystemNodes,
+        NSFileSystemFreeNodes,
+        NSFileSystemNumber
+    };
+    
+    if (_STAT(lpath, &statbuf) != 0)
+    {
+        NSDebugMLLog(@"NSFileManager", @"stat failed for '%s' ... %@",
+                     lpath, [NSError _last]);
+        return nil;
     }
 #ifdef HAVE_STATVFS
-  if (statvfs(lpath, &statfsbuf) != 0)
+    if (statvfs(lpath, &statfsbuf) != 0)
     {
-      NSDebugMLLog(@"NSFileManager", @"statvfs failed for '%s' ... %@",
-        lpath, [NSError _last]);
-      return nil;
+        NSDebugMLLog(@"NSFileManager", @"statvfs failed for '%s' ... %@",
+                     lpath, [NSError _last]);
+        return nil;
     }
-  blocksize = statfsbuf.f_frsize;
+    blocksize = statfsbuf.f_frsize;
 #else
-  if (statfs(lpath, &statfsbuf) != 0)
+    if (statfs(lpath, &statfsbuf) != 0)
     {
-      NSDebugMLLog(@"NSFileManager", @"statfs failed for '%s' ... %@",
-        lpath, [NSError _last]);
-      return nil;
+        NSDebugMLLog(@"NSFileManager", @"statfs failed for '%s' ... %@",
+                     lpath, [NSError _last]);
+        return nil;
     }
-  blocksize = statfsbuf.f_bsize;
+    blocksize = statfsbuf.f_bsize;
 #endif
-
-  totalsize = (unsigned long long) blocksize
+    
+    totalsize = (unsigned long long) blocksize
     * (unsigned long long) statfsbuf.f_blocks;
-  freesize = (unsigned long long) blocksize
+    freesize = (unsigned long long) blocksize
     * (unsigned long long) statfsbuf.f_bavail;
-
-  values[0] = [NSNumber numberWithUnsignedLongLong: totalsize];
-  values[1] = [NSNumber numberWithUnsignedLongLong: freesize];
-  values[2] = [NSNumber numberWithLong: statfsbuf.f_files];
-  values[3] = [NSNumber numberWithLong: statfsbuf.f_ffree];
-  values[4] = [NSNumber numberWithUnsignedLong: statbuf.st_dev];
-
-  return [NSDictionary dictionaryWithObjects: values forKeys: keys count: 5];
+    
+    values[0] = [NSNumber numberWithUnsignedLongLong: totalsize];
+    values[1] = [NSNumber numberWithUnsignedLongLong: freesize];
+    values[2] = [NSNumber numberWithLong: statfsbuf.f_files];
+    values[3] = [NSNumber numberWithLong: statfsbuf.f_ffree];
+    values[4] = [NSNumber numberWithUnsignedLong: statbuf.st_dev];
+    
+    return [NSDictionary dictionaryWithObjects: values forKeys: keys count: 5];
 #else
-  NSLog(@"NSFileManager", @"no support for filesystem attributes");
-  ASSIGN(_lastError, @"no support for filesystem attributes");
-  return nil;
+    NSLog(@"NSFileManager", @"no support for filesystem attributes");
+    ASSIGN(_lastError, @"no support for filesystem attributes");
+    return nil;
 #endif
 #endif /* MINGW */
 }
@@ -2051,9 +2050,9 @@ static NSStringEncoding	defaultEncoding;
    */
   if ([self fileExistsAtPath: path isDirectory: &is_dir] == NO || is_dir == NO)
     {
-      return nil;
+        return nil;
     }
-  content = [NSMutableArray arrayWithCapacity: 128];
+  content = [[NSMutableArray alloc] initWithCapacity: 128];
   /* We initialize the directory enumerator with justContents == YES,
      which tells the NSDirectoryEnumerator code that we only enumerate
      the contents non-recursively once, and exit.  NSDirectoryEnumerator
@@ -2077,7 +2076,7 @@ static NSStringEncoding	defaultEncoding;
 	}
       RELEASE(direnum);
     }
-  return [content makeImmutableCopyOnFail: NO];
+  return [[content makeImmutable] autorelease];
 }
 
 /**
@@ -2091,17 +2090,17 @@ static NSStringEncoding	defaultEncoding;
  */
 - (NSString*) displayNameAtPath: (NSString*)path
 {
-  return [path lastPathComponent];
+    return [path lastPathComponent];
 }
 
 - (NSDirectoryEnumerator*) enumeratorAtPath: (NSString*)path
 {
-  return AUTORELEASE([[NSDirectoryEnumerator alloc]
-		       initWithDirectoryPath: path
-		       recurseIntoSubdirectories: YES
-		       followSymlinks: NO
-		       justContents: NO
-		       for: self]);
+    return AUTORELEASE([[NSDirectoryEnumerator alloc]
+                        initWithDirectoryPath: path
+                        recurseIntoSubdirectories: YES
+                        followSymlinks: NO
+                        justContents: NO
+                        for: self]);
 }
 
 /**
@@ -2118,9 +2117,9 @@ static NSStringEncoding	defaultEncoding;
 
   if (![self fileExistsAtPath: path isDirectory: &isDir] || !isDir)
     {
-      return nil;
+        return nil;
     }
-  content = [NSMutableArray arrayWithCapacity: 128];
+  content = [[NSMutableArray alloc] initWithCapacity: 128];
   direnum = [[NSDirectoryEnumerator alloc] initWithDirectoryPath: path
 				       recurseIntoSubdirectories: YES
 						  followSymlinks: NO
@@ -2140,7 +2139,7 @@ static NSStringEncoding	defaultEncoding;
 	}
       RELEASE(direnum);
     }
-  return [content makeImmutableCopyOnFail: NO];
+  return [[content makeImmutable] autorelease];
 }
 
 /**
@@ -2148,16 +2147,16 @@ static NSStringEncoding	defaultEncoding;
  * specified by otherPath.
  */
 - (BOOL) createSymbolicLinkAtPath: (NSString*)path
-		      pathContent: (NSString*)otherPath
+                      pathContent: (NSString*)otherPath
 {
 #ifdef HAVE_SYMLINK
-  const char* newpath = [self fileSystemRepresentationWithPath: path];
-  const char* oldpath = [self fileSystemRepresentationWithPath: otherPath];
-
-  return (symlink(oldpath, newpath) == 0);
+    const char* newpath = [self fileSystemRepresentationWithPath: path];
+    const char* oldpath = [self fileSystemRepresentationWithPath: otherPath];
+    
+    return (symlink(oldpath, newpath) == 0);
 #else
-  ASSIGN(_lastError, @"symbolic links not supported on this system");
-  return NO;
+    ASSIGN(_lastError, @"symbolic links not supported on this system");
+    return NO;
 #endif
 }
 
@@ -2168,81 +2167,100 @@ static NSStringEncoding	defaultEncoding;
 - (NSString*) pathContentOfSymbolicLinkAtPath: (NSString*)path
 {
 #ifdef HAVE_READLINK
-  char  buf[PATH_MAX];
-  const char* lpath = [self fileSystemRepresentationWithPath: path];
-  int   llen = readlink(lpath, buf, PATH_MAX-1);
-
-  if (llen > 0)
+    char  buf[PATH_MAX];
+    const char* lpath = [self fileSystemRepresentationWithPath: path];
+    size_t llen = readlink(lpath, buf, PATH_MAX-1);
+    
+    if (llen > 0)
     {
-      return [self stringWithFileSystemRepresentation: buf length: llen];
+        return [self stringWithFileSystemRepresentation: buf length: llen];
     }
-  else
+    else
     {
-      return nil;
+        return nil;
     }
 #else
-  ASSIGN(_lastError, @"symbolic links not supported on this system");
-  return nil;
+    ASSIGN(_lastError, @"symbolic links not supported on this system");
+    return nil;
 #endif
 }
 
 #if	defined(__MINGW__)
 - (const GSNativeChar*) fileSystemRepresentationWithPath: (NSString*)path
 {
-  if (path != nil && [path rangeOfString: @"/"].length > 0)
+    if (path != nil && [path rangeOfString: @"/"].length > 0)
     {
-      path = [path stringByReplacingString: @"/" withString: @"\\"];
+        path = [path stringByReplacingString: @"/" withString: @"\\"];
     }
-  return
+    return
     (const GSNativeChar*)[path cStringUsingEncoding: NSUnicodeStringEncoding];
 }
 - (NSString*) stringWithFileSystemRepresentation: (const GSNativeChar*)string
-					  length: (NSUInteger)len
+                                          length: (NSUInteger)len
 {
-  return [NSString stringWithCharacters: string length: len];
+    return [NSString stringWithCharacters: string length: len];
 }
 #else
 - (const GSNativeChar*) fileSystemRepresentationWithPath: (NSString*)path
 {
-  return
+    return
     (const GSNativeChar*)[path cStringUsingEncoding: defaultEncoding];
 }
 - (NSString*) stringWithFileSystemRepresentation: (const GSNativeChar*)string
-					  length: (NSUInteger)len
+                                          length: (NSUInteger)len
 {
-  return AUTORELEASE([[NSString allocWithZone: NSDefaultMallocZone()]
-    initWithBytes: string length: len encoding: defaultEncoding]);
+    return AUTORELEASE([[NSString allocWithZone: NSDefaultMallocZone()]
+                        initWithBytes: string length: len encoding: defaultEncoding]);
 }
 #endif
 
 @end /* NSFileManager */
 
 /* A directory to enumerate.  We keep a stack of the directories we
-   still have to enumerate.  We start by putting the top-level
-   directory into the stack, then we start reading files from it
-   (using readdir).  If we find a file which is actually a directory,
-   and if we have to recurse into it, we create a new
-   GSEnumeratedDirectory struct for the subdirectory, open its DIR
-   *pointer for reading, and put it on top of the stack, so next time
-   -nextObject is called, it will read from that directory instead of
-   the top level one.  Once all the subdirectory is read, it is
-   removed from the stack, so the top of the stack if the top
-   directory again, and enumeration continues in there.  */
+ still have to enumerate.  We start by putting the top-level
+ directory into the stack, then we start reading files from it
+ (using readdir).  If we find a file which is actually a directory,
+ and if we have to recurse into it, we create a new
+ GSEnumeratedDirectory struct for the subdirectory, open its DIR
+ *pointer for reading, and put it on top of the stack, so next time
+ -nextObject is called, it will read from that directory instead of
+ the top level one.  Once all the subdirectory is read, it is
+ removed from the stack, so the top of the stack if the top
+ directory again, and enumeration continues in there.  */
 typedef	struct	_GSEnumeratedDirectory {
-  NSString *path;
-  _DIR *pointer;
+    NSString *path;
+    _DIR *pointer;
 } GSEnumeratedDirectory;
 
+static inline void
+GSEnumeratedDirectoryInit(GSEnumeratedDirectory *dir, NSString *path, _DIR *pointer)
+{
+    dir->path = RETAIN(path);
+    dir->pointer = pointer;
+}
+
+static inline NSString *
+GSEnumeratedDirectoryGetPath(GSEnumeratedDirectory *dir)
+{
+    return dir->path;
+}
+
+static inline _DIR *
+GSEnumeratedDirectoryGetPointer(GSEnumeratedDirectory *dir)
+{
+    return dir->pointer;
+}
 
-static inline void gsedRelease(GSEnumeratedDirectory X)
+static inline void
+GSEnumeratedDirectoryRelease(GSEnumeratedDirectory X)
 {
-  DESTROY(X.path);
-  _CLOSEDIR(X.pointer);
+    DESTROY(X.path);
+    _CLOSEDIR(X.pointer);
 }
 
-#define GSI_ARRAY_TYPES	0
-#define GSI_ARRAY_TYPE	GSEnumeratedDirectory
-#define GSI_ARRAY_RELEASE(A, X)   gsedRelease(X.ext)
+#define GSI_ARRAY_TYPES         0
+#define GSI_ARRAY_TYPE          GSEnumeratedDirectory
+#define GSI_ARRAY_RELEASE(A, X) GSEnumeratedDirectoryRelease(X.ext)
 #define GSI_ARRAY_RETAIN(A, X)
 
 #include "GNUstepBase/GSIArray.h"
@@ -2257,7 +2275,7 @@ static inline void gsedRelease(GSEnumeratedDirectory X)
 
 + (void) initialize
 {
-  if (self == [NSDirectoryEnumerator class])
+    if (self == [NSDirectoryEnumerator class])
     {
     }
 }
@@ -2274,57 +2292,56 @@ static inline void gsedRelease(GSEnumeratedDirectory X)
    recurseIntoSubdirectories: (BOOL)recurse
 	      followSymlinks: (BOOL)follow
 		justContents: (BOOL)justContents
-			 for: (NSFileManager*)mgr
+                         for: (NSFileManager*)mgr
 {
-  if (nil != (self = [super init]))
+    if (nil != (self = [super init]))
     {
-    //TODO: the justContents flag is currently basically useless and should be
-    //      removed
-      _DIR		*dir_pointer;
-      const _CHAR	*localPath;
-
-      _mgr = RETAIN(mgr);
+        //TODO: the justContents flag is currently basically useless and should be
+        //      removed
+        _DIR		*dir_pointer;
+        const _CHAR	*localPath;
+        
+        _mgr = RETAIN(mgr);
 #if	GS_WITH_GC
-      _stack = NSAllocateCollectable(sizeof(GSIArray_t), NSScannedOption);
+        _stack = NSAllocateCollectable(sizeof(GSIArray_t), NSScannedOption);
 #else
-      _stack = NSZoneMalloc([self zone], sizeof(GSIArray_t));
+        _stack = NSZoneMalloc([self zone], sizeof(GSIArray_t));
 #endif
-      GSIArrayInitWithZoneAndCapacity(_stack, [self zone], 64);
-
-      _flags.isRecursive = recurse;
-      _flags.isFollowing = follow;
-      _flags.justContents = justContents;
-
-      _topPath = [[NSString alloc] initWithString: path];
-
-      localPath = [_mgr fileSystemRepresentationWithPath: path];
-      dir_pointer = _OPENDIR(localPath);
-      if (dir_pointer)
+        GSIArrayInitWithZoneAndCapacity(_stack, [self zone], 64);
+        
+        _flags.isRecursive = recurse;
+        _flags.isFollowing = follow;
+        _flags.justContents = justContents;
+        
+        _topPath = [[NSString alloc] initWithString:path];
+        
+        localPath = [_mgr fileSystemRepresentationWithPath:path];
+        dir_pointer = _OPENDIR(localPath);
+        if (dir_pointer)
         {
-          GSIArrayItem item;
-
-          item.ext.path = @"";
-          item.ext.pointer = dir_pointer;
-
-          GSIArrayAddItem(_stack, item);
+            GSIArrayItem item;
+            
+            item.ext.path = @"";
+            item.ext.pointer = dir_pointer;
+            
+            GSIArrayAddItem(_stack, item);
         }
-      else
+        else
         {
-          NSLog(@"Failed to recurse into directory '%@' - %@", path,
-            [NSError _last]);
+            NSLog(@"Failed to recurse into directory '%@' - %@", path, [NSError _last]);
         }
     }
-  return self;
+    return self;
 }
 
 - (void) dealloc
 {
-  GSIArrayEmpty(_stack);
-  NSZoneFree([self zone], _stack);
-  DESTROY(_topPath);
-  DESTROY(_currentFilePath);
-  DESTROY(_mgr);
-  [super dealloc];
+    GSIArrayEmpty(_stack);
+    NSZoneFree([self zone], _stack);
+    DESTROY(_topPath);
+    DESTROY(_currentFilePath);
+    DESTROY(_mgr);
+    [super dealloc];
 }
 
 /**
@@ -2335,8 +2352,8 @@ static inline void gsedRelease(GSEnumeratedDirectory X)
  */
 - (NSDictionary*) directoryAttributes
 {
-  return [_mgr fileAttributesAtPath: _topPath
-		       traverseLink: _flags.isFollowing];
+    return [_mgr fileAttributesAtPath: _topPath
+                         traverseLink: _flags.isFollowing];
 }
 
 /**
@@ -2347,8 +2364,8 @@ static inline void gsedRelease(GSEnumeratedDirectory X)
  */
 - (NSDictionary*) fileAttributes
 {
-  return [_mgr fileAttributesAtPath: _currentFilePath
-		       traverseLink: _flags.isFollowing];
+    return [_mgr fileAttributesAtPath: _currentFilePath
+                         traverseLink: _flags.isFollowing];
 }
 
 /**
@@ -2358,13 +2375,13 @@ static inline void gsedRelease(GSEnumeratedDirectory X)
  */
 - (void) skipDescendents
 {
-  if (GSIArrayCount(_stack) > 0)
+    if (GSIArrayCount(_stack) > 0)
     {
-      GSIArrayRemoveLastItem(_stack);
-      if (_currentFilePath != 0)
-	{
-	  DESTROY(_currentFilePath);
-	}
+        GSIArrayRemoveLastItem(_stack);
+        if (_currentFilePath != 0)
+        {
+            DESTROY(_currentFilePath);
+        }
     }
 }
 
@@ -2381,119 +2398,116 @@ static inline void gsedRelease(GSEnumeratedDirectory X)
  */
 - (id) nextObject
 {
-  NSString *returnFileName = 0;
-
-  if (_currentFilePath != 0)
+    NSString *returnFileName = 0;
+    
+    if (_currentFilePath != 0)
     {
-      DESTROY(_currentFilePath);
+        DESTROY(_currentFilePath);
     }
-
-  while (GSIArrayCount(_stack) > 0)
+    
+    while (GSIArrayCount(_stack) > 0)
     {
-      GSEnumeratedDirectory dir = GSIArrayLastItem(_stack).ext;
-      struct _DIRENT	*dirbuf;
-      struct _STATB	statbuf;
-
-      dirbuf = _READDIR(dir.pointer);
-
-      if (dirbuf)
-	{
+        GSEnumeratedDirectory dir = GSIArrayLastItem(_stack).ext;
+        struct _DIRENT	*dirbuf;
+        struct _STATB	statbuf;
+        
+        dirbuf = _READDIR(GSEnumeratedDirectoryGetPointer(&dir));
+        
+        if (dirbuf)
+        {
 #if defined(__MINGW__)
-	  /* Skip "." and ".." directory entries */
-	  if (wcscmp(dirbuf->d_name, L".") == 0
-	    || wcscmp(dirbuf->d_name, L"..") == 0)
-	    {
-	      continue;
-	    }
-	  /* Name of file to return  */
-	  returnFileName = [_mgr
-	    stringWithFileSystemRepresentation: dirbuf->d_name
-	    length: wcslen(dirbuf->d_name)];
+            /* Skip "." and ".." directory entries */
+            if (wcscmp(dirbuf->d_name, L".") == 0
+                || wcscmp(dirbuf->d_name, L"..") == 0)
+            {
+                continue;
+            }
+            /* Name of file to return  */
+            returnFileName = [_mgr
+                              stringWithFileSystemRepresentation: dirbuf->d_name
+                              length: wcslen(dirbuf->d_name)];
 #else
-	  /* Skip "." and ".." directory entries */
-	  if (strcmp(dirbuf->d_name, ".") == 0
-	    || strcmp(dirbuf->d_name, "..") == 0)
-	    {
-	      continue;
-	    }
-	  /* Name of file to return  */
-	  returnFileName = [_mgr
-	    stringWithFileSystemRepresentation: dirbuf->d_name
-	    length: strlen(dirbuf->d_name)];
+            /* Skip "." and ".." directory entries */
+            if (strcmp(dirbuf->d_name, ".") == 0
+                || strcmp(dirbuf->d_name, "..") == 0)
+            {
+                continue;
+            }
+            /* Name of file to return  */
+            returnFileName = [_mgr
+                              stringWithFileSystemRepresentation: dirbuf->d_name
+                              length: strlen(dirbuf->d_name)];
 #endif
-	  returnFileName = RETAIN([dir.path stringByAppendingPathComponent:
-	    returnFileName]);
-
-	  /* TODO - can this one can be removed ? */
-	  if (!_flags.justContents)
-	    _currentFilePath = RETAIN([_topPath stringByAppendingPathComponent:
-	      returnFileName]);
-
-	  if (_flags.isRecursive == YES)
-	    {
-	      // Do not follow links
+            returnFileName = [GSEnumeratedDirectoryGetPath(&dir) stringByAppendingPathComponent:returnFileName];
+            
+            /* TODO - can this one can be removed ? */
+            if (!_flags.justContents)
+                _currentFilePath = RETAIN([_topPath stringByAppendingPathComponent:returnFileName]);
+            
+            if (_flags.isRecursive == YES)
+            {
+                // Do not follow links
 #ifdef S_IFLNK
 #ifdef __MINGW__
 #warning "lstat does not support unichars"
 #else
-	      if (!_flags.isFollowing)
-		{
-		  if (lstat([_mgr fileSystemRepresentationWithPath:
-		    _currentFilePath], &statbuf) != 0)
-		    {
-		      break;
-		    }
-		  // If link then return it as link
-		  if (S_IFLNK == (S_IFMT & statbuf.st_mode))
-		    {
-		      break;
-		    }
-		}
-	      else
+                if (!_flags.isFollowing)
+                {
+                    if (lstat([_mgr fileSystemRepresentationWithPath:
+                               _currentFilePath], &statbuf) != 0)
+                    {
+                        break;
+                    }
+                    // If link then return it as link
+                    if (S_IFLNK == (S_IFMT & statbuf.st_mode))
+                    {
+                        break;
+                    }
+                }
+                else
 #endif
 #endif
-		{
-		  if (_STAT([_mgr fileSystemRepresentationWithPath:
-		    _currentFilePath], &statbuf) != 0)
-		    {
-		      break;
-		    }
-		}
-	      if (S_IFDIR == (S_IFMT & statbuf.st_mode))
-		{
-		  _DIR*  dir_pointer;
-
-		  dir_pointer
-		    = _OPENDIR([_mgr fileSystemRepresentationWithPath:
-		    _currentFilePath]);
-		  if (dir_pointer)
-		    {
-		      GSIArrayItem item;
-
-		      item.ext.path = RETAIN(returnFileName);
-		      item.ext.pointer = dir_pointer;
-
-		      GSIArrayAddItem(_stack, item);
-		    }
-		  else
-		    {
-		      NSLog(@"Failed to recurse into directory '%@' - %@",
-			_currentFilePath, [NSError _last]);
-		    }
-		}
-	    }
-	  break;	// Got a file name - break out of loop
-	}
-      else
-	{
-	  GSIArrayRemoveLastItem(_stack);
-	  if (_currentFilePath != 0)
-	    {
-	      DESTROY(_currentFilePath);
-	    }
-	}
+                {
+                    if (_STAT([_mgr fileSystemRepresentationWithPath:
+                               _currentFilePath], &statbuf) != 0)
+                    {
+                        break;
+                    }
+                }
+                if (S_IFDIR == (S_IFMT & statbuf.st_mode))
+                {
+                    _DIR*  dir_pointer;
+                    
+                    dir_pointer
+                    = _OPENDIR([_mgr fileSystemRepresentationWithPath:
+                                _currentFilePath]);
+                    if (dir_pointer)
+                    {
+                        GSIArrayItem item;
+                        
+                        GSEnumeratedDirectoryInit(&item.ext, returnFileName, dir_pointer);
+                        
+                        GSIArrayAddItem(_stack, item);
+                    }
+                    else
+                    {
+                        NSLog(@"Failed to recurse into directory '%@' - %@",
+                              _currentFilePath, [NSError _last]);
+                    }
+                }
+            }
+            break;	// Got a file name - break out of loop
+        }
+        else
+        {
+            GSIArrayRemoveLastItem(_stack);
+            if (_currentFilePath != 0)
+            {
+                DESTROY(_currentFilePath);
+            }
+        }
     }
-  return AUTORELEASE(returnFileName);
+    return returnFileName;
 }
 
 @end /* NSDirectoryEnumerator */
@@ -2508,7 +2522,7 @@ static inline void gsedRelease(GSEnumeratedDirectory X)
  */
 - (NSDate*) fileCreationDate
 {
-  return [self objectForKey: NSFileCreationDate];
+    return [self objectForKey: NSFileCreationDate];
 }
 
 /**
@@ -2516,7 +2530,7 @@ static inline void gsedRelease(GSEnumeratedDirectory X)
  */
 - (BOOL) fileExtensionHidden
 {
-  return [[self objectForKey: NSFileExtensionHidden] boolValue];
+    return [[self objectForKey: NSFileExtensionHidden] boolValue];
 }
 
 /**
@@ -2524,7 +2538,7 @@ static inline void gsedRelease(GSEnumeratedDirectory X)
  */
 - (OSType) fileHFSCreatorCode
 {
-  return [[self objectForKey: NSFileHFSCreatorCode] unsignedLongValue];
+    return (OSType)[[self objectForKey: NSFileHFSCreatorCode] unsignedLongValue];
 }
 
 /**
@@ -2532,7 +2546,7 @@ static inline void gsedRelease(GSEnumeratedDirectory X)
  */
 - (OSType) fileHFSTypeCode
 {
-  return [[self objectForKey: NSFileHFSTypeCode] unsignedLongValue];
+    return (OSType)[[self objectForKey: NSFileHFSTypeCode] unsignedLongValue];
 }
 
 /**
@@ -2540,7 +2554,7 @@ static inline void gsedRelease(GSEnumeratedDirectory X)
  */
 - (BOOL) fileIsAppendOnly
 {
-  return [[self objectForKey: NSFileAppendOnly] boolValue];
+    return [[self objectForKey: NSFileAppendOnly] boolValue];
 }
 
 /**
@@ -2548,7 +2562,7 @@ static inline void gsedRelease(GSEnumeratedDirectory X)
  */
 - (BOOL) fileIsImmutable
 {
-  return [[self objectForKey: NSFileImmutable] boolValue];
+    return [[self objectForKey: NSFileImmutable] boolValue];
 }
 
 /**
@@ -2557,13 +2571,13 @@ static inline void gsedRelease(GSEnumeratedDirectory X)
  */
 - (unsigned long long) fileSize
 {
-  NSNumber	*n = [self objectForKey: NSFileSize];
-
-  if (n == nil)
+    NSNumber	*n = [self objectForKey: NSFileSize];
+    
+    if (n == nil)
     {
-      return NSNotFound;
+        return NSNotFound;
     }
-  return [n unsignedLongLongValue];
+    return [n unsignedLongLongValue];
 }
 
 /**
@@ -2571,7 +2585,7 @@ static inline void gsedRelease(GSEnumeratedDirectory X)
  */
 - (NSString*) fileType
 {
-  return [self objectForKey: NSFileType];
+    return [self objectForKey: NSFileType];
 }
 
 /**
@@ -2579,7 +2593,7 @@ static inline void gsedRelease(GSEnumeratedDirectory X)
  */
 - (NSString*) fileOwnerAccountName
 {
-  return [self objectForKey: NSFileOwnerAccountName];
+    return [self objectForKey: NSFileOwnerAccountName];
 }
 
 /**
@@ -2588,7 +2602,7 @@ static inline void gsedRelease(GSEnumeratedDirectory X)
  */
 - (NSNumber*) fileOwnerAccountID
 {
-  return [self objectForKey: NSFileOwnerAccountID];
+    return [self objectForKey: NSFileOwnerAccountID];
 }
 
 /**
@@ -2596,7 +2610,7 @@ static inline void gsedRelease(GSEnumeratedDirectory X)
  */
 - (NSString*) fileGroupOwnerAccountName
 {
-  return [self objectForKey: NSFileGroupOwnerAccountName];
+    return [self objectForKey: NSFileGroupOwnerAccountName];
 }
 
 /**
@@ -2605,7 +2619,7 @@ static inline void gsedRelease(GSEnumeratedDirectory X)
  */
 - (NSNumber*) fileGroupOwnerAccountID
 {
-  return [self objectForKey: NSFileGroupOwnerAccountID];
+    return [self objectForKey: NSFileGroupOwnerAccountID];
 }
 
 /**
@@ -2613,7 +2627,7 @@ static inline void gsedRelease(GSEnumeratedDirectory X)
  */
 - (NSDate*) fileModificationDate
 {
-  return [self objectForKey: NSFileModificationDate];
+    return [self objectForKey: NSFileModificationDate];
 }
 
 /**
@@ -2622,13 +2636,13 @@ static inline void gsedRelease(GSEnumeratedDirectory X)
  */
 - (NSUInteger) filePosixPermissions
 {
-  NSNumber	*n = [self objectForKey: NSFilePosixPermissions];
-
-  if (n == nil)
+    NSNumber	*n = [self objectForKey: NSFilePosixPermissions];
+    
+    if (n == nil)
     {
-      return NSNotFound;
+        return NSNotFound;
     }
-  return [n unsignedIntegerValue];
+    return [n unsignedIntegerValue];
 }
 
 /**
@@ -2637,13 +2651,13 @@ static inline void gsedRelease(GSEnumeratedDirectory X)
  */
 - (NSUInteger) fileSystemNumber
 {
-  NSNumber	*n = [self objectForKey: NSFileSystemNumber];
-
-  if (n == nil)
+    NSNumber	*n = [self objectForKey: NSFileSystemNumber];
+    
+    if (n == nil)
     {
-      return NSNotFound;
+        return NSNotFound;
     }
-  return [n unsignedIntegerValue];
+    return [n unsignedIntegerValue];
 }
 
 /**
@@ -2652,332 +2666,326 @@ static inline void gsedRelease(GSEnumeratedDirectory X)
  */
 - (NSUInteger) fileSystemFileNumber
 {
-  NSNumber	*n = [self objectForKey: NSFileSystemFileNumber];
-
-  if (n == nil)
+    NSNumber	*n = [self objectForKey: NSFileSystemFileNumber];
+    
+    if (n == nil)
     {
-      return NSNotFound;
+        return NSNotFound;
     }
-  return [n unsignedIntegerValue];
+    return [n unsignedIntegerValue];
 }
 @end
 
 @implementation NSFileManager (PrivateMethods)
 
 - (BOOL) _copyFile: (NSString*)source
-	    toFile: (NSString*)destination
-	   handler: (id)handler
+            toFile: (NSString*)destination
+           handler: (id)handler
 {
 #if defined(__MINGW__)
-  if (CopyFileW([self fileSystemRepresentationWithPath: source],
-    [self fileSystemRepresentationWithPath: destination], NO))
-    {
-      return YES;
-    }
-
-  return [self _proceedAccordingToHandler: handler
-				 forError: @"cannot copy file"
-				   inPath: source
-				 fromPath: source
-				   toPath: destination];
-
+    if (CopyFileW([self fileSystemRepresentationWithPath: source],
+                  [self fileSystemRepresentationWithPath: destination], NO))
+    {
+        return YES;
+    }
+    
+    return [self _proceedAccordingToHandler: handler
+                                   forError: @"cannot copy file"
+                                     inPath: source
+                                   fromPath: source
+                                     toPath: destination];
+    
 #else
-  NSDictionary	*attributes;
-  unsigned long long	fileSize;
-  unsigned long long	i;
-  int		bufsize = 8096;
-  int		sourceFd;
-  int		destFd;
-  int		fileMode;
-  int		rbytes;
-  int		wbytes;
-  char		buffer[bufsize];
-
-  /* Assumes source is a file and exists! */
-  NSAssert1 ([self fileExistsAtPath: source],
-    @"source file '%@' does not exist!", source);
-
-  attributes = [self fileAttributesAtPath: source traverseLink: NO];
-  NSAssert1 (attributes, @"could not get the attributes for file '%@'",
-    source);
-
-  fileSize = [attributes fileSize];
-  fileMode = [attributes filePosixPermissions];
-
-  /* Open the source file. In case of error call the handler. */
-  sourceFd = open([self fileSystemRepresentationWithPath: source],
-    GSBINIO|O_RDONLY);
-  if (sourceFd < 0)
-    {
-      return [self _proceedAccordingToHandler: handler
-				     forError: @"cannot open file for reading"
-				       inPath: source
-				     fromPath: source
-				       toPath: destination];
-    }
-
-  /* Open the destination file. In case of error call the handler. */
-  destFd = open([self fileSystemRepresentationWithPath: destination],
-    GSBINIO|O_WRONLY|O_CREAT|O_TRUNC, fileMode);
-  if (destFd < 0)
-    {
-      close (sourceFd);
-
-      return [self _proceedAccordingToHandler: handler
-				     forError:  @"cannot open file for writing"
-				       inPath: destination
-				     fromPath: source
-				       toPath: destination];
-    }
-
-  /* Read bufsize bytes from source file and write them into the destination
+    NSDictionary	*attributes;
+    unsigned long long	fileSize;
+    unsigned long long	i;
+    int		bufsize = 8096;
+    int		sourceFd;
+    int		destFd;
+    NSUInteger fileMode;
+    ssize_t  rbytes;
+    ssize_t  wbytes;
+    char		buffer[bufsize];
+    
+    /* Assumes source is a file and exists! */
+    NSAssert1 ([self fileExistsAtPath: source],
+               @"source file '%@' does not exist!", source);
+    
+    attributes = [self fileAttributesAtPath: source traverseLink: NO];
+    NSAssert1 (attributes, @"could not get the attributes for file '%@'",
+               source);
+    
+    fileSize = [attributes fileSize];
+    fileMode = [attributes filePosixPermissions];
+    
+    /* Open the source file. In case of error call the handler. */
+    sourceFd = open([self fileSystemRepresentationWithPath: source],
+                    GSBINIO|O_RDONLY);
+    if (sourceFd < 0)
+    {
+        return [self _proceedAccordingToHandler: handler
+                                       forError: @"cannot open file for reading"
+                                         inPath: source
+                                       fromPath: source
+                                         toPath: destination];
+    }
+    
+    /* Open the destination file. In case of error call the handler. */
+    destFd = open([self fileSystemRepresentationWithPath: destination],
+                  GSBINIO|O_WRONLY|O_CREAT|O_TRUNC, fileMode);
+    if (destFd < 0)
+    {
+        close (sourceFd);
+        
+        return [self _proceedAccordingToHandler: handler
+                                       forError:  @"cannot open file for writing"
+                                         inPath: destination
+                                       fromPath: source
+                                         toPath: destination];
+    }
+    
+    /* Read bufsize bytes from source file and write them into the destination
      file. In case of errors call the handler and abort the operation. */
-  for (i = 0; i < fileSize; i += rbytes)
+    for (i = 0; i < fileSize; i += rbytes)
     {
-      rbytes = read (sourceFd, buffer, bufsize);
-      if (rbytes < 0)
-	{
-          close (sourceFd);
-          close (destFd);
-
-          return [self _proceedAccordingToHandler: handler
-					 forError: @"cannot read from file"
-					   inPath: source
-					 fromPath: source
-					   toPath: destination];
-	}
-
-      wbytes = write (destFd, buffer, rbytes);
-      if (wbytes != rbytes)
-	{
-          close (sourceFd);
-          close (destFd);
-
-          return [self _proceedAccordingToHandler: handler
-					 forError: @"cannot write to file"
-					   inPath: destination
-					 fromPath: source
-					   toPath: destination];
+        rbytes = read (sourceFd, buffer, bufsize);
+        if (rbytes < 0)
+        {
+            close (sourceFd);
+            close (destFd);
+            
+            return [self _proceedAccordingToHandler: handler
+                                           forError: @"cannot read from file"
+                                             inPath: source
+                                           fromPath: source
+                                             toPath: destination];
+        }
+        
+        wbytes = write (destFd, buffer, rbytes);
+        if (wbytes != rbytes)
+        {
+            close (sourceFd);
+            close (destFd);
+            
+            return [self _proceedAccordingToHandler: handler
+                                           forError: @"cannot write to file"
+                                             inPath: destination
+                                           fromPath: source
+                                             toPath: destination];
         }
     }
-  close (sourceFd);
-  close (destFd);
-
-  return YES;
+    close (sourceFd);
+    close (destFd);
+    
+    return YES;
 #endif
 }
 
 - (BOOL) _copyPath: (NSString*)source
-	    toPath: (NSString*)destination
-	   handler: handler
-{
-  NSDirectoryEnumerator	*enumerator;
-  NSString		*dirEntry;
-  CREATE_AUTORELEASE_POOL(pool);
-
-  enumerator = [self enumeratorAtPath: source];
-  while ((dirEntry = [enumerator nextObject]))
-    {
-      NSString		*sourceFile;
-      NSString		*fileType;
-      NSString		*destinationFile;
-      NSDictionary	*attributes;
-
-      attributes = [enumerator fileAttributes];
-      fileType = [attributes fileType];
-      sourceFile = [source stringByAppendingPathComponent: dirEntry];
-      destinationFile
-	= [destination stringByAppendingPathComponent: dirEntry];
-
-      [self _sendToHandler: handler willProcessPath: sourceFile];
-
-      if ([fileType isEqual: NSFileTypeDirectory])
-	{
-	  BOOL	dirOK;
-
-	  dirOK = [self createDirectoryAtPath: destinationFile
-				   attributes: attributes];
-	  if (dirOK == NO)
-	    {
-              if (![self _proceedAccordingToHandler: handler
-					   forError: _lastError
-					     inPath: destinationFile
-					   fromPath: sourceFile
-					     toPath: destinationFile])
+            toPath: (NSString*)destination
+           handler: handler
+{
+    NSDirectoryEnumerator *enumerator;
+    NSString *dirEntry;
+    CREATE_AUTORELEASE_POOL(pool);
+    
+    enumerator = [self enumeratorAtPath: source];
+    while ((dirEntry = [enumerator nextObject]))
+    {
+        NSString		*sourceFile;
+        NSString		*fileType;
+        NSString		*destinationFile;
+        NSDictionary	*attributes;
+        
+        attributes = [enumerator fileAttributes];
+        fileType = [attributes fileType];
+        sourceFile = [source stringByAppendingPathComponent: dirEntry];
+        destinationFile
+        = [destination stringByAppendingPathComponent: dirEntry];
+        
+        [self _sendToHandler: handler willProcessPath: sourceFile];
+        
+        if ([fileType isEqual: NSFileTypeDirectory])
+        {
+            BOOL	dirOK;
+            
+            dirOK = [self createDirectoryAtPath: destinationFile
+                                     attributes: attributes];
+            if (dirOK == NO)
+            {
+                if (![self _proceedAccordingToHandler: handler
+                                             forError: _lastError
+                                               inPath: destinationFile
+                                             fromPath: sourceFile
+                                               toPath: destinationFile])
                 {
-                  RELEASE(pool);
-                  return NO;
+                    RELEASE(pool);
+                    return NO;
                 }
-	      /*
-	       * We may have managed to create the directory but not set
-	       * its attributes ... if so we can continue copying.
-	       */
-	      if (![self fileExistsAtPath: destinationFile isDirectory: &dirOK])
-	        {
-		  dirOK = NO;
-	        }
-	    }
-	  if (dirOK == YES)
-	    {
-	      [enumerator skipDescendents];
-	      if (![self _copyPath: sourceFile
-                         toPath: destinationFile
-                         handler: handler])
+                /*
+                 * We may have managed to create the directory but not set
+                 * its attributes ... if so we can continue copying.
+                 */
+                if (![self fileExistsAtPath: destinationFile isDirectory: &dirOK])
                 {
-                  RELEASE(pool);
-                  return NO;
+                    dirOK = NO;
                 }
-	    }
-	}
-      else if ([fileType isEqual: NSFileTypeRegular])
-	{
-	  if (![self _copyFile: sourceFile
-			toFile: destinationFile
-		       handler: handler])
+            }
+            if (dirOK == YES)
             {
-              RELEASE(pool);
-              return NO;
+                [enumerator skipDescendents];
+                if (![self _copyPath: sourceFile toPath: destinationFile handler: handler])
+                {
+                    RELEASE(pool);
+                    return NO;
+                }
             }
-	}
-      else if ([fileType isEqual: NSFileTypeSymbolicLink])
-	{
-	  NSString	*path;
-
-	  path = [self pathContentOfSymbolicLinkAtPath: sourceFile];
-	  if (![self createSymbolicLinkAtPath: destinationFile
-				  pathContent: path])
-	    {
-              if (![self _proceedAccordingToHandler: handler
-		forError: @"cannot create symbolic link"
-		inPath: sourceFile
-		fromPath: sourceFile
-		toPath: destinationFile])
+        }
+        else if ([fileType isEqual: NSFileTypeRegular])
+        {
+            if (![self _copyFile: sourceFile toFile: destinationFile handler: handler])
+            {
+                RELEASE(pool);
+                return NO;
+            }
+        }
+        else if ([fileType isEqual: NSFileTypeSymbolicLink])
+        {
+            NSString	*path;
+            
+            path = [self pathContentOfSymbolicLinkAtPath: sourceFile];
+            if (![self createSymbolicLinkAtPath: destinationFile
+                                    pathContent: path])
+            {
+                if (![self _proceedAccordingToHandler: handler
+                                             forError: @"cannot create symbolic link"
+                                               inPath: sourceFile
+                                             fromPath: sourceFile
+                                               toPath: destinationFile])
                 {
-                  RELEASE(pool);
-                  return NO;
+                    RELEASE(pool);
+                    return NO;
                 }
-	    }
-	}
-      else
-	{
-	  NSString	*s;
-
-	  s = [NSString stringWithFormat: @"cannot copy file type '%@'",
-	    fileType];
-	  ASSIGN(_lastError, s);
-	  NSLog(@"%@: %@", sourceFile, s);
-	  continue;
-	}
-      [self changeFileAttributes: attributes atPath: destinationFile];
+            }
+        }
+        else
+        {
+            NSString	*s;
+            
+            s = [NSString stringWithFormat: @"cannot copy file type '%@'",
+                 fileType];
+            ASSIGN(_lastError, s);
+            NSLog(@"%@: %@", sourceFile, s);
+            continue;
+        }
+        [self changeFileAttributes: attributes atPath: destinationFile];
     }
-  RELEASE(pool);
-
-  return YES;
+    RELEASE(pool);
+    
+    return YES;
 }
 
 - (BOOL) _linkPath: (NSString*)source
-	    toPath: (NSString*)destination
-	   handler: handler
+            toPath: (NSString*)destination
+           handler: handler
 {
 #ifdef HAVE_LINK
-  NSDirectoryEnumerator	*enumerator;
-  NSString		*dirEntry;
-  CREATE_AUTORELEASE_POOL(pool);
-
-  enumerator = [self enumeratorAtPath: source];
-  while ((dirEntry = [enumerator nextObject]))
-    {
-      NSString		*sourceFile;
-      NSString		*fileType;
-      NSString		*destinationFile;
-      NSDictionary	*attributes;
-
-      attributes = [enumerator fileAttributes];
-      fileType = [attributes fileType];
-      sourceFile = [source stringByAppendingPathComponent: dirEntry];
-      destinationFile
-	= [destination stringByAppendingPathComponent: dirEntry];
-
-      [self _sendToHandler: handler willProcessPath: sourceFile];
-
-      if ([fileType isEqual: NSFileTypeDirectory] == YES)
-	{
-	  if ([self createDirectoryAtPath: destinationFile
-			       attributes: attributes] == NO)
-	    {
-              if ([self _proceedAccordingToHandler: handler
-					  forError: _lastError
-					    inPath: destinationFile
-					  fromPath: sourceFile
-					    toPath: destinationFile] == NO)
+    NSDirectoryEnumerator *enumerator;
+    NSString *dirEntry;
+    CREATE_AUTORELEASE_POOL(pool);
+    
+    enumerator = [self enumeratorAtPath: source];
+    while ((dirEntry = [enumerator nextObject]))
+    {
+        NSString		*sourceFile;
+        NSString		*fileType;
+        NSString		*destinationFile;
+        NSDictionary	*attributes;
+        
+        attributes = [enumerator fileAttributes];
+        fileType = [attributes fileType];
+        sourceFile = [source stringByAppendingPathComponent: dirEntry];
+        destinationFile
+        = [destination stringByAppendingPathComponent: dirEntry];
+        
+        [self _sendToHandler: handler willProcessPath: sourceFile];
+        
+        if ([fileType isEqual: NSFileTypeDirectory] == YES)
+        {
+            if ([self createDirectoryAtPath: destinationFile
+                                 attributes: attributes] == NO)
+            {
+                if ([self _proceedAccordingToHandler: handler
+                                            forError: _lastError
+                                              inPath: destinationFile
+                                            fromPath: sourceFile
+                                              toPath: destinationFile] == NO)
                 {
-                  RELEASE(pool);
-                  return NO;
+                    RELEASE(pool);
+                    return NO;
                 }
-	    }
-	  else
-	    {
-	      [enumerator skipDescendents];
-	      if ([self _linkPath: sourceFile
-			   toPath: destinationFile
-			  handler: handler] == NO)
-		{
-                  RELEASE(pool);
-		  return NO;
-		}
-	    }
-	}
-      else if ([fileType isEqual: NSFileTypeSymbolicLink])
-	{
-	  NSString	*path;
-
-	  path = [self pathContentOfSymbolicLinkAtPath: sourceFile];
-	  if ([self createSymbolicLinkAtPath: destinationFile
-				 pathContent: path] == NO)
-	    {
-              if ([self _proceedAccordingToHandler: handler
-		forError: @"cannot create symbolic link"
-		inPath: sourceFile
-		fromPath: sourceFile
-		toPath: destinationFile] == NO)
+            }
+            else
+            {
+                [enumerator skipDescendents];
+                if ([self _linkPath: sourceFile toPath: destinationFile handler: handler] == NO)
                 {
-                  RELEASE(pool);
-                  return NO;
+                    RELEASE(pool);
+                    return NO;
                 }
-	    }
-	}
-      else
-	{
-	  if (link([self fileSystemRepresentationWithPath: sourceFile],
-	    [self fileSystemRepresentationWithPath: destinationFile]) < 0)
-	    {
-              if ([self _proceedAccordingToHandler: handler
-		forError: @"cannot create hard link"
-		inPath: sourceFile
-		fromPath: sourceFile
-		toPath: destinationFile] == NO)
+            }
+        }
+        else if ([fileType isEqual: NSFileTypeSymbolicLink])
+        {
+            NSString	*path;
+            
+            path = [self pathContentOfSymbolicLinkAtPath: sourceFile];
+            if ([self createSymbolicLinkAtPath: destinationFile
+                                   pathContent: path] == NO)
+            {
+                if ([self _proceedAccordingToHandler: handler
+                                            forError: @"cannot create symbolic link"
+                                              inPath: sourceFile
+                                            fromPath: sourceFile
+                                              toPath: destinationFile] == NO)
                 {
-                  RELEASE(pool);
-                  return NO;
+                    RELEASE(pool);
+                    return NO;
                 }
-	    }
-	}
-      [self changeFileAttributes: attributes atPath: destinationFile];
+            }
+        }
+        else
+        {
+            if (link([self fileSystemRepresentationWithPath: sourceFile],
+                     [self fileSystemRepresentationWithPath: destinationFile]) < 0)
+            {
+                if ([self _proceedAccordingToHandler: handler
+                                            forError: @"cannot create hard link"
+                                              inPath: sourceFile
+                                            fromPath: sourceFile
+                                              toPath: destinationFile] == NO)
+                {
+                    RELEASE(pool);
+                    return NO;
+                }
+            }
+        }
+        [self changeFileAttributes: attributes atPath: destinationFile];
     }
-  RELEASE(pool);
-  return YES;
+    RELEASE(pool);
+    return YES;
 #else
-  ASSIGN(_lastError, @"Links not supported on this platform");
-  return NO;
+    ASSIGN(_lastError, @"Links not supported on this platform");
+    return NO;
 #endif
 }
 
 - (void) _sendToHandler: (id) handler
         willProcessPath: (NSString*) path
 {
-  if ([handler respondsToSelector: @selector (fileManager:willProcessPath:)])
+    if ([handler respondsToSelector: @selector (fileManager:willProcessPath:)])
     {
-      [handler fileManager: self willProcessPath: path];
+        [handler fileManager: self willProcessPath: path];
     }
 }
 
@@ -2985,16 +2993,15 @@ static inline void gsedRelease(GSEnumeratedDirectory X)
                            forError: (NSString*) error
                              inPath: (NSString*) path
 {
-  if ([handler respondsToSelector:
-    @selector (fileManager:shouldProceedAfterError:)])
+    if ([handler respondsToSelector:@selector(fileManager:shouldProceedAfterError:)])
     {
-      NSDictionary *errorInfo = [NSDictionary dictionaryWithObjectsAndKeys:
-                                                path, NSFilePathErrorKey,
-                                              error, @"Error", nil];
-      return [handler fileManager: self
-	  shouldProceedAfterError: errorInfo];
+        
+        NSDictionary *errorInfo = [NSDictionary dictionaryWithObjectsAndKeys:
+                                   path, NSFilePathErrorKey,
+                                   error, @"Error", nil];
+        return [handler fileManager:self shouldProceedAfterError:errorInfo];
     }
-  return NO;
+    return NO;
 }
 
 - (BOOL) _proceedAccordingToHandler: (id) handler
@@ -3003,565 +3010,563 @@ static inline void gsedRelease(GSEnumeratedDirectory X)
                            fromPath: (NSString*) fromPath
                              toPath: (NSString*) toPath
 {
-  if ([handler respondsToSelector:
-    @selector (fileManager:shouldProceedAfterError:)])
+    if ([handler respondsToSelector:@selector(fileManager:shouldProceedAfterError:)])
     {
-      NSDictionary *errorInfo = [NSDictionary dictionaryWithObjectsAndKeys:
-                                                path, NSFilePathErrorKey,
-                                              fromPath, @"FromPath",
-                                              toPath, @"ToPath",
-                                              error, @"Error", nil];
-      return [handler fileManager: self
-	  shouldProceedAfterError: errorInfo];
+        NSDictionary *errorInfo = [NSDictionary dictionaryWithObjectsAndKeys:
+                                   path, NSFilePathErrorKey,
+                                   fromPath, @"FromPath",
+                                   toPath, @"ToPath",
+                                   error, @"Error", nil];
+        return [handler fileManager:self shouldProceedAfterError:errorInfo];
     }
-  return NO;
+    return NO;
 }
 
 - (NSError*) _errorFrom: (NSString *)fromPath to: (NSString *)toPath
 {
-  NSError       *error;
-  NSDictionary  *errorInfo;
-  NSString      *message;
-  NSString      *domain;
-  NSInteger     code;
-
-  if (_lastError)
+    NSError       *error;
+    NSDictionary  *errorInfo;
+    NSString      *message;
+    NSString      *domain;
+    NSInteger     code;
+    
+    if (_lastError)
     {
-      message = _lastError;
-      domain = NSCocoaErrorDomain;
-      code = 0;
+        message = _lastError;
+        domain = NSCocoaErrorDomain;
+        code = 0;
     }
-  else
+    else
     {
-      error = [NSError _last];
-      message = [error localizedDescription];
-      domain = [error domain];
-      code = [error code];
+        error = [NSError _last];
+        message = [error localizedDescription];
+        domain = [error domain];
+        code = [error code];
     }
-
-  if (fromPath && toPath)
+    
+    if (fromPath && toPath)
     {
-      errorInfo = [NSDictionary dictionaryWithObjectsAndKeys:
-        fromPath, @"FromPath",
-        toPath, @"ToPath",
-        message, NSLocalizedDescriptionKey,
-        nil];
+        errorInfo = [NSDictionary dictionaryWithObjectsAndKeys:
+                     fromPath, @"FromPath",
+                     toPath, @"ToPath",
+                     message, NSLocalizedDescriptionKey,
+                     nil];
     }
-  else if (fromPath)
+    else if (fromPath)
     {
-      errorInfo = [NSDictionary dictionaryWithObjectsAndKeys:
-        fromPath, NSFilePathErrorKey,
-        message, NSLocalizedDescriptionKey,
-        nil];      
+        errorInfo = [NSDictionary dictionaryWithObjectsAndKeys:
+                     fromPath, NSFilePathErrorKey,
+                     message, NSLocalizedDescriptionKey,
+                     nil];      
     }
-  else
+    else
     {
-      errorInfo = [NSDictionary dictionaryWithObjectsAndKeys:
-        message, NSLocalizedDescriptionKey,
-        nil];      
+        errorInfo = [NSDictionary dictionaryWithObjectsAndKeys:
+                     message, NSLocalizedDescriptionKey,
+                     nil];      
     }
-
-  error = [NSError errorWithDomain: domain
-                              code: code
-                          userInfo: errorInfo];
-  DESTROY(_lastError);
-  return error;
+    
+    error = [NSError errorWithDomain: domain
+                                code: code
+                            userInfo: errorInfo];
+    DESTROY(_lastError);
+    return error;
 }
 
 @end /* NSFileManager (PrivateMethods) */
 
-
+
 
 @implementation	GSAttrDictionary
 
 static NSSet	*fileKeys = nil;
 
 + (NSDictionary*) attributesAt: (const _CHAR*)lpath
-		  traverseLink: (BOOL)traverse
+                  traverseLink: (BOOL)traverse
 {
-  GSAttrDictionary	*d;
-  unsigned		l = 0;
-  unsigned		i;
-
-  if (lpath == 0 || *lpath == 0)
+    GSAttrDictionary	*d;
+    unsigned		l = 0;
+    unsigned		i;
+    
+    if (lpath == 0 || *lpath == 0)
     {
-      return nil;
+        return nil;
     }
-  while (lpath[l] != 0)
+    while (lpath[l] != 0)
     {
-      l++;
+        l++;
     }
-  d = (GSAttrDictionary*)NSAllocateObject(self, (l+1)*sizeof(_CHAR),
-    NSDefaultMallocZone());
-
+    d = (GSAttrDictionary*)NSAllocateObject(self, (l+1)*sizeof(_CHAR),
+                                            NSDefaultMallocZone());
+    
 #if defined(S_IFLNK) && !defined(__MINGW__)
-  if (traverse == NO)
+    if (traverse == NO)
     {
-      if (lstat(lpath, &d->statbuf) != 0)
-	{
-	  DESTROY(d);
-	}
+        if (lstat(lpath, &d->statbuf) != 0)
+        {
+            DESTROY(d);
+        }
     }
-  else
+    else
 #endif
-  if (_STAT(lpath, &d->statbuf) != 0)
-    {
-      DESTROY(d);
-    }
-  if (d != nil)
+        if (_STAT(lpath, &d->statbuf) != 0)
+        {
+            DESTROY(d);
+        }
+    if (d != nil)
     {
-      for (i = 0; i <= l; i++)
-	{
-	  d->_path[i] = lpath[i];
-	}
+        for (i = 0; i <= l; i++)
+        {
+            d->_path[i] = lpath[i];
+        }
     }
-  return AUTORELEASE(d);
+    return AUTORELEASE(d);
 }
 
 + (void) initialize
 {
-  if (fileKeys == nil)
-    {
-      fileKeys = [[NSSet alloc] initWithObjects:
-	NSFileAppendOnly,
-	NSFileCreationDate,
-	NSFileDeviceIdentifier,
-	NSFileExtensionHidden,
-	NSFileGroupOwnerAccountName,
-	NSFileGroupOwnerAccountID,
-	NSFileHFSCreatorCode,
-	NSFileHFSTypeCode,
-	NSFileImmutable,
-	NSFileModificationDate,
-	NSFileOwnerAccountName,
-	NSFileOwnerAccountID,
-	NSFilePosixPermissions,
-	NSFileReferenceCount,
-	NSFileSize,
-	NSFileSystemFileNumber,
-	NSFileSystemNumber,
-	NSFileType,
-	nil];
+    if (fileKeys == nil)
+    {
+        fileKeys = [[NSSet alloc] initWithObjects:
+                    NSFileAppendOnly,
+                    NSFileCreationDate,
+                    NSFileDeviceIdentifier,
+                    NSFileExtensionHidden,
+                    NSFileGroupOwnerAccountName,
+                    NSFileGroupOwnerAccountID,
+                    NSFileHFSCreatorCode,
+                    NSFileHFSTypeCode,
+                    NSFileImmutable,
+                    NSFileModificationDate,
+                    NSFileOwnerAccountName,
+                    NSFileOwnerAccountID,
+                    NSFilePosixPermissions,
+                    NSFileReferenceCount,
+                    NSFileSize,
+                    NSFileSystemFileNumber,
+                    NSFileSystemNumber,
+                    NSFileType,
+                    nil];
     }
 }
 
 - (NSUInteger) count
 {
-  return [fileKeys count];
+    return [fileKeys count];
 }
 
 - (NSDate*) fileCreationDate
 {
-  /*
-   * FIXME ... not sure there is any way to get a creation date :-(
-   * Use the earlier of ctime or mtime
-   */
-  if (statbuf.st_ctime < statbuf.st_mtime)
-    return [NSDate dateWithTimeIntervalSince1970: statbuf.st_ctime];
-  else
-    return [NSDate dateWithTimeIntervalSince1970: statbuf.st_mtime];
+    /*
+     * FIXME ... not sure there is any way to get a creation date :-(
+     * Use the earlier of ctime or mtime
+     */
+    if (statbuf.st_ctime < statbuf.st_mtime)
+        return [NSDate dateWithTimeIntervalSince1970: statbuf.st_ctime];
+    else
+        return [NSDate dateWithTimeIntervalSince1970: statbuf.st_mtime];
 }
 
 - (BOOL) fileExtensionHidden
 {
-  return NO;
+    return NO;
 }
 
 - (NSNumber*) fileGroupOwnerAccountID
 {
-  return [NSNumber numberWithInt: statbuf.st_gid];
+    return [NSNumber numberWithInt: statbuf.st_gid];
 }
 
 - (NSString*) fileGroupOwnerAccountName
 {
-  NSString	*group = @"UnknownGroup";
-
+    NSString	*group = @"UnknownGroup";
+    
 #if	defined(__MINGW__)
-  DWORD		returnCode = 0;
-  PSID		sidOwner;
-  int		result = TRUE;
-  _CHAR		account[BUFSIZ];
-  _CHAR		domain[BUFSIZ];
-  DWORD		accountSize = 1024;
-  DWORD		domainSize = 1024;
-  SID_NAME_USE	eUse = SidTypeUnknown;
-  HANDLE	hFile;
-  PSECURITY_DESCRIPTOR pSD;
-
-  // Get the handle of the file object.
-  hFile = CreateFileW(
-    _path,
-    GENERIC_READ,
-    FILE_SHARE_READ,
-    0,
-    OPEN_EXISTING,
-    FILE_FLAG_BACKUP_SEMANTICS,
-    0);
-
-  // Check GetLastError for CreateFile error code.
-  if (hFile == INVALID_HANDLE_VALUE)
-    {
-      DWORD dwErrorCode = 0;
-
-      dwErrorCode = GetLastError();
-      NSDebugMLog(@"Error %d getting file handle for '%S'",
-        dwErrorCode, _path);
-      return group;
-    }
-
-  // Get the group SID of the file.
-  returnCode = GetSecurityInfo(
-    hFile,
-    SE_FILE_OBJECT,
-    GROUP_SECURITY_INFORMATION,
-    0,
-    &sidOwner,
-    0,
-    0,
-    &pSD);
-
-  CloseHandle(hFile);
-
-  // Check GetLastError for GetSecurityInfo error condition.
-  if (returnCode != ERROR_SUCCESS)
-    {
-      DWORD dwErrorCode = 0;
-
-      dwErrorCode = GetLastError();
-      NSDebugMLog(@"Error %d getting security info for '%S'",
-        dwErrorCode, _path);
-      return group;
-    }
-
-  // First call to LookupAccountSid to get the buffer sizes.
-  result = LookupAccountSidW(
-    0,           // local computer
-    sidOwner,
-    account,
-    (LPDWORD)&accountSize,
-    domain,
-    (LPDWORD)&domainSize,
-    &eUse);
-
-  // Check GetLastError for LookupAccountSid error condition.
-  if (result == FALSE)
-    {
-      DWORD dwErrorCode = 0;
-
-      dwErrorCode = GetLastError();
-      if (dwErrorCode == ERROR_NONE_MAPPED)
-	NSDebugMLog(@"Error %d in LookupAccountSid for '%S'", _path);
-      else
+    DWORD		returnCode = 0;
+    PSID		sidOwner;
+    int                 result = TRUE;
+    _CHAR		account[BUFSIZ];
+    _CHAR		domain[BUFSIZ];
+    DWORD		accountSize = 1024;
+    DWORD		domainSize = 1024;
+    SID_NAME_USE	eUse = SidTypeUnknown;
+    HANDLE	hFile;
+    PSECURITY_DESCRIPTOR pSD;
+    
+    // Get the handle of the file object.
+    hFile = CreateFileW(
+                        _path,
+                        GENERIC_READ,
+                        FILE_SHARE_READ,
+                        0,
+                        OPEN_EXISTING,
+                        FILE_FLAG_BACKUP_SEMANTICS,
+                        0);
+    
+    // Check GetLastError for CreateFile error code.
+    if (hFile == INVALID_HANDLE_VALUE)
+    {
+        DWORD dwErrorCode = 0;
+        
+        dwErrorCode = GetLastError();
+        NSDebugMLog(@"Error %d getting file handle for '%S'",
+                    dwErrorCode, _path);
+        return group;
+    }
+    
+    // Get the group SID of the file.
+    returnCode = GetSecurityInfo(
+                                 hFile,
+                                 SE_FILE_OBJECT,
+                                 GROUP_SECURITY_INFORMATION,
+                                 0,
+                                 &sidOwner,
+                                 0,
+                                 0,
+                                 &pSD);
+    
+    CloseHandle(hFile);
+    
+    // Check GetLastError for GetSecurityInfo error condition.
+    if (returnCode != ERROR_SUCCESS)
+    {
+        DWORD dwErrorCode = 0;
+        
+        dwErrorCode = GetLastError();
         NSDebugMLog(@"Error %d getting security info for '%S'",
-          dwErrorCode, _path);
-      return group;
-    }
-
-  if (accountSize >= 1024)
-    {
-      NSDebugMLog(@"Account name for '%S' is unreasonably long", _path);
-      return group;
-    }
-  return [NSString stringWithCharacters: account length: accountSize];
+                    dwErrorCode, _path);
+        return group;
+    }
+    
+    // First call to LookupAccountSid to get the buffer sizes.
+    result = LookupAccountSidW(
+                               0,           // local computer
+                               sidOwner,
+                               account,
+                               (LPDWORD)&accountSize,
+                               domain,
+                               (LPDWORD)&domainSize,
+                               &eUse);
+    
+    // Check GetLastError for LookupAccountSid error condition.
+    if (result == FALSE)
+    {
+        DWORD dwErrorCode = 0;
+        
+        dwErrorCode = GetLastError();
+        if (dwErrorCode == ERROR_NONE_MAPPED)
+            NSDebugMLog(@"Error %d in LookupAccountSid for '%S'", _path);
+        else
+            NSDebugMLog(@"Error %d getting security info for '%S'",
+                        dwErrorCode, _path);
+        return group;
+    }
+    
+    if (accountSize >= 1024)
+    {
+        NSDebugMLog(@"Account name for '%S' is unreasonably long", _path);
+        return group;
+    }
+    return [NSString stringWithCharacters: account length: accountSize];
 #else
 #if defined(HAVE_GRP_H)
 #if defined(HAVE_GETGRGID_H)
-  struct group gp;
-  struct group *p;
-  char buf[BUFSIZ*10];
-
-  if (getgrgid_r(statbuf.st_gid, &gp, buf, sizeof(buf), &p) == 0)
+    struct group gp;
+    struct group *p;
+    char buf[BUFSIZ*10];
+    
+    if (getgrgid_r(statbuf.st_gid, &gp, buf, sizeof(buf), &p) == 0)
     {
-      group = [NSString stringWithCString: gp.gr_name
-				 encoding: defaultEncoding];
+        group = [NSString stringWithCString: gp.gr_name
+                                   encoding: defaultEncoding];
     }
 #else
 #if defined(HAVE_GETGRGID)
-  struct group	*gp;
-
-  [gnustep_global_lock lock];
-  gp = getgrgid(statbuf.st_gid);
-  if (gp != 0)
+    struct group	*gp;
+    
+    [gnustep_global_lock lock];
+    gp = getgrgid(statbuf.st_gid);
+    if (gp != 0)
     {
-      group = [NSString stringWithCString: gp->gr_name
-				 encoding: defaultEncoding];
+        group = [NSString stringWithCString: gp->gr_name
+                                   encoding: defaultEncoding];
     }
-  [gnustep_global_lock unlock];
+    [gnustep_global_lock unlock];
 #endif
 #endif
 #endif
 #endif
-  return group;
+    return group;
 }
 
 - (OSType) fileHFSCreatorCode
 {
-  return 0;
+    return 0;
 }
 
 - (OSType) fileHFSTypeCode
 {
-  return 0;
+    return 0;
 }
 
 - (BOOL) fileIsAppendOnly
 {
-  return 0;
+    return 0;
 }
 
 - (BOOL) fileIsImmutable
 {
-  return 0;
+    return 0;
 }
 
 - (NSDate*) fileModificationDate
 {
-  return [NSDate dateWithTimeIntervalSince1970: statbuf.st_mtime];
+    return [NSDate dateWithTimeIntervalSince1970: statbuf.st_mtime];
 }
 
 - (NSUInteger) filePosixPermissions
 {
-  return (statbuf.st_mode & ~S_IFMT);
+    return (statbuf.st_mode & ~S_IFMT);
 }
 
 - (NSNumber*) fileOwnerAccountID
 {
-  return [NSNumber numberWithInt: statbuf.st_uid];
+    return [NSNumber numberWithInt: statbuf.st_uid];
 }
 
 - (NSString*) fileOwnerAccountName
 {
-  NSString	*owner = @"UnknownUser";
-
+    NSString	*owner = @"UnknownUser";
+    
 #if	defined(__MINGW__)
-  DWORD		returnCode = 0;
-  PSID		sidOwner;
-  int		result = TRUE;
-  _CHAR		account[BUFSIZ];
-  _CHAR		domain[BUFSIZ];
-  DWORD		accountSize = 1024;
-  DWORD		domainSize = 1024;
-  SID_NAME_USE	eUse = SidTypeUnknown;
-  HANDLE	hFile;
-  PSECURITY_DESCRIPTOR pSD;
-
-  // Get the handle of the file object.
-  hFile = CreateFileW(
-    _path,
-    GENERIC_READ,
-    FILE_SHARE_READ,
-    0,
-    OPEN_EXISTING,
-    FILE_FLAG_BACKUP_SEMANTICS,
-    0);
-
-  // Check GetLastError for CreateFile error code.
-  if (hFile == INVALID_HANDLE_VALUE)
-    {
-      DWORD dwErrorCode = 0;
-
-      dwErrorCode = GetLastError();
-      NSDebugMLog(@"Error %d getting file handle for '%S'",
-        dwErrorCode, _path);
-      return owner;
-    }
-
-  // Get the owner SID of the file.
-  returnCode = GetSecurityInfo(
-    hFile,
-    SE_FILE_OBJECT,
-    OWNER_SECURITY_INFORMATION,
-    &sidOwner,
-    0,
-    0,
-    0,
-    &pSD);
-
-  CloseHandle(hFile);
-
-  // Check GetLastError for GetSecurityInfo error condition.
-  if (returnCode != ERROR_SUCCESS)
-    {
-      DWORD dwErrorCode = 0;
-
-      dwErrorCode = GetLastError();
-      NSDebugMLog(@"Error %d getting security info for '%S'",
-        dwErrorCode, _path);
-      return owner;
-    }
-
-  // First call to LookupAccountSid to get the buffer sizes.
-  result = LookupAccountSidW(
-    0,           // local computer
-    sidOwner,
-    account,
-    (LPDWORD)&accountSize,
-    domain,
-    (LPDWORD)&domainSize,
-    &eUse);
-
-  // Check GetLastError for LookupAccountSid error condition.
-  if (result == FALSE)
-    {
-      DWORD dwErrorCode = 0;
-
-      dwErrorCode = GetLastError();
-      if (dwErrorCode == ERROR_NONE_MAPPED)
-	NSDebugMLog(@"Error %d in LookupAccountSid for '%S'", _path);
-      else
+    DWORD		returnCode = 0;
+    PSID		sidOwner;
+    int                 result = TRUE;
+    _CHAR		account[BUFSIZ];
+    _CHAR		domain[BUFSIZ];
+    DWORD		accountSize = 1024;
+    DWORD		domainSize = 1024;
+    SID_NAME_USE	eUse = SidTypeUnknown;
+    HANDLE	hFile;
+    PSECURITY_DESCRIPTOR pSD;
+    
+    // Get the handle of the file object.
+    hFile = CreateFileW(
+                        _path,
+                        GENERIC_READ,
+                        FILE_SHARE_READ,
+                        0,
+                        OPEN_EXISTING,
+                        FILE_FLAG_BACKUP_SEMANTICS,
+                        0);
+    
+    // Check GetLastError for CreateFile error code.
+    if (hFile == INVALID_HANDLE_VALUE)
+    {
+        DWORD dwErrorCode = 0;
+        
+        dwErrorCode = GetLastError();
+        NSDebugMLog(@"Error %d getting file handle for '%S'",
+                    dwErrorCode, _path);
+        return owner;
+    }
+    
+    // Get the owner SID of the file.
+    returnCode = GetSecurityInfo(
+                                 hFile,
+                                 SE_FILE_OBJECT,
+                                 OWNER_SECURITY_INFORMATION,
+                                 &sidOwner,
+                                 0,
+                                 0,
+                                 0,
+                                 &pSD);
+    
+    CloseHandle(hFile);
+    
+    // Check GetLastError for GetSecurityInfo error condition.
+    if (returnCode != ERROR_SUCCESS)
+    {
+        DWORD dwErrorCode = 0;
+        
+        dwErrorCode = GetLastError();
         NSDebugMLog(@"Error %d getting security info for '%S'",
-          dwErrorCode, _path);
-      return owner;
-    }
-
-  if (accountSize >= 1024)
-    {
-      NSDebugMLog(@"Account name for '%S' is unreasonably long", _path);
-      return owner;
-    }
-  return [NSString stringWithCharacters: account length: accountSize];
+                    dwErrorCode, _path);
+        return owner;
+    }
+    
+    // First call to LookupAccountSid to get the buffer sizes.
+    result = LookupAccountSidW(
+                               0,           // local computer
+                               sidOwner,
+                               account,
+                               (LPDWORD)&accountSize,
+                               domain,
+                               (LPDWORD)&domainSize,
+                               &eUse);
+    
+    // Check GetLastError for LookupAccountSid error condition.
+    if (result == FALSE)
+    {
+        DWORD dwErrorCode = 0;
+        
+        dwErrorCode = GetLastError();
+        if (dwErrorCode == ERROR_NONE_MAPPED)
+            NSDebugMLog(@"Error %d in LookupAccountSid for '%S'", _path);
+        else
+            NSDebugMLog(@"Error %d getting security info for '%S'",
+                        dwErrorCode, _path);
+        return owner;
+    }
+    
+    if (accountSize >= 1024)
+    {
+        NSDebugMLog(@"Account name for '%S' is unreasonably long", _path);
+        return owner;
+    }
+    return [NSString stringWithCharacters: account length: accountSize];
 #else
 #ifdef HAVE_PWD_H
 #if     defined(HAVE_GETPWUID_R)
-  struct passwd pw;
-  struct passwd *p;
-  char buf[BUFSIZ*10];
-
-  if (getpwuid_r(statbuf.st_uid, &pw, buf, sizeof(buf), &p) == 0)
+    struct passwd pw;
+    struct passwd *p;
+    char buf[BUFSIZ*10];
+    
+    if (getpwuid_r(statbuf.st_uid, &pw, buf, sizeof(buf), &p) == 0)
     {
-      owner = [NSString stringWithCString: pw.pw_name
-				 encoding: defaultEncoding];
+        owner = [NSString stringWithCString: pw.pw_name
+                                   encoding: defaultEncoding];
     }
 #else
 #if     defined(HAVE_GETPWUID)
-  struct passwd *pw;
-
-  [gnustep_global_lock lock];
-  pw = getpwuid(statbuf.st_uid);
-  if (pw != 0)
+    struct passwd *pw;
+    
+    [gnustep_global_lock lock];
+    pw = getpwuid(statbuf.st_uid);
+    if (pw != 0)
     {
-      owner = [NSString stringWithCString: pw->pw_name
-				 encoding: defaultEncoding];
+        owner = [NSString stringWithCString: pw->pw_name
+                                   encoding: defaultEncoding];
     }
-  [gnustep_global_lock unlock];
+    [gnustep_global_lock unlock];
 #endif
 #endif
 #endif /* HAVE_PWD_H */
 #endif
-  return owner;
+    return owner;
 }
 
 - (unsigned long long) fileSize
 {
-  return statbuf.st_size;
+    return statbuf.st_size;
 }
 
 - (NSUInteger) fileSystemFileNumber
 {
-  return statbuf.st_ino;
+    return statbuf.st_ino;
 }
 
 - (NSUInteger) fileSystemNumber
 {
 #if defined(__MINGW__)
-  DWORD volumeSerialNumber = 0;
-  _CHAR volumePathName[128];
-  if (GetVolumePathNameW(_path,volumePathName,128))
-  {
-    GetVolumeInformationW(volumePathName,NULL,0,&volumeSerialNumber,NULL,NULL,NULL,0);
-  }
-
-  return (NSUInteger)volumeSerialNumber;
+    DWORD volumeSerialNumber = 0;
+    _CHAR volumePathName[128];
+    if (GetVolumePathNameW(_path,volumePathName,128))
+    {
+        GetVolumeInformationW(volumePathName,NULL,0,&volumeSerialNumber,NULL,NULL,NULL,0);
+    }
+    
+    return (NSUInteger)volumeSerialNumber;
 #else
-  return statbuf.st_dev;
+    return statbuf.st_dev;
 #endif
 }
 
 - (NSString*) fileType
 {
-  switch (statbuf.st_mode & S_IFMT)
+    switch (statbuf.st_mode & S_IFMT)
     {
-      case S_IFREG: return NSFileTypeRegular;
-      case S_IFDIR: return NSFileTypeDirectory;
-      case S_IFCHR: return NSFileTypeCharacterSpecial;
-      case S_IFBLK: return NSFileTypeBlockSpecial;
+        case S_IFREG: return NSFileTypeRegular;
+        case S_IFDIR: return NSFileTypeDirectory;
+        case S_IFCHR: return NSFileTypeCharacterSpecial;
+        case S_IFBLK: return NSFileTypeBlockSpecial;
 #ifdef S_IFLNK
-      case S_IFLNK: return NSFileTypeSymbolicLink;
+        case S_IFLNK: return NSFileTypeSymbolicLink;
 #endif
-      case S_IFIFO: return NSFileTypeFifo;
+        case S_IFIFO: return NSFileTypeFifo;
 #ifdef S_IFSOCK
-      case S_IFSOCK: return NSFileTypeSocket;
+        case S_IFSOCK: return NSFileTypeSocket;
 #endif
-      default: return NSFileTypeUnknown;
+        default: return NSFileTypeUnknown;
     }
 }
 
 - (NSEnumerator*) keyEnumerator
 {
-  return [fileKeys objectEnumerator];
+    return [fileKeys objectEnumerator];
 }
 
 - (NSEnumerator*) objectEnumerator
 {
-  return [GSAttrDictionaryEnumerator enumeratorFor: self];
+    return [GSAttrDictionaryEnumerator enumeratorFor: self];
 }
 
 - (id) objectForKey: (id)key
 {
-  int	count = 0;
-
-  while (key != 0 && count < 2)
-    {
-      if (key == NSFileAppendOnly)
-	return [NSNumber numberWithBool: [self fileIsAppendOnly]];
-      if (key == NSFileCreationDate)
-	return [self fileCreationDate];
-      if (key == NSFileDeviceIdentifier)
-	return [NSNumber numberWithUnsignedInt: statbuf.st_dev];
-      if (key == NSFileExtensionHidden)
-	return [NSNumber numberWithBool: [self fileExtensionHidden]];
-      if (key == NSFileGroupOwnerAccountName)
-	return [self fileGroupOwnerAccountName];
-      if (key == NSFileGroupOwnerAccountID)
-	return [self fileGroupOwnerAccountID];
-      if (key == NSFileHFSCreatorCode)
-	return [NSNumber numberWithUnsignedLong: [self fileHFSCreatorCode]];
-      if (key == NSFileHFSTypeCode)
-	return [NSNumber numberWithUnsignedLong: [self fileHFSTypeCode]];
-      if (key == NSFileImmutable)
-	return [NSNumber numberWithBool: [self fileIsImmutable]];
-      if (key == NSFileModificationDate)
-	return [self fileModificationDate];
-      if (key == NSFileOwnerAccountName)
-	return [self fileOwnerAccountName];
-      if (key == NSFileOwnerAccountID)
-	return [self fileOwnerAccountID];
-      if (key == NSFilePosixPermissions)
-	return [NSNumber numberWithUnsignedInt: [self filePosixPermissions]];
-      if (key == NSFileReferenceCount)
-	return [NSNumber numberWithUnsignedInt: statbuf.st_nlink];
-      if (key == NSFileSize)
-	return [NSNumber numberWithUnsignedLongLong: [self fileSize]];
-      if (key == NSFileSystemFileNumber)
-	return [NSNumber numberWithUnsignedInt: [self fileSystemFileNumber]];
-      if (key == NSFileSystemNumber)
-	return [NSNumber numberWithUnsignedInt: [self fileSystemNumber]];
-      if (key == NSFileType)
-	return [self fileType];
-
-      /*
-       * Now, if we didn't get an exact pointer match, check for
-       * string equalities and ensure we get an exact match next
-       * time round the loop.
-       */
-      count++;
-      key = [fileKeys member: key];
-    }
-  if (count >= 2)
-    {
-      NSLog(@"Warning ... key '%@' not handled", key);
-    }
-  return nil;
+    int	count = 0;
+    
+    while (key != 0 && count < 2)
+    {
+        if (key == NSFileAppendOnly)
+            return [NSNumber numberWithBool: [self fileIsAppendOnly]];
+        if (key == NSFileCreationDate)
+            return [self fileCreationDate];
+        if (key == NSFileDeviceIdentifier)
+            return [NSNumber numberWithInteger: statbuf.st_dev];
+        if (key == NSFileExtensionHidden)
+            return [NSNumber numberWithBool: [self fileExtensionHidden]];
+        if (key == NSFileGroupOwnerAccountName)
+            return [self fileGroupOwnerAccountName];
+        if (key == NSFileGroupOwnerAccountID)
+            return [self fileGroupOwnerAccountID];
+        if (key == NSFileHFSCreatorCode)
+            return [NSNumber numberWithUnsignedLong: [self fileHFSCreatorCode]];
+        if (key == NSFileHFSTypeCode)
+            return [NSNumber numberWithUnsignedLong: [self fileHFSTypeCode]];
+        if (key == NSFileImmutable)
+            return [NSNumber numberWithBool: [self fileIsImmutable]];
+        if (key == NSFileModificationDate)
+            return [self fileModificationDate];
+        if (key == NSFileOwnerAccountName)
+            return [self fileOwnerAccountName];
+        if (key == NSFileOwnerAccountID)
+            return [self fileOwnerAccountID];
+        if (key == NSFilePosixPermissions)
+            return [NSNumber numberWithUnsignedInteger: [self filePosixPermissions]];
+        if (key == NSFileReferenceCount)
+            return [NSNumber numberWithInteger: statbuf.st_nlink];
+        if (key == NSFileSize)
+            return [NSNumber numberWithUnsignedLongLong: [self fileSize]];
+        if (key == NSFileSystemFileNumber)
+            return [NSNumber numberWithUnsignedInteger: [self fileSystemFileNumber]];
+        if (key == NSFileSystemNumber)
+            return [NSNumber numberWithUnsignedInteger: [self fileSystemNumber]];
+        if (key == NSFileType)
+            return [self fileType];
+        
+        /*
+         * Now, if we didn't get an exact pointer match, check for
+         * string equalities and ensure we get an exact match next
+         * time round the loop.
+         */
+        count++;
+        key = [fileKeys member: key];
+    }
+    if (count >= 2)
+    {
+        NSLog(@"Warning ... key '%@' not handled", key);
+    }
+    return nil;
 }
 
 @end	/* GSAttrDictionary */
@@ -3569,32 +3574,32 @@ static NSSet	*fileKeys = nil;
 @implementation	GSAttrDictionaryEnumerator
 + (NSEnumerator*) enumeratorFor: (NSDictionary*)d
 {
-  GSAttrDictionaryEnumerator	*e;
-
-  e = (GSAttrDictionaryEnumerator*)
+    GSAttrDictionaryEnumerator	*e;
+    
+    e = (GSAttrDictionaryEnumerator*)
     NSAllocateObject(self, 0, NSDefaultMallocZone());
-  e->dictionary = RETAIN(d);
-  e->enumerator = RETAIN([fileKeys objectEnumerator]);
-  return AUTORELEASE(e);
+    e->dictionary = RETAIN(d);
+    e->enumerator = RETAIN([fileKeys objectEnumerator]);
+    return AUTORELEASE(e);
 }
 
 - (void) dealloc
 {
-  RELEASE(enumerator);
-  RELEASE(dictionary);
-  [super dealloc];
+    RELEASE(enumerator);
+    RELEASE(dictionary);
+    [super dealloc];
 }
 
 - (id) nextObject
 {
-  NSString	*key = [enumerator nextObject];
-  id		val = nil;
-
-  if (key != nil)
+    NSString	*key = [enumerator nextObject];
+    id		val = nil;
+    
+    if (key != nil)
     {
-      val = [dictionary objectForKey: key];
+        val = [dictionary objectForKey: key];
     }
-  return val;
+    return val;
 }
 @end
 
diff --git a/Source/NSHTTPCookie.m b/Source/NSHTTPCookie.m
index a800ebe..8cacdaa 100644
--- a/Source/NSHTTPCookie.m
+++ b/Source/NSHTTPCookie.m
@@ -40,10 +40,14 @@
 #import "common.h"
 #define	EXPOSE_NSHTTPCookie_IVARS	1
 #import "GSURLPrivate.h"
+
+#import "Foundation/NSBundle.h"
+#import "Foundation/NSCalendarDate.h"
+#import "Foundation/NSError.h"
 #import "Foundation/NSSet.h"
-#import "Foundation/NSValue.h"
 #import "Foundation/NSString.h"
-#import "Foundation/NSCalendarDate.h"
+#import "Foundation/NSValue.h"
+
 #import "GNUstepBase/Unicode.h"
 #import "GNUstepBase/NSObject+GNUstepBase.h"
 
@@ -113,7 +117,7 @@ static const unsigned char whitespace[32] = {
 
 #define GS_IS_WHITESPACE(X) IS_BIT_SET(whitespace[(X)/8], (X) % 8)
 
-static id GSPropertyListFromCookieFormat(NSString *string, int version);
+static id GSPropertyListFromCookieFormat(NSString *string, NSInteger version, NSError **error);
 static NSRange GSRangeOfCookie(NSString *string);
 
 @implementation NSHTTPCookie
@@ -138,8 +142,8 @@ static NSRange GSRangeOfCookie(NSString *string);
 }
 
 + (NSMutableArray *) _parseField: (NSString *)field 
-		       forHeader: (NSString *)header
-			  andURL: (NSURL *)url
+                       forHeader: (NSString *)header
+                          andURL: (NSURL *)url
 {
   int version;
   NSString *defaultPath, *defaultDomain;
@@ -166,16 +170,17 @@ static NSRange GSRangeOfCookie(NSString *string);
       NSHTTPCookie *cookie;
       NSMutableDictionary *dict;
       NSString *onecookie;
+      NSError *error;
       NSRange range = GSRangeOfCookie(field);
 
       if (range.location == NSNotFound)
 	break;
       onecookie = [field substringWithRange: range];
-      NS_DURING
-	dict = GSPropertyListFromCookieFormat(onecookie, version);
-      NS_HANDLER
-	dict = nil;
-      NS_ENDHANDLER
+      dict = GSPropertyListFromCookieFormat(onecookie, version, &error);
+      if (!dict)
+      {
+        NSLog(@"%@\nCookie string:\n%@", error, onecookie);
+      }
       if ([dict count])
 	{
 	  if ([dict objectForKey: NSHTTPCookiePath] == nil)
@@ -214,7 +219,7 @@ static NSRange GSRangeOfCookie(NSString *string);
 
 + (NSDictionary *) requestHeaderFieldsWithCookies: (NSArray *)cookies
 {
-  int version;
+  NSUInteger version;
   NSString *field;
   NSHTTPCookie *ck;
   NSEnumerator *ckenum = [cookies objectEnumerator];
@@ -287,11 +292,10 @@ static NSRange GSRangeOfCookie(NSString *string);
   if ((self = [super init]) == nil)
     return nil;
 
-  /* Check a few values.  Based on Mac OS X tests. */
+  /* Check a few values. Based on Mac OS X tests. */
   if (![self _isValidProperty: [properties objectForKey: NSHTTPCookiePath]] 
     || ![self _isValidProperty: [properties objectForKey: NSHTTPCookieDomain]]
     || ![self _isValidProperty: [properties objectForKey: NSHTTPCookieName]]
-    || ![self _isValidProperty: [properties objectForKey: NSHTTPCookieValue]]
     )
     {
       [self release];
@@ -392,9 +396,9 @@ inrange(ch,'0','9') \
 
 typedef	struct	{
   const unsigned char	*ptr;
-  unsigned	end;
-  unsigned	pos;
-  unsigned	lin;
+  NSUInteger	end;
+  NSUInteger	pos;
+  NSUInteger	lin;
   NSString	*err;
   int           opt;
   BOOL		key;
@@ -426,11 +430,12 @@ static BOOL skipSpace(pldata *pld)
   return NO;
 }
 
+static inline id parseQuotedString(pldata* pld) NS_RETURNS_RETAINED;
 static inline id parseQuotedString(pldata* pld)
 {
-  unsigned	start = ++pld->pos;
-  unsigned	escaped = 0;
-  unsigned	shrink = 0;
+  NSUInteger	start = ++pld->pos;
+  NSUInteger	escaped = 0;
+  NSUInteger	shrink = 0;
   BOOL		hex = NO;
   NSString	*obj;
 
@@ -508,12 +513,12 @@ static inline id parseQuotedString(pldata* pld)
     }
   else
     {
-      unsigned	length;
-      unichar	*chars;
-      unichar	*temp = NULL;
-      unsigned	int temp_length = 0;
-      unsigned	j;
-      unsigned	k;
+      NSUInteger  length;
+      unichar     *chars;
+      unichar     *temp = NULL;
+      NSUInteger  temp_length = 0;
+      NSUInteger  j;
+      NSUInteger  k;
 
       if (!GSToUnicode(&temp, &temp_length, &pld->ptr[start],
 		       pld->pos - start, NSUTF8StringEncoding,
@@ -618,13 +623,15 @@ static inline id parseQuotedString(pldata* pld)
   return obj;
 }
 
-/* In cookies, keys are terminated by '=' and values are terminated by ';'
-   or and EOL */
+/*
+ * In cookies, keys are terminated by '=' and values are terminated by ';' or and EOL
+ */
+static inline id parseUnquotedString(pldata *pld, char endChar) NS_RETURNS_RETAINED;
 static inline id parseUnquotedString(pldata *pld, char endChar)
 {
-  unsigned	start = pld->pos;
-  unsigned	i;
-  unsigned	length;
+  NSUInteger	start = pld->pos;
+  NSUInteger	i;
+  NSUInteger	length;
   id		obj;
   unichar	*chars;
 
@@ -642,26 +649,46 @@ static inline id parseUnquotedString(pldata *pld, char endChar)
       chars[i] = pld->ptr[start + i];
     }
 
-    {
-      obj = [NSString alloc];
-      obj = [obj initWithCharactersNoCopy: chars
-				   length: length
-			     freeWhenDone: YES];
-    }
+
+  obj = [NSString alloc];
+  obj = [obj initWithCharactersNoCopy: chars
+                               length: length
+                         freeWhenDone: YES];
   return obj;
 }
 
-static BOOL
+/**
+ * RFC 6265 specifies cookie value as following:
+ *   cookie-value      = *cookie-octet / ( DQUOTE *cookie-octet DQUOTE )
+ *   cookie-octet      = %x21 / %x23-2B / %x2D-3A / %x3C-5B / %x5D-7E
+ *                         ; US-ASCII characters excluding CTLs,
+ *                         ; whitespace DQUOTE, comma, semicolon,
+ *                         ; and backslash
+ * But Apple's implementation allows whitespace, comma and backslash
+ * to be present in value and trims it before the first denied character.
+ */
+static NSString *
+_validCookieValue(NSString *aValue)
+{
+    const char *bytes = [aValue UTF8String];
+    NSUInteger length = [aValue length];
+    NSUInteger index = 0;
+    /* DQUOTE and semicolon are handled by parsing algorithm */
+    while (index < length && bytes[index] >= 0x20 && bytes[index] <= 0x7E) {
+        ++index;
+    }
+    return [aValue substringWithRange:(NSRange){0, index}];
+}
+
+static void
 _setCookieKey(NSMutableDictionary *dict, NSString *key, NSString *value)
 {
   if ([dict count] == 0)
     {
-      /* This must be the name=value pair */
-      if ([value length] == 0)
-	return NO;
+      /* this is a name-value pair */
+      value = _validCookieValue(value);
       [dict setObject: key forKey: NSHTTPCookieName];
       [dict setObject: value forKey: NSHTTPCookieValue];
-      return YES;
     }
   if ([[key lowercaseString] isEqual: @"comment"])
     [dict setObject: value forKey: NSHTTPCookieComment];
@@ -693,11 +720,10 @@ _setCookieKey(NSMutableDictionary *dict, NSString *key, NSString *value)
 	     forKey: NSHTTPCookieSecure];
   else if ([[key lowercaseString] isEqual: @"version"])
     [dict setObject: value forKey: NSHTTPCookieVersion];
-  return YES;
 }
 
 static id
-GSPropertyListFromCookieFormat(NSString *string, int version)
+GSPropertyListFromCookieFormat(NSString *string, NSInteger version, NSError **error)
 {
   NSMutableDictionary	*dict;
   pldata		_pld;
@@ -748,11 +774,7 @@ GSPropertyListFromCookieFormat(NSString *string, int version)
       if (moreCharacters == NO || pld->ptr[pld->pos] == ';')
 	{
 	  pld->pos++;
-	  if (_setCookieKey(dict, key, @"") == NO)
-	    {
-	      pld->err = @"invalid cookie pair";
-	      DESTROY(dict);
-	    }
+	  _setCookieKey(dict, key, @"");
 	  RELEASE(key);
 	}
       else if (pld->ptr[pld->pos] == '=')
@@ -778,15 +800,10 @@ GSPropertyListFromCookieFormat(NSString *string, int version)
 	      DESTROY(dict);
 	      break;
 	    }
-          skipSpace(pld);
-	  if (_setCookieKey(dict, key, val) == NO)
-	    {
-	      pld->err = @"invalid cookie pair";
-	      DESTROY(dict);
-	    }
+	  _setCookieKey(dict, key, val);
 	  RELEASE(key);
 	  RELEASE(val);
-	  if (pld->ptr[pld->pos] == ';')
+	  if (skipSpace(pld) && pld->ptr[pld->pos] == ';')
 	    {
 	      pld->pos++;
 	    }
@@ -803,12 +820,11 @@ GSPropertyListFromCookieFormat(NSString *string, int version)
 	  break;
 	}
     }
-  if (dict == nil && _pld.err != nil)
+  if (dict == nil && _pld.err != nil && error != nil)
     {
-      RELEASE(dict);
-      [NSException raise: NSGenericException
-		  format: @"Parse failed at line %d (char %d) - %@",
-	_pld.lin + 1, _pld.pos + 1, _pld.err];
+        NSString *format = NSLocalizedString(@"Parse failed at line %d (char %d) - %@", @"");
+        NSString *description = [NSString stringWithFormat:format, _pld.lin + 1, _pld.pos + 1, NSLocalizedString(_pld.err, @"")];
+        *error = [NSError errorWithDomain:@"NSHTTPCookieErrorDomain" code:1 userInfo:[NSDictionary dictionaryWithObject:description forKey:NSLocalizedDescriptionKey]];
     }
   return AUTORELEASE(dict);
 }
@@ -863,7 +879,7 @@ GSRangeOfCookie(NSString *string)
 	{
 	  /* Look ahead for something that will tell us if this is a
 	     separate cookie or not */
-          unsigned saved_pos = pld->pos;
+          NSUInteger saved_pos = pld->pos;
 	  while (pld->ptr[pld->pos] != '=' && pld->ptr[pld->pos] != ';'
 		&& pld->ptr[pld->pos] != ',' && pld->pos < pld->end )
 	    pld->pos++;
diff --git a/Source/NSHTTPCookieStorage.m b/Source/NSHTTPCookieStorage.m
index deba824..ccb36af 100644
--- a/Source/NSHTTPCookieStorage.m
+++ b/Source/NSHTTPCookieStorage.m
@@ -144,7 +144,7 @@ static NSHTTPCookieStorage   *storage = nil;
 {
   BOOL changed = NO;
   NSDate *now = [NSDate date];
-  unsigned count = [this->_cookies count];
+  NSUInteger count = [this->_cookies count];
 
   /* FIXME: Handle Max-age */
   while (count-- > 0)
@@ -198,7 +198,7 @@ static NSHTTPCookieStorage   *storage = nil;
 
 - (void) _updateToCookieStore
 {
-  int i, count;
+  NSUInteger i, count;
   NSMutableArray *properties;
   NSString *path = [self _cookieStorePath];
 
@@ -327,7 +327,7 @@ static NSHTTPCookieStorage   *storage = nil;
     mainDocumentURL: (NSURL *)mainDocumentURL
 {
   BOOL     changed = NO;
-  unsigned count = [cookies count];
+  NSUInteger count = [cookies count];
 
   if (count == 0 || this->_policy == NSHTTPCookieAcceptPolicyNever)
     return;
diff --git a/Source/NSHashTable.m b/Source/NSHashTable.m
index c456833..5ccdb2d 100644
--- a/Source/NSHashTable.m
+++ b/Source/NSHashTable.m
@@ -100,8 +100,11 @@ static Class	concreteClass = 0;
 - (id) initWithPointerFunctions: (NSPointerFunctions*)functions
 		       capacity: (NSUInteger)initialCapacity
 {
-  [self subclassResponsibility: _cmd];
-  return nil;
+    if ([self class] == [NSHashTable class]) {
+        [self subclassResponsibility: _cmd];
+        return nil;
+    }
+    return [super init];
 }
 
 - (void) addObject: (id)object
@@ -112,8 +115,8 @@ static Class	concreteClass = 0;
 - (NSArray*) allObjects
 {
   NSEnumerator	*enumerator;
-  unsigned	nodeCount = [self count];
-  unsigned	index;
+  NSUInteger	nodeCount = [self count];
+  NSUInteger	index;
   NSArray	*a;
   GS_BEGINITEMBUF(objects, nodeCount, id);
 
@@ -174,7 +177,7 @@ static Class	concreteClass = 0;
 
 - (void) intersectHashTable: (NSHashTable*)other
 {
-  unsigned		count = [self count];
+  NSUInteger		count = [self count];
 
   if (count > 0)
     {
diff --git a/Source/NSHost.m b/Source/NSHost.m
index 668fe96..c3b3336 100644
--- a/Source/NSHost.m
+++ b/Source/NSHost.m
@@ -390,7 +390,7 @@ myHostName()
 
       if (inet_pton(AF_INET, a, (void*)&hostaddr) <= 0)
 	{
-	  NSLog(@"Invalid host address sent to [NSHost +hostWithAddress:]");
+	  NSLog(@"Invalid host address '%@' sent to [NSHost +hostWithAddress:]", address);
 	  return nil;
 	}
       inet_ntop(AF_INET, (void*)&hostaddr, buf, sizeof(buf));
@@ -404,7 +404,7 @@ myHostName()
 
       if (inet_pton(AF_INET6, a, (void*)&hostaddr6) <= 0)
 	{
-	  NSLog(@"Invalid host address sent to [NSHost +hostWithAddress:]");
+	  NSLog(@"Invalid host address '%@' sent to [NSHost +hostWithAddress:]", address);
 	  return nil;
 	}
       inet_ntop(AF_INET6, (void*)&hostaddr6, buf, sizeof(buf));
diff --git a/Source/NSIndexPath.m b/Source/NSIndexPath.m
index dcff0d8..f989773 100644
--- a/Source/NSIndexPath.m
+++ b/Source/NSIndexPath.m
@@ -136,14 +136,14 @@ static	NSIndexPath	*dummy = nil;
   NSMutableString	*m = [[super description] mutableCopy];
   NSUInteger		i;
 
-  [m appendFormat: @"%u indexes [", _length];
+  [m appendFormat: @"%lu indexes [", (unsigned long)_length];
   for (i = 0; i < _length; i++)
     {
       if (i > 0)
 	{
 	  [m appendString: @", "];
 	}
-      [m appendFormat: @"%u", _indexes[i]];
+      [m appendFormat: @"%lu", (unsigned long)_indexes[i]];
     }
   [m appendString: @"]"];
   return AUTORELEASE(m);
@@ -153,10 +153,10 @@ static	NSIndexPath	*dummy = nil;
 {
   if ([aCoder allowsKeyedCoding] == YES)
     {
-      [aCoder encodeInt: (NSInteger)_length forKey: @"NSIndexPathLength"];
+      [aCoder encodeInteger: (NSInteger)_length forKey: @"NSIndexPathLength"];
       if (_length == 1)
 	{
-	  [aCoder encodeInt: (NSInteger)_indexes[0] forKey: @"NSIndexPathValue"];
+	  [aCoder encodeInteger: (NSInteger)_indexes[0] forKey: @"NSIndexPathValue"];
 	}
       else if (_length > 1)
 	{
@@ -169,7 +169,7 @@ static	NSIndexPath	*dummy = nil;
 	  buf = [m mutableBytes];
 	  for (i = 0; i < _length; i++)
 	    {
-	      buf[i] = NSSwapHostIntToBig(_indexes[i]);
+	      buf[i] = (NSUInteger)NSSwapHostLongLongToBig((long long)_indexes[i]);
 	    }
 	  [aCoder encodeObject: m forKey: @"NSIndexPathData"];
 	  RELEASE(m);
@@ -297,7 +297,7 @@ static	NSIndexPath	*dummy = nil;
                   NSZoneFree(NSDefaultMallocZone(), dst);
                 }
               [NSException raise: NSGenericException format:
-                @"Unable to decode unsigned integers of size %u", s];
+                @"Unable to decode unsigned integers of size %lu", (unsigned long)s];
             }
           self = [self initWithIndexes: dst length: length];
           if ((void*)dst != src)
diff --git a/Source/NSIndexSet.m b/Source/NSIndexSet.m
index fea975b..99245d2 100644
--- a/Source/NSIndexSet.m
+++ b/Source/NSIndexSet.m
@@ -288,19 +288,19 @@ static NSUInteger posForIndex(GSIArray array, NSUInteger index)
         [super description]];
     }
   m = [NSMutableString stringWithFormat:
-    @"%@[number of indexes: %u (in %u ranges), indexes:",
-    [super description], [self count], c];
+    @"%@[number of indexes: %lu (in %lu ranges), indexes:",
+    [super description], (unsigned long)[self count], (unsigned long)c];
   for (i = 0; i < c; i++)
     {
       NSRange	r = GSIArrayItemAtIndex(_array, i).ext;
 
       if (r.length > 1)
         {
-          [m appendFormat: @" (%u-%u)", r.location, NSMaxRange(r) - 1];
+          [m appendFormat: @" (%lu-%lu)", (unsigned long)r.location, (unsigned long)NSMaxRange(r) - 1];
 	}
       else
         {
-          [m appendFormat: @" %u", r.location];
+          [m appendFormat: @" %lu", (unsigned long)r.location];
 	}
     }
   [m appendString: @"]"];
@@ -318,7 +318,7 @@ static NSUInteger posForIndex(GSIArray array, NSUInteger index)
 
   if ([aCoder allowsKeyedCoding])
     {
-      [aCoder encodeInt: rangeCount forKey: @"NSRangeCount"];
+      [aCoder encodeInteger: rangeCount forKey: @"NSRangeCount"];
     }
   else
     {
@@ -337,8 +337,8 @@ static NSUInteger posForIndex(GSIArray array, NSUInteger index)
       r = GSIArrayItemAtIndex(_array, 0).ext;
       if ([aCoder allowsKeyedCoding])
         {
-          [aCoder encodeInt: r.location forKey: @"NSLocation"];
-          [aCoder encodeInt: r.length forKey: @"NSLength"];
+          [aCoder encodeInteger: r.location forKey: @"NSLocation"];
+          [aCoder encodeInteger: r.length forKey: @"NSLength"];
         }
       else
         {
@@ -1109,7 +1109,7 @@ static NSUInteger posForIndex(GSIArray array, NSUInteger index)
       GSIArrayRemoveItemAtIndex(_array, pos + 1);
       if (NSMaxRange(r) > NSMaxRange(aRange))
 	{
-	  int	offset = NSMaxRange(r) - NSMaxRange(aRange);
+	  NSInteger	offset = NSMaxRange(r) - NSMaxRange(aRange);
 
 	  r = GSIArrayItemAtIndex(_array, pos).ext;
 	  r.length += offset;
diff --git a/Source/NSInvocation.ff.m b/Source/NSInvocation.ff.m
new file mode 100644
index 0000000..60f4350
--- /dev/null
+++ b/Source/NSInvocation.ff.m
@@ -0,0 +1,866 @@
+/** Implementation of NSInvocation for GNUStep
+   Copyright (C) 1998,2003 Free Software Foundation, Inc.
+
+   Author:     Richard Frith-Macdonald <richard@brainstorm.co.uk>
+   Date: August 1998
+   Based on code by: Andrew Kachites McCallum <mccallum@gnu.ai.mit.edu>
+
+   This file is part of the GNUstep Base Library.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02111 USA.
+
+   <title>NSInvocation class reference</title>
+   $Date$ $Revision$
+   */
+
+#import "config.h" /* USE_LIBFFI/USE_FFCALL */
+
+#if defined (USE_LIBFFI) || defined (USE_FFCALL)
+
+#import "common.h"
+#define	EXPOSE_NSInvocation_IVARS	1
+#import "Foundation/NSException.h"
+#import "Foundation/NSCoder.h"
+#import "Foundation/NSData.h"
+#import "Foundation/NSInvocation.h"
+#import "Foundation/NSZone.h"
+#import "GSInvocation.h"
+#import "GSPrivate.h"
+#import "GNUstepBase/NSObject+GNUstepBase.h"
+
+#if defined(USE_LIBFFI)
+#include "cifframe.h"
+#elif defined(USE_FFCALL)
+#include "callframe.h"
+#endif
+
+#if     defined(HAVE_SYS_MMAN_H)
+#include <sys/mman.h>
+#endif
+
+#if     defined(HAVE_MMAP)
+#  if   !defined(MAP_ANONYMOUS)
+#    if defined(MAP_ANON)
+#      define MAP_ANONYMOUS   MAP_ANON
+#    else
+#      undef  HAVE_MMAP
+#    endif
+#  endif
+#endif
+
+@implementation GSCodeBuffer
+
++ (GSCodeBuffer*) memoryWithSize: (NSUInteger)_size
+{
+  return [[[self alloc] initWithSize: _size] autorelease];
+}
+
+- (void*) buffer
+{
+  return buffer;
+}
+
+- (void) dealloc
+{
+  DESTROY(frame);
+  if (size > 0)
+    {
+#if	defined(HAVE_FFI_PREP_CLOSURE_LOC)
+      ffi_closure_free(buffer);
+#else
+#if     defined(HAVE_MMAP)
+      munmap(buffer, size);
+#else
+#if     !defined(__MINGW__) && defined(HAVE_MPROTECT)
+      if (mprotect(buffer, NSPageSize(), PROT_READ|PROT_WRITE) == -1)
+	{
+	  NSLog(@"Failed to protect memory as writable: %@", [NSError _last]);
+	}
+#endif
+      NSDeallocateMemoryPages(buffer, NSPageSize());
+#endif
+#endif
+      buffer = 0;
+      executable = 0;
+      size = 0;
+    }
+  [super dealloc];
+}
+
+- (void*) executable
+{
+  return executable;
+}
+
+- (id) initWithSize: (NSUInteger)_size
+{
+  NSAssert(_size > 0, @"Tried to allocate zero length buffer.");
+  NSAssert(_size <= NSPageSize(), @"Tried to allocate more than one page.");
+#if	defined(HAVE_FFI_PREP_CLOSURE_LOC)
+  buffer = ffi_closure_alloc(_size, &executable);
+  if (0 == buffer)
+    {
+      executable = 0;
+    }  
+  else
+    {
+      size = _size;
+    }
+#else
+#if     defined(HAVE_MMAP)
+#if     defined(HAVE_MPROTECT)
+  /* We have mprotect, so we create memory as writable and change it to
+   * executable later (writable and executable may not be possible at
+   * the same time).
+   */
+  buffer = mmap (NULL, _size, PROT_READ|PROT_WRITE,
+    MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
+#else
+  /* We do not have mprotect, so we have to try to create writable and
+   * executable memory.
+   */
+  buffer = mmap (NULL, _size, PROT_READ|PROT_WRITE|PROT_EXEC,
+    MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
+#endif  /* HAVE_MPROTECT */
+  if (buffer == (void*)-1) buffer = (void*)0;
+#else
+  buffer = NSAllocateMemoryPages(NSPageSize());
+#endif  /* HAVE_MMAP */
+
+  if (buffer == (void*)0)
+    {
+      NSLog(@"Failed to map %"PRIuPTR
+	" bytes for execute: %@", _size, [NSError _last]);
+      buffer = 0;
+      executable = 0;
+      [self dealloc];
+      self = nil;
+    }
+  else
+    {
+      executable = buffer;
+      size = _size;
+    }
+#endif	/* USE_LIBFFI */
+  return self;
+}
+
+/* Ensure that the protection on the buffer is such that it will execute
+ * on any architecture.
+ */
+- (void) protect
+{
+#if	!defined(HAVE_FFI_PREP_CLOSURE_LOC)
+#if	defined(__MINGW__)
+  DWORD old;
+  if (VirtualProtect(buffer, size, PAGE_EXECUTE, &old) == 0)
+    {
+      NSLog(@"Failed to protect memory as executable: %@", [NSError _last]);
+    }
+#elif     defined(HAVE_MPROTECT)
+  if (mprotect(buffer, NSPageSize(), PROT_READ|PROT_EXEC) == -1)
+    {
+      NSLog(@"Failed to protect memory as executable: %@", [NSError _last]);
+    }
+#endif
+#endif
+}
+
+- (void) setFrame: (id)aFrame
+{
+  ASSIGN(frame, aFrame);
+}
+@end
+
+static Class   NSInvocation_abstract_class;
+static Class   NSInvocation_concrete_class;
+
+
+
+
+#define	_inf	((NSArgumentInfo*)_info)
+
+/**
+ * <p>The <code>NSInvocation</code> class implements a mechanism of constructing
+ * messages (as <code>NSInvocation</code> instances), sending these to other
+ * objects, and handling the returned values.
+ * </p>
+ * <p>An <code>NSInvocation</code> object may contain a target object to which a
+ * message can be sent, or may send the message to an arbitrary object.<br />
+ * Each message consists of a selector for that method and an argument
+ * list.  Once the message has been sent, the invocation will contain
+ * a return value whose contents may be copied out of it.
+ * </p>
+ * <p>The target, selector, and arguments of an instance be constructed
+ * dynamically, providing a great deal of power/flexibility.
+ * </p>
+ * <p>The sending of the message to the target object (using the -invoke
+ * or -invokeWithTarget: method) can be done at any time, but a standard
+ * use of this is by the [NSObject-forwardInvocation:] method which is
+ * called whenever a method is not implemented by the class of the
+ * object to which it was sent.
+ * </p>
+ * <p>Related to the class are two convenience macros ... NS_MESSAGE()
+ * and NS_INVOCATION() ... to allow easy construction of invocations
+ * with all the arguments set up.
+ * </p>
+ */
+@implementation NSInvocation
+
+#ifdef USE_LIBFFI
+static inline void
+_get_arg(NSInvocation *inv, NSInteger index, void *buffer)
+{
+  cifframe_get_arg((cifframe_t *)inv->_cframe, index, buffer,
+		   ((NSArgumentInfo*)inv->_info)[index+1].size);
+}
+
+static inline void
+_set_arg(NSInvocation *inv, NSInteger index, void *buffer)
+{
+  cifframe_set_arg((cifframe_t *)inv->_cframe, index, buffer,
+		   ((NSArgumentInfo*)inv->_info)[index+1].size);
+}
+
+static inline void *
+_arg_addr(NSInvocation *inv, NSInteger index)
+{
+  return cifframe_arg_addr((cifframe_t *)inv->_cframe, index);
+}
+
+#elif defined(USE_FFCALL)
+static inline void
+_get_arg(NSInvocation *inv, NSInteger index, void *buffer)
+{
+  callframe_get_arg((callframe_t *)inv->_cframe, index, buffer,
+		    ((NSArgumentInfo*)inv->_info)[index+1].size);
+}
+
+static inline void
+_set_arg(NSInvocation *inv, NSInteger index, void *buffer)
+{
+  callframe_set_arg((callframe_t *)inv->_cframe, index, buffer,
+		    ((NSArgumentInfo*)inv->_info)[index+1].size);
+}
+
+static inline void *
+_arg_addr(NSInvocation *inv, NSInteger index)
+{
+  return callframe_arg_addr((callframe_t *)inv->_cframe, index);
+}
+
+#else
+
+static inline void
+_get_arg(NSInvocation *inv, NSInteger index, void *buffer)
+{
+}
+
+static inline void
+_set_arg(NSInvocation *inv, NSInteger index, void *buffer)
+{
+}
+
+static inline void *
+_arg_addr(NSInvocation *inv, NSInteger index)
+{
+  return 0;
+}
+
+#endif
+
++ (id) allocWithZone: (NSZone*)aZone
+{
+  if (self == NSInvocation_abstract_class)
+    {
+      return NSAllocateObject(NSInvocation_concrete_class, 0, aZone);
+    }
+  else
+    {
+      return NSAllocateObject(self, 0, aZone);
+    }
+}
+
++ (void) initialize
+{
+  if (self == [NSInvocation class])
+    {
+      NSInvocation_abstract_class = self;
+#if defined(USE_LIBFFI)
+      NSInvocation_concrete_class = [GSFFIInvocation class];
+#elif defined(USE_FFCALL)
+      NSInvocation_concrete_class = [GSFFCallInvocation class];
+#else
+      NSInvocation_concrete_class = [GSDummyInvocation class];
+#endif
+    }
+}
+
+/**
+ * Returns an invocation instance which can be used to send messages to
+ * a target object using the described signature.<br />
+ * You must set the target and selector (using -setTarget: and -setSelector:)
+ * before you attempt to use the invocation.<br />
+ * Raises an NSInvalidArgumentException if the signature is nil.
+ */
++ (NSInvocation*) invocationWithMethodSignature: (NSMethodSignature*)_signature
+{
+  return AUTORELEASE([[NSInvocation_concrete_class alloc]
+    initWithMethodSignature: _signature]);
+}
+
+- (void) dealloc
+{
+  if (_targetRetained)
+    {
+      _targetRetained = NO;
+      RELEASE(_target);
+    }
+  if (_argsRetained)
+    {
+      _argsRetained = NO;
+      if (_cframe && _sig)
+	{
+	  unsigned int	i;
+
+	  for (i = 3; i <= _numArgs; i++)
+	    {
+	      if (*_inf[i].type == _C_CHARPTR)
+		{
+		  char	*str = 0;
+
+		  _get_arg(self, i-1, &str);
+		  if (str != 0)
+		    {
+		      NSZoneFree(NSDefaultMallocZone(), str);
+		    }
+		}
+	      else if (*_inf[i].type == _C_ID)
+		{
+		  id	obj = nil;
+
+		  _get_arg(self, i-1, &obj);
+		  RELEASE(obj);
+		}
+	    }
+	}
+    }
+
+
+  CLEAR_RETURN_VALUE_IF_OBJECT;
+
+#if	defined(USE_LIBFFI)
+  if (_cframe)
+    {
+      /* If we get here then we are not using GC, so the _frame instance
+       * variable points to a mutable data object containing _cframe and
+       * we can release it.
+       */
+      [((GSFFIInvocation*)self)->_frame release];
+    }
+#elif defined(USE_FFCALL)
+  if (_cframe)
+    {
+      NSZoneFree(NSDefaultMallocZone(), _cframe);
+    }
+#endif
+  if (_retptr)
+    {
+      NSZoneFree(NSDefaultMallocZone(), _retptr);
+    }
+  RELEASE(_sig);
+  [super dealloc];
+}
+
+/**
+ * Copies the argument identified by index into the memory location specified
+ * by the buffer argument.<br />
+ * An index of zero is the target object, an index of one is the selector,
+ * so the actual method arguments start at index 2.
+ */
+- (void) getArgument: (void*)buffer
+	     atIndex: (NSInteger)index
+{
+  if ((NSUInteger)index >= _numArgs)
+    {
+      [NSException raise: NSInvalidArgumentException
+		  format: @"bad invocation argument index"];
+    }
+  if (index == 0)
+    {
+      *(id*)buffer = _target;
+    }
+  else if (index == 1)
+    {
+      *(SEL*)buffer = _selector;
+    }
+  else
+    {
+      _get_arg(self, index, buffer);
+    }		
+}
+
+/**
+ * Copies the invocations return value to the location pointed to by buffer
+ * if a return value has been set (see the -setReturnValue: method).<br />
+ * If there isn't a return value then this method raises an exception.
+ */
+- (void) getReturnValue: (void*)buffer
+{
+  if (_validReturn == NO)
+    {
+      [NSException raise: NSGenericException
+		  format: @"getReturnValue with no value set"];
+    }
+  if (*_inf[0].type != _C_VOID)
+    {
+      memcpy(buffer, _retval, _inf[0].size);
+    }
+}
+
+/**
+ * Returns the selector of the invocation (the argument at index 1)
+ */
+- (SEL) selector
+{
+  return _selector;
+}
+
+/**
+ * Sets the argument identified by index from the memory location specified
+ * by the buffer argument.<br />
+ * Using an index of 0 is equivalent to calling -setTarget: and using an
+ * argument of 1 is equivalent to -setSelector:<br />
+ * Proper arguments start at index 2.<br />
+ * NB. Unlike -setTarget: and -setSelector: the value of buffer must be
+ * <em>a pointer to</em> the argument to be set in the invocation.<br />
+ * If -retainArguments was called, then any object argument set in the
+ * receiver is retained by it.
+ */
+- (void) setArgument: (void*)buffer
+	     atIndex: (NSInteger)index
+{
+  if ((NSUInteger)index >= _numArgs)
+    {
+      [NSException raise: NSInvalidArgumentException
+		  format: @"bad invocation argument index"];
+    }
+  if (index == 0)
+    {
+      [self setTarget: *(id*)buffer];
+    }
+  else if (index == 1)
+    {
+      [self setSelector: *(SEL*)buffer];
+    }
+  else
+    {
+      NSInteger		i = index+1;	/* Allow for return type in '_inf' */
+      const char	*type = _inf[i].type;
+
+      if (_argsRetained && (*type == _C_ID || *type == _C_CHARPTR))
+	{
+	  if (*type == _C_ID)
+	    {
+	      id	old;
+
+	      _get_arg(self, index, &old);
+	      _set_arg(self, index, buffer);
+	      IF_NO_GC(RETAIN(*(id*)buffer));
+	      if (old != nil)
+		{
+		  RELEASE(old);
+		}
+	    }
+	  else
+	    {
+	      char	*oldstr;
+	      char	*newstr = *(char**)buffer;
+
+	      _get_arg(self, index, &oldstr);
+	      if (newstr == 0)
+		{
+		  _set_arg(self, index, buffer);
+		}
+	      else
+		{
+		  size_t	len;
+		  char	*tmp;
+
+		  len = strlen(newstr);
+		  tmp = NSZoneMalloc(NSDefaultMallocZone(), len + 1);
+		  strncpy(tmp, newstr, len);
+		  tmp[len] = '\0';
+		  _set_arg(self, index, tmp);
+		}
+	      if (oldstr != 0)
+		{
+		  NSZoneFree(NSDefaultMallocZone(), oldstr);
+		}
+	    }
+	}
+      else
+	{
+	  _set_arg(self, index, buffer);
+	}
+    }		
+}
+
+/**
+ * Sets the return value of the invocation to the item that buffer points to.
+ */
+- (void) setReturnValue: (void*)buffer
+{
+  const char	*type;
+
+  type = _inf[0].type;
+
+  CLEAR_RETURN_VALUE_IF_OBJECT;
+
+  if (*type != _C_VOID)
+    {
+      memcpy(_retval, buffer, _inf[0].size);
+    }
+
+  RETAIN_RETURN_VALUE;
+  _validReturn = YES;
+}
+
+/**
+ * Sets the selector for the invocation.
+ */
+- (void) setSelector: (SEL)aSelector
+{
+  _selector = aSelector;
+}
+
+/**
+ * Sets the target object for the invocation.<br />
+ * If -retainArguments was called, then the target is retained.
+ */
+- (void) setTarget: (id)anObject
+{
+  if (_targetRetained)
+    {
+      ASSIGN(_target, anObject);
+    }
+  else
+    {
+      _target = anObject;
+    }
+}
+
+/**
+ * Returns the target object of the invocation.
+ */
+- (id) target
+{
+  return _target;
+}
+
+/**
+ * Returns a flag to indicate whether object arguments of the invocation
+ * (including its target) are retained by the invocation.
+ */
+- (BOOL) argumentsRetained
+{
+  return _argsRetained;
+}
+
+/**
+ * Instructs the invocation to retain its object arguments (including the
+ * target). The default is not to retain them.
+ */
+- (void) retainArguments
+{
+  [self retainArgumentsIncludingTarget: YES];
+}
+
+/**
+ * Returns YES if target has been retained yet, NO otherwise.
+ */
+- (BOOL) targetRetained
+{
+  return _targetRetained;
+}
+
+/**
+ * Similar to -[NSInvocation retainArguments], but allows the sender to
+ * explicitly control whether the target is retained as well. Retaining
+ * the target is sometimes not desirable (such as in NSUndoManager), as
+ * retain loops could result.
+ */
+- (void) retainArgumentsIncludingTarget: (BOOL)retainTargetFlag
+{
+  if (_argsRetained == NO)
+    {
+      unsigned int	i;
+
+      _argsRetained = YES;
+      if (_cframe == 0)
+	{
+	  return;
+	}
+      for (i = 3; i <= _numArgs; i++)
+	{
+	  if (*_inf[i].type == _C_ID)
+	    {
+              id        old;
+
+	      _get_arg(self, i-1, &old);
+	      if (old != nil)
+		{
+		  IF_NO_GC(RETAIN(old));
+		}
+            }
+	  else if (*_inf[i].type == _C_CHARPTR)
+	    {
+	      char      *str;
+
+	      _get_arg(self, i-1, &str);
+	      if (str != 0)
+	        {
+		  char  *tmp;
+		  size_t	len;
+
+		  len = strlen(str);
+		  tmp = NSZoneMalloc(NSDefaultMallocZone(), len + 1);
+		  strncpy(tmp, str, len);
+		  tmp[len] = '\0';
+		  _set_arg(self, i-1, &tmp);
+		}
+	    }
+	}
+    }
+
+  if (retainTargetFlag && _targetRetained == NO)
+    {
+      _targetRetained = YES;
+
+      IF_NO_GC(RETAIN(_target));
+    }
+}
+
+/**
+ * Sends the message encapsulated in the invocation to its target.
+ */
+- (void) invoke
+{
+  [self invokeWithTarget: _target];
+}
+
+/**
+ * Sends the message encapsulated in the invocation to anObject.
+ */
+- (void) invokeWithTarget: (id)anObject
+{
+  [self subclassResponsibility: _cmd];
+}
+
+/**
+ * Returns the method signature of the invocation.
+ */
+- (NSMethodSignature*) methodSignature
+{
+  return _sig;
+}
+
+- (NSString*) description
+{
+  /*
+   *	Don't use -[NSString stringWithFormat:] method because it can cause
+   *	infinite recursion.
+   */
+  char buffer[1024];
+
+  snprintf (buffer, 1024, "<%s %p selector: %s target: %s>", \
+    GSClassNameFromObject(self), \
+    self, \
+    _selector ? sel_getName(_selector) : "nil", \
+    _target ? class_getName([_target class]) : "nil" \
+   );
+
+  return [NSString stringWithUTF8String: buffer];
+}
+
+- (void) encodeWithCoder: (NSCoder*)aCoder
+{
+  const char	*types = [_sig methodType];
+  unsigned int	i;
+
+  [aCoder encodeValueOfObjCType: @encode(char*)
+			     at: &types];
+
+  [aCoder encodeObject: _target];
+
+  [aCoder encodeValueOfObjCType: _inf[2].type
+			     at: &_selector];
+
+  for (i = 3; i <= _numArgs; i++)
+    {
+      const char	*type = _inf[i].type;
+      void		*datum;
+
+      datum = _arg_addr(self, i-1);
+
+      if (*type == _C_ID)
+	{
+	  [aCoder encodeObject: *(id*)datum];
+	}
+      else
+	{
+	  [aCoder encodeValueOfObjCType: type at: datum];
+	}
+    }
+  if (*_inf[0].type != _C_VOID)
+    {
+      [aCoder encodeValueOfObjCType: @encode(BOOL) at: &_validReturn];
+      if (_validReturn)
+	{
+	  [aCoder encodeValueOfObjCType: _inf[0].type at: _retval];
+	}
+    }
+}
+
+- (id) initWithCoder: (NSCoder*)aCoder
+{
+  NSMethodSignature	*newSig;
+  const char		*types;
+  void			*datum;
+  unsigned int		i;
+
+  [aCoder decodeValueOfObjCType: @encode(char*) at: &types];
+  newSig = [NSMethodSignature signatureWithObjCTypes: types];
+  NSZoneFree(NSDefaultMallocZone(), (void*)types);
+
+  DESTROY(self);
+  self = RETAIN([NSInvocation invocationWithMethodSignature: newSig]);
+
+  [aCoder decodeValueOfObjCType: @encode(id) at: &_target];
+
+  [aCoder decodeValueOfObjCType: @encode(SEL) at: &_selector];
+
+  for (i = 3; i <= _numArgs; i++)
+    {
+      datum = _arg_addr(self, i-1);
+      [aCoder decodeValueOfObjCType: _inf[i].type at: datum];
+    }
+  _argsRetained = YES;
+  if (*_inf[0].type != _C_VOID)
+    {
+      [aCoder decodeValueOfObjCType: @encode(BOOL) at: &_validReturn];
+      if (_validReturn)
+        {
+          [aCoder decodeValueOfObjCType: _inf[0].type at: _retval];
+        }
+    }
+  return self;
+}
+
+@end
+
+/**
+ * Provides some minor extensions and some utility methods to aid
+ * integration of <code>NSInvocation</code> with the Objective-C runtime.
+ */
+@implementation NSInvocation (GNUstep)
+
+- (id)initWithMethodSignature:(NSMethodSignature *)aSignature
+{
+    [self subclassResponsibility: _cmd];
+    return nil;
+}
+
+- (BOOL) sendsToSuper
+{
+  return _sendToSuper;
+}
+
+- (void) setSendsToSuper: (BOOL)flag
+{
+  _sendToSuper = flag;
+}
+
+- (BOOL)encodeWithDistantCoder:(NSCoder *)coder passPointers:(BOOL)passp
+{
+    [self subclassResponsibility: _cmd];
+    return NO;
+}
+
+@end
+
+/**
+ * These methods are for internal use only ... not public API<br />
+ * They are used by the NS_INVOCATION() and NS_MESSAGE() macros to help
+ * create invocations.
+ */
+@implementation NSInvocation (MacroSetup)
+
+/** <init /><override-subclass />
+ * Initialised an invocation instance which can be used to send messages to
+ * a target object using aSignature.<br />
+ * You must set the target and selector (using -setTarget: and -setSelector:)
+ * before you attempt to use the invocation.<br />
+ * Raises an NSInvalidArgumentException if aSignature is nil.
+ */
+- (id) initWithMethodSignature: (NSMethodSignature*)aSignature
+{
+  [self subclassResponsibility: _cmd];
+  return nil;
+}
+
+@end
+
+@implementation NSInvocation (BackwardCompatibility)
+
+- (void) invokeWithObject: (id)obj
+{
+  [self invokeWithTarget: (id)obj];
+}
+
+@end
+
+#endif /* USE_LIBFFI || USE_FFCALL */
+
+#if !defined(USE_FFCALL) && !defined(USE_LIBFFI) && !defined (NeXT_RUNTIME)
+#warning Using dummy NSInvocation implementation.  It is strongly recommended that you use libffi.
+@implementation GSDummyInvocation
+
+
+/*
+ *	This is the de_signated initialiser.
+ */
+- (id) initWithMethodSignature: (NSMethodSignature*)aSignature
+{
+  return self;
+}
+
+- (void) invokeWithTarget: (id)anObject
+{
+  CLEAR_RETURN_VALUE_IF_OBJECT;
+  _validReturn = NO;
+  /*
+   *	A message to a nil object returns nil.
+   */
+  if (anObject == nil)
+    {
+      _validReturn = YES;
+      return;
+    }
+}
+
+@end
+#endif
diff --git a/Source/NSInvocation.m b/Source/NSInvocation.m
deleted file mode 100644
index a13212f..0000000
--- a/Source/NSInvocation.m
+++ /dev/null
@@ -1,848 +0,0 @@
-/** Implementation of NSInvocation for GNUStep
-   Copyright (C) 1998,2003 Free Software Foundation, Inc.
-
-   Author:     Richard Frith-Macdonald <richard@brainstorm.co.uk>
-   Date: August 1998
-   Based on code by: Andrew Kachites McCallum <mccallum@gnu.ai.mit.edu>
-
-   This file is part of the GNUstep Base Library.
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Library General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with this library; if not, write to the Free
-   Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
-   Boston, MA 02111 USA.
-
-   <title>NSInvocation class reference</title>
-   $Date$ $Revision$
-   */
-
-#import "common.h"
-#define	EXPOSE_NSInvocation_IVARS	1
-#import "Foundation/NSException.h"
-#import "Foundation/NSCoder.h"
-#import "Foundation/NSData.h"
-#import "Foundation/NSInvocation.h"
-#import "Foundation/NSZone.h"
-#import "GSInvocation.h"
-#import "GSPrivate.h"
-#import "GNUstepBase/NSObject+GNUstepBase.h"
-
-#if defined(USE_LIBFFI)
-#include "cifframe.h"
-#elif defined(USE_FFCALL)
-#include "callframe.h"
-#endif
-
-#if     defined(HAVE_SYS_MMAN_H)
-#include <sys/mman.h>
-#endif
-
-#if     defined(HAVE_MMAP)
-#  if   !defined(MAP_ANONYMOUS)
-#    if defined(MAP_ANON)
-#      define MAP_ANONYMOUS   MAP_ANON
-#    else
-#      undef  HAVE_MMAP
-#    endif
-#  endif
-#endif
-
-@implementation GSCodeBuffer
-
-+ (GSCodeBuffer*) memoryWithSize: (NSUInteger)_size
-{
-  return [[[self alloc] initWithSize: _size] autorelease];
-}
-
-- (void*) buffer
-{
-  return buffer;
-}
-
-- (void) dealloc
-{
-  DESTROY(frame);
-  if (size > 0)
-    {
-#if	defined(HAVE_FFI_PREP_CLOSURE_LOC)
-      ffi_closure_free(buffer);
-#else
-#if     defined(HAVE_MMAP)
-      munmap(buffer, size);
-#else
-#if     !defined(__MINGW__) && defined(HAVE_MPROTECT)
-      if (mprotect(buffer, NSPageSize(), PROT_READ|PROT_WRITE) == -1)
-	{
-	  NSLog(@"Failed to protect memory as writable: %@", [NSError _last]);
-	}
-#endif
-      NSDeallocateMemoryPages(buffer, NSPageSize());
-#endif
-#endif
-      buffer = 0;
-      executable = 0;
-      size = 0;
-    }
-  [super dealloc];
-}
-
-- (void*) executable
-{
-  return executable;
-}
-
-- (id) initWithSize: (NSUInteger)_size
-{
-  NSAssert(_size > 0, @"Tried to allocate zero length buffer.");
-  NSAssert(_size <= NSPageSize(), @"Tried to allocate more than one page.");
-#if	defined(HAVE_FFI_PREP_CLOSURE_LOC)
-  buffer = ffi_closure_alloc(_size, &executable);
-  if (0 == buffer)
-    {
-      executable = 0;
-    }  
-  else
-    {
-      size = _size;
-    }
-#else
-#if     defined(HAVE_MMAP)
-#if     defined(HAVE_MPROTECT)
-  /* We have mprotect, so we create memory as writable and change it to
-   * executable later (writable and executable may not be possible at
-   * the same time).
-   */
-  buffer = mmap (NULL, _size, PROT_READ|PROT_WRITE,
-    MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
-#else
-  /* We do not have mprotect, so we have to try to create writable and
-   * executable memory.
-   */
-  buffer = mmap (NULL, _size, PROT_READ|PROT_WRITE|PROT_EXEC,
-    MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
-#endif  /* HAVE_MPROTECT */
-  if (buffer == (void*)-1) buffer = (void*)0;
-#else
-  buffer = NSAllocateMemoryPages(NSPageSize());
-#endif  /* HAVE_MMAP */
-
-  if (buffer == (void*)0)
-    {
-      NSLog(@"Failed to map %"PRIuPTR
-	" bytes for execute: %@", _size, [NSError _last]);
-      buffer = 0;
-      executable = 0;
-      [self dealloc];
-      self = nil;
-    }
-  else
-    {
-      executable = buffer;
-      size = _size;
-    }
-#endif	/* USE_LIBFFI */
-  return self;
-}
-
-/* Ensure that the protection on the buffer is such that it will execute
- * on any architecture.
- */
-- (void) protect
-{
-#if	!defined(HAVE_FFI_PREP_CLOSURE_LOC)
-#if	defined(__MINGW__)
-  DWORD old;
-  if (VirtualProtect(buffer, size, PAGE_EXECUTE, &old) == 0)
-    {
-      NSLog(@"Failed to protect memory as executable: %@", [NSError _last]);
-    }
-#elif     defined(HAVE_MPROTECT)
-  if (mprotect(buffer, NSPageSize(), PROT_READ|PROT_EXEC) == -1)
-    {
-      NSLog(@"Failed to protect memory as executable: %@", [NSError _last]);
-    }
-#endif
-#endif
-}
-
-- (void) setFrame: (id)aFrame
-{
-  ASSIGN(frame, aFrame);
-}
-@end
-
-static Class   NSInvocation_abstract_class;
-static Class   NSInvocation_concrete_class;
-
-
-
-
-#define	_inf	((NSArgumentInfo*)_info)
-
-/**
- * <p>The <code>NSInvocation</code> class implements a mechanism of constructing
- * messages (as <code>NSInvocation</code> instances), sending these to other
- * objects, and handling the returned values.
- * </p>
- * <p>An <code>NSInvocation</code> object may contain a target object to which a
- * message can be sent, or may send the message to an arbitrary object.<br />
- * Each message consists of a selector for that method and an argument
- * list.  Once the message has been sent, the invocation will contain
- * a return value whose contents may be copied out of it.
- * </p>
- * <p>The target, selector, and arguments of an instance be constructed
- * dynamically, providing a great deal of power/flexibility.
- * </p>
- * <p>The sending of the message to the target object (using the -invoke
- * or -invokeWithTarget: method) can be done at any time, but a standard
- * use of this is by the [NSObject-forwardInvocation:] method which is
- * called whenever a method is not implemented by the class of the
- * object to which it was sent.
- * </p>
- * <p>Related to the class are two convenience macros ... NS_MESSAGE()
- * and NS_INVOCATION() ... to allow easy construction of invocations
- * with all the arguments set up.
- * </p>
- */
-@implementation NSInvocation
-
-#ifdef USE_LIBFFI
-static inline void
-_get_arg(NSInvocation *inv, int index, void *buffer)
-{
-  cifframe_get_arg((cifframe_t *)inv->_cframe, index, buffer,
-		   ((NSArgumentInfo*)inv->_info)[index+1].size);
-}
-
-static inline void
-_set_arg(NSInvocation *inv, int index, void *buffer)
-{
-  cifframe_set_arg((cifframe_t *)inv->_cframe, index, buffer,
-		   ((NSArgumentInfo*)inv->_info)[index+1].size);
-}
-
-static inline void *
-_arg_addr(NSInvocation *inv, int index)
-{
-  return cifframe_arg_addr((cifframe_t *)inv->_cframe, index);
-}
-
-#elif defined(USE_FFCALL)
-static inline void
-_get_arg(NSInvocation *inv, int index, void *buffer)
-{
-  callframe_get_arg((callframe_t *)inv->_cframe, index, buffer,
-		    ((NSArgumentInfo*)inv->_info)[index+1].size);
-}
-
-static inline void
-_set_arg(NSInvocation *inv, int index, void *buffer)
-{
-  callframe_set_arg((callframe_t *)inv->_cframe, index, buffer,
-		    ((NSArgumentInfo*)inv->_info)[index+1].size);
-}
-
-static inline void *
-_arg_addr(NSInvocation *inv, int index)
-{
-  return callframe_arg_addr((callframe_t *)inv->_cframe, index);
-}
-
-#else
-
-static inline void
-_get_arg(NSInvocation *inv, int index, void *buffer)
-{
-}
-
-static inline void
-_set_arg(NSInvocation *inv, int index, void *buffer)
-{
-}
-
-static inline void *
-_arg_addr(NSInvocation *inv, int index)
-{
-  return 0;
-}
-
-#endif
-
-+ (id) allocWithZone: (NSZone*)aZone
-{
-  if (self == NSInvocation_abstract_class)
-    {
-      return NSAllocateObject(NSInvocation_concrete_class, 0, aZone);
-    }
-  else
-    {
-      return NSAllocateObject(self, 0, aZone);
-    }
-}
-
-+ (void) initialize
-{
-  if (self == [NSInvocation class])
-    {
-      NSInvocation_abstract_class = self;
-#if defined(USE_LIBFFI)
-      NSInvocation_concrete_class = [GSFFIInvocation class];
-#elif defined(USE_FFCALL)
-      NSInvocation_concrete_class = [GSFFCallInvocation class];
-#else
-      NSInvocation_concrete_class = [GSDummyInvocation class];
-#endif
-    }
-}
-
-/**
- * Returns an invocation instance which can be used to send messages to
- * a target object using the described signature.<br />
- * You must set the target and selector (using -setTarget: and -setSelector:)
- * before you attempt to use the invocation.<br />
- * Raises an NSInvalidArgumentException if the signature is nil.
- */
-+ (NSInvocation*) invocationWithMethodSignature: (NSMethodSignature*)_signature
-{
-  return AUTORELEASE([[NSInvocation_concrete_class alloc]
-    initWithMethodSignature: _signature]);
-}
-
-- (void) dealloc
-{
-  if (_targetRetained)
-    {
-      _targetRetained = NO;
-      RELEASE(_target);
-    }
-  if (_argsRetained)
-    {
-      _argsRetained = NO;
-      if (_cframe && _sig)
-	{
-	  unsigned int	i;
-
-	  for (i = 3; i <= _numArgs; i++)
-	    {
-	      if (*_inf[i].type == _C_CHARPTR)
-		{
-		  char	*str = 0;
-
-		  _get_arg(self, i-1, &str);
-		  if (str != 0)
-		    {
-		      NSZoneFree(NSDefaultMallocZone(), str);
-		    }
-		}
-	      else if (*_inf[i].type == _C_ID)
-		{
-		  id	obj = nil;
-
-		  _get_arg(self, i-1, &obj);
-		  RELEASE(obj);
-		}
-	    }
-	}
-    }
-
-
-  CLEAR_RETURN_VALUE_IF_OBJECT;
-
-#if	defined(USE_LIBFFI)
-  if (_cframe)
-    {
-      /* If we get here then we are not using GC, so the _frame instance
-       * variable points to a mutable data object containing _cframe and
-       * we can release it.
-       */
-      [((GSFFIInvocation*)self)->_frame release];
-    }
-#elif defined(USE_FFCALL)
-  if (_cframe)
-    {
-      NSZoneFree(NSDefaultMallocZone(), _cframe);
-    }
-#endif
-  if (_retptr)
-    {
-      NSZoneFree(NSDefaultMallocZone(), _retptr);
-    }
-  RELEASE(_sig);
-  [super dealloc];
-}
-
-/**
- * Copies the argument identified by index into the memory location specified
- * by the buffer argument.<br />
- * An index of zero is the target object, an index of one is the selector,
- * so the actual method arguments start at index 2.
- */
-- (void) getArgument: (void*)buffer
-	     atIndex: (NSInteger)index
-{
-  if ((NSUInteger)index >= _numArgs)
-    {
-      [NSException raise: NSInvalidArgumentException
-		  format: @"bad invocation argument index"];
-    }
-  if (index == 0)
-    {
-      *(id*)buffer = _target;
-    }
-  else if (index == 1)
-    {
-      *(SEL*)buffer = _selector;
-    }
-  else
-    {
-      _get_arg(self, index, buffer);
-    }		
-}
-
-/**
- * Copies the invocations return value to the location pointed to by buffer
- * if a return value has been set (see the -setReturnValue: method).<br />
- * If there isn't a return value then this method raises an exception.
- */
-- (void) getReturnValue: (void*)buffer
-{
-  if (_validReturn == NO)
-    {
-      [NSException raise: NSGenericException
-		  format: @"getReturnValue with no value set"];
-    }
-  if (*_inf[0].type != _C_VOID)
-    {
-      memcpy(buffer, _retval, _inf[0].size);
-    }
-}
-
-/**
- * Returns the selector of the invocation (the argument at index 1)
- */
-- (SEL) selector
-{
-  return _selector;
-}
-
-/**
- * Sets the argument identified by index from the memory location specified
- * by the buffer argument.<br />
- * Using an index of 0 is equivalent to calling -setTarget: and using an
- * argument of 1 is equivalent to -setSelector:<br />
- * Proper arguments start at index 2.<br />
- * NB. Unlike -setTarget: and -setSelector: the value of buffer must be
- * <em>a pointer to</em> the argument to be set in the invocation.<br />
- * If -retainArguments was called, then any object argument set in the
- * receiver is retained by it.
- */
-- (void) setArgument: (void*)buffer
-	     atIndex: (NSInteger)index
-{
-  if ((NSUInteger)index >= _numArgs)
-    {
-      [NSException raise: NSInvalidArgumentException
-		  format: @"bad invocation argument index"];
-    }
-  if (index == 0)
-    {
-      [self setTarget: *(id*)buffer];
-    }
-  else if (index == 1)
-    {
-      [self setSelector: *(SEL*)buffer];
-    }
-  else
-    {
-      int		i = index+1;	/* Allow for return type in '_inf' */
-      const char	*type = _inf[i].type;
-
-      if (_argsRetained && (*type == _C_ID || *type == _C_CHARPTR))
-	{
-	  if (*type == _C_ID)
-	    {
-	      id	old;
-
-	      _get_arg(self, index, &old);
-	      _set_arg(self, index, buffer);
-	      IF_NO_GC(RETAIN(*(id*)buffer));
-	      if (old != nil)
-		{
-		  RELEASE(old);
-		}
-	    }
-	  else
-	    {
-	      char	*oldstr;
-	      char	*newstr = *(char**)buffer;
-
-	      _get_arg(self, index, &oldstr);
-	      if (newstr == 0)
-		{
-		  _set_arg(self, index, buffer);
-		}
-	      else
-		{
-		  int	len;
-		  char	*tmp;
-
-		  len = strlen(newstr);
-		  tmp = NSZoneMalloc(NSDefaultMallocZone(), len + 1);
-		  strncpy(tmp, newstr, len);
-		  tmp[len] = '\0';
-		  _set_arg(self, index, tmp);
-		}
-	      if (oldstr != 0)
-		{
-		  NSZoneFree(NSDefaultMallocZone(), oldstr);
-		}
-	    }
-	}
-      else
-	{
-	  _set_arg(self, index, buffer);
-	}
-    }		
-}
-
-/**
- * Sets the return value of the invocation to the item that buffer points to.
- */
-- (void) setReturnValue: (void*)buffer
-{
-  const char	*type;
-
-  type = _inf[0].type;
-
-  CLEAR_RETURN_VALUE_IF_OBJECT;
-
-  if (*type != _C_VOID)
-    {
-      memcpy(_retval, buffer, _inf[0].size);
-    }
-
-  RETAIN_RETURN_VALUE;
-  _validReturn = YES;
-}
-
-/**
- * Sets the selector for the invocation.
- */
-- (void) setSelector: (SEL)aSelector
-{
-  _selector = aSelector;
-}
-
-/**
- * Sets the target object for the invocation.<br />
- * If -retainArguments was called, then the target is retained.
- */
-- (void) setTarget: (id)anObject
-{
-  if (_targetRetained)
-    {
-      ASSIGN(_target, anObject);
-    }
-  else
-    {
-      _target = anObject;
-    }
-}
-
-/**
- * Returns the target object of the invocation.
- */
-- (id) target
-{
-  return _target;
-}
-
-/**
- * Returns a flag to indicate whether object arguments of the invocation
- * (including its target) are retained by the invocation.
- */
-- (BOOL) argumentsRetained
-{
-  return _argsRetained;
-}
-
-/**
- * Instructs the invocation to retain its object arguments (including the
- * target). The default is not to retain them.
- */
-- (void) retainArguments
-{
-  [self retainArgumentsIncludingTarget: YES];
-}
-
-/**
- * Returns YES if target has been retained yet, NO otherwise.
- */
-- (BOOL) targetRetained
-{
-  return _targetRetained;
-}
-
-/**
- * Similar to -[NSInvocation retainArguments], but allows the sender to
- * explicitly control whether the target is retained as well. Retaining
- * the target is sometimes not desirable (such as in NSUndoManager), as
- * retain loops could result.
- */
-- (void) retainArgumentsIncludingTarget: (BOOL)retainTargetFlag
-{
-  if (_argsRetained == NO)
-    {
-      unsigned int	i;
-
-      _argsRetained = YES;
-      if (_cframe == 0)
-	{
-	  return;
-	}
-      for (i = 3; i <= _numArgs; i++)
-	{
-	  if (*_inf[i].type == _C_ID)
-	    {
-              id        old;
-
-	      _get_arg(self, i-1, &old);
-	      if (old != nil)
-		{
-		  IF_NO_GC(RETAIN(old));
-		}
-            }
-	  else if (*_inf[i].type == _C_CHARPTR)
-	    {
-	      char      *str;
-
-	      _get_arg(self, i-1, &str);
-	      if (str != 0)
-	        {
-		  char  *tmp;
-		  int	len;
-
-		  len = strlen(str);
-		  tmp = NSZoneMalloc(NSDefaultMallocZone(), len + 1);
-		  strncpy(tmp, str, len);
-		  tmp[len] = '\0';
-		  _set_arg(self, i-1, &tmp);
-		}
-	    }
-	}
-    }
-
-  if (retainTargetFlag && _targetRetained == NO)
-    {
-      _targetRetained = YES;
-
-      IF_NO_GC(RETAIN(_target));
-    }
-}
-
-/**
- * Sends the message encapsulated in the invocation to its target.
- */
-- (void) invoke
-{
-  [self invokeWithTarget: _target];
-}
-
-/**
- * Sends the message encapsulated in the invocation to anObject.
- */
-- (void) invokeWithTarget: (id)anObject
-{
-  [self subclassResponsibility: _cmd];
-}
-
-/**
- * Returns the method signature of the invocation.
- */
-- (NSMethodSignature*) methodSignature
-{
-  return _sig;
-}
-
-- (NSString*) description
-{
-  /*
-   *	Don't use -[NSString stringWithFormat:] method because it can cause
-   *	infinite recursion.
-   */
-  char buffer[1024];
-
-  snprintf (buffer, 1024, "<%s %p selector: %s target: %s>", \
-    GSClassNameFromObject(self), \
-    self, \
-    _selector ? sel_getName(_selector) : "nil", \
-    _target ? class_getName([_target class]) : "nil" \
-   );
-
-  return [NSString stringWithUTF8String: buffer];
-}
-
-- (void) encodeWithCoder: (NSCoder*)aCoder
-{
-  const char	*types = [_sig methodType];
-  unsigned int	i;
-
-  [aCoder encodeValueOfObjCType: @encode(char*)
-			     at: &types];
-
-  [aCoder encodeObject: _target];
-
-  [aCoder encodeValueOfObjCType: _inf[2].type
-			     at: &_selector];
-
-  for (i = 3; i <= _numArgs; i++)
-    {
-      const char	*type = _inf[i].type;
-      void		*datum;
-
-      datum = _arg_addr(self, i-1);
-
-      if (*type == _C_ID)
-	{
-	  [aCoder encodeObject: *(id*)datum];
-	}
-      else
-	{
-	  [aCoder encodeValueOfObjCType: type at: datum];
-	}
-    }
-  if (*_inf[0].type != _C_VOID)
-    {
-      [aCoder encodeValueOfObjCType: @encode(BOOL) at: &_validReturn];
-      if (_validReturn)
-	{
-	  [aCoder encodeValueOfObjCType: _inf[0].type at: _retval];
-	}
-    }
-}
-
-- (id) initWithCoder: (NSCoder*)aCoder
-{
-  NSMethodSignature	*newSig;
-  const char		*types;
-  void			*datum;
-  unsigned int		i;
-
-  [aCoder decodeValueOfObjCType: @encode(char*) at: &types];
-  newSig = [NSMethodSignature signatureWithObjCTypes: types];
-  NSZoneFree(NSDefaultMallocZone(), (void*)types);
-
-  DESTROY(self);
-  self = RETAIN([NSInvocation invocationWithMethodSignature: newSig]);
-
-  [aCoder decodeValueOfObjCType: @encode(id) at: &_target];
-
-  [aCoder decodeValueOfObjCType: @encode(SEL) at: &_selector];
-
-  for (i = 3; i <= _numArgs; i++)
-    {
-      datum = _arg_addr(self, i-1);
-      [aCoder decodeValueOfObjCType: _inf[i].type at: datum];
-    }
-  _argsRetained = YES;
-  if (*_inf[0].type != _C_VOID)
-    {
-      [aCoder decodeValueOfObjCType: @encode(BOOL) at: &_validReturn];
-      if (_validReturn)
-        {
-          [aCoder decodeValueOfObjCType: _inf[0].type at: _retval];
-        }
-    }
-  return self;
-}
-
-@end
-
-/**
- * Provides some minor extensions and some utility methods to aid
- * integration of <code>NSInvocation</code> with the Objective-C runtime.
- */
-@implementation NSInvocation (GNUstep)
-
-- (BOOL) sendsToSuper
-{
-  return _sendToSuper;
-}
-
-- (void) setSendsToSuper: (BOOL)flag
-{
-  _sendToSuper = flag;
-}
-@end
-
-/**
- * These methods are for internal use only ... not public API<br />
- * They are used by the NS_INVOCATION() and NS_MESSAGE() macros to help
- * create invocations.
- */
-@implementation NSInvocation (MacroSetup)
-
-/** <init /><override-subclass />
- * Initialised an invocation instance which can be used to send messages to
- * a target object using aSignature.<br />
- * You must set the target and selector (using -setTarget: and -setSelector:)
- * before you attempt to use the invocation.<br />
- * Raises an NSInvalidArgumentException if aSignature is nil.
- */
-- (id) initWithMethodSignature: (NSMethodSignature*)aSignature
-{
-  [self subclassResponsibility: _cmd];
-  return nil;
-}
-
-@end
-
-@implementation NSInvocation (BackwardCompatibility)
-
-- (void) invokeWithObject: (id)obj
-{
-  [self invokeWithTarget: (id)obj];
-}
-
-@end
-
-#if !defined(USE_FFCALL) && !defined(USE_LIBFFI)
-#warning Using dummy NSInvocation implementation.  It is strongly recommended that you use libffi.
-@implementation GSDummyInvocation
-
-
-/*
- *	This is the de_signated initialiser.
- */
-- (id) initWithMethodSignature: (NSMethodSignature*)aSignature
-{
-  return self;
-}
-
-- (void) invokeWithTarget: (id)anObject
-{
-  CLEAR_RETURN_VALUE_IF_OBJECT;
-  _validReturn = NO;
-  /*
-   *	A message to a nil object returns nil.
-   */
-  if (anObject == nil)
-    {
-      _validReturn = YES;
-      return;
-    }
-}
-
-@end
-#endif
-
diff --git a/Source/NSInvocation.x86_64.S b/Source/NSInvocation.x86_64.S
new file mode 100644
index 0000000..1995454
--- /dev/null
+++ b/Source/NSInvocation.x86_64.S
@@ -0,0 +1,347 @@
+/*
+ * Implementation of NSInvocation logic for x86_64 System V ABI
+ *
+ * Copyright (C) 2012-2013 Free Software Foundation, Inc.
+ *
+ * Written by Marat Ibadinov <ibadinov@me.com>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+#if defined (NeXT_RUNTIME) && (defined (__x86_64__) || defined (__x86_64))
+
+.macro GSAssemblyFunction
+    .text
+    .globl	$0
+    .align	2, 0x90
+$0:
+.endmacro
+
+/********************************************************************
+ *
+ * NSInvocation layout
+ *
+ ********************************************************************/
+
+#define PARENT_SIZE 8
+
+#define IMP_PTR PARENT_SIZE
+#define ARG_PTR IMP_PTR + 8
+#define OFF_PTR ARG_PTR + 8
+#define RES_PTR OFF_PTR + 8
+
+#define ST_SIZE RES_PTR + 8
+#define RS_SIZE ST_SIZE + 4
+#define RS_TYPE RS_SIZE + 4
+#define ARG_CNT RS_TYPE + 4
+
+/********************************************************************
+ *
+ * marg_list layout
+ *
+ ********************************************************************/
+
+#define FP_AREA     0
+#define REG_AREA    FP_AREA     + 16*8
+#define LINK_AREA   REG_AREA    + 8*6
+#define STACK_AREA  LINK_AREA   + 8*4
+
+#define REG_SPACE   200
+
+/********************************************************************
+ *
+ * Save registers to marg_list
+ *
+ ********************************************************************/
+
+.macro SaveRegisters
+  // Save xmm registers
+  movdqa	%xmm0,   0+FP_AREA(%rsp)
+  movdqa	%xmm1,  16+FP_AREA(%rsp)
+  movdqa	%xmm2,  32+FP_AREA(%rsp)
+  movdqa	%xmm3,  48+FP_AREA(%rsp)
+  movdqa	%xmm4,  64+FP_AREA(%rsp)
+  movdqa	%xmm5,  80+FP_AREA(%rsp)
+  movdqa	%xmm6,  96+FP_AREA(%rsp)
+  movdqa	%xmm7, 112+FP_AREA(%rsp)
+
+  // Save parameter registers
+  movq	%rdi,  0+REG_AREA(%rsp)
+  movq	%rsi,  8+REG_AREA(%rsp)
+  movq	%rdx, 16+REG_AREA(%rsp)
+  movq	%rcx, 24+REG_AREA(%rsp)
+  movq	 %r8, 32+REG_AREA(%rsp)
+  movq	 %r9, 40+REG_AREA(%rsp)
+
+  // Save side parameter registers
+  movq	%r10,  0+LINK_AREA(%rsp)	// static chain
+  movq	%rax,  8+LINK_AREA(%rsp)	// xmm count
+  // Return address is already at 8+LINK_AREA(%rsp)
+.endmacro
+
+/********************************************************************
+ *
+ * extern SEL forwardSelector = "forward::"; 
+ *
+ ********************************************************************/
+
+  .data
+  .align 3
+  .private_extern _forwardSelector
+_forwardSelector: .quad 0
+
+/********************************************************************
+ *
+ * void NSInvocationForwardHandler(id receiver, SEL _cmd);
+ *
+ * Forwarding via -forward:: seems to be fixed in last versions of
+ * Apple's ObjC runtime (10.8), so it may be possible to #ifdef this.
+ *
+ ********************************************************************/
+
+GSAssemblyFunction _NSInvocationForwardHandler
+.cfi_startproc
+  cmpq	%rsi, _forwardSelector(%rip)  // Die if forwarding "forward::"
+  je _abort
+
+  subq	$REG_SPACE, %rsp              // Push stack frame
+.cfi_def_cfa_offset REG_SPACE+8
+
+  SaveRegisters
+
+  // Call [receiver forward:(SEL) :(marg_list)]
+  // %rdi is already the receiver
+  movq	%rsp, %rcx                    // marg_list
+  movq	%rsi, %rdx                    // sel
+  movq	_forwardSelector(%rip), %rsi  // forward::
+
+  call	_objc_msgSend
+
+  addq	$REG_SPACE, %rsp              // Pop stack frame
+  ret
+.cfi_endproc
+
+/********************************************************************
+ *
+ * void NSInvocationForwardHandler_stret(void *resultPointer,
+ *                                       id receiver, SEL _cmd);
+ *
+ ********************************************************************/
+
+GSAssemblyFunction _NSInvocationForwardHandler_stret
+.cfi_startproc
+  cmpq	%rdx, _forwardSelector(%rip)  // Die if forwarding "forward::"
+  je _abort
+
+  subq	$REG_SPACE, %rsp              // Push stack frame
+.cfi_def_cfa_offset REG_SPACE+8
+
+  SaveRegisters
+
+  // Call [receiver forward:(SEL) :(marg_list)]
+  // %rdx is already the selector
+  movq	%rsi, %rdi                    // receiver
+  movq	_forwardSelector(%rip), %rsi  // forward::
+  movq	%rsp, %rcx                    // marg_list
+
+  call	_objc_msgSend                 // forward:: is NOT struct-return
+
+  addq	$REG_SPACE, %rsp              // Pop stack frame
+  ret
+.cfi_endproc
+
+/********************************************************************
+ *
+ * void NSInvocationInvoke_internal(NSInvocation *invocation);
+ *
+ ********************************************************************/
+
+GSAssemblyFunction _NSInvocationInvoke_internal
+.cfi_startproc
+  pushq %rbp                  // we need base pointer to support exceptions
+.cfi_def_cfa_offset 16
+.cfi_offset %rbp, -16
+  movq  %rsp, %rbp
+.cfi_def_cfa_register %rbp
+
+  pushq %rbx                  // backup %rbx
+  subq  $8, %rsp              // padding
+  movq  %rdi, %rbx            // save invocation pointer
+
+  movl ST_SIZE(%rbx), %eax    // save stackSize for testing
+
+testq %rax, %rax                // if (!stackSize) goto RestoreRegisters;
+je 0f
+
+  subq %rax, %rsp             // allocate stack_size on stack
+
+  movq          %rsp, %rdi    // 1st arg: dst = %rsp
+  movq ARG_PTR(%rbx), %rsi    // 2nd arg: src = marg_list + STACK_AREA
+  addq   $STACK_AREA, %rsi
+  movq          %rax, %rdx    // 3d arg: size = stackSize (multiple of 16)
+  callq _memcpy
+
+0:
+  movq ARG_PTR(%rbx), %rax    // save marg_list pointer
+
+  movq     0+REG_AREA(%rax), %rdi
+  movq     8+REG_AREA(%rax), %rsi
+  movq    16+REG_AREA(%rax), %rdx
+  movq    24+REG_AREA(%rax), %rcx
+  movq    32+REG_AREA(%rax), %r8
+  movq    40+REG_AREA(%rax), %r9
+
+  movdqa	  0+FP_AREA(%rax), %xmm0
+  movdqa	 16+FP_AREA(%rax), %xmm1
+  movdqa	 32+FP_AREA(%rax), %xmm2
+  movdqa	 48+FP_AREA(%rax), %xmm3
+  movdqa	 64+FP_AREA(%rax), %xmm4
+  movdqa	 80+FP_AREA(%rax), %xmm5
+  movdqa	 96+FP_AREA(%rax), %xmm6
+  movdqa  112+FP_AREA(%rax), %xmm7
+
+  callq *IMP_PTR(%rbx)
+  
+  movl ST_SIZE(%rbx), %ecx
+  addq %rcx, %rsp             // remove stack args. from stack
+  addq $8, %rsp
+  popq %rbx                   // restore backed-up %rbx
+  popq %rbp
+  ret                         // %rax, %xmm0 are already set (if any)
+.cfi_endproc
+
+/********************************************************************
+ *
+ * void NSInvocationInvoke(NSInvocation *invocation);
+ *
+ ********************************************************************/
+
+GSAssemblyFunction _NSInvocationInvoke
+.cfi_startproc
+  pushq RS_TYPE(%rdi)
+  pushq RES_PTR(%rdi)
+  subq $8, %rsp               // padding
+.cfi_def_cfa_offset 24+8
+  callq _NSInvocationInvoke_internal
+  addq $8, %rsp
+  popq %rcx                   // pointer to result buffer
+  popq %rsi                   // return type
+  movl %esi, %esi             // reset hi bytes
+
+  // jmp *NSI_Store_VTable(, %esi, 4)
+  leaq NSI_Store_VTable(%rip), %rdi
+  movslq (%rdi, %rsi, 4), %r10
+  addq %rdi, %r10
+  jmp *%r10
+
+NSI_Store_Xmm:
+  movq %xmm0, (%rcx)
+  ret
+NSI_Store_Int:
+  movq  %rax, (%rcx)
+  ret
+NSI_Store_Stack:
+  // pointer to result buffer was passed to callee as first parameter in %rdi
+  ret
+NSI_Store_Int_Int:
+  movq  %rax, 0x0(%rcx)
+  movq  %rdx, 0x8(%rcx)
+  ret
+NSI_Store_Int_Xmm:
+  movq  %rax, 0x0(%rcx)
+  movq %xmm0, 0x8(%rcx)
+  ret
+NSI_Store_Xmm_Xmm:
+  movq %xmm0, 0x0(%rcx)
+  movq %xmm1, 0x8(%rcx)
+  ret
+NSI_Store_Xmm_Int:
+  movq %xmm0, 0x0(%rcx)
+  movq  %rax, 0x8(%rcx)
+  ret
+.cfi_endproc
+
+.align 4
+NSI_Store_VTable:
+    .long 0x0 // padding, there is no zero return type
+    .long NSI_Store_Xmm        - NSI_Store_VTable
+    .long NSI_Store_Int        - NSI_Store_VTable
+    .long NSI_Store_Stack      - NSI_Store_VTable
+    .long NSI_Store_Int_Int    - NSI_Store_VTable
+    .long NSI_Store_Int_Xmm    - NSI_Store_VTable
+    .long NSI_Store_Xmm_Xmm    - NSI_Store_VTable
+    .long NSI_Store_Xmm_Int    - NSI_Store_VTable
+
+/********************************************************************
+ *
+ * void NSInvocationReturn(NSInvocation *invocation);
+ *
+ ********************************************************************/
+
+GSAssemblyFunction _NSInvocationReturn
+.cfi_startproc
+.cfi_def_cfa_offset 8
+  movq RES_PTR(%rdi), %rcx
+  movl RS_TYPE(%rdi), %esi
+
+  // jmp *NSI_Return_VTable(, %esi, 4)
+  leaq NSI_Return_VTable(%rip), %rdi
+  movslq (%rdi, %rsi, 4), %r10
+  addq %rdi, %r10
+  jmp *%r10
+
+NSI_Return_Xmm:
+  movq    (%rcx), %xmm0 
+  ret
+NSI_Return_Int:
+  movq    (%rcx), %rax
+  ret
+NSI_Return_Stack:
+  // nothing to do here
+  ret
+NSI_Return_Int_Int:
+  movq 0x0(%rcx), %rax
+  movq 0x8(%rcx), %rdx
+  ret
+NSI_Return_Int_Xmm:
+  movq 0x0(%rcx), %rax
+  movq 0x8(%rcx), %xmm0
+  ret
+NSI_Return_Xmm_Xmm:
+  movq 0x0(%rcx), %xmm0
+  movq 0x8(%rcx), %xmm1
+  ret
+NSI_Return_Xmm_Int:
+  movq 0x0(%rcx), %xmm0
+  movq 0x8(%rcx), %rax
+  ret
+.cfi_endproc
+
+.align 4
+NSI_Return_VTable:
+    .long 0x0 // padding, there is no zero return type
+    .long NSI_Return_Xmm        - NSI_Return_VTable
+    .long NSI_Return_Int        - NSI_Return_VTable
+    .long NSI_Return_Stack      - NSI_Return_VTable
+    .long NSI_Return_Int_Int    - NSI_Return_VTable
+    .long NSI_Return_Int_Xmm    - NSI_Return_VTable
+    .long NSI_Return_Xmm_Xmm    - NSI_Return_VTable
+    .long NSI_Return_Xmm_Int    - NSI_Return_VTable
+
+#endif /* __x86_64__ */
\ No newline at end of file
diff --git a/Source/NSInvocation.x86_64.m b/Source/NSInvocation.x86_64.m
new file mode 100644
index 0000000..e0787b9
--- /dev/null
+++ b/Source/NSInvocation.x86_64.m
@@ -0,0 +1,771 @@
+/*
+ * Implementation of NSInvocation logic for x86_64 System V ABI
+ *
+ * Copyright (C) 2012-2013 Free Software Foundation, Inc.
+ *
+ * Written by Marat Ibadinov <ibadinov@me.com>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+#if defined (NeXT_RUNTIME) && (defined (__x86_64__) || defined (__x86_64))
+
+#import <Foundation/NSException.h>
+#import <Foundation/NSInvocation.h>
+#import <Foundation/NSCoder.h>
+#import <Foundation/NSNull.h>
+#import <GNUstepBase/GSObjCRuntime.h>
+#import <objc/message.h>
+#import <string.h>
+#import <stdlib.h>
+
+#undef  MAX
+#define MAX(a, b)                         \
+({                                        \
+  typeof(a) __a = a; typeof(b) __b = b;   \
+  __a > __b ? __a : __b;                  \
+})
+
+@interface NSMethodSignature (Private)
+
+- (const char *)methodType;
+
+@end
+
+extern SEL forwardSelector;
+
+typedef struct SmallStructureInfo
+{
+  uint8_t offset1; /* allways  < 208 */
+  uint8_t offset2; /* allways  < 208 */
+  uint8_t size1;   /* allways  = 8 */
+  uint8_t size2;   /* allways <= 8 */
+} SmallStructureInfo;
+
+/*
+ * struct marg_list_layout
+ * {
+ *    __float128  floatingPointArgs[8];	// xmm0 .. xmm7
+ *    long        linkageArea[4];       // r10, rax, ebp, ret
+ *    long        registerArgs[6];      // rdi, rsi, rdx, rcx, r8, r9
+ *    long        stackArgs[0];         // variable-size
+ * }
+ */
+
+#if defined (__clang__)
+static uint32_t const OffsetFloat     = 0;
+static uint32_t const OffsetRegister  = OffsetFloat + 16 * 8;
+static uint32_t const OffsetLink      = OffsetRegister + 8 * 6;
+static uint32_t const OffsetStack     = OffsetLink + 8 * 4;
+#else
+static uint32_t const OffsetFloat     = 0;
+static uint32_t const OffsetRegister  = 0 + 16 * 8;
+static uint32_t const OffsetLink      = 0 + 16 * 8 + 8 * 6;
+static uint32_t const OffsetStack     = 0 + 16 * 8 + 8 * 6 + 8 * 4;
+#endif
+
+static uint32_t const ArgumentListMinSize   = 208;
+static uint8_t  const StackAlignment        = 16;
+static uint8_t  const MaxArgumentCount      = 32;
+
+typedef enum StorageType
+{
+  StorageTypeXmm       = 0x1,
+  StorageTypeInt       = 0x2,
+  StorageTypeStack     = 0x3,
+  StorageTypeIntInt    = 0x4,
+  StorageTypeIntXmm    = 0x5,
+  StorageTypeXmmXmm    = 0x6,
+  StorageTypeXmmInt    = 0x7
+} StorageType;
+
+static uint8_t const WordSize = sizeof(void *);
+static uint8_t const FloatSize = sizeof(double) * 2;
+
+static uint8_t StorageTypeTransitions[8][8] = {
+  [0] = {
+    [StorageTypeXmm]    = StorageTypeXmm,
+    [StorageTypeInt]    = StorageTypeInt,
+  },
+  [StorageTypeXmm] = {
+    [StorageTypeXmm]    = StorageTypeXmmXmm,
+    [StorageTypeInt]    = StorageTypeXmmInt,
+  },
+  [StorageTypeInt] = {
+    [StorageTypeXmm]    = StorageTypeIntXmm,
+    [StorageTypeInt]    = StorageTypeIntInt,
+  },
+  [StorageTypeIntInt] = {
+    [StorageTypeXmm]    = StorageTypeStack,
+    [StorageTypeInt]    = StorageTypeStack,
+  },
+  [StorageTypeIntXmm] = {
+    [StorageTypeXmm]    = StorageTypeStack,
+    [StorageTypeInt]    = StorageTypeStack,
+  },
+  [StorageTypeXmmXmm] = {
+    [StorageTypeXmm]    = StorageTypeStack,
+    [StorageTypeInt]    = StorageTypeStack,
+  },
+  [StorageTypeXmmInt] = {
+    [StorageTypeXmm]    = StorageTypeStack,
+    [StorageTypeInt]    = StorageTypeStack,
+  },
+  [StorageTypeStack] = {
+    [StorageTypeXmm]    = StorageTypeStack,
+    [StorageTypeInt]    = StorageTypeStack,
+  }
+};
+
+typedef struct StorageInfoAccumulator {
+  uint32_t size;
+  uint8_t  alignment;
+  uint8_t  storageTypeCurrent;
+  uint8_t  storageType;
+  uint32_t totalSize;
+} StorageInfoAccumulator;
+
+static void
+AccumulateInfo(StorageInfoAccumulator *this, GSObjCTypeInfo info)
+{
+  this->alignment = MAX(this->alignment, info.alignment);
+  switch (*info.type)
+    {
+      case GSObjCTypeFloat:
+      case GSObjCTypeDouble:
+        break;
+      case GSObjCTypeArrayBegin:
+      case GSObjCTypeStructureBegin:
+      case GSObjCTypeUnionBegin:
+        break;
+      case GSObjCTypeArrayEnd:
+        this->storageTypeCurrent = StorageTypeInt;
+        info.alignment = info.size = WordSize;
+        break;
+      case GSObjCTypeStructureEnd:
+      case GSObjCTypeUnionEnd:
+        info.size = GSObjCGetPadding(info.size, info.alignment);
+        info.alignment = 1;
+        break;
+      default:
+        this->storageTypeCurrent = StorageTypeInt;
+    }
+  size_t size = GSObjCPadSize(info.size, info.alignment);
+  this->totalSize += size;
+  this->size += size;
+  if (this->size >= WordSize)
+    {
+      this->storageType = StorageTypeTransitions[this->storageType][this->storageTypeCurrent];
+      this->size = 0;
+      this->storageTypeCurrent = StorageTypeXmm;
+    }
+}
+
+static const char *
+GetStorageType(const char *type, uint32_t *storageType, uint32_t *size, uint8_t *alignment)
+{
+  StorageInfoAccumulator info = {0, 0, StorageTypeXmm, 0, 0};
+  type = GSObjCParseTypeSpecification(type,
+                                      (GSObjCTypeParserDelegate)&AccumulateInfo,
+                                      &info, GSObjCReportArrayOnceMask);
+  
+  *storageType = info.storageType ? info.storageType : info.storageTypeCurrent;
+  *size = info.totalSize;
+  *alignment = info.alignment;
+  
+  /* skip offset */
+  if (*type == '-' || *type == '+') ++type;
+  while (*type >= '0' && *type <= '9')
+    {
+      ++type;
+    }
+  return type;
+}
+
+void
+NSInvocationInvoke(id invocation);
+
+void
+NSInvocationReturn(id invocation);
+
+void
+NSInvocationForwardHandler();
+
+void
+NSInvocationForwardHandler_stret();
+
+@implementation NSInvocation 
+
+- (void)dealloc
+{
+  NSZoneFree([self zone], arguments);
+  NSZoneFree([self zone], argumentInfo);
+  if (ownResultBuffer)
+    {
+      NSZoneFree([self zone], result);
+    }
+  [signature release];
+  [pool release];
+  [super dealloc];
+}
+
+- (id)init
+{
+  if (self = [super init])
+    {
+      retainTarget = YES;
+      sendToSuper = NO;
+      retainArguments = NO;
+      retainedArguments = (uint32_t)0 - 1;
+    }
+  return self;
+}
+
+- (id)initWithObjCTypes:(const char *)types
+{
+  if (!(self = [self init]))
+    {
+      return self;
+    }
+  uint32_t regOffset = OffsetRegister, xmmOffset = OffsetFloat;
+  uint32_t regBound = regOffset + WordSize * 6;
+  uint32_t xmmBound = xmmOffset + FloatSize * 8;
+  
+  uint32_t storageType;
+  uint32_t size;
+  uint8_t  alignment;
+  
+  /* analyze return type */
+  types = GetStorageType(types, &storageType, &size, &alignment);
+  size = (uint32_t)GSObjCPadSize(size, alignment);
+  if (storageType == StorageTypeStack)
+    {
+      regOffset += WordSize;
+    }
+  resultStorage = storageType;
+  resultSize = size;
+  
+  ArgumentInfo offsets[MaxArgumentCount];
+  uint8_t stackArgs[MaxArgumentCount], stackArgCount = 0;
+  
+  /* analyze arguments, build offset table */
+  uint8_t  argIndex = 0;
+  while (*types)
+    {
+      if (argIndex == MaxArgumentCount) /* WAT? */
+        {
+          abort();
+        }
+      
+      types = GetStorageType(types, &storageType, &size, &alignment);
+      size = (uint32_t)GSObjCPadSize(size, alignment); /* validate value? */
+      
+      BOOL regAvailable = regOffset < regBound;
+      BOOL xmmAvailable = xmmOffset < xmmBound;
+      
+      /* I know this is terrifyingly ugly */
+      SmallStructureInfo *info = (SmallStructureInfo *) &offsets[argIndex].offset;
+      switch (storageType)
+        {
+          case StorageTypeXmm:
+            if (xmmAvailable)
+              {
+                offsets[argIndex] = (ArgumentInfo){xmmOffset, size};
+                xmmOffset += FloatSize;
+                break;
+              }
+            goto UseStack;
+          case StorageTypeInt:
+            if (regAvailable)
+              {
+                offsets[argIndex] = (ArgumentInfo){regOffset, size};
+                regOffset += WordSize;
+                break;
+              }
+            goto UseStack;
+          case StorageTypeIntInt:
+            if (regOffset > regBound - WordSize * 2)
+              {
+                goto UseStack;
+              }
+            offsets[argIndex].size = 0;
+            info->offset1 = regOffset;
+            regOffset += WordSize;
+            info->offset2 = regOffset;
+            regOffset += WordSize;
+            info->size2 = size - (info->size1 = WordSize);
+            break;
+          case StorageTypeIntXmm:
+            if (!regAvailable || !xmmAvailable)
+              {
+                goto UseStack;
+              }
+            offsets[argIndex].size = 0;
+            info->offset1 = regOffset;
+            regOffset += WordSize;
+            info->offset2 = xmmOffset;
+            xmmOffset += FloatSize;
+            info->size2 = size - (info->size1 = WordSize);
+            break;
+          case StorageTypeXmmXmm:
+            if (xmmOffset > xmmBound - FloatSize * 2)
+              {
+                goto UseStack;
+              }
+            offsets[argIndex].size = 0;
+            info->offset1 = xmmOffset;
+            xmmOffset += FloatSize;
+            info->offset2 = xmmOffset;
+            xmmOffset += FloatSize;
+            info->size2 = size - (info->size1 = WordSize);
+            break;
+          case StorageTypeXmmInt:
+            if (!regAvailable || !xmmAvailable)
+              {
+                goto UseStack;
+              }
+            info->offset1 = xmmOffset;
+            xmmOffset += FloatSize;
+            info->offset2 = regOffset;
+            regOffset += WordSize;
+            info->size2 = size - (info->size1 = WordSize);
+            break;
+          case StorageTypeStack:
+          UseStack:
+            {
+              offsets[argIndex] = (ArgumentInfo){0, size};
+              stackArgs[stackArgCount] = argIndex;
+              ++stackArgCount;
+              break;
+            }
+        }
+      
+      ++argIndex;
+    }
+  
+  argumentCount = argIndex;
+  if (argumentCount)
+    {
+      argumentInfo = NSZoneCalloc([self zone], argumentCount, sizeof(ArgumentInfo));
+      memcpy(argumentInfo, offsets, sizeof(ArgumentInfo) * argumentCount);
+    }
+  else
+    {
+      argumentInfo = NULL;
+    }
+  pool = [[NSMutableArray alloc] initWithCapacity:argumentCount];
+  for (argIndex = 0; argIndex < argumentCount; ++argIndex) {
+    [pool addObject:[NSNull null]];
+  }
+  
+  stackSize = 0;
+  for (uint8_t stackArgIndex = 0; stackArgIndex < stackArgCount; ++stackArgIndex)
+    {
+      argIndex = stackArgs[stackArgIndex];
+      argumentInfo[argIndex].offset = OffsetStack + stackSize;
+      argumentInfo[argIndex].size = offsets[argIndex].size;
+      stackSize += GSObjCPadSize(offsets[argIndex].size, WordSize);
+    }
+  stackSize = (uint32_t)GSObjCPadSize(stackSize, StackAlignment);
+  return self;
+}
+
+- (id)initWithMethodSignature:(NSMethodSignature *)aSignature arguments:(void *)frame
+{
+  if (self = [self initWithObjCTypes:[aSignature methodType]])
+    {
+      arguments = NSZoneMalloc([self zone], ArgumentListMinSize + stackSize);
+      if (frame)
+        {
+          memcpy(arguments, frame, ArgumentListMinSize + stackSize);
+        }
+      if (!frame || resultStorage != StorageTypeStack)
+        {
+          result = NSZoneMalloc([self zone], MAX(resultSize, WordSize * 2));
+          memset(result, 0, resultSize);
+          ownResultBuffer = YES;
+        }
+      else
+        {
+          result = *(void **)(arguments + OffsetRegister);
+          ownResultBuffer = NO;
+        }
+      if (resultStorage == StorageTypeStack)
+        {
+          *(void **)(arguments + OffsetRegister) = result;
+          imp = &objc_msgSend_stret;
+        }
+      else
+        {
+          imp = &objc_msgSend;
+        }
+      signature = [aSignature retain];
+    }
+  return self;
+}
+
+- (id)initWithMethodSignature:(NSMethodSignature *)aSignature
+{
+  return [self initWithMethodSignature:aSignature arguments:NULL];
+}
+
++ (NSInvocation *)invocationWithMethodSignature:(NSMethodSignature *)signature
+{
+  return [[[self alloc] initWithMethodSignature:signature arguments:NULL] autorelease];
+}
+
++ (NSInvocation *)invocationWithMethodSignature:(NSMethodSignature *)signature
+                                  arguments:(void *)arguments
+{
+  return [[[self alloc] initWithMethodSignature:signature arguments:arguments] autorelease];
+}
+
+- (void)getArgument:(void*)buffer atIndex:(NSInteger)index
+{
+  ArgumentInfo info = argumentInfo[index];
+  if (info.size)
+    {
+      memcpy(buffer, arguments + info.offset, info.size);
+    }
+  else
+    {
+      SmallStructureInfo *smallInfo = (SmallStructureInfo *) &info.offset;
+      memcpy(buffer, arguments + smallInfo->offset1, WordSize);
+      memcpy(buffer + WordSize, arguments + smallInfo->offset2, smallInfo->size2);
+    }
+}
+
+- (void)retainArgument:(void *)value atIndex:(NSInteger)index
+{
+  if (index == 0 && !retainTarget)
+    {
+      return;
+    }
+  const char *type = [signature getArgumentTypeAtIndex:index];
+  type = objc_skip_type_qualifiers(type);
+  if (*type == '@')
+    {
+      id object = *(id *)value;
+      object = object != nil ? object : [NSNull null];
+      [pool replaceObjectAtIndex:index withObject:object];
+    }
+  retainedArguments |= (uint32_t)1 << index;
+}
+
+- (void)setArgument:(void *)value atIndex:(NSInteger)index
+{
+  if (retainArguments)
+    {
+      [self retainArgument:value atIndex:index];
+    }
+  else
+    {
+      retainedArguments ^= (uint32_t)1 << index;
+    }
+  ArgumentInfo info = argumentInfo[index];
+  if (info.size)
+    {
+      memcpy(arguments + info.offset, value, info.size);
+    }
+  else
+    {
+      SmallStructureInfo *smallInfo = (SmallStructureInfo *) &info.offset;
+      memcpy(arguments + smallInfo->offset1, value, WordSize);
+      memcpy(arguments + smallInfo->offset2, value + WordSize, smallInfo->size2);
+    }
+}
+
+- (void)setImplementation:(IMP)anImp
+{
+  imp = anImp;
+}
+
+- (void)invoke
+{
+  if (__builtin_expect(sendToSuper, NO))
+    {
+      void *oldImp = imp;
+      imp = resultStorage == StorageTypeStack ? (void *)&objc_msgSendSuper_stret : (void *)&objc_msgSendSuper;
+      
+      id target = [self target];
+      struct objc_super sup = {target, [target superclass]};
+      void *ptr = &sup;
+      [self setArgument:&ptr atIndex:0];
+      
+      NSInvocationInvoke(self);
+      
+      imp = oldImp;
+      return;
+    }
+  
+  NSInvocationInvoke(self);
+}
+
+- (void)returnResult
+{
+}
+
++ (void)load
+{
+  forwardSelector = @selector(forward::);
+  objc_setForwardHandler(&NSInvocationForwardHandler, &NSInvocationForwardHandler_stret);
+}
+
++ (void)initialize
+{
+  // without sendsToSuper support, -invoke may be replaced with NSInvocationInvoke()
+  // class_replaceMethod(self, @selector(invoke), (IMP)&NSInvocationInvoke, "v@:");
+  class_replaceMethod(self, @selector(returnResult), (IMP)&NSInvocationReturn, "v@:");
+}
+
+- (void)getReturnValue:(void*)buffer
+{
+  memcpy(buffer, result, resultSize);
+}
+
+- (void)setReturnValue:(void*)buffer
+{
+  memcpy(result, buffer, resultSize);
+}
+
+- (SEL)selector
+{
+  return *(SEL *)(arguments + argumentInfo[1].offset);
+}
+
+- (void)setSelector:(SEL)aSelector
+{
+  [self setArgument:&aSelector atIndex:1];
+}
+
+- (id)target
+{
+  return *(id *)(arguments + argumentInfo[0].offset);
+}
+
+- (void)setTarget:(id)anObject
+{
+  [self setArgument:&anObject atIndex:0];
+}
+
+- (BOOL)argumentsRetained
+{
+  return retainArguments;
+}
+
+- (void)retainArguments
+{
+  retainArguments = YES;
+  if (retainedArguments != (uint32_t)0 - 1)
+    {
+      for (uint8_t index = 0; index < argumentCount; ++index)
+        {
+          uint32_t flag = (uint32_t)1 << index;
+          if (!(retainedArguments & flag))
+            {
+              ArgumentInfo info = argumentInfo[index]; 
+              if (info.size && info.size == WordSize)
+                {
+                  [self retainArgument:(arguments + info.offset) atIndex:index];
+                }
+            }
+        }
+    }
+}
+
+- (void)invokeWithTarget:(id)anObject
+{
+  [self setArgument:&anObject atIndex:0];
+  [self invoke];
+}
+
+- (NSMethodSignature *)methodSignature
+{
+  return signature;
+}
+
+- (BOOL)targetRetained
+{
+  return retainTarget;
+}
+
+- (void)retainArgumentsIncludingTarget:(BOOL)retainTargetFlag
+{
+  retainTarget = retainTargetFlag;
+  [self retainArguments];
+}
+
+- (BOOL)sendsToSuper
+{
+  return sendToSuper;
+}
+
+- (void)setSendsToSuper:(BOOL)flag
+{
+  sendToSuper = flag;
+}
+
+/*
+ * Used by NSConnection.
+ * If there are any Out parameters, returns YES, otherwise NO is returned.
+ */
+- (BOOL)encodeWithDistantCoder:(NSCoder *)coder passPointers:(BOOL)passPointers
+{
+  BOOL        outParameters = NO;
+  const char  *type = [signature methodType];
+  uint64_t    buffer[2]; /* two words should suffice for small structures */
+  
+  [coder encodeValueOfObjCType:@encode(char*) at:&type];
+  
+  for (uint8_t argumentIndex = 0; argumentIndex < argumentCount; ++argumentIndex)
+    {
+      const char *type = [signature getArgumentTypeAtIndex:argumentIndex];
+      unsigned qualifiers = objc_get_type_qualifiers(type);
+      type = objc_skip_type_qualifiers(type);
+
+      /* arguments that are scattered over registers should be stored into continuous buffer */
+      void *argumentPointer;
+      if (argumentInfo[argumentIndex].size != 0)
+        {
+          argumentPointer = arguments + argumentInfo[argumentIndex].offset;
+        }
+      else
+        {
+          [self getArgument:buffer atIndex:argumentIndex];
+          argumentPointer = buffer;
+        }
+      
+      switch (*type)
+        {
+          case GSObjCTypeId:
+            if (qualifiers & GSObjCQualifierByCopyMask)
+              {
+                [coder encodeBycopyObject:*(id*)argumentPointer];
+              }
+            else if (qualifiers & GSObjCQualifierByRefMask)
+              {
+                [coder encodeByrefObject:*(id*)argumentPointer];
+              }
+            else
+              {
+                [coder encodeObject:*(id*)argumentPointer];
+              }
+            break;
+          case GSObjCTypePointer:
+            /* if we can't pass pointer itself, pass what it is pointing to */
+            if (!passPointers)
+              {
+                  /* todo: should we explicitly handle void** and void* types? */
+                  type++;
+                  argumentPointer = *(void**)argumentPointer;
+              }
+            /* continue to the part common with char pointers */
+          case GSObjCTypeCharPointer:
+            /* if pointer is not qualified as In parameter, it is an Out parameter */
+            if ((qualifiers & GSObjCQualifierOutMask) || !(qualifiers & GSObjCQualifierInMask))
+              {
+                outParameters = YES;
+              }
+            /* if it is In or is not explicitly Out, pass it's value */
+            if ((qualifiers & GSObjCQualifierInMask) || !(qualifiers & GSObjCQualifierOutMask))
+              {
+                [coder encodeValueOfObjCType:type at:argumentPointer];
+              }
+            break;
+          
+          default:
+            /* no special treatment for other types */
+            [coder encodeValueOfObjCType:type at:argumentPointer];
+        }
+    }
+  
+  return outParameters;
+}
+
+@end
+
+/* Forwarding implementation, there should be a place better for this */
+
+#import <Foundation/NSException.h>
+#import <Foundation/NSObject.h>
+#import <Foundation/NSProxy.h>
+
+static NSMethodSignature *
+GSMethodSignatureForForwarding(id receiver, SEL forward, SEL selector)
+{
+  if (nil == receiver)
+    {
+      return nil;
+    }
+  
+  NSMethodSignature *signature = nil;
+  Class class  = object_getClass(receiver);
+      
+  if (class_respondsToSelector(class, @selector(methodSignatureForSelector:)))
+    {
+      signature = [receiver methodSignatureForSelector:selector];
+    }
+  if (nil == signature)
+    {
+        [NSException raise:NSInvalidArgumentException
+                    format:@"%c[%s %s]: unrecognized selector sent to instance %p",
+                           (class_isMetaClass(class) ? '+' : '-'),
+                           class_getName(class), 
+                           sel_getName(selector), 
+                           receiver];
+    }
+  return signature;
+}
+
+
+@interface NSObject (InvocationForwarding)
+-(void)forward:(SEL)sel :(marg_list)args;
+@end
+
+@interface NSProxy (InvocationForwarding)
+-(void)forward:(SEL)sel :(marg_list)args;
+@end
+
+
+@implementation NSObject (InvocationForwarding)
+
+-(void)forward:(SEL)sel :(marg_list)args
+{
+  NSMethodSignature *signature = GSMethodSignatureForForwarding(self, _cmd, sel);
+  NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:signature arguments:args];
+  [self forwardInvocation:invocation];
+  [invocation returnResult];
+}
+
+@end
+
+
+@implementation NSProxy (InvocationForwarding)
+
+-(void)forward:(SEL)sel :(marg_list)args
+{
+  NSMethodSignature *signature = GSMethodSignatureForForwarding(self, _cmd, sel);
+  NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:signature arguments:args];
+  [self forwardInvocation:invocation];
+  [invocation returnResult];
+}
+
+@end
+
+#endif
\ No newline at end of file
diff --git a/Source/NSJSONSerialization.m b/Source/NSJSONSerialization.m
index 32c88fe..e56e6b8 100644
--- a/Source/NSJSONSerialization.m
+++ b/Source/NSJSONSerialization.m
@@ -265,8 +265,8 @@ parseError(ParserState *state)
    */
   NSDictionary *userInfo = [[NSDictionary alloc] initWithObjectsAndKeys:
     _(@"JSON Parse error"), NSLocalizedDescriptionKey,
-    _(([NSString stringWithFormat: @"Unexpected character %c at index %d",
-        (char)currentChar(state), state->sourceIndex])), 
+    _(([NSString stringWithFormat: @"Unexpected character %c at index %ld",
+        (char)currentChar(state), (long)state->sourceIndex])), 
       NSLocalizedFailureReasonErrorKey,
     nil];
   state->error = [NSError errorWithDomain: NSCocoaErrorDomain
@@ -385,7 +385,7 @@ parseString(ParserState *state)
     }
   if (!state->mutableStrings)
     {
-      val = [val makeImmutableCopyOnFail: YES];
+      val = [val makeImmutable];
     }
   // Consume the trailing "
   consumeChar(state);
@@ -508,7 +508,7 @@ parseArray(ParserState *state)
   consumeChar(state);
   if (!state->mutableContainers)
     {
-      array = [array makeImmutableCopyOnFail: YES];
+      array = [array makeImmutable];
     }
   return array;
 }
@@ -569,7 +569,7 @@ parseObject(ParserState *state)
   consumeChar(state);
   if (!state->mutableContainers)
     {
-      dict = [dict makeImmutableCopyOnFail: YES];
+      dict = [dict makeImmutable];
     }
   return dict;
 
@@ -789,7 +789,7 @@ writeObject(id obj, NSMutableString *output, NSInteger tabs)
   else if ([obj isKindOfClass: NSStringClass])
     {
       NSString  *str = (NSString*)obj;
-      unsigned	length = [str length];
+      NSUInteger length = [str length];
 
       if (length == 0)
         {
@@ -797,11 +797,11 @@ writeObject(id obj, NSMutableString *output, NSInteger tabs)
         }
       else
         {
-          unsigned	size = 2;
+          NSUInteger size = 2;
           unichar	*from;
-          unsigned	i = 0;
+          NSUInteger i = 0;
           unichar	*to;
-          unsigned	j = 0;
+          NSUInteger j = 0;
 
           from = NSZoneMalloc (NSDefaultMallocZone(), sizeof(unichar) * length);
           [str getCharacters: from];
@@ -939,6 +939,7 @@ writeObject(id obj, NSMutableString *output, NSInteger tabs)
 	  *error = [NSError errorWithDomain: NSCocoaErrorDomain
 				       code: 0
 				   userInfo: userInfo];
+	  [userInfo release];
 	}
     }
   [str release];
diff --git a/Source/NSKeyValueCoding.m b/Source/NSKeyValueCoding.m
index 9a6c9f5..b6faf61 100644
--- a/Source/NSKeyValueCoding.m
+++ b/Source/NSKeyValueCoding.m
@@ -78,11 +78,11 @@ static inline void setupCompat()
 #endif
 
 static void
-SetValueForKey(NSObject *self, id anObject, const char *key, unsigned size)
+SetValueForKey(NSObject *self, id anObject, const char *key, size_t size)
 {
-  SEL		sel = 0;
-  const char	*type = 0;
-  int		off = 0;
+  SEL         sel = 0;
+  const char  *type = 0;
+  ptrdiff_t   off = 0;
 
   if (size > 0)
     {
@@ -147,14 +147,29 @@ SetValueForKey(NSObject *self, id anObject, const char *key, unsigned size)
 	    }
 	}
     }
-  GSObjCSetVal(self, key, anObject, sel, type, size, off);
+  /* KVO support for properties with direct access, that are observed */
+  if (off && class_respondsToSelector(object_getClass(self), @selector(_isNSKVONotifying)))
+    {
+      NSString *keyString = [[NSString alloc] initWithUTF8String:key];
+      if ([[self class] automaticallyNotifiesObserversForKey:keyString])
+        {
+          [self willChangeValueForKey:keyString];
+          GSObjCSetVal(self, key, anObject, sel, type, size, off);
+          [self didChangeValueForKey:keyString];
+        }
+      [keyString release];
+    }
+    else
+    {
+      GSObjCSetVal(self, key, anObject, sel, type, size, off);
+    }
 }
 
-static id ValueForKey(NSObject *self, const char *key, unsigned size)
+static id ValueForKey(NSObject *self, const char *key, size_t size)
 {
-  SEL		sel = 0;
-  int		off = 0;
-  const char	*type = NULL;
+  SEL         sel = 0;
+  ptrdiff_t   off = 0;
+  const char  *type = NULL;
 
   if (size > 0)
     {
@@ -342,15 +357,15 @@ static id ValueForKey(NSObject *self, const char *key, unsigned size)
     }
 #endif
   [NSException raise: NSInvalidArgumentException
-    format: @"%@ -- %@ 0x%x: Given nil value to set for key \"%@\"",
+    format: @"%@ -- %@ 0x%lx: Given nil value to set for key \"%@\"",
     NSStringFromSelector(_cmd), NSStringFromClass([self class]),
-    self, aKey];
+    (unsigned long)self, aKey];
 }
 
 
 - (void) setValue: (id)anObject forKey: (NSString*)aKey
 {
-  unsigned	size = [aKey length] * 8;
+  NSUInteger	size = [aKey length] * 8;
   char		key[size + 1];
 #ifdef WANT_DEPRECATED_KVC_COMPAT
   IMP   	o = [self methodForSelector: @selector(takeValue:forKey:)];
@@ -462,7 +477,7 @@ static id ValueForKey(NSObject *self, const char *key, unsigned size)
                 forKey: (NSString*)aKey
                  error: (NSError**)anError
 {
-  unsigned	size;
+  NSUInteger	size;
 
   if (aValue == 0 || (size = [aKey length] * 8) == 0)
     {
@@ -519,7 +534,7 @@ static id ValueForKey(NSObject *self, const char *key, unsigned size)
 
 - (id) valueForKey: (NSString*)aKey
 {
-  unsigned	size = [aKey length] * 8;
+  NSUInteger	size = [aKey length] * 8;
   char		key[size + 1];
 
   [aKey getCString: key
@@ -592,7 +607,7 @@ static id ValueForKey(NSObject *self, const char *key, unsigned size)
 
 - (id) storedValueForKey: (NSString*)aKey
 {
-  unsigned	size;
+  size_t size;
 
   if ([[self class] useStoredAccessor] == NO)
     {
@@ -602,14 +617,14 @@ static id ValueForKey(NSObject *self, const char *key, unsigned size)
   size = [aKey length] * 8;
   if (size > 0)
     {
-      SEL		sel = 0;
-      const char	*type = NULL;
-      int		off = 0;
-      const char	*name;
-      char		key[size + 1];
-      char		buf[size + 5];
-      char		lo;
-      char		hi;
+      SEL         sel = 0;
+      const char  *type = NULL;
+      ptrdiff_t   off = 0;
+      const char  *name;
+      char        key[size + 1];
+      char        buf[size + 5];
+      char        lo;
+      char        hi;
 
       strncpy(buf, "_get", 4);
       [aKey getCString: key
@@ -676,7 +691,7 @@ static id ValueForKey(NSObject *self, const char *key, unsigned size)
 
 - (void) takeStoredValue: (id)anObject forKey: (NSString*)aKey
 {
-  unsigned	size;
+  size_t size;
 
   if ([[self class] useStoredAccessor] == NO)
     {
@@ -687,14 +702,14 @@ static id ValueForKey(NSObject *self, const char *key, unsigned size)
   size = [aKey length] * 8;
   if (size > 0)
     {
-      SEL		sel;
-      const char	*type;
-      int		off;
-      const char	*name;
-      char		key[size + 1];
-      char		buf[size + 6];
-      char		lo;
-      char		hi;
+      SEL         sel;
+      const char  *type;
+      ptrdiff_t   off;
+      const char  *name;
+      char        key[size + 1];
+      char        buf[size + 6];
+      char        lo;
+      char        hi;
 
       strncpy(buf, "_set", 4);
       [aKey getCString: key
@@ -801,11 +816,11 @@ static id ValueForKey(NSObject *self, const char *key, unsigned size)
 
 - (void) takeValue: (id)anObject forKey: (NSString*)aKey
 {
-  SEL		sel = 0;
-  const char	*type = 0;
-  int		off = 0;
-  unsigned	size = [aKey length] * 8;
-  char		key[size + 1];
+  SEL         sel = 0;
+  const char  *type = 0;
+  ptrdiff_t   off = 0;
+  size_t      size = [aKey length] * 8;
+  char        key[size + 1];
 
   GSOnceMLog(@"This method is deprecated, use -setValue:forKey:");
   [aKey getCString: key
@@ -899,17 +914,17 @@ static id ValueForKey(NSObject *self, const char *key, unsigned size)
 {
   GSOnceMLog(@"This method is deprecated, use -setNilValueForKey:");
   [NSException raise: NSInvalidArgumentException
-	      format: @"%@ -- %@ 0x%x: Given nil value to set for key \"%@\"",
-    NSStringFromSelector(_cmd), NSStringFromClass([self class]), self, aKey];
+	      format: @"%@ -- %@ 0x%lx: Given nil value to set for key \"%@\"",
+    NSStringFromSelector(_cmd), NSStringFromClass([self class]), (unsigned long)self, aKey];
 }
 
 
 - (NSDictionary*) valuesForKeys: (NSArray*)keys
 {
   NSMutableDictionary	*dict;
-  NSNull		*null = [NSNull null];
-  unsigned		count = [keys count];
-  unsigned		pos;
+  NSNull      *null = [NSNull null];
+  NSUInteger  count = [keys count];
+  NSUInteger  pos;
 
   GSOnceMLog(@"This method is deprecated, use -dictionaryWithValuesForKeys:");
   dict = [NSMutableDictionary dictionaryWithCapacity: count];
diff --git a/Source/NSKeyValueMutableArray.m b/Source/NSKeyValueMutableArray.m
index 1da7e7a..b50e0a9 100644
--- a/Source/NSKeyValueMutableArray.m
+++ b/Source/NSKeyValueMutableArray.m
@@ -90,7 +90,7 @@
                                 ofObject: (id)anObject
 {
   NSKeyValueMutableArray *proxy;
-  unsigned size = [aKey maximumLengthOfBytesUsingEncoding: 
+  NSUInteger size = [aKey maximumLengthOfBytesUsingEncoding: 
 			  NSUTF8StringEncoding];
   char keybuf[size + 1];
   [aKey getCString: keybuf
@@ -428,13 +428,13 @@
 {
   if ((self = [super initWithKey: aKey  ofObject: anObject]) != nil)
     {
-      unsigned size = [aKey maximumLengthOfBytesUsingEncoding:
+      size_t size = [aKey maximumLengthOfBytesUsingEncoding:
         NSUTF8StringEncoding];
       char cKey[size + 2];
       char *cKeyPtr = &cKey[0];
       const char *type = 0;
       BOOL found = NO;
-      int offset;
+      ptrdiff_t offset;
       
       cKey[0] = '_';
       [aKey getCString: cKeyPtr + 1
diff --git a/Source/NSKeyValueMutableSet.m b/Source/NSKeyValueMutableSet.m
index c7647e7..e8e18b6 100644
--- a/Source/NSKeyValueMutableSet.m
+++ b/Source/NSKeyValueMutableSet.m
@@ -25,6 +25,8 @@
 
 #import "common.h"
 #import "Foundation/NSInvocation.h"
+#import "Foundation/NSSet.h"
+#import "Foundation/NSKeyValueObserving.h"
 
 @interface NSKeyValueMutableSet : NSMutableSet
 {
@@ -90,8 +92,7 @@
 + (NSKeyValueMutableSet *) setForKey: (NSString *)aKey ofObject: (id)anObject
 {
   NSKeyValueMutableSet *proxy;
-  unsigned size = [aKey maximumLengthOfBytesUsingEncoding:
-			  NSUTF8StringEncoding];
+  NSUInteger size = [aKey maximumLengthOfBytesUsingEncoding: NSUTF8StringEncoding];
   char keybuf[size + 1];
 
   [aKey getCString: keybuf
@@ -561,13 +562,13 @@
 {
   if ((self = [super initWithKey: aKey  ofObject: anObject]) != nil)
     {
-      unsigned size = [aKey maximumLengthOfBytesUsingEncoding:
+      size_t size = [aKey maximumLengthOfBytesUsingEncoding:
         NSUTF8StringEncoding];
       char cKey[size + 2];
       char *cKeyPtr = &cKey[0];
       const char *type = 0;
 
-      int offset;
+      ptrdiff_t offset;
 
       
       cKey[0] = '_';
diff --git a/Source/NSKeyValueObserving.m b/Source/NSKeyValueObserving.m
deleted file mode 100644
index 6dcae56..0000000
--- a/Source/NSKeyValueObserving.m
+++ /dev/null
@@ -1,2046 +0,0 @@
-/** Implementation of GNUSTEP key value observing
-   Copyright (C) 2005 Free Software Foundation, Inc.
-
-   Written by Richard Frith-Macdonald <richard@brainstorm.co.uk>
-   Date: 2005-2008
-
-   This file is part of the GNUstep Base Library.
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Library General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with this library; if not, write to the Free
-   Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
-   Boston, MA 02111 USA.
-
-   $Date$ $Revision$
-*/
-
-#import "common.h"
-#import "Foundation/NSCharacterSet.h"
-#import "Foundation/NSDictionary.h"
-#import "Foundation/NSEnumerator.h"
-#import "Foundation/NSException.h"
-#import "Foundation/NSHashTable.h"
-#import "Foundation/NSKeyValueCoding.h"
-#import "Foundation/NSKeyValueObserving.h"
-#import "Foundation/NSLock.h"
-#import "Foundation/NSMapTable.h"
-#import "Foundation/NSMethodSignature.h"
-#import "Foundation/NSNull.h"
-#import "Foundation/NSSet.h"
-#import "Foundation/NSValue.h"
-#import "GNUstepBase/GSObjCRuntime.h"
-#import "GNUstepBase/Unicode.h"
-#import "GNUstepBase/GSLock.h"
-#import "GNUstepBase/NSObject+GNUstepBase.h"
-#import "GSInvocation.h"
-
-#if defined(USE_LIBFFI)
-#import "cifframe.h"
-#endif
-
-/*
- * IMPLEMENTATION NOTES
- *
- * Originally, I wanted to do KVO via a proxy, with class pointer swizzling
- * to turn the original instance into an instance of the proxy class.
- * However, I couldn't figure a way to get decent performance out of
- * this model, as every message to the instance would have to be
- * forwarded through the proxy class methods to the original class
- * methods.
- *
- * So, instead I arrived at the mechanism of creating a subclass of
- * each class being observed, with a few subclass methods overriding
- * those of the original, but most remaining the same.
- * The same class pointer swizzling technique was used to convert between the
- * original class and the superclass.
- * This subclass basically overrides several standard methods with
- * those from a template class, and then overrides any setter methods
- * with a another generic setter.
- */
-
-NSString *const NSKeyValueChangeIndexesKey = @"indexes";
-NSString *const NSKeyValueChangeKindKey = @"kind";
-NSString *const NSKeyValueChangeNewKey = @"new";
-NSString *const NSKeyValueChangeOldKey = @"old";
-NSString *const NSKeyValueChangeNotificationIsPriorKey = @"notificationIsPrior";
-
-static NSRecursiveLock	*kvoLock = nil;
-static NSMapTable	*classTable = 0;
-static NSMapTable	*infoTable = 0;
-static NSMapTable       *dependentKeyTable;
-static Class		baseClass;
-static id               null;
-
-static inline void
-setup()
-{
-  if (nil == kvoLock)
-    {
-      [gnustep_global_lock lock];
-      if (nil == kvoLock)
-	{
-	  kvoLock = [GSLazyRecursiveLock new];
-	  null = [[NSNull null] retain];
-	  classTable = NSCreateMapTable(NSNonOwnedPointerMapKeyCallBacks,
-	    NSNonOwnedPointerMapValueCallBacks, 128);
-	  infoTable = NSCreateMapTable(NSNonOwnedPointerMapKeyCallBacks,
-	    NSNonOwnedPointerMapValueCallBacks, 1024);
-	  dependentKeyTable = NSCreateMapTable(NSNonOwnedPointerMapKeyCallBacks,
-	      NSOwnedPointerMapValueCallBacks, 128);
-	  baseClass = NSClassFromString(@"GSKVOBase");
-	}
-      [gnustep_global_lock unlock];
-    }
-}
-/*
- * This is the template class whose methods are added to KVO classes to
- * override the originals and make the swizzled class look like the
- * original class.
- */
-@interface	GSKVOBase : NSObject
-@end
-
-/*
- * This holds information about a subclass replacing a class which is
- * being observed.
- */
-@interface	GSKVOReplacement : NSObject
-{
-  Class         original;       /* The original class */
-  Class         replacement;    /* The replacement class */
-  NSMutableSet  *keys;          /* The observed setter keys */
-}
-- (id) initWithClass: (Class)aClass;
-- (void) overrideSetterFor: (NSString*)aKey;
-- (Class) replacement;
-@end
-
-/*
- * This is a placeholder class which has the abstract setter method used
- * to replace all setter methods in the original.
- */
-@interface	GSKVOSetter : NSObject
-- (void) setter: (void*)val;
-- (void) setterChar: (unsigned char)val;
-- (void) setterDouble: (double)val;
-- (void) setterFloat: (float)val;
-- (void) setterInt: (unsigned int)val;
-- (void) setterLong: (unsigned long)val;
-#ifdef  _C_LNG_LNG
-- (void) setterLongLong: (unsigned long long)val;
-#endif
-- (void) setterShort: (unsigned short)val;
-- (void) setterRange: (NSRange)val;
-- (void) setterPoint: (NSPoint)val;
-- (void) setterSize: (NSSize)val;
-- (void) setterRect: (NSRect)rect;
-@end
-
-/* An instance of this records all the information for a single observation.
- */
-@interface	GSKVOObservation : NSObject
-{
-@public
-  NSObject      *observer;      // Not retained (zeroing weak pointer)
-  void          *context;
-  int           options;
-}
-@end
-
-/* An instance of thsi records the observations for a key path and the
- * recursion state of the process of sending notifications.
- */
-@interface	GSKVOPathInfo : NSObject
-{
-@public
-  unsigned              recursion;
-  unsigned              allOptions;
-  NSMutableArray        *observations;
-  NSMutableDictionary   *change;
-}
-- (void) notifyForKey: (NSString *)aKey ofInstance: (id)instance prior: (BOOL)f;
-@end
-
-/*
- * Instances of this class are created to hold information about the
- * observers monitoring a particular object which is being observed.
- */
-@interface	GSKVOInfo : NSObject
-{
-  NSObject	        *instance;	// Not retained.
-  GSLazyRecursiveLock	        *iLock;
-  NSMapTable	        *paths;
-}
-- (GSKVOPathInfo *) lockReturningPathInfoForKey: (NSString *)key;
-- (void*) contextForObserver: (NSObject*)anObserver ofKeyPath: (NSString*)aPath;
-- (id) initWithInstance: (NSObject*)i;
-- (NSObject*) instance;
-- (BOOL) isUnobserved;
-- (void) unlock;
-
-@end
-
-@interface NSKeyValueObservationForwarder : NSObject
-{
-  id                                    target;
-  NSKeyValueObservationForwarder        *child;
-  void                                  *contextToForward;
-  id                                    observedObjectForUpdate;
-  NSString                              *keyForUpdate;
-  id                                    observedObjectForForwarding;
-  NSString                              *keyForForwarding;
-  NSString                              *keyPathToForward;
-}
-
-- (id) initWithKeyPath: (NSString *)keyPath
-              ofObject: (id)object
-            withTarget: (id)aTarget
-               context: (void *)context;
-
-- (void) keyPathChanged: (id)objectToObserve;
-@end
-
-@implementation	GSKVOBase
-
-- (void) dealloc
-{
-  // Turn off KVO for self ... then call the real dealloc implementation.
-  [self setObservationInfo: nil];
-  object_setClass(self, [self class]);
-  [self dealloc];
-  GSNOSUPERDEALLOC;
-}
-
-- (Class) class
-{
-  return class_getSuperclass(object_getClass(self));
-}
-
-- (void) setValue: (id)anObject forKey: (NSString*)aKey
-{
-  Class		c = [self class];
-  void		(*imp)(id,SEL,id,id);
-
-  imp = (void (*)(id,SEL,id,id))[c instanceMethodForSelector: _cmd];
-
-  if ([[self class] automaticallyNotifiesObserversForKey: aKey])
-    {
-      [self willChangeValueForKey: aKey];
-      imp(self,_cmd,anObject,aKey);
-      [self didChangeValueForKey: aKey];
-    }
-  else
-    {
-      imp(self,_cmd,anObject,aKey);
-    }
-}
-
-- (void) takeStoredValue: (id)anObject forKey: (NSString*)aKey
-{
-  Class		c = [self class];
-  void		(*imp)(id,SEL,id,id);
-
-  imp = (void (*)(id,SEL,id,id))[c instanceMethodForSelector: _cmd];
-
-  if ([[self class] automaticallyNotifiesObserversForKey: aKey])
-    {
-      [self willChangeValueForKey: aKey];
-      imp(self,_cmd,anObject,aKey);
-      [self didChangeValueForKey: aKey];
-    }
-  else
-    {
-      imp(self,_cmd,anObject,aKey);
-    }
-}
-
-- (void) takeValue: (id)anObject forKey: (NSString*)aKey
-{
-  Class		c = [self class];
-  void		(*imp)(id,SEL,id,id);
-
-  imp = (void (*)(id,SEL,id,id))[c instanceMethodForSelector: _cmd];
-
-  if ([[self class] automaticallyNotifiesObserversForKey: aKey])
-    {
-      [self willChangeValueForKey: aKey];
-      imp(self,_cmd,anObject,aKey);
-      [self didChangeValueForKey: aKey];
-    }
-  else
-    {
-      imp(self,_cmd,anObject,aKey);
-    }
-}
-
-- (void) takeValue: (id)anObject forKeyPath: (NSString*)aKey
-{
-  Class		c = [self class];
-  void		(*imp)(id,SEL,id,id);
-
-  imp = (void (*)(id,SEL,id,id))[c instanceMethodForSelector: _cmd];
-
-  if ([[self class] automaticallyNotifiesObserversForKey: aKey])
-    {
-      [self willChangeValueForKey: aKey];
-      imp(self,_cmd,anObject,aKey);
-      [self didChangeValueForKey: aKey];
-    }
-  else
-    {
-      imp(self,_cmd,anObject,aKey);
-    }
-}
-
-- (Class) superclass
-{
-  return class_getSuperclass(class_getSuperclass(object_getClass(self)));
-}
-@end
-
-/*
- * Get a key name from a selector (setKey: or _setKey:) by
- * taking the key part and making the first letter lowercase.
- */
-static NSString *newKey(SEL _cmd)
-{
-  const char	*name = sel_getName(_cmd);
-  unsigned	len;
-  NSString	*key;
-  unsigned	i;
-
-  if (0 == _cmd || 0 == (name = sel_getName(_cmd)))
-    {
-      [NSException raise: NSInvalidArgumentException
-		  format: @"Missing selector name"];
-    }
-  len = strlen(name);
-  if (*name == '_')
-    {
-      name++;
-      len--;
-    }
-  if (len < 5 || name[len-1] != ':' || strncmp(name, "set", 3) != 0)
-    {
-      [NSException raise: NSInvalidArgumentException
-		  format: @"Invalid selector name"];
-    }
-  name += 3;			// Step past 'set'
-  len -= 4;			// allow for 'set' and trailing ':'
-  for (i = 0; i < len; i++)
-    {
-      if (name[i] & 0x80)
-	{
-	  break;
-	}
-    }
-  if (i == len)
-    {
-      char	buf[len];
-
-      /* Efficient key creation for ascii keys
-       */
-      for (i = 0; i < len; i++) buf[i] = name[i];
-      if (isupper(buf[0]))
-	{
-	  buf[0] = tolower(buf[0]);
-	}
-      key = [[NSString alloc] initWithBytes: buf
-				     length: len
-				   encoding: NSASCIIStringEncoding];
-    }
-  else
-    {
-      unichar		u;
-      NSMutableString	*m;
-      NSString		*tmp;
-
-      /*
-       * Key creation for unicode strings.
-       */
-      m = [[NSMutableString alloc] initWithBytes: name
-					  length: len
-					encoding: NSUTF8StringEncoding];
-      u = [m characterAtIndex: 0];
-      u = uni_tolower(u);
-      tmp = [[NSString alloc] initWithCharacters: &u length: 1];
-      [m replaceCharactersInRange: NSMakeRange(0, 1) withString: tmp];
-      [tmp release];
-      key = m;
-    }
-  return key;
-}
-
-
-static GSKVOReplacement *
-replacementForClass(Class c)
-{
-  GSKVOReplacement *r;
-
-  setup();
-  [kvoLock lock];
-  r = (GSKVOReplacement*)NSMapGet(classTable, (void*)c);
-  if (r == nil)
-    {
-      r = [[GSKVOReplacement alloc] initWithClass: c];
-      NSMapInsert(classTable, (void*)c, (void*)r);
-    }
-  [kvoLock unlock];
-  return r;
-}
-
-#if defined(USE_LIBFFI)
-static void
-cifframe_callback(ffi_cif *cif, void *retp, void **args, void *user)
-{
-  id            obj;
-  SEL           sel;
-  NSString	*key;
-  Class		c;
-  void		(*imp)(id,SEL,void*);
-
-  obj = *(id *)args[0];
-  sel = *(SEL *)args[1];
-  c = [obj class];
-
-  imp = (void (*)(id,SEL,void*))[c instanceMethodForSelector: sel];
-  key = newKey(sel);
-  if ([c automaticallyNotifiesObserversForKey: key] == YES)
-    {
-      // pre setting code here
-      [obj willChangeValueForKey: key];
-      ffi_call(cif, (void*)imp, retp, args);
-      // post setting code here
-      [obj didChangeValueForKey: key];
-    }
-  else
-    {
-      ffi_call(cif, (void*)imp, retp, args);
-    }
-  RELEASE(key);
-}
-#endif
-
-@implementation	GSKVOReplacement
-- (void) dealloc
-{
-  DESTROY(keys);
-  [super dealloc];
-}
-
-- (id) initWithClass: (Class)aClass
-{
-  NSValue		*template;
-  NSString		*superName;
-  NSString		*name;
-
-  if ([aClass instanceMethodForSelector: @selector(takeValue:forKey:)]
-    != [NSObject instanceMethodForSelector: @selector(takeValue:forKey:)])
-    {
-      NSLog(@"WARNING The class '%@' (or one of its superclasses) overrides"
-        @" the deprecated takeValue:forKey: method.  Using KVO to observe"
-        @" this class may interfere with this method.  Please change the"
-        @" class to override -setValue:forKey: instead.",
-        NSStringFromClass(aClass));
-    }
-  if ([aClass instanceMethodForSelector: @selector(takeValue:forKeyPath:)]
-    != [NSObject instanceMethodForSelector: @selector(takeValue:forKeyPath:)])
-    {
-      NSLog(@"WARNING The class '%@' (or one of its superclasses) overrides"
-        @" the deprecated takeValue:forKeyPath: method.  Using KVO to observe"
-        @" this class may interfere with this method.  Please change the"
-        @" class to override -setValue:forKeyPath: instead.",
-        NSStringFromClass(aClass));
-    }
-  original = aClass;
-
-  /*
-   * Create subclass of the original, and override some methods
-   * with implementations from our abstract base class.
-   */
-  superName = NSStringFromClass(original);
-  name = [@"GSKVO" stringByAppendingString: superName];
-  template = GSObjCMakeClass(name, superName, nil);
-  GSObjCAddClasses([NSArray arrayWithObject: template]);
-  replacement = NSClassFromString(name);
-  GSObjCAddClassBehavior(replacement, baseClass);
-
-  /* Create the set of setter methods overridden.
-   */
-  keys = [NSMutableSet new];
-
-  return self;
-}
-
-- (void) overrideSetterFor: (NSString*)aKey
-{
-  if ([keys member: aKey] == nil)
-    {
-      NSMethodSignature	*sig;
-      SEL		sel;
-      IMP		imp;
-      const char	*type;
-      NSString          *suffix;
-      NSString          *a[2];
-      unsigned          i;
-      BOOL              found = NO;
-      NSString		*tmp;
-      unichar u;
-
-      suffix = [aKey substringFromIndex: 1];
-      u = uni_toupper([aKey characterAtIndex: 0]);
-      tmp = [[NSString alloc] initWithCharacters: &u length: 1];
-      a[0] = [NSString stringWithFormat: @"set%@%@:", tmp, suffix];
-      a[1] = [NSString stringWithFormat: @"_set%@%@:", tmp, suffix];
-      [tmp release];
-      for (i = 0; i < 2; i++)
-        {
-          /*
-           * Replace original setter with our own version which does KVO
-           * notifications.
-           */
-          sel = NSSelectorFromString(a[i]);
-          if (sel == 0)
-            {
-              continue;
-            }
-          sig = [original instanceMethodSignatureForSelector: sel];
-          if (sig == 0)
-            {
-              continue;
-            }
-
-          /*
-           * A setter must take three arguments (self, _cmd, value).
-           * The return value (if any) is ignored.
-           */
-          if ([sig numberOfArguments] != 3)
-            {
-              continue;	// Not a valid setter method.
-            }
-
-          /*
-           * Since the compiler passes different argument types
-           * differently, we must use a different setter method
-           * for each argument type.
-           * FIXME ... support structures
-           * Unsupported types are quietly ignored ... is that right?
-           */
-          type = [sig getArgumentTypeAtIndex: 2];
-          switch (*type)
-            {
-              case _C_CHR:
-              case _C_UCHR:
-                imp = [[GSKVOSetter class]
-                  instanceMethodForSelector: @selector(setterChar:)];
-                break;
-              case _C_SHT:
-              case _C_USHT:
-                imp = [[GSKVOSetter class]
-                  instanceMethodForSelector: @selector(setterShort:)];
-                break;
-              case _C_INT:
-              case _C_UINT:
-                imp = [[GSKVOSetter class]
-                  instanceMethodForSelector: @selector(setterInt:)];
-                break;
-              case _C_LNG:
-              case _C_ULNG:
-                imp = [[GSKVOSetter class]
-                  instanceMethodForSelector: @selector(setterLong:)];
-                break;
-#ifdef  _C_LNG_LNG
-              case _C_LNG_LNG:
-              case _C_ULNG_LNG:
-                imp = [[GSKVOSetter class]
-                  instanceMethodForSelector: @selector(setterLongLong:)];
-                break;
-#endif
-              case _C_FLT:
-                imp = [[GSKVOSetter class]
-                  instanceMethodForSelector: @selector(setterFloat:)];
-                break;
-              case _C_DBL:
-                imp = [[GSKVOSetter class]
-                  instanceMethodForSelector: @selector(setterDouble:)];
-                break;
-              case _C_ID:
-              case _C_CLASS:
-              case _C_PTR:
-                imp = [[GSKVOSetter class]
-                  instanceMethodForSelector: @selector(setter:)];
-                break;
-              case _C_STRUCT_B:
-                if (GSSelectorTypesMatch(@encode(NSRange), type))
-                  {
-                    imp = [[GSKVOSetter class]
-                      instanceMethodForSelector: @selector(setterRange:)];
-                  }
-                else if (GSSelectorTypesMatch(@encode(NSPoint), type))
-                  {
-                    imp = [[GSKVOSetter class]
-                      instanceMethodForSelector: @selector(setterPoint:)];
-                  }
-                else if (GSSelectorTypesMatch(@encode(NSSize), type))
-                  {
-                    imp = [[GSKVOSetter class]
-                      instanceMethodForSelector: @selector(setterSize:)];
-                  }
-                else if (GSSelectorTypesMatch(@encode(NSRect), type))
-                  {
-                    imp = [[GSKVOSetter class]
-                      instanceMethodForSelector: @selector(setterRect:)];
-                  }
-                else
-                  {
-#if defined(USE_LIBFFI)
-                    GSCodeBuffer    *b;
-
-                    b = cifframe_closure(sig, cifframe_callback);
-                    [b retain];
-                    imp = [b executable];
-#else
-                    imp = 0;
-#endif
-                  }
-                break;
-              default:
-                imp = 0;
-                break;
-            }
-
-          if (imp != 0)
-            {
-	      if (class_addMethod(replacement, sel, imp, [sig methodType]))
-		{
-                  found = YES;
-		}
-	      else
-		{
-		  NSLog(@"Failed to add setter method for %s to %s",
-		    sel_getName(sel), class_getName(original));
-		}
-            }
-        }
-      if (found == YES)
-        {
-          [keys addObject: aKey];
-        }
-      else
-        {
-          NSMapTable *depKeys = NSMapGet(dependentKeyTable, original);
-
-          if (depKeys)
-            {
-              NSMapEnumerator enumerator = NSEnumerateMapTable(depKeys);
-              NSString *mainKey;
-              NSHashTable *dependents;
-
-              while (NSNextMapEnumeratorPair(&enumerator, (void **)(&mainKey),
-                (void**)&dependents))
-                {
-                  NSHashEnumerator dependentKeyEnum;
-                  NSString *dependentKey;
-
-                  if (!dependents) continue;
-                  dependentKeyEnum = NSEnumerateHashTable(dependents);
-                  while ((dependentKey
-                    = NSNextHashEnumeratorItem(&dependentKeyEnum)))
-                    {
-                      if ([dependentKey isEqual: aKey])
-                        {
-                          [self overrideSetterFor: mainKey];
-                          // Mark the key as used
-                          [keys addObject: aKey];
-                          found = YES;
-                        }
-                    }
-                  NSEndHashTableEnumeration(&dependentKeyEnum);
-               }
-              NSEndMapTableEnumeration(&enumerator);
-            }
-
-          if (!found)
-            {
-              NSDebugLLog(@"KVC", @"class %@ not KVC compliant for %@",
-		original, aKey);
-              /*
-              [NSException raise: NSInvalidArgumentException
-                           format: @"class not KVC complient for %@", aKey];
-              */
-            }
-        }
-    }
-}
-
-- (Class) replacement
-{
-  return replacement;
-}
-@end
-
-/*
- * This class
- */
-@implementation	GSKVOSetter
-- (void) setter: (void*)val
-{
-  NSString	*key;
-  Class		c = [self class];
-  void		(*imp)(id,SEL,void*);
-
-  imp = (void (*)(id,SEL,void*))[c instanceMethodForSelector: _cmd];
-
-  key = newKey(_cmd);
-  if ([c automaticallyNotifiesObserversForKey: key] == YES)
-    {
-      // pre setting code here
-      [self willChangeValueForKey: key];
-      (*imp)(self, _cmd, val);
-      // post setting code here
-      [self didChangeValueForKey: key];
-    }
-  else
-    {
-      (*imp)(self, _cmd, val);
-    }
-  RELEASE(key);
-}
-
-- (void) setterChar: (unsigned char)val
-{
-  NSString	*key;
-  Class		c = [self class];
-  void		(*imp)(id,SEL,unsigned char);
-
-  imp = (void (*)(id,SEL,unsigned char))[c instanceMethodForSelector: _cmd];
-
-  key = newKey(_cmd);
-  if ([c automaticallyNotifiesObserversForKey: key] == YES)
-    {
-      // pre setting code here
-      [self willChangeValueForKey: key];
-      (*imp)(self, _cmd, val);
-      // post setting code here
-      [self didChangeValueForKey: key];
-    }
-  else
-    {
-      (*imp)(self, _cmd, val);
-    }
-  RELEASE(key);
-}
-
-- (void) setterDouble: (double)val
-{
-  NSString	*key;
-  Class		c = [self class];
-  void		(*imp)(id,SEL,double);
-
-  imp = (void (*)(id,SEL,double))[c instanceMethodForSelector: _cmd];
-
-  key = newKey(_cmd);
-  if ([c automaticallyNotifiesObserversForKey: key] == YES)
-    {
-      // pre setting code here
-      [self willChangeValueForKey: key];
-      (*imp)(self, _cmd, val);
-      // post setting code here
-      [self didChangeValueForKey: key];
-    }
-  else
-    {
-      (*imp)(self, _cmd, val);
-    }
-  RELEASE(key);
-}
-
-- (void) setterFloat: (float)val
-{
-  NSString	*key;
-  Class		c = [self class];
-  void		(*imp)(id,SEL,float);
-
-  imp = (void (*)(id,SEL,float))[c instanceMethodForSelector: _cmd];
-
-  key = newKey(_cmd);
-  if ([c automaticallyNotifiesObserversForKey: key] == YES)
-    {
-      // pre setting code here
-      [self willChangeValueForKey: key];
-      (*imp)(self, _cmd, val);
-      // post setting code here
-      [self didChangeValueForKey: key];
-    }
-  else
-    {
-      (*imp)(self, _cmd, val);
-    }
-  RELEASE(key);
-}
-
-- (void) setterInt: (unsigned int)val
-{
-  NSString	*key;
-  Class		c = [self class];
-  void		(*imp)(id,SEL,unsigned int);
-
-  imp = (void (*)(id,SEL,unsigned int))[c instanceMethodForSelector: _cmd];
-
-  key = newKey(_cmd);
-  if ([c automaticallyNotifiesObserversForKey: key] == YES)
-    {
-      // pre setting code here
-      [self willChangeValueForKey: key];
-      (*imp)(self, _cmd, val);
-      // post setting code here
-      [self didChangeValueForKey: key];
-    }
-  else
-    {
-      (*imp)(self, _cmd, val);
-    }
-  RELEASE(key);
-}
-
-- (void) setterLong: (unsigned long)val
-{
-  NSString	*key;
-  Class		c = [self class];
-  void		(*imp)(id,SEL,unsigned long);
-
-  imp = (void (*)(id,SEL,unsigned long))[c instanceMethodForSelector: _cmd];
-
-  key = newKey(_cmd);
-  if ([c automaticallyNotifiesObserversForKey: key] == YES)
-    {
-      // pre setting code here
-      [self willChangeValueForKey: key];
-      (*imp)(self, _cmd, val);
-      // post setting code here
-      [self didChangeValueForKey: key];
-    }
-  else
-    {
-      (*imp)(self, _cmd, val);
-    }
-  RELEASE(key);
-}
-
-#ifdef  _C_LNG_LNG
-- (void) setterLongLong: (unsigned long long)val
-{
-  NSString	*key;
-  Class		c = [self class];
-  void		(*imp)(id,SEL,unsigned long long);
-
-  imp = (void (*)(id,SEL,unsigned long long))
-    [c instanceMethodForSelector: _cmd];
-
-  key = newKey(_cmd);
-  if ([c automaticallyNotifiesObserversForKey: key] == YES)
-    {
-      // pre setting code here
-      [self willChangeValueForKey: key];
-      (*imp)(self, _cmd, val);
-      // post setting code here
-      [self didChangeValueForKey: key];
-    }
-  else
-    {
-      (*imp)(self, _cmd, val);
-    }
-  RELEASE(key);
-}
-#endif
-
-- (void) setterShort: (unsigned short)val
-{
-  NSString	*key;
-  Class		c = [self class];
-  void		(*imp)(id,SEL,unsigned short);
-
-  imp = (void (*)(id,SEL,unsigned short))[c instanceMethodForSelector: _cmd];
-
-  key = newKey(_cmd);
-  if ([c automaticallyNotifiesObserversForKey: key] == YES)
-    {
-      // pre setting code here
-      [self willChangeValueForKey: key];
-      (*imp)(self, _cmd, val);
-      // post setting code here
-      [self didChangeValueForKey: key];
-    }
-  else
-    {
-      (*imp)(self, _cmd, val);
-    }
-  RELEASE(key);
-}
-
-- (void) setterRange: (NSRange)val
-{
-  NSString  *key;
-  Class     c = [self class];
-  void      (*imp)(id,SEL,NSRange);
-
-  imp = (void (*)(id,SEL,NSRange))[c instanceMethodForSelector: _cmd];
-
-  key = newKey(_cmd);
-  if ([c automaticallyNotifiesObserversForKey: key] == YES)
-    {
-      // pre setting code here
-      [self willChangeValueForKey: key];
-      (*imp)(self, _cmd, val);
-      // post setting code here
-      [self didChangeValueForKey: key];
-    }
-  else
-    {
-      (*imp)(self, _cmd, val);
-    }
-  RELEASE(key);
-}
-
-- (void) setterPoint: (NSPoint)val
-{
-  NSString  *key;
-  Class     c = [self class];
-  void      (*imp)(id,SEL,NSPoint);
-
-  imp = (void (*)(id,SEL,NSPoint))[c instanceMethodForSelector: _cmd];
-
-  key = newKey(_cmd);
-  if ([c automaticallyNotifiesObserversForKey: key] == YES)
-    {
-      // pre setting code here
-      [self willChangeValueForKey: key];
-      (*imp)(self, _cmd, val);
-      // post setting code here
-      [self didChangeValueForKey: key];
-    }
-  else
-    {
-      (*imp)(self, _cmd, val);
-    }
-  RELEASE(key);
-}
-
-- (void) setterSize: (NSSize)val
-{
-  NSString  *key;
-  Class     c = [self class];
-  void      (*imp)(id,SEL,NSSize);
-
-  imp = (void (*)(id,SEL,NSSize))[c instanceMethodForSelector: _cmd];
-
-  key = newKey(_cmd);
-  if ([c automaticallyNotifiesObserversForKey: key] == YES)
-    {
-      // pre setting code here
-      [self willChangeValueForKey: key];
-      (*imp)(self, _cmd, val);
-      // post setting code here
-      [self didChangeValueForKey: key];
-    }
-  else
-    {
-      (*imp)(self, _cmd, val);
-    }
-  RELEASE(key);
-}
-
-- (void) setterRect: (NSRect)val
-{
-  NSString  *key;
-  Class     c = [self class];
-  void      (*imp)(id,SEL,NSRect);
-
-  imp = (void (*)(id,SEL,NSRect))[c instanceMethodForSelector: _cmd];
-
-  key = newKey(_cmd);
-  if ([c automaticallyNotifiesObserversForKey: key] == YES)
-    {
-      // pre setting code here
-      [self willChangeValueForKey: key];
-      (*imp)(self, _cmd, val);
-      // post setting code here
-      [self didChangeValueForKey: key];
-    }
-  else
-    {
-      (*imp)(self, _cmd, val);
-    }
-  RELEASE(key);
-}
-@end
-
-
-@implementation	GSKVOObservation
-#if	GS_WITH_GC
-+ (void) initialize
-{
-  GSMakeWeakPointer(self, "observer");
-}
-- (void) finalize
-{
-  GSAssignZeroingWeakPointer((void**)&observer, nil);
-}
-#endif
-@end
-
-@implementation	GSKVOPathInfo
-- (void) dealloc
-{
-  [change release];
-  [observations release];
-  [super dealloc];
-}
-
-- (id) init
-{
-  change = [NSMutableDictionary new];
-  observations = [NSMutableArray new];
-  return self;
-}
-
-- (void) notifyForKey: (NSString *)aKey ofInstance: (id)instance prior: (BOOL)f
-{
-  unsigned      count;
-  id            oldValue;
-  id            newValue;
-
-  if (f == YES)
-    {
-      if ((allOptions & NSKeyValueObservingOptionPrior) == 0)
-        {
-          return;   // Nothing to do.
-        }
-      [change setObject: [NSNumber numberWithBool: YES]
-                 forKey: NSKeyValueChangeNotificationIsPriorKey];
-    }
-  else
-    {
-      [change removeObjectForKey: NSKeyValueChangeNotificationIsPriorKey];
-    }
-
-  oldValue = [[change objectForKey: NSKeyValueChangeOldKey] retain];
-  if (oldValue == nil)
-    {
-      oldValue = null;
-    }
-  newValue = [[change objectForKey: NSKeyValueChangeNewKey] retain];
-  if (newValue == nil)
-    {
-      newValue = null;
-    }
-
-  /* Retain self so that we won't be deallocated during the
-   * notification process.
-   */
-  [self retain];
-  count = [observations count];
-  while (count-- > 0)
-    {
-      GSKVOObservation  *o = [observations objectAtIndex: count];
-
-      if (f == YES)
-        {
-          if ((o->options & NSKeyValueObservingOptionPrior) == 0)
-            {
-              continue;
-            }
-        }
-      else
-        {
-          if (o->options & NSKeyValueObservingOptionNew)
-            {
-              [change setObject: newValue
-                         forKey: NSKeyValueChangeNewKey];
-            }
-        }
-
-      if (o->options & NSKeyValueObservingOptionOld)
-        {
-          [change setObject: oldValue
-                     forKey: NSKeyValueChangeOldKey];
-        }
-
-      [o->observer observeValueForKeyPath: aKey
-                                 ofObject: instance
-                                   change: change
-                                  context: o->context];
-    }
-
-  [change setObject: oldValue forKey: NSKeyValueChangeOldKey];
-  [oldValue release];
-  [change setObject: newValue forKey: NSKeyValueChangeNewKey];
-  [newValue release];
-  [self release];
-}
-@end
-
-@implementation	GSKVOInfo
-
-- (NSObject*) instance
-{
-  return instance;
-}
-
-/* Locks receiver and returns path info on success, otherwise
- * leaves receiver munlocked and returns nil.
- */
-- (GSKVOPathInfo*) lockReturningPathInfoForKey: (NSString*)key
-{
-  GSKVOPathInfo *pathInfo;
-
-  [iLock lock];
-  pathInfo = (GSKVOPathInfo*)NSMapGet(paths, (void*)key);
-  if (pathInfo == nil)
-    {
-      [iLock unlock];
-    }
-  return pathInfo;
-}
-
-- (void) unlock
-{
-  [iLock unlock];
-}
-
-- (void) addObserver: (NSObject*)anObserver
-	  forKeyPath: (NSString*)aPath
-	     options: (NSKeyValueObservingOptions)options
-	     context: (void*)aContext
-{
-  GSKVOPathInfo         *pathInfo;
-  GSKVOObservation      *observation;
-  unsigned              count;
-
-  if ([anObserver respondsToSelector:
-    @selector(observeValueForKeyPath:ofObject:change:context:)] == NO)
-    {
-      return;
-    }
-  [iLock lock];
-  pathInfo = (GSKVOPathInfo*)NSMapGet(paths, (void*)aPath);
-  if (pathInfo == nil)
-    {
-      pathInfo = [GSKVOPathInfo new];
-      // use immutable object for map key
-      aPath = [aPath copy];
-      NSMapInsert(paths, (void*)aPath, (void*)pathInfo);
-      [pathInfo release];
-      [aPath release];
-    }
-
-  observation = nil;
-  pathInfo->allOptions = 0;
-  count = [pathInfo->observations count];
-  while (count-- > 0)
-    {
-      GSKVOObservation      *o;
-
-      o = [pathInfo->observations objectAtIndex: count];
-      if (o->observer == anObserver)
-        {
-          o->context = aContext;
-          o->options = options;
-          observation = o;
-        }
-#if	GS_WITH_GC
-      else if (o->observer == nil)
-	{
-	  /* The observer for thsi observation must have been collected.
-	   */
-	  [pathInfo->observations removeObjectAtIndex: count];
-	  continue;
-	}
-#endif
-      pathInfo->allOptions |= o->options;
-    }
-  if (observation == nil)
-    {
-      observation = [GSKVOObservation new];
-      GSAssignZeroingWeakPointer((void**)&observation->observer,
-	(void*)anObserver);
-      observation->context = aContext;
-      observation->options = options;
-      [pathInfo->observations addObject: observation];
-      [observation release];
-      pathInfo->allOptions |= options;
-    }
-
-  if (options & NSKeyValueObservingOptionInitial)
-    {
-      /* If the NSKeyValueObservingOptionInitial option is set,
-       * we must send an immediate notification containing the
-       * existing value in the NSKeyValueChangeNewKey
-       */
-      [pathInfo->change setObject: [NSNumber numberWithInt: 1]
-                           forKey:  NSKeyValueChangeKindKey];
-      if (options & NSKeyValueObservingOptionNew)
-        {
-          id    value;
-
-          value = [instance valueForKey: aPath];
-          if (value == nil)
-            {
-              value = null;
-            }
-          [pathInfo->change setObject: value
-                               forKey: NSKeyValueChangeNewKey];
-        }
-      [anObserver observeValueForKeyPath: aPath
-                                ofObject: instance
-                                  change: pathInfo->change
-                                 context: aContext];
-    }
-  [iLock unlock];
-}
-
-- (void) dealloc
-{
-  if (paths != 0) NSFreeMapTable(paths);
-  RELEASE(iLock);
-  [super dealloc];
-}
-
-- (id) initWithInstance: (NSObject*)i
-{
-  instance = i;
-  paths = NSCreateMapTable(NSObjectMapKeyCallBacks,
-    NSObjectMapValueCallBacks, 8);
-  iLock = [GSLazyRecursiveLock new];
-  return self;
-}
-
-- (BOOL) isUnobserved
-{
-  BOOL	result = NO;
-
-  [iLock lock];
-  if (NSCountMapTable(paths) == 0)
-    {
-      result = YES;
-    }
-  [iLock unlock];
-  return result;
-}
-
-/*
- * removes the observer
- */
-- (void) removeObserver: (NSObject*)anObserver forKeyPath: (NSString*)aPath
-{
-  GSKVOPathInfo	*pathInfo;
-
-  [iLock lock];
-  pathInfo = (GSKVOPathInfo*)NSMapGet(paths, (void*)aPath);
-  if (pathInfo != nil)
-    {
-      unsigned  count = [pathInfo->observations count];
-
-      pathInfo->allOptions = 0;
-      while (count-- > 0)
-        {
-          GSKVOObservation      *o;
-
-          o = [pathInfo->observations objectAtIndex: count];
-          if (o->observer == anObserver || o->observer == nil)
-            {
-              [pathInfo->observations removeObjectAtIndex: count];
-              if ([pathInfo->observations count] == 0)
-                {
-                  NSMapRemove(paths, (void*)aPath);
-                }
-            }
-          else
-            {
-              pathInfo->allOptions |= o->options;
-            }
-	}
-    }
-  [iLock unlock];
-}
-
-- (void*) contextForObserver: (NSObject*)anObserver ofKeyPath: (NSString*)aPath
-{
-  GSKVOPathInfo	*pathInfo;
-  void          *context = 0;
-
-  [iLock lock];
-  pathInfo = (GSKVOPathInfo*)NSMapGet(paths, (void*)aPath);
-  if (pathInfo != nil)
-    {
-      unsigned  count = [pathInfo->observations count];
-
-      while (count-- > 0)
-        {
-          GSKVOObservation      *o;
-
-          o = [pathInfo->observations objectAtIndex: count];
-          if (o->observer == anObserver)
-            {
-              context = o->context;
-              break;
-            }
-#if	GS_WITH_GC
-	  else if (o->observer == nil)
-	    {
-	      /* The observer for thsi observation must have been collected.
-	       */
-	      [pathInfo->observations removeObjectAtIndex: count];
-	    }
-#endif
-	}
-    }
-  [iLock unlock];
-  return context;
-}
-@end
-
-@implementation NSKeyValueObservationForwarder
-
-- (id) initWithKeyPath: (NSString *)keyPath
-              ofObject: (id)object
-            withTarget: (id)aTarget
-               context: (void *)context
-{
-  NSString * remainingKeyPath;
-  NSRange dot;
-
-  target = aTarget;
-  keyPathToForward = [keyPath copy];
-  contextToForward = context;
-
-  dot = [keyPath rangeOfString: @"."];
-  if (dot.location == NSNotFound)
-    {
-      [NSException raise: NSInvalidArgumentException
-        format: @"NSKeyValueObservationForwarder was not given a key path"];
-    }
-  keyForUpdate = [[keyPath substringToIndex: dot.location] copy];
-  remainingKeyPath = [keyPath substringFromIndex: dot.location + 1];
-  observedObjectForUpdate = object;
-  [object addObserver: self
-           forKeyPath: keyForUpdate
-              options: NSKeyValueObservingOptionNew
-                     | NSKeyValueObservingOptionOld
-              context: target];
-  dot = [remainingKeyPath rangeOfString: @"."];
-  if (dot.location != NSNotFound)
-    {
-      child = [[NSKeyValueObservationForwarder alloc]
-        initWithKeyPath: remainingKeyPath
-	       ofObject: [object valueForKey: keyForUpdate]
-	     withTarget: self
-		context: NULL];
-      observedObjectForForwarding = nil;
-    }
-  else
-    {
-      keyForForwarding = [remainingKeyPath copy];
-      observedObjectForForwarding = [object valueForKey: keyForUpdate];
-      [observedObjectForForwarding addObserver: self
-                                    forKeyPath: keyForForwarding
-                                       options: NSKeyValueObservingOptionNew
-                                              | NSKeyValueObservingOptionOld
-                                       context: target];
-      child = nil;
-    }
-
-  return self;
-}
-
-- (void) finalize
-{
-  if (child)
-    {
-      [child finalize];
-    }
-  if (observedObjectForUpdate)
-    {
-      [observedObjectForUpdate removeObserver: self forKeyPath: keyForUpdate];
-    }
-  if (observedObjectForForwarding)
-    {
-      [observedObjectForForwarding removeObserver: self forKeyPath:
-        keyForForwarding];
-    }
-  DESTROY(self);
-}
-
-- (void) dealloc
-{
-  [keyForUpdate release];
-  [keyForForwarding release];
-  [keyPathToForward release];
-
-  [super dealloc];
-}
-
-- (void) observeValueForKeyPath: (NSString *)keyPath
-                       ofObject: (id)anObject
-                         change: (NSDictionary *)change
-                        context: (void *)context
-{
-  if (anObject == observedObjectForUpdate)
-    {
-      [self keyPathChanged: nil];
-    }
-  else
-    {
-      [target observeValueForKeyPath: keyPathToForward
-                            ofObject: observedObjectForUpdate
-                              change: change
-                             context: contextToForward];
-    }
-}
-
-- (void) keyPathChanged: (id)objectToObserve
-{
-  if (objectToObserve != nil)
-    {
-      [observedObjectForUpdate removeObserver: self forKeyPath: keyForUpdate];
-      observedObjectForUpdate = objectToObserve;
-      [objectToObserve addObserver: self
-                        forKeyPath: keyForUpdate
-                           options: NSKeyValueObservingOptionNew
-                                  | NSKeyValueObservingOptionOld
-                           context: target];
-    }
-  if (child != nil)
-    {
-      [child keyPathChanged:
-        [observedObjectForUpdate valueForKey: keyForUpdate]];
-    }
-  else
-    {
-      NSMutableDictionary *change;
-
-      change = [NSMutableDictionary dictionaryWithObject:
-                                        [NSNumber numberWithInt: 1]
-                                    forKey:  NSKeyValueChangeKindKey];
-
-      if (observedObjectForForwarding != nil)
-        {
-          id oldValue;
-
-          oldValue
-            = [observedObjectForForwarding valueForKey: keyForForwarding];
-          [observedObjectForForwarding removeObserver: self forKeyPath:
-                                           keyForForwarding];
-          if (oldValue)
-            {
-              [change setObject: oldValue
-                         forKey: NSKeyValueChangeOldKey];
-            }
-        }
-      observedObjectForForwarding = [observedObjectForUpdate
-        valueForKey:keyForUpdate];
-      if (observedObjectForForwarding != nil)
-        {
-          id newValue;
-
-          [observedObjectForForwarding addObserver: self
-                                       forKeyPath: keyForForwarding
-                                       options: NSKeyValueObservingOptionNew
-                                       | NSKeyValueObservingOptionOld
-                                       context: target];
-          //prepare change notification
-          newValue
-            = [observedObjectForForwarding valueForKey: keyForForwarding];
-          if (newValue)
-            {
-              [change setObject: newValue forKey: NSKeyValueChangeNewKey];
-            }
-        }
-      [target observeValueForKeyPath: keyPathToForward
-                            ofObject: observedObjectForUpdate
-                              change: change
-                             context: contextToForward];
-    }
-}
-
-@end
-
-@implementation NSObject (NSKeyValueObserving)
-
-- (void) observeValueForKeyPath: (NSString*)aPath
-		       ofObject: (id)anObject
-			 change: (NSDictionary*)aChange
-		        context: (void*)aContext
-{
-  [NSException raise: NSInvalidArgumentException
-              format: @"-%@ cannot be sent to %@ ..."
-              @" create an instance overriding this",
-              NSStringFromSelector(_cmd), NSStringFromClass([self class])];
-  return;
-}
-
-@end
-
-@implementation NSObject (NSKeyValueObserverRegistration)
-
-- (void) addObserver: (NSObject*)anObserver
-	  forKeyPath: (NSString*)aPath
-	     options: (NSKeyValueObservingOptions)options
-	     context: (void*)aContext
-{
-  GSKVOInfo             *info;
-  GSKVOReplacement      *r;
-  NSKeyValueObservationForwarder *forwarder;
-  NSRange               dot;
-
-  setup();
-  [kvoLock lock];
-
-  // Use the original class
-  r = replacementForClass([self class]);
-
-  /*
-   * Get the existing observation information, creating it (and changing
-   * the receiver to start key-value-observing by switching its class)
-   * if necessary.
-   */
-  info = (GSKVOInfo*)[self observationInfo];
-  if (info == nil)
-    {
-      info = [[GSKVOInfo alloc] initWithInstance: self];
-      [self setObservationInfo: info];
-      object_setClass(self, [r replacement]);
-    }
-
-  /*
-   * Now add the observer.
-   */
-  dot = [aPath rangeOfString:@"."];
-  if (dot.location != NSNotFound)
-    {
-      forwarder = [[NSKeyValueObservationForwarder alloc]
-        initWithKeyPath: aPath
-	       ofObject: self
-	     withTarget: anObserver
-		context: aContext];
-      [info addObserver: anObserver
-             forKeyPath: aPath
-                options: options
-                context: forwarder];
-    }
-  else
-    {
-      [r overrideSetterFor: aPath];
-      [info addObserver: anObserver
-             forKeyPath: aPath
-                options: options
-                context: aContext];
-    }
-
-  [kvoLock unlock];
-}
-
-- (void) removeObserver: (NSObject*)anObserver forKeyPath: (NSString*)aPath
-{
-  GSKVOInfo	*info;
-  id forwarder;
-
-  setup();
-  [kvoLock lock];
-  /*
-   * Get the observation information and remove this observation.
-   */
-  info = (GSKVOInfo*)[self observationInfo];
-  forwarder = [info contextForObserver: anObserver ofKeyPath: aPath];
-  [info removeObserver: anObserver forKeyPath: aPath];
-  if ([info isUnobserved] == YES)
-    {
-      /*
-       * The instance is no longer being observed ... so we can
-       * turn off key-value-observing for it.
-       */
-      object_setClass(self, [self class]);
-      IF_NO_GC(AUTORELEASE(info);)
-      [self setObservationInfo: nil];
-    }
-  [kvoLock unlock];
-  if ([aPath rangeOfString:@"."].location != NSNotFound)
-    [forwarder finalize];
-}
-
-@end
-
-/**
- * NSArray objects are not observable, so the registration methods
- * raise an exception.
- */
-@implementation NSArray (NSKeyValueObserverRegistration)
-
-- (void) addObserver: (NSObject*)anObserver
-	  forKeyPath: (NSString*)aPath
-	     options: (NSKeyValueObservingOptions)options
-	     context: (void*)aContext
-{
-  [NSException raise: NSGenericException
-	      format: @"[%@-%@]: This class is not observable",
-    NSStringFromClass([self class]), NSStringFromSelector(_cmd)];
-}
-
-- (void) addObserver: (NSObject*)anObserver
-  toObjectsAtIndexes: (NSIndexSet*)indexes
-	  forKeyPath: (NSString*)aPath
-	     options: (NSKeyValueObservingOptions)options
-	     context: (void*)aContext
-{
-  [self notImplemented: _cmd];
-}
-
-- (void) removeObserver: (NSObject*)anObserver forKeyPath: (NSString*)aPath
-{
-  [NSException raise: NSGenericException
-	      format: @"[%@-%@]: This class is not observable",
-    NSStringFromClass([self class]), NSStringFromSelector(_cmd)];
-}
-
-- (void) removeObserver: (NSObject*)anObserver
-   fromObjectsAtIndexes: (NSIndexSet*)indexes
-	     forKeyPath: (NSString*)aPath
-{
-  [self notImplemented: _cmd];
-}
-
-@end
-
-/**
- * NSSet objects are not observable, so the registration methods
- * raise an exception.
- */
-@implementation NSSet (NSKeyValueObserverRegistration)
-
-- (void) addObserver: (NSObject*)anObserver
-	  forKeyPath: (NSString*)aPath
-	     options: (NSKeyValueObservingOptions)options
-	     context: (void*)aContext
-{
-  [NSException raise: NSGenericException
-	      format: @"[%@-%@]: This class is not observable",
-    NSStringFromClass([self class]), NSStringFromSelector(_cmd)];
-}
-
-- (void) removeObserver: (NSObject*)anObserver forKeyPath: (NSString*)aPath
-{
-  [NSException raise: NSGenericException
-	      format: @"[%@-%@]: This class is not observable",
-    NSStringFromClass([self class]), NSStringFromSelector(_cmd)];
-}
-
-@end
-
-@implementation NSObject (NSKeyValueObserverNotification)
-
-- (void) willChangeValueForDependentsOfKey: (NSString *)aKey
-{
-  NSMapTable *keys = NSMapGet(dependentKeyTable, [self class]);
-
-  if (keys != nil)
-    {
-      NSHashTable       *dependents = NSMapGet(keys, aKey);
-
-      if (dependents != 0)
-        {
-          NSString              *dependentKey;
-          NSHashEnumerator      dependentKeyEnum;
-
-          dependentKeyEnum = NSEnumerateHashTable(dependents);
-          while ((dependentKey = NSNextHashEnumeratorItem(&dependentKeyEnum)))
-            {
-              [self willChangeValueForKey: dependentKey];
-            }
-          NSEndHashTableEnumeration(&dependentKeyEnum);
-        }
-    }
-}
-
-- (void) didChangeValueForDependentsOfKey: (NSString *)aKey
-{
-  NSMapTable *keys = NSMapGet(dependentKeyTable, [self class]);
-
-  if (keys != nil)
-    {
-      NSHashTable *dependents = NSMapGet(keys, aKey);
-
-      if (dependents != nil)
-        {
-          NSString              *dependentKey;
-          NSHashEnumerator      dependentKeyEnum;
-
-          dependentKeyEnum = NSEnumerateHashTable(dependents);
-          while ((dependentKey = NSNextHashEnumeratorItem(&dependentKeyEnum)))
-            {
-              [self didChangeValueForKey: dependentKey];
-            }
-          NSEndHashTableEnumeration(&dependentKeyEnum);
-        }
-    }
-}
-
-- (void) willChangeValueForKey: (NSString*)aKey
-{
-  GSKVOPathInfo *pathInfo;
-  GSKVOInfo     *info;
-
-  info = (GSKVOInfo *)[self observationInfo];
-  if (info == nil)
-    {
-      return;
-    }
-
-  pathInfo = [info lockReturningPathInfoForKey: aKey];
-  if (pathInfo != nil)
-    {
-      if (pathInfo->recursion++ == 0)
-        {
-          id    old = [pathInfo->change objectForKey: NSKeyValueChangeNewKey];
-
-          if (old != nil)
-            {
-              /* We have set a value for this key already, so the value
-               * we set must now be the old value and we don't need to
-               * refetch it.
-               */
-              [pathInfo->change setObject: old
-                                   forKey: NSKeyValueChangeOldKey];
-              [pathInfo->change removeObjectForKey: NSKeyValueChangeNewKey];
-            }
-          else if (pathInfo->allOptions & NSKeyValueObservingOptionOld)
-            {
-              /* We don't have an old value set, so we must fetch the
-               * existing value because at least one observation wants it.
-               */
-              old = [self valueForKey: aKey];
-              if (old == nil)
-                {
-                  old = null;
-                }
-              [pathInfo->change setObject: old
-                                   forKey: NSKeyValueChangeOldKey];
-            }
-          [pathInfo->change setValue:
-            [NSNumber numberWithInt: NSKeyValueChangeSetting]
-            forKey: NSKeyValueChangeKindKey];
-
-          [pathInfo notifyForKey: aKey ofInstance: [info instance] prior: YES];
-        }
-      [info unlock];
-    }
-
-  [self willChangeValueForDependentsOfKey: aKey];
-}
-
-- (void) didChangeValueForKey: (NSString*)aKey
-{
-  GSKVOPathInfo *pathInfo;
-  GSKVOInfo	*info;
-
-  info = (GSKVOInfo *)[self observationInfo];
-  if (info == nil)
-    {
-      return;
-    }
-
-  pathInfo = [info lockReturningPathInfoForKey: aKey];
-  if (pathInfo != nil)
-    {
-      if (pathInfo->recursion == 1)
-        {
-          id    value = [self valueForKey: aKey];
-
-          if (value == nil)
-            {
-              value = null;
-            }
-          [pathInfo->change setValue: value
-                              forKey: NSKeyValueChangeNewKey];
-          [pathInfo->change setValue:
-            [NSNumber numberWithInt: NSKeyValueChangeSetting]
-            forKey: NSKeyValueChangeKindKey];
-          [pathInfo notifyForKey: aKey ofInstance: [info instance] prior: NO];
-        }
-      if (pathInfo->recursion > 0)
-        {
-          pathInfo->recursion--;
-        }
-      [info unlock];
-    }
-
-  [self didChangeValueForDependentsOfKey: aKey];
-}
-
-- (void) didChange: (NSKeyValueChange)changeKind
-   valuesAtIndexes: (NSIndexSet*)indexes
-	    forKey: (NSString*)aKey
-{
-  GSKVOPathInfo *pathInfo;
-  GSKVOInfo	*info;
-
-  info = [self observationInfo];
-  if (info == nil)
-    {
-      return;
-    }
-
-  pathInfo = [info lockReturningPathInfoForKey: aKey];
-  if (pathInfo != nil)
-    {
-      if (pathInfo->recursion == 1)
-        {
-          NSMutableArray        *array;
-
-          array = [self valueForKey: aKey];
-          [pathInfo->change setValue: [NSNumber numberWithInt: changeKind]
-                              forKey: NSKeyValueChangeKindKey];
-          [pathInfo->change setValue: indexes
-                              forKey: NSKeyValueChangeIndexesKey];
-
-          if (changeKind == NSKeyValueChangeInsertion
-            || changeKind == NSKeyValueChangeReplacement)
-            {
-              [pathInfo->change setValue: [array objectsAtIndexes: indexes]
-                                  forKey: NSKeyValueChangeNewKey];
-            }
-          [pathInfo notifyForKey: aKey ofInstance: [info instance] prior: NO];
-        }
-      if (pathInfo->recursion > 0)
-        {
-          pathInfo->recursion--;
-        }
-      [info unlock];
-    }
-
-  [self didChangeValueForDependentsOfKey: aKey];
-}
-
-- (void) willChange: (NSKeyValueChange)changeKind
-    valuesAtIndexes: (NSIndexSet*)indexes
-	     forKey: (NSString*)aKey
-{
-  GSKVOPathInfo *pathInfo;
-  GSKVOInfo	*info;
-
-  info = [self observationInfo];
-  if (info == nil)
-    {
-      return;
-    }
-
-  pathInfo = [info lockReturningPathInfoForKey: aKey];
-  if (pathInfo != nil)
-    {
-      if (pathInfo->recursion++ == 0)
-        {
-          NSMutableArray        *array;
-
-          array = [self valueForKey: aKey];
-          if (changeKind == NSKeyValueChangeRemoval
-            || changeKind == NSKeyValueChangeReplacement)
-            {
-              [pathInfo->change setValue: [array objectsAtIndexes: indexes]
-                                  forKey: NSKeyValueChangeOldKey];
-            }
-          [pathInfo->change setValue: [NSNumber numberWithInt: changeKind]
-                              forKey: NSKeyValueChangeKindKey];
-          [pathInfo notifyForKey: aKey ofInstance: [info instance] prior: YES];
-        }
-      [info unlock];
-    }
-
-  [self willChangeValueForDependentsOfKey: aKey];
-}
-
-- (void) willChangeValueForKey: (NSString*)aKey
-	       withSetMutation: (NSKeyValueSetMutationKind)mutationKind
-		  usingObjects: (NSSet*)objects
-{
-  GSKVOPathInfo *pathInfo;
-  GSKVOInfo	*info;
-
-  info = [self observationInfo];
-  if (info == nil)
-    {
-      return;
-    }
-
-  pathInfo = [info lockReturningPathInfoForKey: aKey];
-  if (pathInfo != nil)
-    {
-      if (pathInfo->recursion++ == 0)
-        {
-          id    set = objects;
-
-          if (nil == set)
-            {
-              set = [self valueForKey: aKey];
-            }
-          [pathInfo->change setValue: [set mutableCopy] forKey: @"oldSet"];
-          [pathInfo notifyForKey: aKey ofInstance: [info instance] prior: YES];
-        }
-      [info unlock];
-    }
-
-  [self willChangeValueForDependentsOfKey: aKey];
-}
-
-- (void) didChangeValueForKey: (NSString*)aKey
-	      withSetMutation: (NSKeyValueSetMutationKind)mutationKind
-		 usingObjects: (NSSet*)objects
-{
-  GSKVOPathInfo *pathInfo;
-  GSKVOInfo	*info;
-
-  info = [self observationInfo];
-  if (info == nil)
-    {
-      return;
-    }
-
-  pathInfo = [info lockReturningPathInfoForKey: aKey];
-  if (pathInfo != nil)
-    {
-      if (pathInfo->recursion == 1)
-        {
-          NSMutableSet  *oldSet;
-          id            set = objects;
-
-          oldSet = [pathInfo->change valueForKey: @"oldSet"];
-          if (nil == set)
-            {
-              set = [self valueForKey: aKey];
-            }
-          [pathInfo->change removeObjectForKey: @"oldSet"];
-
-          if (mutationKind == NSKeyValueUnionSetMutation)
-            {
-              set = [set mutableCopy];
-              [set minusSet: oldSet];
-              [pathInfo->change setValue:
-                [NSNumber numberWithInt: NSKeyValueChangeInsertion]
-                        forKey: NSKeyValueChangeKindKey];
-              [pathInfo->change setValue: set
-                                  forKey: NSKeyValueChangeNewKey];
-            }
-          else if (mutationKind == NSKeyValueMinusSetMutation
-            || mutationKind == NSKeyValueIntersectSetMutation)
-            {
-              [oldSet minusSet: set];
-              [pathInfo->change setValue:
-                [NSNumber numberWithInt: NSKeyValueChangeRemoval]
-                        forKey: NSKeyValueChangeKindKey];
-              [pathInfo->change setValue: oldSet
-                                  forKey: NSKeyValueChangeOldKey];
-            }
-          else if (mutationKind == NSKeyValueSetSetMutation)
-            {
-              NSMutableSet      *old;
-              NSMutableSet      *new;
-
-              old = [oldSet mutableCopy];
-              [old minusSet: set];
-              new = [set mutableCopy];
-              [new minusSet: oldSet];
-              [pathInfo->change setValue:
-                [NSNumber numberWithInt: NSKeyValueChangeReplacement]
-                        forKey: NSKeyValueChangeKindKey];
-              [pathInfo->change setValue: old
-                                  forKey: NSKeyValueChangeOldKey];
-              [pathInfo->change setValue: new
-                                  forKey: NSKeyValueChangeNewKey];
-            }
-
-          [pathInfo notifyForKey: aKey ofInstance: [info instance] prior: NO];
-        }
-      if (pathInfo->recursion > 0)
-        {
-          pathInfo->recursion--;
-        }
-      [info unlock];
-    }
-  [self didChangeValueForDependentsOfKey: aKey];
-}
-
-@end
-
-@implementation NSObject (NSKeyValueObservingCustomization)
-
-+ (BOOL) automaticallyNotifiesObserversForKey: (NSString*)aKey
-{
-  return YES;
-}
-
-+ (void) setKeys: (NSArray*)triggerKeys
-triggerChangeNotificationsForDependentKey: (NSString*)dependentKey
-{
-  NSMapTable    *affectingKeys;
-  NSEnumerator  *enumerator;
-  NSString      *affectingKey;
-
-  setup();
-  affectingKeys = NSMapGet(dependentKeyTable, self);
-  if (!affectingKeys)
-    {
-      affectingKeys = NSCreateMapTable(NSObjectMapKeyCallBacks,
-        NSNonOwnedPointerMapValueCallBacks, 10);
-      NSMapInsert(dependentKeyTable, self, affectingKeys);
-    }
-  enumerator = [triggerKeys objectEnumerator];
-  while ((affectingKey = [enumerator nextObject]))
-    {
-      NSHashTable *dependentKeys = NSMapGet(affectingKeys, affectingKey);
-
-      if (!dependentKeys)
-        {
-          dependentKeys = NSCreateHashTable(NSObjectHashCallBacks, 10);
-          NSMapInsert(affectingKeys, affectingKey, dependentKeys);
-        }
-      NSHashInsert(dependentKeys, dependentKey);
-    }
-}
-
-- (void*) observationInfo
-{
-  void	*info;
-
-  setup();
-  [kvoLock lock];
-  info = NSMapGet(infoTable, (void*)self);
-  IF_NO_GC(AUTORELEASE(RETAIN((id)info));)
-  [kvoLock unlock];
-  return info;
-}
-
-- (void) setObservationInfo: (void*)observationInfo
-{
-  setup();
-  [kvoLock lock];
-  if (observationInfo == 0)
-    {
-      NSMapRemove(infoTable, (void*)self);
-    }
-  else
-    {
-      NSMapInsert(infoTable, (void*)self, observationInfo);
-    }
-  [kvoLock unlock];
-}
-
-@end
-
diff --git a/Source/NSKeyedArchiver.m b/Source/NSKeyedArchiver.m
index 55c9a28..c662cd5 100644
--- a/Source/NSKeyedArchiver.m
+++ b/Source/NSKeyedArchiver.m
@@ -132,12 +132,12 @@ setupCache(void)
 /*
  * Make a dictionary referring to the object at ref in the array of all objects.
  */
-static NSDictionary *makeReference(unsigned ref)
+static NSDictionary *makeReference(NSUInteger ref)
 {
   NSNumber	*n;
   NSDictionary	*d;
 
-  n = [NSNumber numberWithUnsignedInt: ref];
+  n = [NSNumber numberWithUnsignedInteger: ref];
   d = [NSDictionary dictionaryWithObject: n forKey:  @"CF$UID"];
   return d;
 }
@@ -163,8 +163,8 @@ static NSDictionary *makeReference(unsigned ref)
   else
     {
       NSMutableArray	*m;
-      unsigned		c;
-      unsigned		i;
+      NSUInteger		c;
+      NSUInteger		i;
 
       c = [anArray count];
       m = [NSMutableArray arrayWithCapacity: c];
@@ -198,7 +198,7 @@ static NSDictionary *makeReference(unsigned ref)
   id			objectInfo = nil;	// Encoded object
   NSMutableDictionary	*m = nil;
   NSDictionary		*refObject;
-  unsigned		ref = 0;		// Reference to nil
+  NSUInteger		ref = 0;		// Reference to nil
 
   if (anObject != nil)
     {
@@ -732,17 +732,17 @@ static NSDictionary *makeReference(unsigned ref)
 	return;
 
       case _C_CHR:
-	o = [NSNumber numberWithInt: (NSInteger)*(char*)address];
+	o = [NSNumber numberWithInteger: (NSInteger)*(char*)address];
 	[_enc setObject: o forKey: aKey];
 	return;
 
       case _C_UCHR:
-	o = [NSNumber numberWithInt: (NSInteger)*(unsigned char*)address];
+	o = [NSNumber numberWithInteger: (NSInteger)*(unsigned char*)address];
 	[_enc setObject: o forKey: aKey];
 	return;
 
       case _C_SHT:
-	o = [NSNumber numberWithInt: (NSInteger)*(short*)address];
+	o = [NSNumber numberWithInteger: (NSInteger)*(short*)address];
 	[_enc setObject: o forKey: aKey];
 	return;
 
@@ -752,12 +752,12 @@ static NSDictionary *makeReference(unsigned ref)
 	return;
 
       case _C_INT:
-	o = [NSNumber numberWithInt: *(NSInteger*)address];
+	o = [NSNumber numberWithInteger: *(NSInteger*)address];
 	[_enc setObject: o forKey: aKey];
 	return;
 
       case _C_UINT:
-	o = [NSNumber numberWithUnsignedInt: *(NSUInteger*)address];
+	o = [NSNumber numberWithUnsignedInteger: *(NSUInteger*)address];
 	[_enc setObject: o forKey: aKey];
 	return;
 
diff --git a/Source/NSKeyedUnarchiver.m b/Source/NSKeyedUnarchiver.m
index 5b68f37..89d5691 100644
--- a/Source/NSKeyedUnarchiver.m
+++ b/Source/NSKeyedUnarchiver.m
@@ -45,7 +45,12 @@
 #define GSI_ARRAY_RETAIN(A, X)	[(X).obj retain]
 #define GSI_ARRAY_RELEASE(A, X)	[(X).obj release]
 #endif
-#define GSI_ARRAY_TYPES GSUNION_OBJ
+/* 
+ * With Apple's clang: 
+ * nil is void* and -initForReadingWithData: uses it as GSIMapKey,
+ * so there is a need to add GSUNION_PTR
+ */
+#define GSI_ARRAY_TYPES GSUNION_OBJ|GSUNION_PTR
 
 
 #include "GNUstepBase/GSIArray.h"
@@ -83,6 +88,31 @@ static NSMapTable	*globalClassMap = 0;
   o = [_keyMap objectForKey: aKey];
 
 
+/* This is really, really dirty and SHOULD be removed */
+@implementation NSKeyedUnarchiver (GNUstepGUI)
+
+- (BOOL)replaceObject:(id)anObject withObject:(id)newObject
+{
+    NSUInteger index = 0;
+    NSUInteger count = GSIArrayCount(_objMap);
+    for (index = 0; index < count; ++index)
+    {
+        id obj = GSIArrayItemAtIndex(_objMap, index).obj;
+        if (obj == anObject) {
+            break;
+        }
+    }
+    
+    if (index < count)
+    {
+        GSIArraySetItemAtIndex(_objMap, (GSIArrayItem)newObject, index);
+        return YES;
+    }
+    
+    return NO;
+}
+
+@end
 
 @interface NSKeyedUnarchiver (Private)
 - (id) _decodeObject: (unsigned)index;
@@ -101,9 +131,9 @@ static NSMapTable	*globalClassMap = 0;
     {
       if ([o isKindOfClass: [NSArray class]] == YES)
 	{
-	  unsigned		c = [o count];
+	  NSUInteger c = [o count];
 	  NSMutableArray	*m = [NSMutableArray arrayWithCapacity: c];
-	  unsigned		i;
+	  NSUInteger i;
 
 	  for (i = 0; i < c; i++)
 	    {
@@ -217,25 +247,29 @@ static NSMapTable	*globalClassMap = 0;
       o = [c allocWithZone: _zone];	// Create instance.
       // Store object in map so that decoding of it can be self referential.
       GSIArraySetItemAtIndex(_objMap, (GSIArrayItem)o, index);
+      RETAIN(o);
       r = [o initWithCoder: self];
       if (r != o)
 	{
 	  [_delegate unarchiver: self
 	      willReplaceObject: o
 		     withObject: r];
-	  o = r;
-	  GSIArraySetItemAtIndex(_objMap, (GSIArrayItem)o, index);
+	  GSIArraySetItemAtIndex(_objMap, (GSIArrayItem)r, index);
 	}
+      RELEASE(o);
+      o = r;
+      RETAIN(o);
       r = [o awakeAfterUsingCoder: self];
       if (r != o)
 	{
 	  [_delegate unarchiver: self
 	      willReplaceObject: o
 		     withObject: r];
-	  o = r;
-	  GSIArraySetItemAtIndex(_objMap, (GSIArrayItem)o, index);
+	  
+	  GSIArraySetItemAtIndex(_objMap, (GSIArrayItem)r, index);
 	}
-
+      RELEASE(o);
+      o = r;
       if (_delegate != nil)
 	{
 	  r = [_delegate unarchiver: self didDecodeObject: o];
@@ -244,12 +278,13 @@ static NSMapTable	*globalClassMap = 0;
 	      [_delegate unarchiver: self
 		  willReplaceObject: o
 			 withObject: r];
-	      o = r;
-	      GSIArraySetItemAtIndex(_objMap, (GSIArrayItem)o, index);
+	      RELEASE(o);
+	      o = RETAIN(r);
+	      GSIArraySetItemAtIndex(_objMap, (GSIArrayItem)r, index);
 	    }
 	}
       RELEASE(o);	// Retained in array
-      obj = o;
+      obj = GSIArrayItemAtIndex(_objMap, index).obj;
       _keyMap = savedKeyMap;
       _cursor = savedCursor;
     }
@@ -394,13 +429,13 @@ static NSMapTable	*globalClassMap = 0;
     {
       [NSException raise: NSInvalidUnarchiveOperationException
 		  format: @"[%@ +%@]: type missmatch",
-	NSStringFromClass([self class]), NSStringFromSelector(_cmd), o];
+	NSStringFromClass([self class]), NSStringFromSelector(_cmd)];
     }
   if ([o count] != expected)
     {
       [NSException raise: NSInvalidUnarchiveOperationException
 		  format: @"[%@ +%@]: count missmatch",
-	NSStringFromClass([self class]), NSStringFromSelector(_cmd), o];
+	NSStringFromClass([self class]), NSStringFromSelector(_cmd)];
     }
   NSGetSizeAndAlignment(type, 0, &size);
   memcpy(buf, [o bytes], expected * size);
@@ -800,8 +835,8 @@ static NSMapTable	*globalClassMap = 0;
 	}
       else
 	{
-	  unsigned	count;
-	  unsigned	i;
+	  NSUInteger count;
+	  NSUInteger i;
 
 	  IF_NO_GC(RETAIN(_archive);)
 	  _archiverClass = [_archive objectForKey: @"$archiver"];
diff --git a/Source/NSLocale.m b/Source/NSLocale.m
index cba5d54..9415f17 100644
--- a/Source/NSLocale.m
+++ b/Source/NSLocale.m
@@ -739,8 +739,7 @@ static NSRecursiveLock *classLock = nil;
   
   localeId = [NSLocale canonicalLocaleIdentifierFromString: string];
   // Normalize locale ID
-  uloc_canonicalize ([localeId UTF8String], cLocaleId,
-    ULOC_FULLNAME_CAPACITY, &error);
+  uloc_canonicalize ([localeId UTF8String], cLocaleId, ULOC_FULLNAME_CAPACITY, &error);
   if (U_FAILURE(error))
     {
       [self release];
@@ -757,22 +756,27 @@ static NSRecursiveLock *classLock = nil;
       return nil;
     }
 
+  id result;
   [classLock lock];
   newLocale = [allLocales objectForKey: localeId];
   if (nil == newLocale)
     {
-      _localeId = [localeId copy];
-      _components = [[NSMutableDictionary alloc] initWithCapacity: 0];
-      [allLocales setObject: self forKey: localeId];
+        if (self = [super init])
+        {
+            _localeId = [localeId copy];
+            _components = [[NSMutableDictionary alloc] initWithCapacity: 0];
+            [allLocales setObject: self forKey: localeId];
+        }
+        result = self;
     }
   else
     {
       [self release];
-      self = [newLocale retain];
+      result = [newLocale retain];
     }
   [classLock unlock];
 
-  return self;
+  return result;
 }
 
 - (NSString *) localeIdentifier
@@ -953,12 +957,18 @@ static NSRecursiveLock *classLock = nil;
   cLocaleId = [_localeId UTF8String];
   localeData = ulocdata_open (cLocaleId, &err);
   if (U_FAILURE(err))
+  {
+    RELEASE(mSet);
     return nil;
+  }
   
   charSet = ulocdata_getExemplarSet (localeData, NULL,
     USET_ADD_CASE_MAPPINGS, ULOCDATA_ES_STANDARD, &err);
   if (U_FAILURE(err))
+  {
+    RELEASE(mSet);
     return nil;
+  }
   ulocdata_close(localeData);
   
   count = uset_getItemCount(charSet);
@@ -1008,7 +1018,7 @@ static NSRecursiveLock *classLock = nil;
   
   cLocaleId = [_localeId UTF8String];
   localeData = ulocdata_open (cLocaleId, &err);
-  strLen = ulocdata_getDelimiter (localeData, delimiterType, result, 32, &err);
+  strLen = ulocdata_getDelimiter (localeData, (ULocaleDataDelimiterType)delimiterType, result, 32, &err);
   ulocdata_close (localeData);
   if (U_SUCCESS(err))
     return [NSString stringWithCharacters: (unichar *)result length: strLen];
@@ -1035,7 +1045,7 @@ static NSRecursiveLock *classLock = nil;
   
   result = [[NSCalendar alloc] initWithCalendarIdentifier: calId];
   
-  return result;
+  return [result autorelease];
 #else
   return nil;
 #endif
diff --git a/Source/NSLock.m b/Source/NSLock.m
index 3a3294b..8a49717 100644
--- a/Source/NSLock.m
+++ b/Source/NSLock.m
@@ -133,6 +133,7 @@ static pthread_mutexattr_t attr_recursive;
 /*
  * OS X 10.5 compatibility function to allow debugging deadlock conditions.
  */
+void _NSLockError(id obj, SEL _cmd, BOOL stop);
 void _NSLockError(id obj, SEL _cmd, BOOL stop)
 {
   NSLog(@"*** -[%@ %@]: deadlock (%@)", [obj class],
diff --git a/Source/NSLog.m b/Source/NSLog.m
index 64e8462..d3ed322 100644
--- a/Source/NSLog.m
+++ b/Source/NSLog.m
@@ -112,7 +112,7 @@ _NSLog_standard_printf_handler (NSString* message)
 {
   NSData	*d;
   const char	*buf;
-  unsigned	len;
+  NSUInteger	len;
 #if	defined(__MINGW__)
   LPCWSTR	null_terminated_buf;
 #else
@@ -193,7 +193,7 @@ _NSLog_standard_printf_handler (NSString* message)
       // QNX's slog has a size limit per entry. We might need to iterate over
 	  // _SLOG_MAXSIZEd chunks of the buffer
       const char *newBuf = buf;
-      unsigned newLen = len;
+      NSUInteger newLen = len;
 
       // Allocate at most _SLOG_MAXSIZE bytes
 	  null_terminated_buf = malloc(sizeof(char) * MIN(newLen, _SLOG_MAXSIZE));
@@ -341,8 +341,8 @@ NSLogv (NSString* format, va_list args)
     {
       if (GSPrivateDefaultsFlag(GSLogThread) == YES)
 	{
-	  prefix = [NSString stringWithFormat: @"[thread:%x] ",
-	    GSCurrentThread()];
+	  prefix = [NSString stringWithFormat: @"[thread:%lx] ",
+	    (unsigned long)GSCurrentThread()];
 	}
       else
 	{
@@ -355,11 +355,11 @@ NSLogv (NSString* format, va_list args)
       if (GSPrivateDefaultsFlag(GSLogThread) == YES)
 	{
 	  prefix = [NSString
-	    stringWithFormat: @"%@ %@[%d,%x] ",
+	    stringWithFormat: @"%@ %@[%d,%lxx] ",
 	    [[NSCalendarDate calendarDate]
 	      descriptionWithCalendarFormat: @"%Y-%m-%d %H:%M:%S.%F"],
 	    [[NSProcessInfo processInfo] processName],
-	    pid, GSCurrentThread()];
+	    pid, (unsigned long)GSCurrentThread()];
 	}
       else
 	{
diff --git a/Source/NSMapTable.m b/Source/NSMapTable.m
index edcae2e..eb6e467 100644
--- a/Source/NSMapTable.m
+++ b/Source/NSMapTable.m
@@ -151,8 +151,11 @@ static Class	concreteClass = 0;
 	     valuePointerFunctions: (NSPointerFunctions*)valueFunctions
 			  capacity: (NSUInteger)initialCapacity
 {
-  [self subclassResponsibility: _cmd];
-  return nil;
+    if ([self class] == [NSMapTable class]) {
+        [self subclassResponsibility: _cmd];
+        return nil;
+    }
+    return [super init];
 }
 
 - (id) copyWithZone: (NSZone*)aZone
diff --git a/Source/NSMessagePort.m b/Source/NSMessagePort.m
index 6546515..27114dd 100644
--- a/Source/NSMessagePort.m
+++ b/Source/NSMessagePort.m
@@ -189,7 +189,7 @@ newDataWithEncodedPort(NSMessagePort *port)
   unsigned		plen;
   const unsigned char	*name = [port _name];
 
-  plen = 2 + strlen((char*)name);
+  plen = (unsigned)strlen((char*)name) + 2;
 
   data = [[NSMutableData alloc] initWithLength: sizeof(GSPortItemHeader)+plen];
   pih = (GSPortItemHeader*)[data mutableBytes];
@@ -203,6 +203,13 @@ newDataWithEncodedPort(NSMessagePort *port)
   return data;
 }
 
+NS_INLINE uint32_t
+SwapHostLengthToBig(NSUInteger length)
+{
+    NSCParameterAssert(length <= UINT32_MAX);
+    return GSSwapHostI32ToBig((uint32_t)length);
+}
+
 /* Older systems (Solaris) compatibility */
 #ifndef AF_LOCAL
 #define AF_LOCAL AF_UNIX
@@ -351,7 +358,7 @@ static Class	runLoopClass;
   const unsigned char *name;
 
   M_LOCK(myLock);
-  NSDebugMLLog(@"NSMessagePort", @"Connecting on 0x%x before %@", self, when);
+  NSDebugMLLog(@"NSMessagePort", @"Connecting on 0x%lx before %@", (unsigned long)self, when);
   if (state != GS_H_UNCON)
     {
       BOOL	result;
@@ -388,7 +395,7 @@ static Class	runLoopClass;
   sockAddr.sun_family = AF_LOCAL;
   strncpy(sockAddr.sun_path, (char*)name, sizeof(sockAddr.sun_path));
 
-  if (connect(desc, (struct sockaddr*)&sockAddr, SUN_LEN(&sockAddr)) < 0)
+  if (connect(desc, (struct sockaddr*)&sockAddr, (socklen_t)SUN_LEN(&sockAddr)) < 0)
     {
       if (!GSWOULDBLOCK)
 	{
@@ -500,7 +507,7 @@ static Class	runLoopClass;
 		    type: ET_WDESC
 		 forMode: nil
 		     all: YES];
-	  NSDebugMLLog(@"NSMessagePort", @"invalidated 0x%x", self);
+	  NSDebugMLLog(@"NSMessagePort", @"invalidated 0x%lx", (unsigned long)self);
 	  [[self recvPort] removeHandle: self];
 	  [[self sendPort] removeHandle: self];
 	}
@@ -527,8 +534,8 @@ static Class	runLoopClass;
 	       forMode: (NSString*)mode
 {
   NSDebugMLLog(@"NSMessagePort_details",
-    @"received %s event on 0x%x",
-    type != ET_WDESC ? "read" : "write", self);
+    @"received %s event on 0x%lx",
+    type != ET_WDESC ? "read" : "write", (unsigned long)self);
   /*
    * If we have been invalidated (desc < 0) then we should ignore this
    * event and remove ourself from the runloop.
@@ -548,9 +555,9 @@ static Class	runLoopClass;
 
   if (type != ET_WDESC)
     {
-      unsigned	want;
+      NSUInteger	want;
       void	*bytes;
-      int	res;
+      ssize_t	res;
 
       /*
        * Make sure we have a buffer big enough to hold all the data we are
@@ -587,7 +594,7 @@ static Class	runLoopClass;
 	{
 	  if (res == 0)
 	    {
-	      NSDebugMLLog(@"NSMessagePort", @"read eof on 0x%x", self);
+	      NSDebugMLLog(@"NSMessagePort", @"read eof on 0x%lx", (unsigned long)self);
 	      M_UNLOCK(myLock);
 	      [self invalidate];
 	      return;
@@ -603,7 +610,7 @@ static Class	runLoopClass;
 	  res = 0;	/* Interrupted - continue	*/
 	}
       NSDebugMLLog(@"NSMessagePort_details",
-	@"read %d bytes on 0x%x", res, self);
+	@"read %zd bytes on 0x%lx", res, (unsigned long)self);
       rLength += res;
 
       while (valid == YES && rLength >= rWant)
@@ -861,7 +868,7 @@ static Class	runLoopClass;
 	      rId = 0;
 	      DESTROY(rItems);
 	      NSDebugMLLog(@"NSMessagePort_details",
-		@"got message %@ on 0x%x", pm, self);
+		@"got message %@ on 0x%lx", pm, (unsigned long)self);
 	      IF_NO_GC([rp retain];)
 	      M_UNLOCK(myLock);
 	      NS_DURING
@@ -905,11 +912,11 @@ static Class	runLoopClass;
 	    {
 	      NSData	*d = newDataWithEncodedPort([self recvPort]);
 
-	      len = write(desc, [d bytes], [d length]);
+	      ssize_t len = write(desc, [d bytes], [d length]);
 	      if (len == (int)[d length])
 		{
 		  NSDebugMLLog(@"NSMessagePort_details",
-		    @"wrote %d bytes on 0x%x", len, self);
+		    @"wrote %zd bytes on 0x%lx", len, (unsigned long)self);
 		  state = GS_H_CONNECTED;
 		}
 	      else
@@ -923,8 +930,8 @@ static Class	runLoopClass;
 	}
       else
 	{
-	  int		res;
-	  unsigned	l;
+	  ssize_t		res;
+	  NSUInteger	l;
 	  const void	*b;
 
 	  if (wData == nil)
@@ -959,7 +966,7 @@ static Class	runLoopClass;
 	  else
 	    {
 	      NSDebugMLLog(@"NSMessagePort_details",
-		@"wrote %d bytes on 0x%x", res, self);
+		@"wrote %zd bytes on 0x%lx", res, (unsigned long)self);
 	      wLength += res;
 	      if (wLength == l)
 		{
@@ -984,7 +991,7 @@ static Class	runLoopClass;
 		       * message completed - remove from list.
 		       */
 		      NSDebugMLLog(@"NSMessagePort_details",
-			@"completed 0x%x on 0x%x", components, self);
+			@"completed 0x%lx on 0x%lx", (unsigned long)components, (unsigned long)self);
 		      wData = nil;
 		      wItem = 0;
 		      [wMsgs removeObjectAtIndex: 0];
@@ -1004,8 +1011,8 @@ static Class	runLoopClass;
 
   NSAssert([components count] > 0, NSInternalInconsistencyException);
   NSDebugMLLog(@"NSMessagePort_details",
-    @"Sending message 0x%x %@ on 0x%x(%d) before %@",
-    components, components, self, desc, when);
+    @"Sending message 0x%lx %@ on 0x%lx(%d) before %@",
+    (unsigned long)components, components, (unsigned long)self, desc, when);
   M_LOCK(myLock);
   [wMsgs addObject: components];
 
@@ -1046,7 +1053,7 @@ static Class	runLoopClass;
     }
   M_UNLOCK(myLock);
   NSDebugMLLog(@"NSMessagePort_details",
-    @"Message send 0x%x on 0x%x status %d", components, self, sent);
+    @"Message send 0x%lx on 0x%lx status %d", (unsigned long)components, (unsigned long)self, sent);
   RELEASE(self);
   return sent;
 }
@@ -1281,11 +1288,9 @@ typedef	struct {
 	      NSLog(@"unable to create socket - %@", [NSError _last]);
 	      desc = -1;
 	    }
-	  else if (bind(desc, (struct sockaddr *)&sockAddr,
-	    SUN_LEN(&sockAddr)) < 0)
+	  else if (bind(desc, (struct sockaddr *)&sockAddr, (socklen_t)SUN_LEN(&sockAddr)) < 0)
 	    {
-	      if (connect(desc, (struct sockaddr*)&sockAddr,
-		SUN_LEN(&sockAddr)) < 0)
+	      if (connect(desc, (struct sockaddr*)&sockAddr, (socklen_t)SUN_LEN(&sockAddr)) < 0)
 		{
 		  NSDebugLLog(@"NSMessagePort", @"not live, reseting");
 		  unlink((const char*)socketName);
@@ -1296,8 +1301,7 @@ typedef	struct {
 			[NSError _last]);
 		      desc = -1;
 		    }
-		  else if (bind(desc, (struct sockaddr *)&sockAddr,
-		    SUN_LEN(&sockAddr)) < 0)
+		  else if (bind(desc, (struct sockaddr *)&sockAddr, (socklen_t)SUN_LEN(&sockAddr)) < 0)
 		    {
 		      NSLog(@"unable to bind to %s - %@",
 			sockAddr.sun_path, [NSError _last]);
@@ -1408,7 +1412,7 @@ typedef	struct {
 
 - (void) finalize
 {
-  NSDebugMLLog(@"NSMessagePort", @"NSMessagePort 0x%x finalized", self);
+  NSDebugMLLog(@"NSMessagePort", @"NSMessagePort 0x%lx finalized", (unsigned long)self);
   [self invalidate];
   if (_internal != 0)
     {
@@ -1575,12 +1579,12 @@ typedef	struct {
   if (d == nil)
     {
       NSDebugMLLog(@"NSMessagePort",
-	@"No delegate to handle incoming message", 0);
+	@"No delegate to handle incoming message");
       return;
     }
   if ([d respondsToSelector: @selector(handlePortMessage:)] == NO)
     {
-      NSDebugMLLog(@"NSMessagePort", @"delegate doesn't handle messages", 0);
+      NSDebugMLLog(@"NSMessagePort", @"delegate doesn't handle messages");
       return;
     }
   [d handlePortMessage: m];
@@ -1608,7 +1612,7 @@ typedef	struct {
       if ([self isValid] == YES)
 	{
 	  NSArray	*handleArray;
-	  unsigned	i;
+	  NSUInteger	i;
 
 	  M_LOCK(messagePortLock);
 	  NSMapRemove(messagePortMap, (void*)name);
@@ -1788,7 +1792,7 @@ typedef	struct {
 {
   BOOL		sent = NO;
   GSMessageHandle	*h;
-  unsigned	rl;
+  NSUInteger	rl;
 
   if ([self isValid] == NO)
     {
@@ -1820,12 +1824,12 @@ typedef	struct {
   if (h != nil)
     {
       NSMutableData	*header;
-      unsigned		hLength;
-      unsigned		l;
+      NSUInteger		hLength;
+      NSUInteger		l;
       GSPortItemHeader	*pih;
       GSPortMsgHeader	*pmh;
-      unsigned		c = [components count];
-      unsigned		i;
+      NSUInteger		c = [components count];
+      NSUInteger		i;
       BOOL		pack = YES;
 
       /*
@@ -1849,7 +1853,7 @@ typedef	struct {
       l = hLength - sizeof(GSPortItemHeader);
       pih = (GSPortItemHeader*)[header mutableBytes];
       pih->type = GSSwapHostI32ToBig(GSP_HEAD);
-      pih->length = GSSwapHostI32ToBig(l);
+      pih->length = SwapHostLengthToBig(l);
 
       /*
        * The message header contains the message Id and the original count
@@ -1857,8 +1861,8 @@ typedef	struct {
        * simply to hold the header).
        */
       pmh = (GSPortMsgHeader*)&pih[1];
-      pmh->mId = GSSwapHostI32ToBig(msgId);
-      pmh->nItems = GSSwapHostI32ToBig(c);
+      pmh->mId = SwapHostLengthToBig(msgId);
+      pmh->nItems = SwapHostLengthToBig(c);
 
       /*
        * Now insert item header information as required.
@@ -1874,8 +1878,8 @@ typedef	struct {
 	  if ([o isKindOfClass: [NSData class]])
 	    {
 	      GSPortItemHeader	*pih;
-	      unsigned		h = sizeof(GSPortItemHeader);
-	      unsigned		l = [o length];
+	      NSUInteger		h = sizeof(GSPortItemHeader);
+	      NSUInteger		l = [o length];
 	      void		*b;
 
 	      if (pack == YES && hLength + l + h <= NETBLOCK)
@@ -1907,7 +1911,7 @@ typedef	struct {
 #else
 		  pih = (GSPortItemHeader*)b;
 		  pih->type = GSSwapHostI32ToBig(GSP_DATA);
-		  pih->length = GSSwapHostI32ToBig(l);
+		  pih->length = SwapHostLengthToBig(l);
 #endif
 		  memcpy(b+h, [o bytes], l);
 		  [components removeObjectAtIndex: i--];
@@ -1924,7 +1928,7 @@ typedef	struct {
 		  pih = (GSPortItemHeader*)b;
 		  memcpy(b+h, [o bytes], l);
 		  pih->type = GSSwapHostI32ToBig(GSP_DATA);
-		  pih->length = GSSwapHostI32ToBig(l);
+		  pih->length = SwapHostLengthToBig(l);
 		  [components replaceObjectAtIndex: i
 					withObject: d];
 		  RELEASE(d);
@@ -1933,7 +1937,7 @@ typedef	struct {
 	  else if ([o isKindOfClass: messagePortClass])
 	    {
 	      NSData	*d = newDataWithEncodedPort(o);
-	      unsigned	dLength = [d length];
+	      NSUInteger	dLength = [d length];
 
 	      if (pack == YES && hLength + dLength <= NETBLOCK)
 		{
diff --git a/Source/NSMessagePortNameServer.m b/Source/NSMessagePortNameServer.m
index db6131b..a1615ab 100644
--- a/Source/NSMessagePortNameServer.m
+++ b/Source/NSMessagePortNameServer.m
@@ -360,7 +360,7 @@ static void clean_up_names(void)
 	    @"couldn't create socket, assuming not live (%m)");
 	  return NO;
 	}
-      if (connect(desc, (struct sockaddr*)&sockAddr, SUN_LEN(&sockAddr)) < 0)
+      if (connect(desc, (struct sockaddr*)&sockAddr, (socklen_t)SUN_LEN(&sockAddr)) < 0)
 	{
 	  unlink([path fileSystemRepresentation]);
 	  unlink(socket_path);
diff --git a/Source/NSMethodSignature.m b/Source/NSMethodSignature.m
index fe45a82..1d97512 100644
--- a/Source/NSMethodSignature.m
+++ b/Source/NSMethodSignature.m
@@ -29,7 +29,7 @@
 
 #import "common.h"
 
-#if !defined (__GNU_LIBOBJC__)
+#if !defined (__GNU_LIBOBJC__) && !defined (NeXT_RUNTIME)
 #  include <objc/encoding.h>
 #endif
 
@@ -92,17 +92,17 @@ next_arg(const char *typePtr, NSArgumentInfo *info, char *outTypes)
     {
       switch (*typePtr)
 	{
-	  case _C_CONST:  info->qual |= _F_CONST; break;
-	  case _C_IN:     info->qual |= _F_IN; break;
-	  case _C_INOUT:  info->qual |= _F_INOUT; break;
-	  case _C_OUT:    info->qual |= _F_OUT; break;
-	  case _C_BYCOPY: info->qual |= _F_BYCOPY; break;
+	  case _C_CONST:  info->qual |= GSObjCQualifierConst; break;
+	  case _C_IN:     info->qual |= GSObjCQualifierIn; break;
+	  case _C_INOUT:  info->qual |= GSObjCQualifierInOut; break;
+	  case _C_OUT:    info->qual |= GSObjCQualifierOut; break;
+	  case _C_BYCOPY: info->qual |= GSObjCQualifierByCopy; break;
 #ifdef	_C_BYREF
-	  case _C_BYREF:  info->qual |= _F_BYREF; break;
+	  case _C_BYREF:  info->qual |= GSObjCQualifierByRef; break;
 #endif
-	  case _C_ONEWAY: info->qual |= _F_ONEWAY; break;
+	  case _C_ONEWAY: info->qual |= GSObjCQualifierOneWay; break;
 #ifdef	_C_GCINVISIBLE
-	  case _C_GCINVISIBLE:  info->qual |= _F_GCINVISIBLE; break;
+	  case _C_GCINVISIBLE:  info->qual |= GSObjCQualifierInvisible; break;
 #endif
 	  default: flag = NO;
 	}
@@ -236,7 +236,7 @@ next_arg(const char *typePtr, NSArgumentInfo *info, char *outTypes)
       case _C_STRUCT_B:
 	{
 	  unsigned int acc_size = 0;
-	  unsigned int def_align = objc_alignof_type(typePtr-1);
+	  unsigned int def_align = (unsigned)objc_alignof_type(typePtr-1);
 	  unsigned int acc_align = def_align;
 	  const char	*ptr = typePtr;
 
@@ -338,7 +338,7 @@ next_arg(const char *typePtr, NSArgumentInfo *info, char *outTypes)
    */
   if (outTypes != 0)
     {
-      unsigned	len = typePtr - info->qtype;
+      ptrdiff_t	len = typePtr - info->qtype;
 
       strncpy(outTypes, info->qtype, len);
       outTypes[len] = '\0';
@@ -400,9 +400,9 @@ next_arg(const char *typePtr, NSArgumentInfo *info, char *outTypes)
       char		*ret;
       char		*end;
       char		*ptr;
-      int		alen;
-      int		blen;
-      int		rlen;
+      ptrdiff_t		alen;
+      ptrdiff_t		blen;
+      ptrdiff_t		rlen;
 
 /* In case we have been given a method encoding string without offsets,
  * we attempt to generate the frame size and offsets in a new copy of
@@ -431,7 +431,7 @@ next_arg(const char *typePtr, NSArgumentInfo *info, char *outTypes)
       p = objc_skip_type_qualifiers (p);
       while (p && *p)
 	{
-	  int	size;
+	  NSUInteger	size;
 
 	  _numArgs++;
 	  size = objc_promoted_size (p);
@@ -503,7 +503,7 @@ next_arg(const char *typePtr, NSArgumentInfo *info, char *outTypes)
       [self methodInfo];
       NSAssert(0 != _inf, @"Initialising failed");
     }
-  return (_inf[0].qual & _F_ONEWAY) ? YES : NO;
+  return (_inf[0].qual & GSObjCQualifierOneWay) ? YES : NO;
 }
 
 - (NSUInteger) methodReturnLength
@@ -561,7 +561,7 @@ next_arg(const char *typePtr, NSArgumentInfo *info, char *outTypes)
     }
   else
     {
-      int i, n;
+      NSUInteger i, n;
       n = [self numberOfArguments];
       for (i = 0; i < n; i++)
         {
diff --git a/Source/NSNetServices.m b/Source/NSNetServices.m
index bcdc6c3..3ee6f1a 100644
--- a/Source/NSNetServices.m
+++ b/Source/NSNetServices.m
@@ -87,7 +87,8 @@ static Class concreteBrowserClass;
                  type: (NSString *) type
                  name: (NSString *) name
 {
-  return [self subclassResponsibility: _cmd];
+    [self subclassResponsibility: _cmd];
+    return nil;
 }
 
 - (id) initWithDomain: (NSString *) domain
@@ -95,7 +96,8 @@ static Class concreteBrowserClass;
                  name: (NSString *) name
                  port: (NSInteger) port
 {
-  return [self subclassResponsibility: _cmd];
+    [self subclassResponsibility: _cmd];
+    return nil;
 }
 
 - (void) removeFromRunLoop: (NSRunLoop *) aRunLoop
@@ -111,7 +113,7 @@ static Class concreteBrowserClass;
 }
 
 
-#if OS_API_VERSION(100500,GS_API_LATEST) 
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_5,GS_API_LATEST) 
 /** Not implemented */
 - (NSInteger)port
 {
@@ -268,8 +270,8 @@ static Class concreteBrowserClass;
                          forKey: [parts objectAtIndex: 0]];
         }
       END_FOR_IN(array)
-    [self setTXTRecordData:
-      [[self class] dataFromTXTRecordDictionary: dictionary]];
+      [self setTXTRecordData:[[self class] dataFromTXTRecordDictionary: dictionary]];
+      RELEASE(dictionary);
     }
 }
 
diff --git a/Source/NSNotification.m b/Source/NSNotification.m
index 603b64c..9375a28 100644
--- a/Source/NSNotification.m
+++ b/Source/NSNotification.m
@@ -111,6 +111,7 @@ static Class	concreteClass = 0;
     [self name], [self object], [self userInfo]];
 }
 
+/* todo: attempt to create an empty notification should result in exception */
 - (id) init
 {
   if ([self class] == abstractClass)
@@ -123,6 +124,27 @@ static Class	concreteClass = 0;
   return self;
 }
 
+/*
+ * Nofications should be considered equal iff:
+ * - names and userInfos are equal and not nil
+ * - objects are equal or nil
+ */
+- (BOOL)isEqual:(id)anObject
+{
+    if (![anObject isKindOfClass:[NSNotification class]]) {
+        return NO;
+    }
+    if (![[self name] isEqualToString:[anObject name]]) {
+        return NO;
+    }
+    if (![[self userInfo] isEqualToDictionary:[anObject userInfo]]) {
+        return NO;
+    }
+    id obj1 = [self object];
+    id obj2 = [anObject object];
+    return (obj1 == nil && obj2 == nil) || [obj1 isEqual:obj2];
+}
+
 /**
  *  Returns the notification name.
  */
diff --git a/Source/NSNotificationCenter.m b/Source/NSNotificationCenter.m
index c449ff5..d9e7d9c 100644
--- a/Source/NSNotificationCenter.m
+++ b/Source/NSNotificationCenter.m
@@ -191,7 +191,7 @@ static inline unsigned doHash(NSString* key)
     }
   else
     {
-      return [key hash];
+      return (unsigned)[key hash];
     }
 }
 
@@ -255,7 +255,12 @@ static void obsFree(Observation *o);
 #define GSI_MAP_RETAIN_VAL(M, X)
 #define GSI_MAP_RELEASE_VAL(M, X)
 
-#define GSI_MAP_KTYPES GSUNION_OBJ|GSUNION_NSINT
+/* 
+ * With Apple's clang: 
+ * nil is void* and _postAndRelease() uses it as GSIMapKey,
+ * so there is a need to add GSUNION_PTR
+ */
+#define GSI_MAP_KTYPES GSUNION_OBJ|GSUNION_NSINT|GSUNION_PTR
 #define GSI_MAP_VTYPES GSUNION_PTR
 #define GSI_MAP_VEXTRA Observation*
 #define	GSI_MAP_EXTRA	void*
@@ -1094,7 +1099,7 @@ static NSNotificationCenter *default_center = nil;
 - (void) _postAndRelease: (NSNotification*)notification
 {
   Observation	*o;
-  unsigned	count;
+  NSUInteger	count;
   NSString	*name = [notification name];
   id		object;
   GSIMapNode	n;
diff --git a/Source/NSNumber.m b/Source/NSNumber.m
index d5e1619..50dbd8a 100644
--- a/Source/NSNumber.m
+++ b/Source/NSNumber.m
@@ -954,7 +954,7 @@ if (aValue >= -1 && aValue <= 12)\
   // Compile time constant; the compiler will remove this conditional
   if (sizeof (NSInteger) == sizeof (int))
     {
-      return [self numberWithInt: aValue];
+      return [self numberWithInt: (int)aValue];
     }
   return [self numberWithLongLong: aValue];
 }
@@ -969,7 +969,7 @@ if (aValue >= -1 && aValue <= 12)\
   // Compile time constant; the compiler will remove this conditional
   if (sizeof (NSUInteger) == sizeof (unsigned int))
     {
-      return [self numberWithUnsignedInt: aValue];
+      return [self numberWithUnsignedInt: (unsigned int)aValue];
     }
   return [self numberWithUnsignedLongLong: aValue];
 }
@@ -1091,15 +1091,4 @@ if (aValue >= -1 && aValue <= 12)\
   return NO;
 }
 
-- (NSDecimal) decimalValue
-{
-  NSDecimalNumber *dn;
-  NSDecimal decimal;
-
-  dn = [[NSDecimalNumber alloc] initWithString: [self stringValue]];
-  decimal = [dn decimalValue];
-  [dn release];
-  return decimal;
-}
-
 @end
diff --git a/Source/NSNumberFormatter.m b/Source/NSNumberFormatter.m
index 7495ea1..ca41087 100644
--- a/Source/NSNumberFormatter.m
+++ b/Source/NSNumberFormatter.m
@@ -277,7 +277,7 @@ GS_PRIVATE_INTERNAL(NSNumberFormatter)
 - (int32_t) attributeForKey: (int)key;
 - (NSString*) symbolForKey: (int)key;
 - (NSString*) textAttributeForKey: (int)key;
-- (void) setAttribute: (int32_t)value forKey: (int)key;
+- (void) setAttribute: (NSInteger)value forKey: (int)key;
 - (void) setSymbol: (NSString*)value forKey: (int)key;
 - (void) setTextAttribute: (NSString*)value forKey: (int)key;
 @end
@@ -359,7 +359,7 @@ GS_PRIVATE_INTERNAL(NSNumberFormatter)
 #endif
 }
 
-- (void) setAttribute: (int32_t)value forKey: (int)key
+- (void) setAttribute: (NSInteger)value forKey: (int)key
 {
   NSAssert(key >= 0
     && key < sizeof(_attributes) / sizeof(*_attributes),
@@ -367,8 +367,8 @@ GS_PRIVATE_INTERNAL(NSNumberFormatter)
 #if GS_USE_ICU == 1
   if (value < 0)
     value = -1;
-  _attributes[key] = value;
-  unum_setAttribute (_formatter, key, value);
+  _attributes[key] = (int32_t)value;
+  unum_setAttribute (_formatter, key, (int32_t)value);
 #endif
   return;
 }
@@ -400,7 +400,7 @@ GS_PRIVATE_INTERNAL(NSNumberFormatter)
   if (length > BUFFER_SIZE)
     length = BUFFER_SIZE;
   [value getCharacters: buffer range: NSMakeRange (0, length)];
-  unum_setSymbol (_formatter, key, buffer, length, &err);
+  unum_setSymbol (_formatter, key, buffer, (int32_t)length, &err);
 #endif
   return;
 }
@@ -420,7 +420,7 @@ GS_PRIVATE_INTERNAL(NSNumberFormatter)
   if (length > BUFFER_SIZE)
     length = BUFFER_SIZE;
   [value getCharacters: buffer range: NSMakeRange (0, length)];
-  unum_setTextAttribute (_formatter, key, buffer, length, &err);
+  unum_setTextAttribute (_formatter, key, buffer, (int32_t)length, &err);
 #endif
   return;
 }
@@ -720,6 +720,10 @@ static NSUInteger _defaultBehavior = NSNumberFormatterBehavior10_4;
 
 - (id) init
 {
+    if (!(self = [super init]))
+    {
+        return nil;
+    }
   id	o;
   int idx;
   
@@ -1144,7 +1148,7 @@ static NSUInteger _defaultBehavior = NSNumberFormatterBehavior10_4;
       NSDecimalNumber	*roundedNumber;
       NSDecimalNumber	*intPart;
       NSDecimalNumber	*fracPart;
-      int		decimalPlaces = 0;
+      NSInteger		decimalPlaces = 0;
       BOOL		displayThousandsSeparators = NO;
       BOOL		displayFractionalPart = NO;
       BOOL		negativeNumber = NO;
@@ -1313,7 +1317,7 @@ static NSUInteger _defaultBehavior = NSNumberFormatterBehavior10_4;
       // fix the thousands separators up
       if (displayThousandsSeparators && [intPartString length] > 3)
         {
-          int index = [intPartString length];
+          NSInteger index = [intPartString length];
 
           while (0 < (index -= 3))
 	    {
@@ -1435,7 +1439,7 @@ static NSUInteger _defaultBehavior = NSNumberFormatterBehavior10_4;
   if (range.location == NSNotFound)
     {
       intNum = unum_parseInt64(internal->_formatter,
-        ustring, length, NULL, &err);
+        ustring, (int32_t)length, NULL, &err);
       if (U_FAILURE(err))
         return nil;
       if (intNum == 0 || intNum == 1)
@@ -1448,7 +1452,7 @@ static NSUInteger _defaultBehavior = NSNumberFormatterBehavior10_4;
   else
     {
       doubleNum = unum_parseDouble(internal->_formatter,
-        ustring, length, NULL, &err);
+        ustring, (int32_t)length, NULL, &err);
       if (U_FAILURE(err))
         return nil;
       result = [NSNumber numberWithDouble: doubleNum];
@@ -1968,10 +1972,11 @@ static NSUInteger _defaultBehavior = NSNumberFormatterBehavior10_4;
                   error: (out NSError **) error
 {
 #if GS_USE_ICU == 1
+  NSParameterAssert(rangep->location + rangep->length < INT32_MAX);
   BOOL result;
   BOOL genDec = [self generatesDecimalNumbers];
   NSUInteger inLen;
-  int32_t parsePos = rangep->location;
+  int32_t parsePos = (int32_t)rangep->location;
   UChar inBuffer[BUFFER_SIZE];
   UErrorCode err = U_ZERO_ERROR;
   
@@ -2014,7 +2019,7 @@ static NSUInteger _defaultBehavior = NSNumberFormatterBehavior10_4;
       double output;
       
       output = 
-        unum_parseDouble (internal->_formatter, inBuffer, inLen, &parsePos,
+        unum_parseDouble (internal->_formatter, inBuffer, (int32_t)inLen, &parsePos,
           &err);
       if (U_SUCCESS(err))
         {
@@ -2160,7 +2165,7 @@ static NSUInteger _defaultBehavior = NSNumberFormatterBehavior10_4;
 	    length = BUFFER_SIZE;
 	  [internal->_symbols[idx] getCharacters: buffer
 					   range: NSMakeRange (0, length)];
-	  unum_setSymbol (internal->_formatter, idx, buffer, length, &err);
+	  unum_setSymbol (internal->_formatter, idx, buffer, (int32_t)length, &err);
 	}
     }
 
@@ -2174,7 +2179,7 @@ static NSUInteger _defaultBehavior = NSNumberFormatterBehavior10_4;
 	  [internal->_textAttributes[idx] getCharacters: buffer
 					   range: NSMakeRange (0, length)];
 	  unum_setTextAttribute
-	    (internal->_formatter, idx, buffer, length, &err);
+	    (internal->_formatter, idx, buffer, (int32_t)length, &err);
 	}
     }
 
@@ -2190,4 +2195,5 @@ static NSUInteger _defaultBehavior = NSNumberFormatterBehavior10_4;
   return;
 #endif
 }
+
 @end
diff --git a/Source/NSObjCRuntime.m b/Source/NSObjCRuntime.m
index 71167d8..bce8c59 100644
--- a/Source/NSObjCRuntime.m
+++ b/Source/NSObjCRuntime.m
@@ -27,7 +27,7 @@
 
 #import "common.h"
 
-#if !defined (__GNU_LIBOBJC__)
+#if !defined (__GNU_LIBOBJC__) && !defined (NeXT_RUNTIME)
 #  include <objc/encoding.h>
 #endif
 
@@ -54,7 +54,7 @@ NSProtocolFromString(NSString *aProtocolName)
 {
   if (aProtocolName != nil)
     {
-      int	len = [aProtocolName length];
+      NSUInteger	len = [aProtocolName length];
       char	buf[len+1];
 
       [aProtocolName getCString: buf
@@ -86,7 +86,7 @@ NSSelectorFromString(NSString *aSelectorName)
 {
   if (aSelectorName != nil)
     {
-      int	len = [aSelectorName length];
+      NSUInteger	len = [aSelectorName length];
       char	buf[len+1];
 
       [aSelectorName getCString: buf
@@ -107,7 +107,7 @@ NSClassFromString(NSString *aClassName)
 {
   if (aClassName != nil)
     {
-      int	len = [aClassName length];
+      NSUInteger	len = [aClassName length];
       char	buf[len+1];
 
       [aClassName getCString: buf
diff --git a/Source/NSObject.m b/Source/NSObject.m
index 1f028ff..a1ceff9 100644
--- a/Source/NSObject.m
+++ b/Source/NSObject.m
@@ -35,19 +35,20 @@
 
 #import "common.h"
 #include <objc/Protocol.h>
-#import "Foundation/NSMethodSignature.h"
-#import "Foundation/NSInvocation.h"
-#import "Foundation/NSLock.h"
-#import "Foundation/NSAutoreleasePool.h"
 #import "Foundation/NSArray.h"
+#import "Foundation/NSAutoreleasePool.h"
+#import "Foundation/NSDistantObject.h"
 #import "Foundation/NSException.h"
+#import "Foundation/NSInvocation.h"
+#import "Foundation/NSLock.h"
+#import "Foundation/NSMapTable.h"
+#import "Foundation/NSMethodSignature.h"
+#import "Foundation/NSNotification.h"
 #import "Foundation/NSPortCoder.h"
-#import "Foundation/NSDistantObject.h"
 #import "Foundation/NSThread.h"
-#import "Foundation/NSNotification.h"
-#import "Foundation/NSMapTable.h"
 #import "GNUstepBase/GSLocale.h"
 #import "GNUstepBase/NSObject+GNUstepBase.h"
+#import "KVO/NSKeyValueObservingPrivate.h"
 #ifdef HAVE_LOCALE_H
 #include <locale.h>
 #endif
@@ -108,7 +109,7 @@ static Class	NSConstantStringClass;
 @class	NSDataMalloc;
 @class	NSMutableDataMalloc;
 
-GS_ROOT_CLASS @interface	NSZombie
+GS_ROOT_CLASS @interface NSZombie
 {
   Class	isa;
 }
@@ -781,7 +782,7 @@ NSAllocateObject (Class aClass, NSUInteger extraBytes, NSZone *zone)
 #endif
 {
   id	new;
-  int	size;
+  size_t	size;
 
   NSCAssert((!class_isMetaClass(aClass)), @"Bad class for new object");
   size = class_getInstanceSize(aClass) + extraBytes + sizeof(struct obj_layout);
@@ -969,12 +970,14 @@ GSGarbageCollectorLog(char *msg, GC_word arg)
 }
 #endif
 
+#ifndef NeXT_RUNTIME
 /**
  * Semi-private function in libobjc2 that initialises the classes used for
  * blocks.
  */
 extern BOOL
 objc_create_block_classes_as_subclasses_of(Class super);
+#endif
 
 #ifdef OBJC_CAP_ARC
 static id gs_weak_load(id obj)
@@ -988,7 +991,9 @@ static id gs_weak_load(id obj)
 #ifdef OBJC_CAP_ARC
   _objc_weak_load = gs_weak_load;
 #endif
+#ifndef NeXT_RUNTIME
   objc_create_block_classes_as_subclasses_of(self);
+#endif
 }
 
 + (void) initialize
@@ -1131,6 +1136,7 @@ static id gs_weak_load(id obj)
 	       name: NSWillBecomeMultiThreadedNotification
 	     object: nil];
     }
+  _NSKVOIntialize();
   return;
 }
 
@@ -1491,7 +1497,7 @@ static id gs_weak_load(id obj)
  */
 + (BOOL) conformsToProtocol: (Protocol*)aProtocol
 {
-#ifdef __GNU_LIBOBJC__
+#if defined (__GNU_LIBOBJC__) || defined (NeXT_RUNTIME)
   Class c;
 
   /* Iterate over the current class and all the superclasses.  */
@@ -1550,15 +1556,8 @@ static id gs_weak_load(id obj)
   if (aSelector == 0)
     [NSException raise: NSInvalidArgumentException
 		format: @"%@ null selector given", NSStringFromSelector(_cmd)];
-  /* The Apple runtime API would do:
-   * return class_getMethodImplementation(object_getClass(self), aSelector);
-   * but this cannot ask self for information about any method reached by
-   * forwarding, so the returned forwarding function would ge a generic one
-   * rather than one aware of hardware issues with returning structures
-   * and floating points.  We therefore prefer the GNU API which is able to
-   * use forwarding callbacks to get better type information.
-   */
-  return objc_msg_lookup(self, aSelector);
+
+  return GSObjCMethodForSelector(self, aSelector);
 }
 
 /**
@@ -1815,7 +1814,7 @@ static id gs_weak_load(id obj)
         [NSException
 	  raise: NSGenericException
 	  format: @"Autorelease would release object too many times.\n"
-	  @"%d release(s) versus %d retain(s)", release_count, retain_count];
+	  @"%lu release(s) versus %lu retain(s)", (unsigned long)release_count, (unsigned long)retain_count];
     }
 
   (*autorelease_imp)(autorelease_class, autorelease_sel, self);
@@ -1849,14 +1848,7 @@ static id gs_weak_load(id obj)
  */
 - (NSUInteger) hash
 {
-  /*
-   * Ideally we would shift left to lose any zero bits produced by the
-   * alignment of the object in memory ... but that depends on the
-   * processor architecture and the memory allocatiion implementation.
-   * In the absence of detailed information, pick a reasonable value
-   * assuming the object will be aligned to an eight byte boundary.
-   */
-  return (NSUInteger)(uintptr_t)self >> 3;
+  return GSPointerHash((uintptr_t)self);
 }
 
 /**
@@ -1941,15 +1933,7 @@ static id gs_weak_load(id obj)
     [NSException raise: NSInvalidArgumentException
 		format: @"%@ null selector given", NSStringFromSelector(_cmd)];
 
-  /* The Apple runtime API would do:
-   * msg = class_getMethodImplementation(object_getClass(self), aSelector);
-   * but this cannot ask self for information about any method reached by
-   * forwarding, so the returned forwarding function would ge a generic one
-   * rather than one aware of hardware issues with returning structures
-   * and floating points.  We therefore prefer the GNU API which is able to
-   * use forwarding callbacks to get better type information.
-   */
-  msg = objc_msg_lookup(self, aSelector);
+  msg = GSObjCMethodForSelector(self, aSelector);
   if (!msg)
     {
       [NSException raise: NSGenericException
@@ -1974,15 +1958,7 @@ static id gs_weak_load(id obj)
     [NSException raise: NSInvalidArgumentException
 		format: @"%@ null selector given", NSStringFromSelector(_cmd)];
 
-  /* The Apple runtime API would do:
-   * msg = class_getMethodImplementation(object_getClass(self), aSelector);
-   * but this cannot ask self for information about any method reached by
-   * forwarding, so the returned forwarding function would ge a generic one
-   * rather than one aware of hardware issues with returning structures
-   * and floating points.  We therefore prefer the GNU API which is able to
-   * use forwarding callbacks to get better type information.
-   */
-  msg = objc_msg_lookup(self, aSelector);
+  msg = GSObjCMethodForSelector(self, aSelector);
   if (!msg)
     {
       [NSException raise: NSGenericException
@@ -2010,15 +1986,7 @@ static id gs_weak_load(id obj)
     [NSException raise: NSInvalidArgumentException
 		format: @"%@ null selector given", NSStringFromSelector(_cmd)];
 
-  /* The Apple runtime API would do:
-   * msg = class_getMethodImplementation(object_getClass(self), aSelector);
-   * but this cannot ask self for information about any method reached by
-   * forwarding, so the returned forwarding function would ge a generic one
-   * rather than one aware of hardware issues with returning structures
-   * and floating points.  We therefore prefer the GNU API which is able to
-   * use forwarding callbacks to get better type information.
-   */
-  msg = objc_msg_lookup(self, aSelector);
+  msg = GSObjCMethodForSelector(self, aSelector);
   if (!msg)
     {
       [NSException raise: NSGenericException
@@ -2202,12 +2170,20 @@ static id gs_weak_load(id obj)
  */
 + (id) setVersion: (NSInteger)aVersion
 {
-  if (aVersion < 0)
-    [NSException raise: NSInvalidArgumentException
-	        format: @"%s +setVersion: may not set a negative version",
-			GSClassNameFromObject(self)];
-  class_setVersion(self, aVersion);
-  return self;
+    if (aVersion < 0)
+    {
+        [NSException raise: NSInvalidArgumentException
+                    format: @"%s +setVersion: must not set a negative version",
+         GSClassNameFromObject(self)];
+    }
+    if (aVersion > INT_MAX)
+    {
+        [NSException raise: NSInvalidArgumentException
+                    format: @"%s +setVersion: version must not exceed int size",
+         GSClassNameFromObject(self)];
+    }  
+    class_setVersion(self, (int)aVersion);
+    return self;
 }
 
 /**
diff --git a/Source/NSOperation.m b/Source/NSOperation.m
index e5287f2..fd94716 100644
--- a/Source/NSOperation.m
+++ b/Source/NSOperation.m
@@ -65,6 +65,7 @@
 #import "Foundation/NSKeyValueObserving.h"
 #import "Foundation/NSThread.h"
 #import "GSPrivate.h"
+#import "GNUstepBase/NSObject+GNUstepBase.h"
 
 #define	GSInternal	NSOperationInternal
 #include	"GSInternal.h"
@@ -75,6 +76,7 @@ GS_PRIVATE_INTERNAL(NSOperation)
 #define	POOL	8
 
 static NSArray	*empty = nil;
+static NSRecursiveLock *dependencyLock = nil;
 
 @interface	NSOperation (Private)
 - (void) _finish;
@@ -91,7 +93,10 @@ static NSArray	*empty = nil;
 
 + (void) initialize
 {
-  empty = [NSArray new];
+    if (!empty) {
+        empty = [NSObject leakRetained:[NSArray new]];
+        dependencyLock = [NSObject leakRetained:[NSRecursiveLock new]];
+    }
 }
 
 - (void) addDependency: (NSOperation *)op
@@ -108,6 +113,7 @@ static NSArray	*empty = nil;
 		  format: @"[%@-%@] attempt to add dependency on self",
 	NSStringFromClass([self class]), NSStringFromSelector(_cmd)];
     }
+  [dependencyLock lock];
   [internal->lock lock];
   if (internal->dependencies == nil)
     {
@@ -151,11 +157,13 @@ static NSArray	*empty = nil;
   NS_HANDLER
     {
       [internal->lock unlock];
+      [dependencyLock unlock];
       NSLog(@"Problem adding dependency: %@", localException);
       return;
     }
   NS_ENDHANDLER
   [internal->lock unlock];
+  [dependencyLock unlock];
 }
 
 - (void) cancel
@@ -327,6 +335,7 @@ static NSArray	*empty = nil;
 
 - (void) removeDependency: (NSOperation *)op
 {
+  [dependencyLock lock];
   [internal->lock lock];
   NS_DURING
     {
@@ -352,11 +361,13 @@ static NSArray	*empty = nil;
   NS_HANDLER
     {
       [internal->lock unlock];
+      [dependencyLock unlock];
       NSLog(@"Problem removing dependency: %@", localException);
       return;
     }
   NS_ENDHANDLER
   [internal->lock unlock];
+  [dependencyLock unlock];
 }
 
 - (void) setCompletionBlock: (GSOperationCompletionBlock)aBlock
@@ -517,6 +528,7 @@ static NSArray	*empty = nil;
    * queue removes and releases us.
    */
   [self retain];
+  [dependencyLock lock];
   [internal->lock lock];
   if (NO == internal->finished)
     {
@@ -541,6 +553,7 @@ static NSArray	*empty = nil;
 	}
     }
   [internal->lock unlock];
+  [dependencyLock unlock];
   [self release];
 }
 
@@ -608,6 +621,7 @@ static NSOperationQueue *mainQueue = nil;
 		  format: @"[%@-%@] object is not an NSOperation",
 	NSStringFromClass([self class]), NSStringFromSelector(_cmd)];
     }
+  [dependencyLock lock];
   [internal->lock lock];
   if (NSNotFound == [internal->operations indexOfObjectIdenticalTo: op]
     && NO == [op isFinished])
@@ -630,6 +644,7 @@ static NSOperationQueue *mainQueue = nil;
 	}
     }
   [internal->lock unlock];
+  [dependencyLock unlock];
 }
 
 - (void) addOperations: (NSArray *)ops
@@ -718,9 +733,9 @@ static NSOperationQueue *mainQueue = nil;
       if (YES == invalidArg)
 	{
 	  [NSException raise: NSInvalidArgumentException
-	    format: @"[%@-%@] object at index %u is not an NSOperation",
+	    format: @"[%@-%@] object at index %lu is not an NSOperation",
 	    NSStringFromClass([self class]), NSStringFromSelector(_cmd),
-	    index];
+	    (unsigned long)index];
 	}
     }
   if (YES == shouldWait)
@@ -813,8 +828,8 @@ static NSOperationQueue *mainQueue = nil;
     && cnt != NSOperationQueueDefaultMaxConcurrentOperationCount)
     {
       [NSException raise: NSInvalidArgumentException
-		  format: @"[%@-%@] cannot set negative (%d) count",
-	NSStringFromClass([self class]), NSStringFromSelector(_cmd), cnt];
+		  format: @"[%@-%@] cannot set negative (%ld) count",
+	NSStringFromClass([self class]), NSStringFromSelector(_cmd), (long)cnt];
     }
   [internal->lock lock];
   if (cnt != internal->count)
@@ -916,6 +931,7 @@ static NSOperationQueue *mainQueue = nil;
 
   for (;;)
     {
+      NSAutoreleasePool	*opPool = [NSAutoreleasePool new];
       NSOperation	*op;
       NSDate		*when;
       BOOL		found;
@@ -925,6 +941,7 @@ static NSOperationQueue *mainQueue = nil;
       [when release];
       if (NO == found)
 	{
+        [opPool release];
 	  break;	// Idle for 5 seconds ... exit thread.
 	}
 
@@ -953,14 +970,11 @@ static NSOperationQueue *mainQueue = nil;
 	{
           NS_DURING
 	    {
-	      NSAutoreleasePool	*opPool = [NSAutoreleasePool new];
-
 	      if (NO == [op isCancelled])
 		{
 		  [NSThread setThreadPriority: [op threadPriority]];
 		  [op main];
 		}
-	      [opPool release];
 	    }
           NS_HANDLER
 	    {
@@ -970,6 +984,7 @@ static NSOperationQueue *mainQueue = nil;
           NS_ENDHANDLER
 	  [op _finish];
 	}
+      [opPool release];
     }
 
   [internal->lock lock];
diff --git a/Source/NSPathUtilities.m b/Source/NSPathUtilities.m
index 3eda6c4..58f9376 100644
--- a/Source/NSPathUtilities.m
+++ b/Source/NSPathUtilities.m
@@ -309,8 +309,8 @@ substUser(NSString *str)
   if (str != nil && [str rangeOfString: @"%"].length > 0)
     {
       NSMutableString	*m = [[str mutableCopy] autorelease];
-      int		l = [m length];
-      int		i = 0;
+      NSUInteger		l = [m length];
+      NSUInteger		i = 0;
       BOOL		percent = NO;
 
       while (i < l)
@@ -339,7 +339,7 @@ substUser(NSString *str)
 		}
 	      if (s != nil)
 		{
-		  int	diff = [s length] - 2;
+		  NSInteger	diff = [s length] - 2;
 
 		  [m replaceCharactersInRange: NSMakeRange(i-1, 2)
 				   withString: s];
@@ -1280,7 +1280,7 @@ ParseConfigurationFile(NSString *fileName, NSMutableDictionary *dict,
 {
   NSDictionary	*attributes;
   NSString      *file;
-  unsigned	l;
+  NSUInteger	l;
   unichar	*src;
   unichar	*dst;
   unichar	*end;
@@ -2074,8 +2074,8 @@ NSSearchPathForDirectoriesInDomains(NSSearchPathDirectory directoryKey,
 {
   NSMutableArray  *paths;
   NSString        *path;
-  unsigned        i;
-  unsigned        count;
+  NSUInteger        i;
+  NSUInteger        count;
 
   InitialisePathUtilities();
 
diff --git a/Source/NSPointerArray.m b/Source/NSPointerArray.m
index 249b5ea..41137c4 100644
--- a/Source/NSPointerArray.m
+++ b/Source/NSPointerArray.m
@@ -44,8 +44,8 @@ static Class	concreteClass = Nil;
   PFInfo	_pf;
   NSUInteger	_count;
   void		**_contents;
-  unsigned	_capacity;
-  unsigned	_grow_factor;
+  NSUInteger	_capacity;
+  NSUInteger	_grow_factor;
 }
 @end
 
@@ -134,8 +134,11 @@ static Class	concreteClass = Nil;
 
 - (id) initWithPointerFunctions: (NSPointerFunctions*)functions
 {
-  [self subclassResponsibility: _cmd];
-  return nil;
+    if ([self class] == [NSPointerArray class]) {
+        [self subclassResponsibility: _cmd];
+        return nil;
+    }
+    return [super init];
 }
 
 - (BOOL) isEqual: (id)other
@@ -230,13 +233,13 @@ static Class	concreteClass = Nil;
   NSString     *reason;
 
   info = [NSDictionary dictionaryWithObjectsAndKeys:
-    [NSNumber numberWithUnsignedInt: index], @"Index",
-    [NSNumber numberWithUnsignedInt: _count], @"Count",
+    [NSNumber numberWithUnsignedInteger: index], @"Index",
+    [NSNumber numberWithUnsignedInteger: _count], @"Count",
     self, @"Array", nil, nil];
 
   reason = [NSString stringWithFormat:
-    @"Index %d is out of range %d (in '%@')",
-    index, _count, NSStringFromSelector(sel)];
+    @"Index %lu is out of range %lu (in '%@')",
+    (unsigned long)index, (unsigned long)_count, NSStringFromSelector(sel)];
 
   exception = [NSException exceptionWithName: NSRangeException
 		                      reason: reason
@@ -263,7 +266,7 @@ static Class	concreteClass = Nil;
     }
   else
     {
-      GSMutableArray	*a = [GSMutableArray arrayWithCapacity: c];
+      GSMutableArray	*a = [[GSMutableArray alloc] initWithCapacity: c];
 
       for (i = 0; i < _count; i++)
         {
@@ -273,7 +276,7 @@ static Class	concreteClass = Nil;
 	      [a addObject: obj];
 	    }
 	}
-      return [a makeImmutableCopyOnFail: NO]; 
+      return [[a makeImmutable] autorelease]; 
     }
 }
 
@@ -300,7 +303,7 @@ static Class	concreteClass = Nil;
 - (id) copyWithZone: (NSZone*)zone
 {
   NSConcretePointerArray	*c;
-  unsigned			i;
+  NSUInteger			i;
   
   c = (NSConcretePointerArray*)NSCopyObject(self, 0, NSDefaultMallocZone());
   c->_capacity = c->_count;
@@ -320,7 +323,7 @@ static Class	concreteClass = Nil;
 #endif
   for (i = 0; i < _count; i++)
     {
-      NSLog(@"Copying %d, %p", i, _contents[i]);
+      NSLog(@"Copying %ld, %p", (long)i, _contents[i]);
       pointerFunctionsAcquire(&_pf, &c->_contents[i],
               pointerFunctionsRead(&_pf, &_contents[i]));
     }
@@ -436,6 +439,10 @@ static Class	concreteClass = Nil;
 
 - (id) initWithPointerFunctions: (NSPointerFunctions*)functions
 {
+    if (!(self = [super initWithPointerFunctions:functions]))
+    {
+        return nil;
+    }
   if (![functions isKindOfClass: [NSConcretePointerFunctions class]])
     {
       static NSConcretePointerFunctions	*defaultFunctions = nil;
diff --git a/Source/NSPortCoder.m b/Source/NSPortCoder.m
index 6995706..1418ce3 100644
--- a/Source/NSPortCoder.m
+++ b/Source/NSPortCoder.m
@@ -35,7 +35,7 @@
 
 #import "common.h"
 
-#if !defined (__GNU_LIBOBJC__)
+#if !defined (__GNU_LIBOBJC__) && !defined (NeXT_RUNTIME)
 #  include <objc/encoding.h>
 #endif
 
@@ -327,16 +327,16 @@ typeCheck(char t1, char t2)
 
 
 @interface	NSPortCoder (Headers)
-- (void) _deserializeHeaderAt: (unsigned*)pos
+- (void) _deserializeHeaderAt: (NSUInteger*)pos
 		      version: (unsigned*)v
-		      classes: (unsigned*)c
-		      objects: (unsigned*)o
-		     pointers: (unsigned*)p;
-- (void) _serializeHeaderAt: (unsigned)pos
+		      classes: (NSUInteger*)c
+		      objects: (NSUInteger*)o
+		     pointers: (NSUInteger*)p;
+- (void) _serializeHeaderAt: (NSUInteger)pos
 		    version: (unsigned)v
-		    classes: (unsigned)c
-		    objects: (unsigned)o
-		   pointers: (unsigned)p;
+		    classes: (NSUInteger)c
+		    objects: (NSUInteger)o
+		   pointers: (NSUInteger)p;
 @end
 
 
@@ -420,7 +420,7 @@ static unsigned	encodingVersion;
     }
   if (_clsAry != 0)
     {
-      unsigned	count = GSIArrayCount(_clsAry);
+      NSUInteger	count = GSIArrayCount(_clsAry);
 
       // Zero'th item is nul
       while (count-- > 1)
@@ -494,8 +494,8 @@ static unsigned	encodingVersion;
   if (count != expected)
     {
       [NSException raise: NSInternalInconsistencyException
-		  format: @"expected array count %u and got %u",
-			expected, count];
+		  format: @"expected array count %lu and got %lu",
+			(unsigned long)expected, (unsigned long)count];
     }
 
   switch (*type)
@@ -656,16 +656,16 @@ static unsigned	encodingVersion;
 		  rep = [obj initWithCoder: self];
 		  if (rep != obj)
 		    {
-		      obj = rep;
-		      GSIArraySetItemAtIndex(_objAry, (GSIArrayItem)obj, xref);
+		      GSIArraySetItemAtIndex(_objAry, (GSIArrayItem)rep, xref);
 		    }
+		  obj = rep;
 
-		  rep = [obj awakeAfterUsingCoder: self];
+		  rep = [rep awakeAfterUsingCoder: self];
 		  if (rep != obj)
 		    {
-		      obj = rep;
-		      GSIArraySetItemAtIndex(_objAry, (GSIArrayItem)obj, xref);
+		      GSIArraySetItemAtIndex(_objAry, (GSIArrayItem)rep, xref);
 		    }
+		  obj = rep;
 		  GS_CONSUMED(rep)
 		}
 	    }
@@ -850,6 +850,7 @@ static unsigned	encodingVersion;
 
 	      (*_dValImp)(self, dValSel, ftype, (char*)address + offset);
 	    }
+    objc_layout_finish_structure(&layout, NULL, NULL);
 	  return;
 	}
 
@@ -875,7 +876,7 @@ static unsigned	encodingVersion;
 	    }
 	  else
 	    {
-	      unsigned	size;
+	      size_t	size;
 
 	      if (GSIArrayCount(_ptrAry) != xref)
 		{
@@ -921,8 +922,8 @@ static unsigned	encodingVersion;
 	    }
 	  else
 	    {
-	      char	*tmp;
-	      int	len;
+	      char  *tmp;
+	      size_t len;
 
 	      if (xref != GSIArrayCount(_ptrAry))
 		{
@@ -1147,7 +1148,7 @@ static unsigned	encodingVersion;
 			    at: (const void*)buf
 {
   NSUInteger	i;
-  uint32_t      c = count;
+  uint32_t      c;
   uint8_t	bytes[20];
   uint8_t	*bytePtr = 0;
   uint8_t	byteCount = 0;
@@ -1181,7 +1182,7 @@ static unsigned	encodingVersion;
 	}
       else
 	{
-	  c = count;
+	  c = (uint32_t)count;
 	}
     }
 
@@ -1459,10 +1460,10 @@ static unsigned	encodingVersion;
  */
 - (void) encodePortObject: (NSPort*)aPort
 {
-  unsigned	pos = [_comp count];
+  NSUInteger	pos = [_comp count];
 
   [_comp addObject: aPort];
-  [self encodeValueOfObjCType: @encode(unsigned) at: &pos];
+  [self encodeValueOfObjCType: @encode(NSUInteger) at: &pos];
 }
 
 - (void) encodeRootObject: (id)rootObject
@@ -1536,6 +1537,7 @@ static unsigned	encodingVersion;
 
 	      (*_eValImp)(self, eValSel, ftype, (char*)buf + offset);
 	    }
+    objc_layout_finish_structure(&layout, NULL, NULL);
 	}
 	return;
 
@@ -1920,9 +1922,9 @@ static unsigned	encodingVersion;
       _comp = [comp mutableCopy];
       NS_DURING
 	{
-	  unsigned	sizeC;
-	  unsigned	sizeO;
-	  unsigned	sizeP;
+	  NSUInteger	sizeC;
+	  NSUInteger	sizeO;
+	  NSUInteger	sizeP;
 
 	  if (firstTime == YES)
 	    {
@@ -1930,7 +1932,7 @@ static unsigned	encodingVersion;
 	    }
 	  _src = [_comp objectAtIndex: 0];
 	  _dDesImp = [_src methodForSelector: dDesSel];
-	  _dTagImp = (void (*)(id, SEL, unsigned char*, unsigned*, unsigned*))
+	  _dTagImp = (void (*)(id, SEL, unsigned char*, unsigned*, NSUInteger*))
 	    [_src methodForSelector: dTagSel];
 
 	  /*
@@ -1977,7 +1979,7 @@ static unsigned	encodingVersion;
 	    }
 	  else
 	    {
-	      unsigned	count = GSIArrayCount(_clsAry);
+	      NSUInteger	count = GSIArrayCount(_clsAry);
 
 	      while (count-- > 0)
 		{
@@ -2031,7 +2033,7 @@ static unsigned	encodingVersion;
 {
   GSClassInfo	*info = nil;
   NSInteger	version = NSNotFound;
-  unsigned	count = GSIArrayCount(_clsAry);
+  NSUInteger	count = GSIArrayCount(_clsAry);
 
   /*
    * Lazy ... we construct a dictionary of all the class information in
@@ -2087,11 +2089,11 @@ static unsigned	encodingVersion;
 
 @implementation	NSPortCoder (Headers)
 
-- (void) _deserializeHeaderAt: (unsigned*)pos
+- (void) _deserializeHeaderAt: (NSUInteger*)pos
 		      version: (unsigned*)v
-		      classes: (unsigned*)c
-		      objects: (unsigned*)o
-		     pointers: (unsigned*)p
+		      classes: (NSUInteger*)c
+		      objects: (NSUInteger*)o
+		     pointers: (NSUInteger*)p
 {
   unsigned	plen = strlen(PREFIX);
   unsigned	size = plen+36;
@@ -2105,25 +2107,32 @@ static unsigned	encodingVersion;
       [NSException raise: NSInternalInconsistencyException
 		  format: @"Archive has wrong prefix"];
     }
-  if (sscanf(&header[plen], "%x:%x:%x:%x:", v, c, o, p) != 4)
+  int ver, cls, obj, ptr;
+  if (sscanf(&header[plen], "%x:%x:%x:%x:", &ver, &cls, &obj, &ptr) != 4)
     {
       [NSException raise: NSInternalInconsistencyException
 		  format: @"Archive has wrong prefix"];
     }
+    *v = ver;
+    *c = cls;
+    *o = obj;
+    *p = ptr;
 }
 
-- (void) _serializeHeaderAt: (unsigned)locationInData
+- (void) _serializeHeaderAt: (NSUInteger)locationInData
 		    version: (unsigned)v
-		    classes: (unsigned)cc
-		    objects: (unsigned)oc
-		   pointers: (unsigned)pc
+		    classes: (NSUInteger)cc
+		    objects: (NSUInteger)oc
+		   pointers: (NSUInteger)pc
 {
   unsigned	headerLength = strlen(PREFIX)+36;
   char		header[headerLength+1];
-  unsigned	dataLength = [_dst length];
+  NSUInteger	dataLength = [_dst length];
+    
 
+  NSAssert(cc < INT_MAX && oc < INT_MAX && pc < INT_MAX, @"Counts are limited to size of int");
   snprintf(header, sizeof(header), "%s%08x:%08x:%08x:%08x:",
-    PREFIX, v, cc, oc, pc);
+    PREFIX, v, (int)cc, (int)oc, (int)pc);
 
   if (locationInData + headerLength <= dataLength)
     {
diff --git a/Source/NSPortMessage.m b/Source/NSPortMessage.m
index c004b15..8930305 100644
--- a/Source/NSPortMessage.m
+++ b/Source/NSPortMessage.m
@@ -46,8 +46,8 @@
 - (NSString*) description
 {
   return [NSString stringWithFormat:
-    @"NSPortMessage 0x%x (Id %u)\n  Send: %@\n  Recv: %@\n  Components -\n%@",
-    self, _msgid, _send, _recv, _components];
+    @"NSPortMessage 0x%lx (Id %u)\n  Send: %@\n  Recv: %@\n  Components -\n%@",
+    (unsigned long)self, _msgid, _send, _recv, _components];
 }
 
 /*	PortMessages MUST be initialised with ports and data.	*/
diff --git a/Source/NSPredicate.m b/Source/NSPredicate.m
index 8e5c4f6..5216a29 100644
--- a/Source/NSPredicate.m
+++ b/Source/NSPredicate.m
@@ -136,7 +136,7 @@ extern void     GSPropertyListMake(id,NSDictionary*,BOOL,BOOL,unsigned,id*);
   @public
   NSString		*_function;
   NSArray		*_args;
-  unsigned int		_argc;
+  NSUInteger		_argc;
   SEL                   _selector;
   NSString              *_op;        // Not retained;
 }
@@ -213,7 +213,7 @@ extern void     GSPropertyListMake(id,NSDictionary*,BOOL,BOOL,unsigned,id*);
               case 'D':
               case 'i':
                 ptr++;
-                [arr addObject: [NSNumber numberWithInt:
+                [arr addObject: [NSNumber numberWithInteger:
                   va_arg(args, NSInteger)]];
                 break;
 
@@ -224,7 +224,7 @@ extern void     GSPropertyListMake(id,NSDictionary*,BOOL,BOOL,unsigned,id*);
               case 'x':
               case 'X':
                 ptr++;
-                [arr addObject: [NSNumber numberWithUnsignedInt:
+                [arr addObject: [NSNumber numberWithUnsignedInteger:
                   va_arg(args, NSUInteger)]];
                 break;
 
@@ -457,9 +457,9 @@ extern void     GSPropertyListMake(id,NSDictionary*,BOOL,BOOL,unsigned,id*);
 
 - (NSPredicate *) predicateWithSubstitutionVariables: (NSDictionary *)variables
 {
-  unsigned int count = [_subs count];
+  NSUInteger count = [_subs count];
   NSMutableArray *esubs = [NSMutableArray arrayWithCapacity: count];
-   unsigned int i;
+   NSUInteger i;
 
   for (i = 0; i < count; i++)
     {
@@ -467,7 +467,7 @@ extern void     GSPropertyListMake(id,NSDictionary*,BOOL,BOOL,unsigned,id*);
                             predicateWithSubstitutionVariables: variables]];
     }
 
-  return [[[self class] alloc] initWithType: _type subpredicates: esubs];
+  return [[[[self class] alloc] initWithType: _type subpredicates: esubs] autorelease];
 }
 
 - (Class) classForCoder
@@ -841,10 +841,10 @@ GSICUStringMatchesRegex(NSString *string, NSString *regex, NSStringCompareOption
   flags |= UREGEX_DOTALL; // . is supposed to recognize newlines
   if ((opts & NSCaseInsensitiveSearch) != 0) { flags |= UREGEX_CASE_INSENSITIVE; }
 
-  icuregex = uregex_open(regexBuffer, regexLength, flags, NULL, &error);
+  icuregex = uregex_open(regexBuffer, (int32_t)regexLength, flags, NULL, &error);
   if (icuregex != NULL && U_SUCCESS(error))
     {
-      uregex_setText(icuregex, stringBuffer, stringLength, &error);
+      uregex_setText(icuregex, stringBuffer, (int32_t)stringLength, &error);
       result = uregex_matches(icuregex, 0, &error);
     }
   uregex_close(icuregex);
@@ -1573,7 +1573,7 @@ GSICUStringMatchesRegex(NSString *string, NSString *regex, NSStringCompareOption
 - (id) _eval_count: (NSArray *)expressions
 {
   NSAssert(_argc == 1, NSInternalInconsistencyException);
-  return [NSNumber numberWithUnsignedInt:
+  return [NSNumber numberWithUnsignedInteger:
     [[expressions objectAtIndex: 0] count]];
 }
 
@@ -1659,7 +1659,7 @@ GSICUStringMatchesRegex(NSString *string, NSString *regex, NSStringCompareOption
   NSEnumerator		*e = [self objectEnumerator];
   id			object;
 
-  result = [NSMutableArray arrayWithCapacity: [self count]];
+  result = [[NSMutableArray alloc] initWithCapacity: [self count]];
   while ((object = [e nextObject]) != nil)
     {
       if ([predicate evaluateWithObject: object] == YES)
@@ -1667,7 +1667,7 @@ GSICUStringMatchesRegex(NSString *string, NSString *regex, NSStringCompareOption
           [result addObject: object];  // passes filter
         }
     }
-  return [result makeImmutableCopyOnFail: NO];
+  return [[result makeImmutable] autorelease];
 }
 
 @end
@@ -1676,7 +1676,7 @@ GSICUStringMatchesRegex(NSString *string, NSString *regex, NSStringCompareOption
 
 - (void) filterUsingPredicate: (NSPredicate *)predicate
 {	
-  unsigned	count = [self count];
+  NSUInteger	count = [self count];
 
   while (count-- > 0)
     {
@@ -1699,7 +1699,7 @@ GSICUStringMatchesRegex(NSString *string, NSString *regex, NSStringCompareOption
   NSEnumerator	*e = [self objectEnumerator];
   id		object;
 
-  result = [NSMutableSet setWithCapacity: [self count]];
+  result = [[NSMutableSet alloc] initWithCapacity: [self count]];
   while ((object = [e nextObject]) != nil)
     {
       if ([predicate evaluateWithObject: object] == YES)
@@ -1707,7 +1707,7 @@ GSICUStringMatchesRegex(NSString *string, NSString *regex, NSStringCompareOption
           [result addObject: object];  // passes filter
         }
     }
-  return [result makeImmutableCopyOnFail: NO];
+  return [[result makeImmutable] autorelease];
 }
 
 @end
@@ -1756,7 +1756,7 @@ GSICUStringMatchesRegex(NSString *string, NSString *regex, NSStringCompareOption
 - (BOOL) scanPredicateKeyword: (NSString *)key
 {
   // save to back up
-  unsigned loc = [self scanLocation];
+  NSUInteger loc = [self scanLocation];
   unichar c;
   
   [self setCaseSensitive: NO];
@@ -2125,7 +2125,7 @@ GSICUStringMatchesRegex(NSString *string, NSString *regex, NSStringCompareOption
 
 - (NSExpression *) parseSimpleExpression
 {
-  unsigned      location;
+  NSUInteger    location;
   double        dbl;
 
   if ([self scanDouble: &dbl])
@@ -2295,7 +2295,7 @@ GSICUStringMatchesRegex(NSString *string, NSString *regex, NSStringCompareOption
 	{
 	  [self setCharactersToBeSkipped: skip];
           [NSException raise: NSInvalidArgumentException 
-                      format: @"Invalid double quoted literal at %u", location];
+                      format: @"Invalid double quoted literal at %lu", (unsigned long)location];
 	}
       [self setCharactersToBeSkipped: skip];
       [self scanString: @"\"" intoString: NULL];
@@ -2312,7 +2312,7 @@ GSICUStringMatchesRegex(NSString *string, NSString *regex, NSStringCompareOption
 	{
 	  [self setCharactersToBeSkipped: skip];
           [NSException raise: NSInvalidArgumentException 
-                      format: @"Invalid single quoted literal at %u", location];
+                      format: @"Invalid single quoted literal at %lu", (unsigned long)location];
 	}
       [self setCharactersToBeSkipped: skip];
       [self scanString: @"'" intoString: NULL];
diff --git a/Source/NSProcessInfo.m b/Source/NSProcessInfo.m
index 5c2842f..4386afd 100644
--- a/Source/NSProcessInfo.m
+++ b/Source/NSProcessInfo.m
@@ -108,6 +108,7 @@
 #include <crt_externs.h>
 #endif
 
+#import "config.h" /* for HAVE_LOAD_METHOD */
 #import "GNUstepBase/GSConfig.h"
 #import "Foundation/NSArray.h"
 #import "Foundation/NSSet.h"
@@ -245,7 +246,7 @@ _gnu_process_args(int argc, char *argv[], char *env[])
 
   if (argv != 0 && argv[0] != 0)
     {
-      int	len;
+      NSUInteger	len;
 
       len = strlen(argv[0]) + 1;
       _gnu_arg_zero = (char*)malloc(len);
@@ -430,7 +431,7 @@ _gnu_process_args(int argc, char *argv[], char *env[])
 	i = 0;
 	while (env[i])
 	  {
-	    int		len = strlen(env[i]);
+	    NSUInteger		len = strlen(env[i]);
 	    char	*cp = strchr(env[i], '=');
 
 	    if (len && cp)
@@ -457,7 +458,7 @@ _gnu_process_args(int argc, char *argv[], char *env[])
   [arp drain];
 }
 
-#if !GS_FAKE_MAIN && ((defined(HAVE_PROCFS)  || defined(HAVE_KVM_ENV) || defined(HAVE_PROCFS_PSINFO) || defined(__APPLE__)) && (defined(HAVE_LOAD_METHOD)))
+#if !GS_FAKE_MAIN && ((defined (HAVE_PROCFS)  || defined (HAVE_KVM_ENV) || defined (HAVE_PROCFS_PSINFO) || defined (__APPLE__)) && defined (HAVE_LOAD_METHOD))
 /*
  * We have to save program arguments and environment before main () is
  * executed, because main () could modify their values before we get a
@@ -936,7 +937,12 @@ extern char **__libc_argv;
       _gnu_process_args(__libc_argc, __libc_argv, environ);
     }
 }
+#elif defined (__APPLE__)
 
++ (void)initialize
+{
+    GSInitializeProcess(*_NSGetArgc(), *_NSGetArgv(), *_NSGetEnviron());
+}
 
 #else
 #ifndef GS_PASS_ARGUMENTS
@@ -963,14 +969,6 @@ int gnustep_base_user_main (int argc, char *argv[], char *env[])
 }
 int main(int argc, char *argv[], char *env[])
 {
-#ifdef NeXT_RUNTIME
-  /* This memcpy has to be done before the first message is sent to any
-     constant string object. See Apple Radar 2870817 */
-  memcpy(&_NSConstantStringClassReference,
-         objc_getClass(STRINGIFY(NXConstantString)),
-         sizeof(_NSConstantStringClassReference));
-#endif
-
 #if defined(__MINGW__)
   WSADATA lpWSAData;
 
@@ -1002,7 +1000,12 @@ int main(int argc, char *argv[], char *env[])
   // We can't use NSAssert, which calls NSLog, which calls NSProcessInfo...
   if (!(_gnu_processName && _gnu_arguments && _gnu_environment))
     {
-      _NSLog_printf_handler(_GNU_MISSING_MAIN_FUNCTION_CALL);
+      [NSException raise:@"Process info is missing" format:_GNU_MISSING_MAIN_FUNCTION_CALL];
+      /* If syslog is present _NSLog_printf_handler requests 
+       * GSPrivateDefaultsFlag(GSLogSyslog) and we get into 
+       * the infinite recursion
+       */
+      // _NSLog_printf_handler(_GNU_MISSING_MAIN_FUNCTION_CALL);
       exit(1);
     }
 
@@ -1034,7 +1037,7 @@ int main(int argc, char *argv[], char *env[])
   if (pid > 0)
     {
 #if	defined(__MINGW__)
-      HANDLE        h = OpenProcess(PROCESS_QUERY_INFORMATION,0,pid);
+      HANDLE h = OpenProcess(PROCESS_QUERY_INFORMATION,0,pid);
       if (h == NULL && GetLastError() != ERROR_ACCESS_DENIED)
         {
           return NO;
@@ -1125,7 +1128,7 @@ static void determineOperatingSystem()
        */
       if (uname(&uts) == 0)
 	{
-	  os = [NSString stringWithCString: uts.sysname                                                           encoding: [NSString defaultCStringEncoding]];
+	  os = [NSString stringWithCString: uts.sysname encoding: [NSString defaultCStringEncoding]];
 	  os = [os lowercaseString];
 	  /* Get the operating system version ... usually the version string
 	   * is pretty horrible, and the kernel release string actually
@@ -1398,8 +1401,8 @@ static void determineOperatingSystem()
 #elif	defined(_SC_PHYS_PAGES)
       availMem = sysconf(_SC_PHYS_PAGES) * NSPageSize();
 #elif	defined(HAVE_SYSCTLBYNAME)
-      long	val;
-      size_t	len = val;
+      long    val = 0;
+      size_t  len = 0;
 
       if (sysctlbyname("hw.physmem", &val, &len, 0, 0) == 0)
         {
diff --git a/Source/NSPropertyList.m b/Source/NSPropertyList.m
index fc08f93..c26c39d 100644
--- a/Source/NSPropertyList.m
+++ b/Source/NSPropertyList.m
@@ -83,8 +83,6 @@ static Class	NSMutableStringClass;
 static Class	GSStringClass;
 static Class	GSMutableStringClass;
 
-extern BOOL GSScanDouble(unichar*, unsigned, double*);
-
 @class	GSMutableDictionary;
 @interface GSMutableDictionary : NSObject	// Help the compiler
 @end
@@ -241,7 +239,8 @@ foundIgnorableWhitespace: (NSString *)string
 	}
       else
         {
-	  ASSIGN(plist, [[stack lastObject] makeImmutableCopyOnFail: NO]);
+	  // ASSIGN(plist, [[stack lastObject] makeImmutableCopyOnFail: NO]);
+	  ASSIGN(plist, [stack lastObject]); // FIXME!
 	}
       [stack removeLastObject];
       inArray = NO;
@@ -451,14 +450,14 @@ foundIgnorableWhitespace: (NSString *)string
 @interface GSBinaryPLParser : NSObject
 {
   NSPropertyListMutabilityOptions	mutability;
-  unsigned              _length;
+  NSUInteger              _length;
   const unsigned char	*_bytes;
   NSData		*data;
-  unsigned		offset_size;	// Number of bytes per table entry
-  unsigned		index_size;	// Number of bytes per table entry
-  unsigned		object_count;	// Number of objects
-  unsigned		root_index;	// Index of root object
-  unsigned		table_start;	// Start address of object table
+  NSUInteger		object_count;	// Number of objects
+  NSUInteger		root_index;	// Index of root object
+  NSUInteger		table_start;	// Start address of object table
+  unsigned          offset_size;	// Number of bytes per table entry
+  unsigned          index_size;	// Number of bytes per table entry
 }
 
 - (id) initWithData: (NSData*)plData
@@ -470,19 +469,19 @@ foundIgnorableWhitespace: (NSString *)string
 
 @interface GSBinaryPLGenerator : NSObject
 {
-  NSMutableData *dest;
-  NSMapTable 	*objectList;
-  NSMutableArray *objectsToDoList;
-  id root;
-
-  // Number of bytes per object table index
-  unsigned int index_size;
-  // Number of bytes per object table entry
-  unsigned int offset_size;
-
-  unsigned int table_start;
-  unsigned int table_size;
-  unsigned int *table;
+    NSMutableData *dest;
+    NSMapTable 	*objectList;
+    NSMutableArray *objectsToDoList;
+    id root;
+    
+    NSUInteger table_start;
+    NSUInteger table_size;
+    unsigned *table;
+    
+    // Number of bytes per object table index
+    unsigned index_size;
+    // Number of bytes per object table entry
+    unsigned offset_size;
 }
 
 + (void) serializePropertyList: (id)aPropertyList
@@ -618,9 +617,9 @@ static void setupQuotables(void)
 
 typedef	struct	{
   const unsigned char	*ptr;
-  unsigned	end;
-  unsigned	pos;
-  unsigned	lin;
+  NSUInteger	end;
+  NSUInteger	pos;
+  NSUInteger	lin;
   NSString	*err;
   NSPropertyListMutabilityOptions opt;
   BOOL		key;
@@ -709,11 +708,12 @@ static BOOL skipSpace(pldata *pld)
   return NO;
 }
 
+static inline id parseQuotedString(pldata* pld) NS_RETURNS_RETAINED;
 static inline id parseQuotedString(pldata* pld)
 {
-  unsigned	start = ++pld->pos;
-  unsigned	escaped = 0;
-  unsigned	shrink = 0;
+  NSUInteger	start = ++pld->pos;
+  NSUInteger	escaped = 0;
+  NSUInteger	shrink = 0;
   BOOL		hex = NO;
   NSString	*obj;
 
@@ -791,12 +791,12 @@ static inline id parseQuotedString(pldata* pld)
     }
   else
     {
-      unsigned	length;
-      unichar	*chars;
-      unichar	*temp = NULL;
-      unsigned	int temp_length = 0;
-      unsigned	j;
-      unsigned	k;
+      NSUInteger  length;
+      unichar     *chars;
+      unichar     *temp = NULL;
+      NSUInteger  temp_length = 0;
+      NSUInteger  j;
+      NSUInteger  k;
 
       if (!GSToUnicode(&temp, &temp_length, &pld->ptr[start],
 		       pld->pos - start, NSUTF8StringEncoding,
@@ -912,11 +912,12 @@ static inline id parseQuotedString(pldata* pld)
   return obj;
 }
 
+static inline id parseUnquotedString(pldata *pld) NS_RETURNS_RETAINED;
 static inline id parseUnquotedString(pldata *pld)
 {
-  unsigned	start = pld->pos;
-  unsigned	i;
-  unsigned	length;
+  NSUInteger	start = pld->pos;
+  NSUInteger	i;
+  NSUInteger	length;
   id		obj;
   unichar	*chars;
 
@@ -951,6 +952,7 @@ static inline id parseUnquotedString(pldata *pld)
   return obj;
 }
 
+static id parsePlItem(pldata* pld) NS_RETURNS_RETAINED;
 static id parsePlItem(pldata* pld)
 {
   id	result = nil;
@@ -979,6 +981,7 @@ static id parsePlItem(pldata* pld)
 	      pld->key = NO;
 	      if (key == nil)
 		{
+		  RELEASE(dict);
 		  return nil;
 		}
 	      if (skipSpace(pld) == NO)
@@ -1052,7 +1055,7 @@ static id parsePlItem(pldata* pld)
 	  result = dict;
 	  if (pld->opt == NSPropertyListImmutable)
 	    {
-	      [result makeImmutableCopyOnFail: NO];
+	      result = [result makeImmutable];
 	    }
 	}
 	break;
@@ -1104,7 +1107,7 @@ static id parsePlItem(pldata* pld)
 	  result = array;
 	  if (pld->opt == NSPropertyListImmutable)
 	    {
-	      [result makeImmutableCopyOnFail: NO];
+	      result = [result makeImmutable];
 	    }
 	}
 	break;
@@ -1114,9 +1117,9 @@ static id parsePlItem(pldata* pld)
 	if (pld->pos < pld->end && pld->ptr[pld->pos] == '*')
 	  {
 	    const unsigned char	*ptr;
-	    unsigned		min;
-	    unsigned		len = 0;
-	    unsigned		i;
+	    NSUInteger		min;
+	    NSUInteger		len = 0;
+	    NSUInteger		i;
 
 	    pld->old = NO;
 	    pld->pos++;
@@ -1211,11 +1214,13 @@ static id parsePlItem(pldata* pld)
 	    if (pld->pos >= pld->end)
 	      {
 		pld->err = @"unexpected end of string when parsing data";
+		RELEASE(result);
 		return nil;
 	      }
 	    if (pld->ptr[pld->pos] != '>')
 	      {
 		pld->err = @"unexpected character (wanted '>')";
+		RELEASE(result);
 		return nil;
 	      }
 	    pld->pos++;
@@ -1223,9 +1228,9 @@ static id parsePlItem(pldata* pld)
 	else
 	  {
 	    NSMutableData	*data;
-	    unsigned	max = pld->end - 1;
+	    NSUInteger	max = pld->end - 1;
 	    unsigned	char	buf[BUFSIZ];
-	    unsigned	len = 0;
+	    NSUInteger	len = 0;
 
 	    data = [[NSMutableData alloc] initWithCapacity: 0];
 	    skipSpace(pld);
@@ -1282,6 +1287,7 @@ static id parsePlItem(pldata* pld)
       if (skipSpace(pld) == YES)
 	{
 	  pld->err = @"extra data after parsed string";
+	  RELEASE(result);
 	  result = nil;		// Not at end of string.
 	}
       else
@@ -1410,8 +1416,8 @@ GSPropertyListFromStringsFormat(NSString *string)
     {
       RELEASE(dict);
       [NSException raise: NSGenericException
-		  format: @"Parse failed at line %d (char %d) - %@",
-	_pld.lin + 1, _pld.pos + 1, _pld.err];
+		  format: @"Parse failed at line %lu (char %lu) - %@",
+	(unsigned long)_pld.lin + 1, (unsigned long)_pld.pos + 1, _pld.err];
     }
   return AUTORELEASE(dict);
 }
@@ -1426,14 +1432,14 @@ static char base64[]
 static void
 encodeBase64(NSData *source, NSMutableData *dest)
 {
-  int		length = [source length];
-  int		enclen = length / 3;
-  int		remlen = length - 3 * enclen;
-  int		destlen = 4 * ((length + 2) / 3);
+  NSInteger		length = [source length];
+  NSInteger		enclen = length / 3;
+  NSInteger		remlen = length - 3 * enclen;
+  NSInteger		destlen = 4 * ((length + 2) / 3);
   unsigned char *sBuf;
   unsigned char *dBuf;
-  int		sIndex = 0;
-  int		dIndex = [dest length];
+  NSInteger		sIndex = 0;
+  NSInteger		dIndex = [dest length];
 
   [dest setLength: dIndex + destlen];
 
@@ -1486,7 +1492,7 @@ static inline void Append(void *bytes, unsigned length, NSMutableData *dst)
 static void
 PString(NSString *obj, NSMutableData *output)
 {
-  unsigned	length;
+  NSUInteger	length;
 
   if ((length = [obj length]) == 0)
     {
@@ -1498,8 +1504,8 @@ PString(NSString *obj, NSMutableData *output)
       unichar		*from;
       unichar		*end;
       unsigned char	*ptr;
-      int		base = [output length];
-      int		len = 0;
+      NSInteger		base = [output length];
+      NSInteger		len = 0;
       GS_BEGINITEMBUF(ustring, (length * sizeof(unichar)), unichar)
 
       end = &ustring[length];
@@ -1621,7 +1627,7 @@ static void
 XString(NSString* obj, NSMutableData *output)
 {
   static const char	*hexdigits = "0123456789ABCDEF";
-  unsigned	end;
+  NSUInteger	end;
 
   end = [obj length];
   if (end == 0)
@@ -1634,9 +1640,9 @@ XString(NSString* obj, NSMutableData *output)
       unichar	*base;
       unichar	*map;
       unichar	c;
-      unsigned	len;
-      unsigned	rpos;
-      unsigned	wpos;
+      NSUInteger	len;
+      NSUInteger	rpos;
+      NSUInteger	wpos;
       BOOL	osx;
 
       osx = GSPrivateDefaultsFlag(GSMacOSXCompatible);
@@ -1925,9 +1931,9 @@ OAppend(id obj, NSDictionary *loc, unsigned lev, unsigned step,
 	{
 	  const unsigned char	*src;
 	  unsigned char		*dst;
-	  int		length;
-	  int		i;
-	  int		j;
+	  NSInteger		length;
+	  NSInteger		i;
+	  NSInteger		j;
 
 	  src = [obj bytes];
 	  length = [obj length];
@@ -1985,7 +1991,7 @@ OAppend(id obj, NSDictionary *loc, unsigned lev, unsigned step,
     {
       const char	*iBaseString;
       const char	*iSizeString;
-      unsigned	level = lev;
+      unsigned      level = lev;
 
       if (level*step < sizeof(indentStrings)/sizeof(id))
 	{
@@ -2023,10 +2029,10 @@ OAppend(id obj, NSDictionary *loc, unsigned lev, unsigned step,
 	}
       else
 	{
-	  unsigned		count = [obj count];
-	  unsigned		last = count - 1;
+	  NSUInteger		count = [obj count];
+	  NSUInteger		last = count - 1;
 	  NSString		*plists[count];
-	  unsigned		i;
+	  NSUInteger		i;
 
 	  if ([obj isProxy] == YES)
 	    {
@@ -2084,9 +2090,9 @@ OAppend(id obj, NSDictionary *loc, unsigned lev, unsigned step,
       const char	*iSizeString;
       SEL		objSel = @selector(objectForKey:);
       IMP		myObj = [obj methodForSelector: objSel];
-      unsigned		i;
+      NSUInteger		i;
       NSArray		*keyArray = [obj allKeys];
-      unsigned		numKeys = [keyArray count];
+      NSUInteger		numKeys = [keyArray count];
       NSString		*plists[numKeys];
       NSString		*keys[numKeys];
       BOOL		canCompare = YES;
@@ -2170,10 +2176,10 @@ OAppend(id obj, NSDictionary *loc, unsigned lev, unsigned step,
       if (canCompare == YES)
 	{
 	  #define STRIDE_FACTOR 3
-	  unsigned	c,d, stride;
+	  NSUInteger	c,d, stride;
 	  BOOL		found;
 	  NSComparisonResult	(*comp)(id, SEL, id) = 0;
-	  unsigned int	count = numKeys;
+	  NSUInteger	count = numKeys;
 	  #ifdef	GSWARN
 	  BOOL		badComparison = NO;
 	  #endif
@@ -2430,7 +2436,7 @@ static BOOL	classInitialized = NO;
 
 void
 GSPropertyListMake(id obj, NSDictionary *loc, BOOL xml,
-  BOOL forDescription, unsigned step, id *str)
+                   BOOL forDescription, unsigned step, id *str)
 {
   NSString		*tmp;
   NSPropertyListFormat	style;
@@ -2548,7 +2554,7 @@ GSPropertyListMake(id obj, NSDictionary *loc, BOOL xml,
   NSString           *errorStr = nil;
   id			result = nil;
   const unsigned char	*bytes = 0;
-  unsigned int		length = 0;
+  NSUInteger		length = 0;
 
   if (data == nil)
     {
@@ -2642,8 +2648,8 @@ GSPropertyListMake(id obj, NSDictionary *loc, BOOL xml,
             if (_pld.err != nil)
               {
                 errorStr = [NSString stringWithFormat:
-		  @"Parse failed at line %d (char %d) - %@",
-		  _pld.lin + 1, _pld.pos + 1, _pld.err];
+		  @"Parse failed at line %lu (character %lu) - %@",
+		  (unsigned long)_pld.lin + 1, (unsigned long)_pld.pos + 1, _pld.err];
               }
           }
           break;
@@ -2826,19 +2832,19 @@ GSPropertyListMake(id obj, NSDictionary *loc, BOOL xml,
 
       if (offset_size < 1 || offset_size > 4)
 	{
-	  unsigned saved = offset_size;
+	  NSUInteger saved = offset_size;
 
 	  DESTROY(self);	// Bad format
 	  [NSException raise: NSGenericException
-		      format: @"Unknown offset size %d", saved];
+		      format: @"Unknown offset size %lu", (unsigned long)saved];
 	}
       else if (index_size < 1 || index_size > 4)
 	{
-	  unsigned saved = index_size;
+	  NSUInteger saved = index_size;
 
 	  DESTROY(self);	// Bad format
 	  [NSException raise: NSGenericException
-		      format: @"Unknown table size %d", saved];
+		      format: @"Unknown table size %lu", (unsigned long)saved];
 	}
       else if (table_start + object_count * offset_size > _length)
         {
@@ -2865,19 +2871,19 @@ GSPropertyListMake(id obj, NSDictionary *loc, BOOL xml,
   return self;
 }
 
-- (unsigned long) offsetForIndex: (unsigned)index
+- (NSUInteger) offsetForIndex: (NSUInteger)index
 {
   if (index >= object_count)
     {
       [NSException raise: NSRangeException
-		   format: @"Object table index out of bounds %d.", index];
+                  format: @"Object table index out of bounds %lu", (unsigned long)index];
       return 0; /* Not reached */
     }
   else
     {
-      unsigned long     offset;
-      unsigned          count;
-      unsigned          pos;
+      NSUInteger offset;
+      NSUInteger count;
+      NSUInteger pos;
 
       /* An offset is stored in big-endian byte order, so we can simply
        * read it byte by byte.
@@ -2892,11 +2898,11 @@ GSPropertyListMake(id obj, NSDictionary *loc, BOOL xml,
     }
 }
 
-- (unsigned) readObjectIndexAt: (unsigned*)counter
+- (NSUInteger) readObjectIndexAt: (NSUInteger*)counter
 {
-  unsigned      index;
-  unsigned      count;
-  unsigned      pos;
+  NSUInteger index;
+  NSUInteger count;
+  NSUInteger pos;
 
 NSAssert(0 != counter, NSInvalidArgumentException);
   pos = *counter;
@@ -2910,10 +2916,10 @@ NSAssert(pos + index_size < _length, NSInvalidArgumentException);
   return index;
 }
 
-- (unsigned long) readCountAt: (unsigned*) counter
+- (NSUInteger) readCountAt: (NSUInteger*) counter
 {
-  unsigned long count;
-  unsigned      pos;
+  NSUInteger count;
+  NSUInteger pos;
   unsigned char c;
 
 NSAssert(0 != counter, NSInvalidArgumentException);
@@ -2967,7 +2973,7 @@ NSAssert(pos + count < _length, NSInvalidArgumentException);
 - (id) objectAtIndex: (NSUInteger)index
 {
   unsigned char	next;
-  unsigned counter = [self offsetForIndex: index];
+  NSUInteger counter = [self offsetForIndex: index];
   id	        result = nil;
 
   [data getBytes: &next range: NSMakeRange(counter,1)];
@@ -3088,7 +3094,7 @@ NSAssert(counter + len <= _length, NSInvalidArgumentException);
   else if (next == 0x5F)
     {
       NSString  *s;     // Long utf8 string
-      unsigned	len;
+      NSUInteger	len;
 
       if (mutability == NSPropertyListMutableContainersAndLeaves)
 	{
@@ -3170,7 +3176,7 @@ NSAssert(counter + len <= _length, NSInvalidArgumentException);
 
       for (i = 0; i < len; i++)
         {
-	  int oid = [self readObjectIndexAt: &counter];
+	  NSUInteger oid = [self readObjectIndexAt: &counter];
 
 	  objects[i] = [self objectAtIndex: oid];
 	}
@@ -3197,7 +3203,7 @@ NSAssert(counter + len <= _length, NSInvalidArgumentException);
 
       for (i = 0; i < len; i++)
         {
-	  int oid = [self readObjectIndexAt: &counter];
+	  NSUInteger oid = [self readObjectIndexAt: &counter];
 
 	  objects[i] = [self objectAtIndex: oid];
 	}
@@ -3223,14 +3229,14 @@ NSAssert(counter + len <= _length, NSInvalidArgumentException);
 
       for (i = 0; i < len; i++)
         {
-	  int oid = [self readObjectIndexAt: &counter];
+	  NSUInteger oid = [self readObjectIndexAt: &counter];
 
 	  keys[i] = [self objectAtIndex: oid];
 	}
 
       for (i = 0; i < len; i++)
         {
-	  int oid = [self readObjectIndexAt: &counter];
+	  NSUInteger oid = [self readObjectIndexAt: &counter];
 
 	  values[i] = [self objectAtIndex: oid];
 	}
@@ -3262,14 +3268,14 @@ NSAssert(counter + len <= _length, NSInvalidArgumentException);
       values = keys + len;
       for (i = 0; i < len; i++)
         {
-	  int oid = [self readObjectIndexAt: &counter];
+	  NSUInteger oid = [self readObjectIndexAt: &counter];
 
 	  keys[i] = [self objectAtIndex: oid];
 	}
 
       for (i = 0; i < len; i++)
         {
-	  int oid = [self readObjectIndexAt: &counter];
+	  NSUInteger oid = [self readObjectIndexAt: &counter];
 
 	  values[i] = [self objectAtIndex: oid];
 	}
@@ -3424,33 +3430,32 @@ isEqualFunc(const void *item1, const void *item2,
     }
 }
 
-- (void) markOffset: (unsigned int) offset for: (id)object
+- (void) markOffset: (NSUInteger) offset for: (id)object
 {
-  int oid;
-
-  oid = (NSInteger)[objectList objectForKey: object];
+  NSInteger oid = (NSInteger)[objectList objectForKey: object];
+    
   if (oid <= 0)
     {
       [NSException raise: NSGenericException
-		   format: @"Unknown object %@.", object];
+                  format: @"Unknown object %@", object];
     }
   oid--;
   if (oid >= table_size)
     {
       [NSException raise: NSRangeException
-		   format: @"Object table index out of bounds %d.", oid];
+                  format: @"Object table index out of bounds %ld", (long)oid];
     }
 
-  table[oid] = offset;
+  table[oid] = (unsigned) offset;
 }
 
 - (void) writeObjectTable
 {
-  unsigned int size;
-  unsigned int len;
-  unsigned int i;
+  NSUInteger size;
+  NSUInteger len;
+  NSUInteger i;
   unsigned char *buffer;
-  unsigned int last_offset;
+  NSUInteger last_offset;
 
   table_start = [dest length];
   // This is a bit too much, as the length
@@ -3476,7 +3481,7 @@ isEqualFunc(const void *item1, const void *item2,
   else
     {
       [NSException raise: NSRangeException
-	format: @"Object table offset out of bounds %d.", last_offset];
+                  format: @"Object table offset out of bounds %lu", (unsigned long)last_offset];
     }
 
   len = [objectList count];
@@ -3538,8 +3543,8 @@ isEqualFunc(const void *item1, const void *item2,
 - (void) writeMetaData
 {
   unsigned char meta[32];
-  unsigned int i;
-  unsigned int len;
+  NSUInteger i;
+  NSUInteger len;
 
   for (i = 0; i < 32; i++)
     {
@@ -3597,8 +3602,8 @@ isEqualFunc(const void *item1, const void *item2,
   else if (index_size == 3)
     {
       unsigned char buffer[index_size];
-      int i;
-      unsigned num = index;
+      NSInteger i;
+      NSUInteger num = index;
 
       for (i = index_size - 1; i >= 0; i--)
         {
@@ -3609,9 +3614,7 @@ isEqualFunc(const void *item1, const void *item2,
     }
   else if (index_size == 4)
     {
-      unsigned int oid;
-
-      oid = NSSwapHostIntToBig(index);
+      NSUInteger oid = (NSUInteger)NSSwapHostLongToBig((long)index);
       [dest appendBytes: &oid length: 4];
     }
   else
@@ -3621,7 +3624,7 @@ isEqualFunc(const void *item1, const void *item2,
     }
 }
 
-- (void) storeCount: (unsigned int)count
+- (void) storeCount: (NSUInteger)count
 {
   unsigned char code;
 
@@ -3648,14 +3651,16 @@ isEqualFunc(const void *item1, const void *item2,
     {
       code = 0x13;
       [dest appendBytes: &code length: 1];
-      count = NSSwapHostIntToBig(count);
-      [dest appendBytes: &count length: 4];
+      NSAssert1(count < UINT32_MAX, @"Count is too large: %lu", count);
+      count = NSSwapHostLongToBig(count);
+      uint32_t count32 = (uint32_t)count;
+      [dest appendBytes: &count32 length: 4];
     }
 }
 
 - (void) storeData: (NSData*) data
 {
-  unsigned int len;
+  NSUInteger len;
   unsigned char code;
 
   len = [data length];
@@ -3677,7 +3682,7 @@ isEqualFunc(const void *item1, const void *item2,
 
 - (void) storeString: (NSString*) string
 {
-  unsigned int len;
+  NSUInteger len;
   NSData        *ascii;
   unsigned char code;
 
@@ -3852,8 +3857,8 @@ isEqualFunc(const void *item1, const void *item2,
 - (void) storeArray: (NSArray*) array
 {
   unsigned char code;
-  unsigned int len;
-  unsigned int i;
+  NSUInteger len;
+  NSUInteger i;
 
   len = [array count];
 
@@ -3914,7 +3919,7 @@ isEqualFunc(const void *item1, const void *item2,
     }
   else
     {
-      unsigned int len = [dict count];
+      NSUInteger len = [dict count];
       NSArray *keys = [dict allKeys];
       NSMutableArray *objects = [NSMutableArray arrayWithCapacity: len];
       id key;
diff --git a/Source/NSProxy.m b/Source/NSProxy.m
index eb70269..cb81e8c 100644
--- a/Source/NSProxy.m
+++ b/Source/NSProxy.m
@@ -136,6 +136,11 @@
   /* Do nothing	*/
 }
 
++ (void) initialize
+{
+  /* Do nothing */
+}
+
 - (IMP) methodForSelector: (SEL)aSelector
 {
   if (aSelector == 0)
@@ -291,14 +296,7 @@
  */
 - (NSUInteger) hash
 {
-  /*
-   * Ideally we would shift left to lose any zero bits produced by the
-   * alignment of the object in memory ... but that depends on the
-   * processor architecture and the memory allocatiion implementation.
-   * In the absence of detailed information, pick a reasonable value
-   * assuming the object will be aligned to an eight byte boundary.
-   */
-  return ((NSUInteger)(uintptr_t)self)>>3;
+  return GSPointerHash((uintptr_t)self);
 }
 
 /** <init /> <override-subclass />
@@ -406,7 +404,7 @@
 
 - (id) performSelector: (SEL)aSelector
 {
-  IMP msg = objc_msg_lookup(self, aSelector);
+  IMP msg = GSObjCMethodForSelector(self, aSelector);
 
   if (!msg)
     {
@@ -421,7 +419,7 @@
 - (id) performSelector: (SEL)aSelector
 	    withObject: (id)anObject
 {
-  IMP msg = objc_msg_lookup(self, aSelector);
+  IMP msg = GSObjCMethodForSelector(self, aSelector);
 
   if (!msg)
     {
@@ -437,7 +435,7 @@
 	    withObject: (id)anObject
 	    withObject: (id)anotherObject
 {
-  IMP msg = objc_msg_lookup(self, aSelector);
+  IMP msg = GSObjCMethodForSelector(self, aSelector);
 
   if (!msg)
     {
diff --git a/Source/NSRange.m b/Source/NSRange.m
index 5680920..b2e92ee 100644
--- a/Source/NSRange.m
+++ b/Source/NSRange.m
@@ -88,8 +88,8 @@ NSString *
 NSStringFromRange(NSRange range)
 {
   setupCache();
-  return [NSStringClass stringWithFormat: @"{location=%d, length=%d}",
-    range.location, range.length];
+  return [NSStringClass stringWithFormat: @"{location=%lu, length=%lu}",
+    (unsigned long)range.location, (unsigned long)range.length];
 }
 
 GS_EXPORT void _NSRangeExceptionRaise ()
diff --git a/Source/NSRegularExpression.m b/Source/NSRegularExpression.m
index 2fc0194..9d36d47 100644
--- a/Source/NSRegularExpression.m
+++ b/Source/NSRegularExpression.m
@@ -55,7 +55,7 @@
  * in theory use the libicu values directly (that would be sensible), but that
  * would break any code that didn't correctly use the symbolic constants.
  */
-uint32_t
+static uint32_t
 NSRegularExpressionOptionsToURegexpFlags(NSRegularExpressionOptions opts)
 {
   uint32_t flags = 0;
@@ -217,12 +217,13 @@ callback(const void *context, int32_t steps)
 #if HAVE_UREGEX_OPENUTEXT
 static URegularExpression *
 setupRegex(URegularExpression *regex,
-  NSString *string,
-  UText *txt,
-  NSMatchingOptions options,
-  NSRange range,
-  GSRegexBlock block)
+           NSString *string,
+           UText *txt,
+           NSMatchingOptions options,
+           NSRange range,
+           GSRegexBlock block)
 {
+  NSCParameterAssert(range.location + range.length < INT32_MAX);
   UErrorCode		s = 0;
   URegularExpression	*r = uregex_clone(regex, &s);
 
@@ -232,7 +233,7 @@ setupRegex(URegularExpression *regex,
     }
   UTextInitWithNSString(txt, string);
   uregex_setUText(r, txt, &s);
-  uregex_setRegion(r, range.location, range.location+range.length, &s);
+  uregex_setRegion(r, (int32_t)range.location, (int32_t)(range.location + range.length), &s);
   if (options & NSMatchingWithoutAnchoringBounds)
     {
       uregex_useAnchoringBounds(r, FALSE, &s);
@@ -287,13 +288,14 @@ setupRegex(URegularExpression *regex,
 
 static uint32_t
 prepareResult(NSRegularExpression *regex,
-  URegularExpression *r,
-  NSRangePointer ranges,
-  NSUInteger groups,
-  UErrorCode *s)
+              URegularExpression *r,
+              NSRangePointer ranges,
+              NSUInteger groups,
+              UErrorCode *s)
 {
+  NSCParameterAssert(groups < INT32_MAX);
   uint32_t	flags = 0;
-  NSUInteger	i = 0;
+  int32_t	i = 0;
 
   for (i = 0; i < groups; i++)
     {
@@ -704,7 +706,7 @@ prepareResult(NSRegularExpression *regex,
   utext_close(&txt);
   utext_close(output);
   utext_close(&replacement);
-  return ret;
+  return [ret autorelease];
 }
 
 - (NSString*) replacementStringForResult: (NSTextCheckingResult*)result
diff --git a/Source/NSRunLoop.m b/Source/NSRunLoop.m
index 86e75fd..78865e8 100644
--- a/Source/NSRunLoop.m
+++ b/Source/NSRunLoop.m
@@ -84,7 +84,7 @@ static NSDate	*theFuture = nil;
   SEL		selector;
   id		target;
   id		argument;
-  unsigned	order;
+  NSUInteger	order;
 }
 
 - (void) fire;
@@ -269,7 +269,7 @@ static inline BOOL timerInvalidated(NSTimer *t)
 + (void) cancelPreviousPerformRequestsWithTarget: (id)target
 {
   NSMutableArray	*perf = [[NSRunLoop currentRunLoop] _timedPerformers];
-  unsigned		count = [perf count];
+  NSUInteger		count = [perf count];
 
   if (count > 0)
     {
@@ -303,7 +303,7 @@ static inline BOOL timerInvalidated(NSTimer *t)
 					  object: (id)arg
 {
   NSMutableArray	*perf = [[NSRunLoop currentRunLoop] _timedPerformers];
-  unsigned		count = [perf count];
+  NSUInteger		count = [perf count];
 
   if (count > 0)
     {
@@ -349,14 +349,14 @@ static inline BOOL timerInvalidated(NSTimer *t)
 	      afterDelay: (NSTimeInterval)seconds
 		 inModes: (NSArray*)modes
 {
-  unsigned	count = [modes count];
+  NSUInteger	count = [modes count];
 
   if (count > 0)
     {
       NSRunLoop		*loop = [NSRunLoop currentRunLoop];
       NSString		*marray[count];
       GSTimedPerformer	*item;
-      unsigned		i;
+      NSUInteger		i;
 
       item = [[GSTimedPerformer alloc] initWithSelector: aSelector
 						 target: self
@@ -409,7 +409,7 @@ static inline BOOL timerInvalidated(NSTimer *t)
 {
   GSRunLoopCtxt	*context;
   GSIArray	watchers;
-  unsigned	i;
+  NSUInteger	i;
 
   context = NSMapGet(_contextMap, mode);
   if (context == nil)
@@ -424,8 +424,8 @@ static inline BOOL timerInvalidated(NSTimer *t)
   if (i % 1000 == 0 && i > context->maxWatchers)
     {
       context->maxWatchers = i;
-      NSLog(@"WARNING ... there are %u watchers scheduled in mode %@ of %@",
-	i, mode, self);
+      NSLog(@"WARNING ... there are %lu watchers scheduled in mode %@ of %@",
+	(unsigned long)i, mode, self);
     }
 }
 
@@ -436,7 +436,7 @@ static inline BOOL timerInvalidated(NSTimer *t)
   if (context != nil)
     {
       GSIArray	performers = context->performers;
-      unsigned	count = GSIArrayCount(performers);
+      NSUInteger	count = GSIArrayCount(performers);
 
       if (count > 0)
 	{
@@ -444,7 +444,7 @@ static inline BOOL timerInvalidated(NSTimer *t)
 	  NSMapEnumerator	enumerator;
 	  GSRunLoopCtxt		*context;
 	  void			*mode;
-	  unsigned		i;
+	  NSUInteger		i;
 
 	  /*
 	   * Copy the array - because we have to cancel the requests
@@ -464,7 +464,7 @@ static inline BOOL timerInvalidated(NSTimer *t)
 	      if (context != nil)
 		{
 		  GSIArray	performers = context->performers;
-		  unsigned	tmpCount = GSIArrayCount(performers);
+		  NSUInteger	tmpCount = GSIArrayCount(performers);
 
 		  while (tmpCount--)
 		    {
@@ -521,7 +521,7 @@ static inline BOOL timerInvalidated(NSTimer *t)
   if (context != nil)
     {
       GSIArray	watchers = context->watchers;
-      unsigned	i = GSIArrayCount(watchers);
+      NSUInteger	i = GSIArrayCount(watchers);
 
       while (i-- > 0)
 	{
@@ -582,7 +582,7 @@ static inline BOOL timerInvalidated(NSTimer *t)
   if (context != nil)
     {
       GSIArray	watchers = context->watchers;
-      unsigned	i = GSIArrayCount(watchers);
+      NSUInteger	i = GSIArrayCount(watchers);
 
       while (i-- > 0)
 	{
@@ -816,7 +816,7 @@ static inline BOOL timerInvalidated(NSTimer *t)
 {
   GSRunLoopCtxt	*context;
   GSIArray	timers;
-  unsigned      i;
+  NSUInteger      i;
 
   if ([timer isKindOfClass: [NSTimer class]] == NO
     || [timer isProxy] == YES)
@@ -871,8 +871,8 @@ static inline BOOL timerInvalidated(NSTimer *t)
   if (i % 1000 == 0 && i > context->maxTimers)
     {
       context->maxTimers = i;
-      NSLog(@"WARNING ... there are %u timers scheduled in mode %@ of %@",
-	i, mode, self);
+      NSLog(@"WARNING ... there are %lu timers scheduled in mode %@ of %@",
+	(unsigned long)i, mode, self);
     }
 }
 
@@ -962,8 +962,8 @@ updateTimer(NSTimer *t, NSDate *d, NSTimeInterval now)
 	  NSTimer		*t;
 	  NSTimeInterval	ti;
 	  NSTimeInterval	ei;
-          unsigned              c;
-          unsigned              i;
+          NSUInteger              c;
+          NSUInteger              i;
 
 	  ei = 0.0;	// Only needed to avoid compiler warning
 
@@ -1082,7 +1082,7 @@ updateTimer(NSTimer *t, NSDate *d, NSTimeInterval now)
       if (when == nil)
         {
 	  GSIArray		watchers = context->watchers;
-	  unsigned		i = GSIArrayCount(watchers);
+	  NSInteger		i = GSIArrayCount(watchers);
 
 	  while (i-- > 0)
 	    {
@@ -1346,7 +1346,7 @@ updateTimer(NSTimer *t, NSDate *d, NSTimeInterval now)
       if (context != nil)
 	{
 	  GSIArray	performers = context->performers;
-	  unsigned	count = GSIArrayCount(performers);
+	  NSUInteger	count = GSIArrayCount(performers);
 
 	  while (count--)
 	    {
@@ -1385,7 +1385,7 @@ updateTimer(NSTimer *t, NSDate *d, NSTimeInterval now)
       if (context != nil)
 	{
 	  GSIArray	performers = context->performers;
-	  unsigned	count = GSIArrayCount(performers);
+	  NSUInteger	count = GSIArrayCount(performers);
 
 	  while (count--)
 	    {
@@ -1428,7 +1428,7 @@ updateTimer(NSTimer *t, NSDate *d, NSTimeInterval now)
 		   order: (NSUInteger)order
 		   modes: (NSArray*)modes
 {
-  unsigned		count = [modes count];
+  NSUInteger		count = [modes count];
 
   if (count > 0)
     {
@@ -1442,7 +1442,7 @@ updateTimer(NSTimer *t, NSDate *d, NSTimeInterval now)
 
       if ([modes isProxy])
 	{
-	  unsigned	i;
+	  NSUInteger	i;
 
 	  for (i = 0; i < count; i++)
 	    {
@@ -1456,8 +1456,8 @@ updateTimer(NSTimer *t, NSDate *d, NSTimeInterval now)
       while (count-- > 0)
 	{
 	  NSString	*mode = array[count];
-	  unsigned	end;
-	  unsigned	i;
+	  NSUInteger	end;
+	  NSUInteger	i;
 	  GSRunLoopCtxt	*context;
 	  GSIArray	performers;
 
@@ -1491,8 +1491,8 @@ updateTimer(NSTimer *t, NSDate *d, NSTimeInterval now)
 	  if (i % 1000 == 0 && i > context->maxPerformers)
 	    {
 	      context->maxPerformers = i;
-	      NSLog(@"WARNING ... there are %u performers scheduled"
-		@" in mode %@ of %@", i, mode, self);
+	      NSLog(@"WARNING ... there are %lu performers scheduled"
+		@" in mode %@ of %@", (unsigned long)i, mode, self);
 	    }
 	}
       RELEASE(item);
diff --git a/Source/NSScanner.m b/Source/NSScanner.m
index fc28b60..633e17b 100644
--- a/Source/NSScanner.m
+++ b/Source/NSScanner.m
@@ -79,9 +79,9 @@ static NSStringEncoding internalEncoding = NSISOLatin1StringEncoding;
 
 static inline unichar myGetC(unsigned char c)
 {
-  unsigned int  size = 1;
-  unichar       u = 0;
-  unichar       *dst = &u;
+  NSUInteger  size = 1;
+  unichar     u = 0;
+  unichar     *dst = &u;
 
   GSToUnicode(&dst, &size, &c, 1, internalEncoding, 0, 0);
   return u;
@@ -252,8 +252,8 @@ typedef GSString	*ivars;
  */
 - (BOOL) isAtEnd
 {
-  unsigned int	save__scanLocation;
-  BOOL		ret;
+  NSUInteger  save__scanLocation;
+  BOOL        ret;
 
   if (_scanLocation >= myLength())
     return YES;
@@ -345,7 +345,7 @@ typedef GSString	*ivars;
  */
 - (BOOL) scanInt: (int*)value
 {
-  unsigned int saveScanLocation = _scanLocation;
+  NSUInteger saveScanLocation = _scanLocation;
 
   if (skipToNextField() && [self _scanInt: value])
     return YES;
@@ -361,10 +361,10 @@ typedef GSString	*ivars;
 		    radix: (NSUInteger)radix
 		gotDigits: (BOOL)gotDigits
 {
-  unsigned int	num = 0;
-  unsigned int	numLimit, digitLimit, digitValue;
-  BOOL		overflow = NO;
-  unsigned int	saveScanLocation = _scanLocation;
+  NSUInteger  num = 0;
+  NSUInteger  numLimit, digitLimit, digitValue;
+  BOOL        overflow = NO;
+  NSUInteger  saveScanLocation = _scanLocation;
 
   /* Set limits */
   numLimit = UINT_MAX / radix;
@@ -428,7 +428,7 @@ typedef GSString	*ivars;
       if (overflow)
 	*value = UINT_MAX;
       else
-	*value = num;
+	*value = (unsigned int) num;
     }
   return YES;
 }
@@ -448,9 +448,9 @@ typedef GSString	*ivars;
  */
 - (BOOL) scanRadixUnsignedInt: (unsigned int*)value
 {
-  unsigned int	radix;
-  BOOL		gotDigits = NO;
-  unsigned int	saveScanLocation = _scanLocation;
+  unsigned int  radix;
+  BOOL          gotDigits = NO;
+  NSUInteger    saveScanLocation = _scanLocation;
 
   /* Skip whitespace */
   if (!skipToNextField())
@@ -498,7 +498,7 @@ typedef GSString	*ivars;
  */
 - (BOOL) scanHexInt: (unsigned int*)value
 {
-  unsigned int saveScanLocation = _scanLocation;
+  NSUInteger saveScanLocation = _scanLocation;
 
   /* Skip whitespace */
   if (!skipToNextField())
@@ -554,7 +554,7 @@ typedef GSString	*ivars;
   BOOL				negative = NO;
   BOOL				overflow = NO;
   BOOL				got_digits = NO;
-  unsigned int			saveScanLocation = _scanLocation;
+  NSUInteger  saveScanLocation = _scanLocation;
 
   /* Skip whitespace */
   if (!skipToNextField())
@@ -652,13 +652,13 @@ typedef GSString	*ivars;
  */
 - (BOOL) scanDouble: (double *)value
 {
-  unichar	c = 0;
-  double	num = 0.0;
-  long int	exponent = 0;
-  BOOL		negative = NO;
-  BOOL		got_dot = NO;
-  BOOL		got_digit = NO;
-  unsigned int	saveScanLocation = _scanLocation;
+  unichar     c = 0;
+  double      num = 0.0;
+  long int    exponent = 0;
+  BOOL        negative = NO;
+  BOOL        got_dot = NO;
+  BOOL        got_digit = NO;
+  NSUInteger  saveScanLocation = _scanLocation;
 
   /* Skip whitespace */
   if (!skipToNextField())
@@ -724,7 +724,7 @@ typedef GSString	*ivars;
   /* Check for trailing exponent */
   if ((_scanLocation < myLength()) && ((c == 'e') || (c == 'E')))
     {
-      unsigned int	expScanLocation = _scanLocation;
+      NSUInteger expScanLocation = _scanLocation;
       int expval;
       
 
@@ -796,12 +796,12 @@ typedef GSString	*ivars;
 - (BOOL) scanCharactersFromSet: (NSCharacterSet *)aSet
 		    intoString: (NSString **)value
 {
-  unsigned int	saveScanLocation = _scanLocation;
+  NSUInteger saveScanLocation = _scanLocation;
 
   if (skipToNextField())
     {
-      unsigned int	start;
-      BOOL		(*memImp)(NSCharacterSet*, SEL, unichar);
+      NSUInteger start;
+      BOOL (*memImp)(NSCharacterSet*, SEL, unichar);
 
       if (aSet == _charactersToBeSkipped)
 	memImp = _skipImp;
@@ -855,8 +855,8 @@ typedef GSString	*ivars;
 - (BOOL) scanUpToCharactersFromSet: (NSCharacterSet *)aSet
 		        intoString: (NSString **)value
 {
-  unsigned int	saveScanLocation = _scanLocation;
-  unsigned int	start;
+  NSUInteger saveScanLocation = _scanLocation;
+  NSUInteger start;
   BOOL		(*memImp)(NSCharacterSet*, SEL, unichar);
 
   if (!skipToNextField())
@@ -911,8 +911,8 @@ typedef GSString	*ivars;
  */
 - (BOOL) scanString: (NSString *)string intoString: (NSString **)value
 {
-  NSRange	range;
-  unsigned int	saveScanLocation = _scanLocation;
+  NSRange     range;
+  NSUInteger  saveScanLocation = _scanLocation;
 
   if (skipToNextField() == NO)
     {
@@ -967,9 +967,9 @@ typedef GSString	*ivars;
 - (BOOL) scanUpToString: (NSString *)string
 	     intoString: (NSString **)value
 {
-  NSRange	range;
-  NSRange	found;
-  unsigned int	saveScanLocation = _scanLocation;
+  NSRange     range;
+  NSRange     found;
+  NSUInteger  saveScanLocation = _scanLocation;
 
   if (skipToNextField() == NO)
     {
@@ -1154,15 +1154,15 @@ typedef GSString	*ivars;
 /*
  * Some utilities
  */
-BOOL
-GSScanInt(unichar *buf, unsigned length, int *result)
+static BOOL
+GSScanInt(unichar *buf, NSUInteger length, int *result)
 {
   unsigned int num = 0;
   const unsigned int limit = UINT_MAX / 10;
   BOOL negative = NO;
   BOOL overflow = NO;
   BOOL got_digits = NO;
-  unsigned int pos = 0;
+  NSUInteger pos = 0;
 
   /* Check for sign */
   if (pos < length)
@@ -1229,7 +1229,7 @@ static double powersOf10[] = {
  * No value is returned in result if it is a null pointer.
  */
 BOOL
-GSScanDouble(unichar *buf, unsigned length, double *result)
+GSScanDouble(unichar *buf, NSUInteger length, double *result)
 {
   unichar	c = 0;
   char          mantissa[20];
@@ -1240,7 +1240,7 @@ GSScanDouble(unichar *buf, unsigned length, double *result)
   int	        exponent = 0;
   BOOL	        negativeMantissa = NO;
   BOOL		negativeExponent = NO;
-  unsigned	pos = 0;
+  NSUInteger	pos = 0;
   int           mantissaLength;
   int           dotPos = -1;
   int           hi = 0;
diff --git a/Source/NSSerializer.m b/Source/NSSerializer.m
index cac253f..f343529 100644
--- a/Source/NSSerializer.m
+++ b/Source/NSSerializer.m
@@ -121,11 +121,11 @@ static Class	NumberClass = 0;
 
 typedef struct {
   NSMutableData	*data;
-  void		(*appImp)(NSData*,SEL,const void*,unsigned);
+  void		(*appImp)(NSData*,SEL,const void*,NSUInteger);
   void*		(*datImp)(NSMutableData*,SEL);		// Bytes pointer.
   unsigned int	(*lenImp)(NSData*,SEL);			// Length of data.
-  void		(*serImp)(NSMutableData*,SEL,int);	// Serialize integer.
-  void		(*setImp)(NSMutableData*,SEL,unsigned);	// Set length of data.
+  void		(*serImp)(NSMutableData*,SEL,NSUInteger);	// Serialize integer.
+  void		(*setImp)(NSMutableData*,SEL,NSUInteger);	// Set length of data.
   unsigned	count;			// String counter.
   GSIMapTable_t	map;			// For uniquing.
   BOOL		shouldUnique;		// Do we do uniquing?
@@ -144,15 +144,15 @@ initSerializerInfo(_NSSerializerInfo* info, NSMutableData *d, BOOL u)
 
   c = object_getClass(d);
   info->data = d;
-  info->appImp = (void (*)(NSData*,SEL,const void*,unsigned))
+  info->appImp = (void (*)(NSData*,SEL,const void*,NSUInteger))
     class_getMethodImplementation(c, appSel);
   info->datImp = (void* (*)(NSMutableData*,SEL))
     class_getMethodImplementation(c, datSel);
   info->lenImp = (unsigned int (*)(NSData*,SEL))
     class_getMethodImplementation(c, lenSel);
-  info->serImp = (void (*)(NSMutableData*,SEL,int))
+  info->serImp = (void (*)(NSMutableData*,SEL,NSUInteger))
     class_getMethodImplementation(c, serSel);
-  info->setImp = (void (*)(NSMutableData*,SEL,unsigned))
+  info->setImp = (void (*)(NSMutableData*,SEL,NSUInteger))
     class_getMethodImplementation(c, setSel);
   info->shouldUnique = u;
   (*info->appImp)(d, appSel, &info->shouldUnique, 1);
@@ -199,8 +199,8 @@ serializeToInfo(id object, _NSSerializerInfo* info)
 	node = 0;
       if (node == 0)
 	{
-	  unsigned	slen;
-	  unsigned	dlen;
+	  NSUInteger slen;
+	  NSUInteger dlen;
 
 	  slen = [object length] + 1;
 	  (*info->appImp)(info->data, appSel, &st_cstring, 1);
@@ -230,8 +230,8 @@ serializeToInfo(id object, _NSSerializerInfo* info)
 	node = 0;
       if (node == 0)
 	{
-	  unsigned	slen;
-	  unsigned	dlen;
+	  NSUInteger	slen;
+	  NSUInteger	dlen;
 
 	  slen = [object length];
 	  (*info->appImp)(info->data, appSel, &st_string, 1);
@@ -266,7 +266,7 @@ serializeToInfo(id object, _NSSerializerInfo* info)
     }
   else if (GSObjCIsKindOf(c, ArrayClass))
     {
-      unsigned int count;
+      NSUInteger count;
 
       if ([object isKindOfClass: MutableArrayClass])
         (*info->appImp)(info->data, appSel, &st_marray, 1);
@@ -367,7 +367,7 @@ static BOOL	shouldBeCompact = NO;
       appSel = @selector(appendBytes:length:);
       datSel = @selector(mutableBytes);
       lenSel = @selector(length);
-      serSel = @selector(serializeInt:);
+      serSel = @selector(serializeAlignedBytesLength:);
       setSel = @selector(setLength:);
       ArrayClass = [NSArray class];
       MutableArrayClass = [NSMutableArray class];
@@ -449,7 +449,7 @@ static Class	MDCls = 0;	/* Mutable Dictionary	*/
 
 typedef struct {
   NSData	*data;
-  unsigned	*cursor;
+  NSUInteger	*cursor;
   BOOL		mutable;
   BOOL		didUnique;
   void		(*debImp)();
@@ -471,7 +471,7 @@ static IMP maAddImp;
 static IMP mdSetImp;
 
 static BOOL
-initDeserializerInfo(_NSDeserializerInfo* info, NSData *d, unsigned *c, BOOL m)
+initDeserializerInfo(_NSDeserializerInfo* info, NSData *d, NSUInteger *c, BOOL m)
 {
   unsigned char	u;
 
@@ -490,7 +490,7 @@ initDeserializerInfo(_NSDeserializerInfo* info, NSData *d, unsigned *c, BOOL m)
       if (u == 'G')
 	{
 	  const unsigned char	*b = [d bytes];
-	  unsigned int		l = [d length];
+	  NSUInteger		l = [d length];
 
 	  if (*c + 11 < l && memcmp(&b[*c-1], "GNUstepSer", 10) == 0)
 	    {
@@ -649,7 +649,7 @@ deserializeFromInfo(_NSDeserializerInfo* info)
 		}
 	      if (code != ST_MARRAY && info->mutable == NO)
 		{
-		  [a makeImmutableCopyOnFail: NO];
+		  a = [a makeImmutable];
 		}
 	    }
 	  return a;
@@ -702,7 +702,7 @@ deserializeFromInfo(_NSDeserializerInfo* info)
 		}
 	      if (code != ST_MDICT && info->mutable == NO)
 		{
-		  [d makeImmutableCopyOnFail: NO];
+		  d = [d makeImmutable];
 		}
 	    }
 	  return d;
@@ -764,13 +764,13 @@ deserializeFromInfo(_NSDeserializerInfo* info)
   id			plist;
 }
 + (_NSDeserializerProxy*) proxyWithData: (NSData*)d
-			       atCursor: (unsigned int*)c
+			       atCursor: (NSUInteger*)c
 				mutable: (BOOL)m;
 @end
 
 @implementation	_NSDeserializerProxy
 + (_NSDeserializerProxy*) proxyWithData: (NSData*)d
-			       atCursor: (unsigned int*)c
+			       atCursor: (NSUInteger*)c
 				mutable: (BOOL)m
 {
   _NSDeserializerProxy	*proxy;
@@ -853,7 +853,7 @@ deserializeFromInfo(_NSDeserializerInfo* info)
  * </p>
  */
 + (id) deserializePropertyListFromData: (NSData*)data
-                              atCursor: (unsigned int*)cursor
+                              atCursor: (NSUInteger*)cursor
                      mutableContainers: (BOOL)flag
 {
   _NSDeserializerInfo	info;
@@ -888,7 +888,7 @@ deserializeFromInfo(_NSDeserializerInfo* info)
                      mutableContainers: (BOOL)flag
 {
   _NSDeserializerInfo	info;
-  unsigned int	cursor = 0;
+  NSUInteger	cursor = 0;
   id		o;
 
   if (data == nil || [data isKindOfClass: [NSData class]] == NO)
@@ -923,8 +923,8 @@ deserializeFromInfo(_NSDeserializerInfo* info)
  * </p>
  */
 + (id) deserializePropertyListLazilyFromData: (NSData*)data
-                                    atCursor: (unsigned*)cursor
-                                      length: (unsigned)length
+                                    atCursor: (NSUInteger*)cursor
+                                      length: (NSUInteger)length
                            mutableContainers: (BOOL)flag
 {
   if (data == nil || [data isKindOfClass: [NSData class]] == NO)
diff --git a/Source/NSSet.m b/Source/NSSet.m
index 67ee55a..e508768 100644
--- a/Source/NSSet.m
+++ b/Source/NSSet.m
@@ -196,11 +196,11 @@ static Class NSMutableSet_concrete_class;
     }
   else
     {
-      unsigned		count = [self count];
+      NSUInteger		count = [self count];
       NSEnumerator	*e = [self objectEnumerator];
       id		o;
 
-      [aCoder encodeValueOfObjCType: @encode(unsigned) at: &count];
+      [aCoder encodeValueOfObjCType: @encode(NSUInteger) at: &count];
       while ((o = [e nextObject]) != nil)
 	{
 	  [aCoder encodeValueOfObjCType: @encode(id) at: &o];
@@ -369,7 +369,7 @@ static Class NSMutableSet_concrete_class;
  */
 - (id) initWithArray: (NSArray*)other
 {
-  unsigned	count = [other count];
+  NSUInteger	count = [other count];
 
   if (count == 0)
     {
@@ -381,7 +381,7 @@ static Class NSMutableSet_concrete_class;
 
       if ([other isProxy])
 	{
-	  unsigned	i;
+	  NSUInteger	i;
 
 	  for (i = 0; i < count; i++)
 	    {
@@ -404,9 +404,9 @@ static Class NSMutableSet_concrete_class;
  */
 - (id) initWithSet: (NSSet*)other copyItems: (BOOL)flag
 {
-  unsigned	c = [other count];
+  NSUInteger	c = [other count];
   id		o, e = [other objectEnumerator];
-  unsigned	i = 0;
+  NSUInteger	i = 0;
   GS_BEGINIDBUF(os, c);
 
   while ((o = [e nextObject]))
@@ -441,8 +441,8 @@ static Class NSMutableSet_concrete_class;
 - (NSArray*) allObjects
 {
   id		e = [self objectEnumerator];
-  unsigned	i;
-  unsigned	c = [self count];
+  NSUInteger	i;
+  NSUInteger	c = [self count];
   NSArray	*result = nil;
   GS_BEGINIDBUF(k, c);
 
@@ -639,7 +639,7 @@ static Class NSMutableSet_concrete_class;
         {
           if ([path isEqualToString: @"@count"] == YES)
             {
-              result = [NSNumber numberWithUnsignedInt: [self count]];
+              result = [NSNumber numberWithUnsignedInteger: [self count]];
             }
           else
             {
@@ -650,11 +650,11 @@ static Class NSMutableSet_concrete_class;
         {
           NSString      *op = [path substringToIndex: r.location];
           NSString      *rem = [path substringFromIndex: NSMaxRange(r)];
-          unsigned      count = [self count];
+          NSUInteger      count = [self count];
 
           if ([op isEqualToString: @"@count"] == YES)
             {
-              result = [NSNumber numberWithUnsignedInt: count];
+              result = [NSNumber numberWithUnsignedInteger: count];
             }
           else if ([op isEqualToString: @"@avg"] == YES)
             {
@@ -792,13 +792,13 @@ static Class NSMutableSet_concrete_class;
                   NSEnumerator  *e = [self objectEnumerator];
                   id            o;
 
-                  result = [GSMutableArray array];
+                  result = [[GSMutableArray alloc] init];
                   while ((o = [e nextObject]) != nil)
                     {
                       o = [o valueForKeyPath: rem];
                       [result addObjectsFromArray: o];
                     }
-                  [result makeImmutableCopyOnFail: NO];
+                  result = [[result makeImmutable] autorelease];
                 }
               else
                 {
@@ -812,13 +812,13 @@ static Class NSMutableSet_concrete_class;
                   NSEnumerator  *e = [self objectEnumerator];
                   id            o;
 
-                  result = [GSMutableArray array];
+                  result = [[GSMutableArray alloc] init];
                   while ((o = [e nextObject]) != nil)
                     {
                       o = [o valueForKeyPath: rem];
                       [result addObject: o];
                     }
-                  [result makeImmutableCopyOnFail: NO];
+                  result = [[result makeImmutable] autorelease];
                 }
               else
                 {
@@ -832,13 +832,13 @@ static Class NSMutableSet_concrete_class;
                   NSEnumerator  *e = [self objectEnumerator];
                   id            o;
 
-                  result = [GSMutableArray array];
+                  result = [[GSMutableArray alloc] init];
                   while ((o = [e nextObject]) != nil)
                     {
                       o = [o valueForKeyPath: rem];
                       [result addObjectsFromArray: [o allObjects]];
                     }
-                  [result makeImmutableCopyOnFail: NO];
+                  result = [[result makeImmutable] autorelease];
                 }
               else
                 {
@@ -895,7 +895,7 @@ static Class NSMutableSet_concrete_class;
   id<NSFastEnumeration> enumerator = self;
   NSMutableSet          *resultSet;
 
-  resultSet = [NSMutableSet setWithCapacity: [self count]];
+  resultSet = [[NSMutableSet alloc] initWithCapacity: [self count]];
     
   FOR_IN (id, obj, enumerator)
     {
@@ -912,7 +912,7 @@ static Class NSMutableSet_concrete_class;
     }
   END_FOR_IN(enumerator)
     
-  return [resultSet makeImmutableCopyOnFail: NO];
+  return [[resultSet makeImmutable] autorelease];
 }
 
 /** Return a set formed by adding anObject to the receiver.
@@ -1059,7 +1059,7 @@ static Class NSMutableSet_concrete_class;
  */
 - (void) addObjectsFromArray: (NSArray*)array
 {
-  unsigned	i, c = [array count];
+  NSUInteger	i, c = [array count];
 
   for (i = 0; i < c; i++)
     {
diff --git a/Source/NSSocketPort.m b/Source/NSSocketPort.m
index 20d4152..09eda71 100644
--- a/Source/NSSocketPort.m
+++ b/Source/NSSocketPort.m
@@ -251,6 +251,13 @@ typedef enum {
 @end
 
 
+NS_INLINE uint32_t
+SwapHostLengthToBig(NSUInteger length)
+{
+    NSCParameterAssert(length <= UINT32_MAX);
+    return GSSwapHostI32ToBig((uint32_t)length);
+}
+
 /*
  * Utility functions for encoding and decoding ports.
  */
@@ -309,7 +316,7 @@ newDataWithEncodedPort(NSSocketPort *port)
   GSPortItemHeader	*pih;
   GSPortInfo		*pi;
   NSMutableData		*data;
-  unsigned		plen;
+  NSUInteger		plen;
   NSString		*addr;
   uint16_t		pnum;
 
@@ -347,7 +354,7 @@ newDataWithEncodedPort(NSSocketPort *port)
   data = [[NSMutableData alloc] initWithLength: sizeof(GSPortItemHeader)+plen];
   pih = (GSPortItemHeader*)[data mutableBytes];
   pih->type = GSSwapHostI32ToBig(GSP_PORT);
-  pih->length = GSSwapHostI32ToBig(plen);
+  pih->length = SwapHostLengthToBig(plen);
   pi = (GSPortInfo*)&pih[1];
   pi->num = GSSwapHostI16ToBig(pnum);
   [addr getCString: pi->addr];
@@ -465,7 +472,7 @@ static Class	runLoopClass;
   NSRunLoop		*l;
 
   M_LOCK(myLock);
-  NSDebugMLLog(@"GSTcpHandle", @"Connecting on 0x%x before %@", self, when);
+  NSDebugMLLog(@"GSTcpHandle", @"Connecting on 0x%lx before %@", (unsigned long)self, when);
   if (state != GS_H_UNCON)
     {
       BOOL	result;
@@ -680,8 +687,7 @@ static Class	runLoopClass;
 
 - (NSString*) description
 {
-  return [NSString stringWithFormat: @"Handle (%d) to %s:%d",
-    desc, GSPrivateSockaddrName(&sockAddr)];
+  return [NSString stringWithFormat: @"Handle (%d) to %@", desc, GSPrivateSockaddrName(&sockAddr)];
 }
 
 - (int) descriptor
@@ -733,7 +739,7 @@ static Class	runLoopClass;
 		 forMode: nil
 		     all: YES];
 #endif
-	  NSDebugMLLog(@"GSTcpHandle", @"invalidated 0x%x", self);
+	  NSDebugMLLog(@"GSTcpHandle", @"invalidated 0x%lx", (unsigned long)self);
 	  [[self recvPort] removeHandle: self];
 	  [[self sendPort] removeHandle: self];
 #if	defined(__MINGW__)
@@ -760,9 +766,9 @@ static Class	runLoopClass;
 
 - (void) receivedEventRead
 {
-  unsigned	want;
+  NSUInteger	want;
   void	*bytes;
-  int	res;
+  ssize_t	res;
 
   /*
    * Make sure we have a buffer big enough to hold all the data we are
@@ -799,7 +805,7 @@ static Class	runLoopClass;
     {
       if (res == 0)
         {
-          NSDebugMLLog(@"GSTcpHandle", @"read eof on 0x%x", self);
+          NSDebugMLLog(@"GSTcpHandle", @"read eof on 0x%lx", (unsigned long)self);
           [self invalidate];
           return;
         }
@@ -817,7 +823,7 @@ static Class	runLoopClass;
 	}
 	res = 0;	/* Interrupted - continue	*/
     }
-  NSDebugMLLog(@"GSTcpHandle", @"read %d bytes on 0x%x", res, self);
+  NSDebugMLLog(@"GSTcpHandle", @"read %zd bytes on 0x%lx", res, (unsigned long)self);
   rLength += res;
 
   while (valid == YES && rLength >= rWant)
@@ -1068,7 +1074,7 @@ static Class	runLoopClass;
           rId = 0;
           DESTROY(rItems);
           NSDebugMLLog(@"GSTcpHandle",
-        	@"got message %@ on 0x%x", pm, self);
+        	@"got message %@ on 0x%lx", pm, (unsigned long)self);
           IF_NO_GC(RETAIN(rp);)
           M_UNLOCK(myLock);
           NS_DURING
@@ -1112,12 +1118,12 @@ static Class	runLoopClass;
         {
           NSData	*d = newDataWithEncodedPort([self recvPort]);
 
-          len = send(desc, [d bytes], [d length], 0);
-          if (len == (int)[d length])
+          ssize_t len = send(desc, [d bytes], [d length], 0);
+          if (len == [d length])
             {
 	      ASSIGN(defaultAddress, GSPrivateSockaddrHost(&sockAddr));
 	      NSDebugMLLog(@"GSTcpHandle",
-	        @"wrote %d bytes on 0x%x", len, self);
+	        @"wrote %zd bytes on 0x%lx", len, (unsigned long)self);
 	      state = GS_H_CONNECTED;
 	    }
 	  else
@@ -1131,8 +1137,8 @@ static Class	runLoopClass;
     }
   else
     {
-      int		res;
-      unsigned	l;
+      ssize_t		res;
+      NSUInteger	l;
       const void	*b;
 
       if (wData == nil)
@@ -1176,7 +1182,7 @@ static Class	runLoopClass;
       else
         {
           NSDebugMLLog(@"GSTcpHandle",
-            @"wrote %d bytes on 0x%x", res, self);
+            @"wrote %zd bytes on 0x%lx", res, (unsigned long)self);
 	  wLength += res;
           if (wLength == l)
             {
@@ -1201,7 +1207,7 @@ static Class	runLoopClass;
 	           * message completed - remove from list.
 	           */
 	          NSDebugMLLog(@"GSTcpHandle",
-	            @"completed 0x%x on 0x%x", components, self);
+	            @"completed 0x%lx on 0x%lx", (unsigned long)components, (unsigned long)self);
 		  wData = nil;
 	          wItem = 0;
 	          [wMsgs removeObjectAtIndex: 0];
@@ -1346,8 +1352,8 @@ static Class	runLoopClass;
 
   NSAssert([components count] > 0, NSInternalInconsistencyException);
   NSDebugMLLog(@"GSTcpHandle",
-    @"Sending message 0x%x %@ on 0x%x(%d) before %@",
-    components, components, self, desc, when);
+    @"Sending message 0x%lx %@ on 0x%lx(%d) before %@",
+    (unsigned long)components, components, (unsigned long)self, desc, when);
   M_LOCK(myLock);
   [wMsgs addObject: components];
 
@@ -1440,7 +1446,7 @@ static Class	runLoopClass;
     }
   M_UNLOCK(myLock);
   NSDebugMLLog(@"GSTcpHandle",
-    @"Message send 0x%x on 0x%x status %d", components, self, sent);
+    @"Message send 0x%lx on 0x%lx status %d", (unsigned long)components, (unsigned long)self, sent);
   RELEASE(self);
   return sent;
 }
@@ -1796,7 +1802,7 @@ static Class		tcpPortClass;
 
 - (void) finalize
 {
-  NSDebugMLLog(@"NSPort", @"NSSocketPort 0x%x finalized", self);
+  NSDebugMLLog(@"NSPort", @"NSSocketPort 0x%lx finalized", (unsigned long)self);
   [self invalidate];
   if (handles != 0)
     {
@@ -2011,12 +2017,12 @@ static Class		tcpPortClass;
 
   if (d == nil)
     {
-      NSDebugMLLog(@"NSPort", @"No delegate to handle incoming message", 0);
+      NSDebugMLLog(@"NSPort", @"No delegate to handle incoming message");
       return;
     }
   if ([d respondsToSelector: @selector(handlePortMessage:)] == NO)
     {
-      NSDebugMLLog(@"NSPort", @"delegate doesn't handle messages", 0);
+      NSDebugMLLog(@"NSPort", @"delegate doesn't handle messages");
       return;
     }
   [d handlePortMessage: m];
@@ -2050,7 +2056,7 @@ static Class		tcpPortClass;
 	{
 	  NSMapTable	*thePorts;
 	  NSArray	*handleArray;
-	  unsigned	i;
+	  NSUInteger	i;
 
 	  M_LOCK(tcpPortLock);
 	  thePorts = NSMapGet(tcpPortMap, (void*)(uintptr_t)portNum);
@@ -2132,8 +2138,8 @@ static Class		tcpPortClass;
 #endif
   GSTcpHandle	*handle;
 
-  NSDebugMLLog(@"NSPort", @"received %s event %p on 0x%x",
-    type == ET_RPORT ? "read" : "write", extra, self);
+  NSDebugMLLog(@"NSPort", @"received %s event %p on 0x%lx",
+    type == ET_RPORT ? "read" : "write", extra, (unsigned long)self);
 
 #if	defined(__MINGW__)
   if (event == eventListener)
@@ -2283,14 +2289,14 @@ static Class		tcpPortClass;
 }
 
 - (BOOL) sendBeforeDate: (NSDate*)when
-		  msgid: (NSInteger)msgId
+                  msgid: (NSInteger)msgId
              components: (NSMutableArray*)components
                    from: (NSPort*)receivingPort
                reserved: (NSUInteger)length
 {
   BOOL		sent = NO;
   GSTcpHandle	*h;
-  unsigned	rl;
+  NSUInteger	rl;
 
   if ([self isValid] == NO)
     {
@@ -2322,12 +2328,12 @@ static Class		tcpPortClass;
   if (h != nil)
     {
       NSMutableData	*header;
-      unsigned		hLength;
-      unsigned		l;
+      NSUInteger		hLength;
+      NSUInteger		l;
       GSPortItemHeader	*pih;
       GSPortMsgHeader	*pmh;
-      unsigned		c = [components count];
-      unsigned		i;
+      NSUInteger		c = [components count];
+      NSUInteger		i;
       BOOL		pack = YES;
 
       /*
@@ -2351,7 +2357,7 @@ static Class		tcpPortClass;
       l = hLength - sizeof(GSPortItemHeader);
       pih = (GSPortItemHeader*)[header mutableBytes];
       pih->type = GSSwapHostI32ToBig(GSP_HEAD);
-      pih->length = GSSwapHostI32ToBig(l);
+      pih->length = SwapHostLengthToBig(l);
 
       /*
        * The message header contains the message Id and the original count
@@ -2359,8 +2365,8 @@ static Class		tcpPortClass;
        * simply to hold the header).
        */
       pmh = (GSPortMsgHeader*)&pih[1];
-      pmh->mId = GSSwapHostI32ToBig(msgId);
-      pmh->nItems = GSSwapHostI32ToBig(c);
+      pmh->mId = SwapHostLengthToBig(msgId);
+      pmh->nItems = SwapHostLengthToBig(c);
 
       /*
        * Now insert item header information as required.
@@ -2376,8 +2382,8 @@ static Class		tcpPortClass;
 	  if ([o isKindOfClass: [NSData class]])
 	    {
 	      GSPortItemHeader	*pih;
-	      unsigned		h = sizeof(GSPortItemHeader);
-	      unsigned		l = [o length];
+	      NSUInteger		h = sizeof(GSPortItemHeader);
+	      NSUInteger		l = [o length];
 	      void		*b;
 
 	      if (pack == YES && hLength + l + h <= NETBLOCK)
@@ -2409,7 +2415,7 @@ static Class		tcpPortClass;
 #else
 		  pih = (GSPortItemHeader*)b;
 		  pih->type = GSSwapHostI32ToBig(GSP_DATA);
-		  pih->length = GSSwapHostI32ToBig(l);
+		  pih->length = SwapHostLengthToBig(l);
 #endif
 		  memcpy(b+h, [o bytes], l);
 		  [components removeObjectAtIndex: i--];
@@ -2426,7 +2432,7 @@ static Class		tcpPortClass;
 		  pih = (GSPortItemHeader*)b;
 		  memcpy(b+h, [o bytes], l);
 		  pih->type = GSSwapHostI32ToBig(GSP_DATA);
-		  pih->length = GSSwapHostI32ToBig(l);
+		  pih->length = SwapHostLengthToBig(l);
 		  [components replaceObjectAtIndex: i
 					withObject: d];
 		  RELEASE(d);
@@ -2435,7 +2441,7 @@ static Class		tcpPortClass;
 	  else if ([o isKindOfClass: tcpPortClass])
 	    {
 	      NSData	*d = newDataWithEncodedPort(o);
-	      unsigned	dLength = [d length];
+	      NSUInteger	dLength = [d length];
 
 	      if (pack == YES && hLength + dLength <= NETBLOCK)
 		{
diff --git a/Source/NSSocketPortNameServer.m b/Source/NSSocketPortNameServer.m
index c9e3016..51cad0c 100644
--- a/Source/NSSocketPortNameServer.m
+++ b/Source/NSSocketPortNameServer.m
@@ -611,9 +611,9 @@ typedef enum {
   NSRunLoop		*loop = [NSRunLoop currentRunLoop];
   struct in_addr	singleServer;
   struct in_addr	*svrs = &singleServer;
-  unsigned		numSvrs = 1;
-  unsigned		count;
-  unsigned		len;
+  NSUInteger		numSvrs = 1;
+  NSUInteger		count;
+  NSUInteger		len;
   NSMutableArray	*array;
   NSDate		*limit;
 
@@ -727,7 +727,7 @@ typedef enum {
   [serverLock lock];
   NS_DURING
     {
-      unsigned	i;
+      NSUInteger	i;
 
       *port = 0;
       count = 0;
@@ -872,7 +872,7 @@ typedef enum {
 {
   NSRunLoop	*loop = [NSRunLoop currentRunLoop];
   GSPortCom	*com = nil;
-  unsigned	len;
+  NSUInteger	len;
   NSDate	*limit;
 
   if (name == nil)
@@ -1054,7 +1054,7 @@ typedef enum {
 {
   NSRunLoop	*loop = [NSRunLoop currentRunLoop];
   GSPortCom	*com = nil;
-  unsigned	len;
+  NSUInteger	len;
   NSDate	*limit = [NSDate dateWithTimeIntervalSinceNow: timeout];
   BOOL		val = NO;
 
diff --git a/Source/NSSortDescriptor.m b/Source/NSSortDescriptor.m
index e01ba71..217014c 100644
--- a/Source/NSSortDescriptor.m
+++ b/Source/NSSortDescriptor.m
@@ -38,20 +38,6 @@
 
 static BOOL     initialized = NO;
 
-#ifdef  __clang__
-#pragma clang diagnostic ignored "-Wreceiver-forward-class"
-#endif
-
-#if     GS_USE_TIMSORT
-@class  GSTimSortDescriptor;
-#endif
-#if     GS_USE_QUICKSORT
-@class  GSQuickSortPlaceHolder;
-#endif
-#if     GS_USE_SHELLSORT
-@class  GSShellSortPlaceHolder;
-#endif
-
 @implementation NSSortDescriptor
 
 + (void) initialize
@@ -59,13 +45,13 @@ static BOOL     initialized = NO;
   if (NO == initialized)
     {
 #if     GS_USE_TIMSORT
-      [GSTimSortDescriptor class];
+      [NSClassFromString(@"GSTimSortDescriptor") class];
 #endif
 #if     GS_USE_QUICKSORT
-      [GSQuickSortPlaceHolder class];
+      [NSClassFromString(@"GSQuickSortPlaceHolder") class];
 #endif
 #if     GS_USE_SHELLSORT
-      [GSShellSortPlaceHolder class];
+      [NSClassFromString(@"GSShellSortPlaceHolder") class];
 #endif
       initialized = YES;
     }
@@ -131,13 +117,12 @@ static BOOL     initialized = NO;
          ascending: (BOOL) ascending
           selector: (SEL) selector
 {
-  if ([self init])
+  if (self = [self init])
     {
       if (key == nil)
         {
           [NSException raise: NSInvalidArgumentException
-                      format: _(@"Passed nil key when initializing "
-            @"an NSSortDescriptor.")];
+                      format: @"%@", _(@"Passed nil key when initializing a NSSortDescriptor")];
         }
       if (selector == NULL)
         {
@@ -156,6 +141,19 @@ static BOOL     initialized = NO;
     }
 }
 
++ (id) sortDescriptorWithKey: (NSString *)key
+                   ascending: (BOOL)ascending
+{
+  return AUTORELEASE([[self alloc] initWithKey:key ascending:ascending]);
+}
+
++ (id) sortDescriptorWithKey: (NSString *)key
+                   ascending: (BOOL)ascending
+                    selector: (SEL)selector
+{
+  return AUTORELEASE([[self alloc] initWithKey:key ascending:ascending selector:selector]);
+}
+
 - (BOOL) isEqual: (id)other
 {
   if (other == self)
@@ -333,11 +331,11 @@ GSSortUnstableConcurrent(id* buffer, NSRange range, id descriptorOrComparator,
 
 - (NSArray *) sortedArrayUsingDescriptors: (NSArray *) sortDescriptors
 {
-  NSMutableArray *sortedArray = [GSMutableArray arrayWithArray: self];
+  NSMutableArray *sortedArray = [[GSMutableArray alloc] initWithArray: self];
 
   [sortedArray sortUsingDescriptors: sortDescriptors];
 
-  return [sortedArray makeImmutableCopyOnFail: NO];
+  return [[sortedArray makeImmutable] autorelease];
 }
 
 @end
@@ -348,19 +346,19 @@ GSSortUnstableConcurrent(id* buffer, NSRange range, id descriptorOrComparator,
  */
 static void
 SortRange(id *objects, NSRange range, id *descriptors,
-  unsigned numDescriptors)
+  NSUInteger numDescriptors)
 {
   NSSortDescriptor	*sd = (NSSortDescriptor*)descriptors[0];
 
   GSSortUnstable(objects, range, sd, GSComparisonTypeSortDescriptor, NULL);
   if (numDescriptors > 1)
     {
-      unsigned	start = range.location;
-      unsigned	finish = NSMaxRange(range);
+      NSUInteger	start = range.location;
+      NSUInteger	finish = NSMaxRange(range);
 
       while (start < finish)
 	{
-	  unsigned	pos = start + 1;
+	  NSUInteger	pos = start + 1;
 
 	  /* Find next range of adjacent objects.
 	   */
@@ -387,8 +385,8 @@ SortRange(id *objects, NSRange range, id *descriptors,
 
 - (void) sortUsingDescriptors: (NSArray *)sortDescriptors
 {
-  unsigned	count = [self count];
-  unsigned	numDescriptors = [sortDescriptors count];
+  NSUInteger	count = [self count];
+  NSUInteger	numDescriptors = [sortDescriptors count];
 
   if (count > 1 && numDescriptors > 0)
     {
@@ -399,7 +397,7 @@ SortRange(id *objects, NSRange range, id *descriptors,
       [self getObjects: objects];
       if ([sortDescriptors isProxy])
 	{
-	  unsigned	i;
+	  NSUInteger	i;
 
 	  for (i = 0; i < numDescriptors; i++)
 	    {
@@ -424,7 +422,7 @@ SortRange(id *objects, NSRange range, id *descriptors,
 
 - (void) sortUsingDescriptors: (NSArray *)sortDescriptors
 {
-  unsigned	dCount = [sortDescriptors count];
+  NSUInteger	dCount = [sortDescriptors count];
 
   if (_count > 1 && dCount > 0)
     {
@@ -432,7 +430,7 @@ SortRange(id *objects, NSRange range, id *descriptors,
 
       if ([sortDescriptors isProxy])
 	{
-	  unsigned	i;
+	  NSUInteger	i;
 
 	  for (i = 0; i < dCount; i++)
 	    {
diff --git a/Source/NSSpellServer.m b/Source/NSSpellServer.m
index 6bcbe4e..e111373 100644
--- a/Source/NSSpellServer.m
+++ b/Source/NSSpellServer.m
@@ -50,6 +50,10 @@ static NSConnection *spellServerConnection = nil;
 static NSString *GNU_UserDictionariesDir = @"Dictionaries";
 
 // Function to create name for spell server....
+// todo: move into some protected header
+NSString*
+GSSpellServerName(NSString *vendor, NSString *language);
+
 NSString*
 GSSpellServerName(NSString *vendor, NSString *language)
 {
diff --git a/Source/NSString.m b/Source/NSString.m
index 1bad340..9441627 100644
--- a/Source/NSString.m
+++ b/Source/NSString.m
@@ -110,8 +110,6 @@
 
 #import "GSPrivate.h"
 
-extern BOOL GSScanDouble(unichar*, unsigned, double*);
-
 @class	GSString;
 @class	GSMutableString;
 @class	GSPlaceholderString;
@@ -389,9 +387,9 @@ pathSepString()
  * 2. On windows, a root consisting of a single path separator indicates
  * a drive-relative path with no drive ... so the path is relative.
  */
-static unsigned rootOf(NSString *s, unsigned l)
+static NSUInteger rootOf(NSString *s, NSUInteger l)
 {
-  unsigned	root = 0;
+  NSUInteger	root = 0;
 
   if (l > 0)
     {
@@ -442,7 +440,7 @@ static unsigned rootOf(NSString *s, unsigned l)
 					       range: range];
 		  if (range.length > 0 && range.location > 2)
 		    {
-		      unsigned pos = NSMaxRange(range);
+		      NSUInteger pos = NSMaxRange(range);
 
 		      // Found end of UNC host perhaps ... look for share
 		      if (pos < l)
@@ -556,9 +554,9 @@ handle_printf_atsign (FILE *stream,
     {
       if (sizeof(wchar_t) == 4)
         {
-	  unsigned	length = [string_object length];
+	  NSUInteger	length = [string_object length];
 	  wchar_t	buf[length + 1];
-	  unsigned	i;
+	  NSUInteger	i;
 
 	  for (i = 0; i < length; i++)
 	    {
@@ -836,7 +834,7 @@ static UCollator *GSICUCollatorOpen(NSStringCompareOptions mask, NSLocale *local
 + (id) stringWithCString: (const char*)byteString
 {
   NSString	*obj;
-  unsigned	length = byteString ? strlen(byteString) : 0;
+  NSUInteger	length = byteString ? strlen(byteString) : 0;
 
   obj = [self allocWithZone: NSDefaultMallocZone()];
   obj = [obj initWithCString: byteString length: length];
@@ -1178,7 +1176,7 @@ static UCollator *GSICUCollatorOpen(NSStringCompareOptions mask, NSLocale *local
  */
 - (id) initWithString: (NSString*)string
 {
-  unsigned	length = [string length];
+  NSUInteger	length = [string length];
 
   if (length > 0)
     {
@@ -1359,7 +1357,7 @@ static UCollator *GSICUCollatorOpen(NSStringCompareOptions mask, NSLocale *local
 {
   NSStringEncoding	enc = _DefaultStringEncoding;
   NSData		*d;
-  unsigned int		len;
+  NSUInteger		len;
   const unsigned char	*data_bytes;
 
   d = [[NSDataClass alloc] initWithContentsOfFile: path];
@@ -1425,7 +1423,7 @@ static UCollator *GSICUCollatorOpen(NSStringCompareOptions mask, NSLocale *local
                         error: (NSError**)error
 {
   NSData		*d;
-  unsigned int		len;
+  NSUInteger		len;
   const unsigned char	*data_bytes;
 
   d = [[NSDataClass alloc] initWithContentsOfFile: path];
@@ -1479,7 +1477,7 @@ static UCollator *GSICUCollatorOpen(NSStringCompareOptions mask, NSLocale *local
                         error: (NSError**)error
 {
   NSData		*d;
-  unsigned int		len;
+  NSUInteger		len;
 
   d = [[NSDataClass alloc] initWithContentsOfFile: path];
   if (d == nil)
@@ -1530,7 +1528,7 @@ static UCollator *GSICUCollatorOpen(NSStringCompareOptions mask, NSLocale *local
 {
   NSStringEncoding	enc = _DefaultStringEncoding;
   NSData		*d = [NSDataClass dataWithContentsOfURL: url];
-  unsigned int		len = [d length];
+  NSUInteger		len = [d length];
   const unsigned char	*data_bytes;
 
   if (d == nil)
@@ -1574,7 +1572,7 @@ static UCollator *GSICUCollatorOpen(NSStringCompareOptions mask, NSLocale *local
                        error: (NSError**)error
 {
   NSData		*d;
-  unsigned int		len;
+  NSUInteger		len;
   const unsigned char	*data_bytes;
 
   d = [NSDataClass dataWithContentsOfURL: url];
@@ -1626,7 +1624,7 @@ static UCollator *GSICUCollatorOpen(NSStringCompareOptions mask, NSLocale *local
                        error: (NSError**)error
 {
   NSData		*d;
-  unsigned int		len;
+  NSUInteger		len;
 
   d = [NSDataClass dataWithContentsOfURL: url];
   if (d == nil)
@@ -1696,8 +1694,8 @@ static UCollator *GSICUCollatorOpen(NSStringCompareOptions mask, NSLocale *local
 - (void) getCharacters: (unichar*)buffer
 		 range: (NSRange)aRange
 {
-  unsigned	l = [self length];
-  unsigned	i;
+  NSUInteger	l = [self length];
+  NSUInteger	i;
   unichar	(*caiImp)(NSString*, SEL, NSUInteger);
 
   GS_RANGE_CHECK(aRange, l);
@@ -1738,10 +1736,10 @@ static UCollator *GSICUCollatorOpen(NSStringCompareOptions mask, NSLocale *local
   if (data != nil)
     {
       unsigned char	*src = (unsigned char*)[data bytes];
-      unsigned int	slen = [data length];
+      NSUInteger	slen = [data length];
       unsigned char	*dst;
-      unsigned int	spos = 0;
-      unsigned int	dpos = 0;
+      NSUInteger	spos = 0;
+      NSUInteger	dpos = 0;
 
       dst = (unsigned char*)NSZoneMalloc(NSDefaultMallocZone(), slen * 3);
       while (spos < slen)
@@ -1795,8 +1793,8 @@ static UCollator *GSICUCollatorOpen(NSStringCompareOptions mask, NSLocale *local
  */
 - (NSString*) stringByAppendingString: (NSString*)aString
 {
-  unsigned	len = [self length];
-  unsigned	otherLength = [aString length];
+  NSUInteger	len = [self length];
+  NSUInteger	otherLength = [aString length];
   NSZone	*z = [self zone];
   unichar	*s = NSZoneMalloc(z, (len+otherLength)*sizeof(unichar));
   NSString	*tmp;
@@ -1901,13 +1899,13 @@ static UCollator *GSICUCollatorOpen(NSStringCompareOptions mask, NSLocale *local
 {
   id copy;
 
-  copy = [[[GSMutableStringClass allocWithZone: NSDefaultMallocZone()]
-    initWithString: self] autorelease];
+  copy = [[GSMutableStringClass allocWithZone: NSDefaultMallocZone()]
+    initWithString: self];
   [copy replaceOccurrencesOfString: replace
                         withString: by
                            options: opts
                              range: searchRange];
-  return [copy makeImmutableCopyOnFail: NO];
+  return [[copy makeImmutable] autorelease];
 }
 
 - (NSString*) stringByReplacingOccurrencesOfString: (NSString*)replace
@@ -1929,10 +1927,10 @@ static UCollator *GSICUCollatorOpen(NSStringCompareOptions mask, NSLocale *local
 {
   id	copy;
 
-  copy = [[[GSMutableStringClass allocWithZone: NSDefaultMallocZone()]
-    initWithString: self] autorelease];
+  copy = [[GSMutableStringClass allocWithZone: NSDefaultMallocZone()]
+    initWithString: self];
   [copy replaceCharactersInRange: aRange withString: by];
-  return [copy makeImmutableCopyOnFail: NO];
+  return [[copy makeImmutable] autorelease];
 }
 
 /**
@@ -1981,7 +1979,7 @@ static UCollator *GSICUCollatorOpen(NSStringCompareOptions mask, NSLocale *local
 {
   unichar	*buf;
   id		ret;
-  unsigned	len = [self length];
+  NSUInteger	len = [self length];
 
   GS_RANGE_CHECK(aRange, len);
 
@@ -2043,10 +2041,10 @@ static UCollator *GSICUCollatorOpen(NSStringCompareOptions mask, NSLocale *local
 			    options: (NSUInteger)mask
 			      range: (NSRange)aRange
 {
-  unsigned int	i;
-  unsigned int	start;
-  unsigned int	stop;
-  int		step;
+  NSUInteger	i;
+  NSUInteger	start;
+  NSUInteger	stop;
+  NSInteger		step;
   NSRange	range;
   unichar	(*cImp)(id, SEL, NSUInteger);
   BOOL		(*mImp)(id, SEL, unichar);
@@ -2205,9 +2203,10 @@ static UCollator *GSICUCollatorOpen(NSStringCompareOptions mask, NSLocale *local
       
 	  [self getCharacters: charsSelf range: searchRange];
 	  [aString getCharacters: charsOther range: NSMakeRange(0, countOther)];
-	  
-	  search = usearch_openFromCollator(charsOther, countOther,
-					    charsSelf, countSelf,
+
+      NSCAssert(countSelf < INT32_MAX && countOther < INT32_MAX, @"String(s) too large");
+	  search = usearch_openFromCollator(charsOther, (int32_t)countOther,
+					    charsSelf, (int32_t)countSelf,
 					    coll, NULL, &status);
 	  if (search != NULL && U_SUCCESS(status))
 	    {
@@ -2240,8 +2239,7 @@ static UCollator *GSICUCollatorOpen(NSStringCompareOptions mask, NSLocale *local
 			{
 			  if (matchLocation == 0)
                             {
-                              result = NSMakeRange(searchRange.location
-                                + matchLocation, matchLength);
+                              result = NSMakeRange(searchRange.location, matchLength);
                             }
 			}
 		    }
@@ -2290,9 +2288,9 @@ static UCollator *GSICUCollatorOpen(NSStringCompareOptions mask, NSLocale *local
  */
 - (NSRange) rangeOfComposedCharacterSequenceAtIndex: (NSUInteger)anIndex
 {
-  unsigned	start;
-  unsigned	end;
-  unsigned	length = [self length];
+  NSUInteger	start;
+  NSUInteger	end;
+  NSUInteger	length = [self length];
   unichar	ch;
   unichar	(*caiImp)(NSString*, SEL, NSUInteger);
   NSCharacterSet *nbSet = [NSCharacterSet nonBaseCharacterSet];
@@ -2430,8 +2428,8 @@ static UCollator *GSICUCollatorOpen(NSStringCompareOptions mask, NSLocale *local
  */
 - (NSUInteger) hash
 {
-  uint32_t	ret = 0;
-  int   	len = (int)[self length];
+  NSUInteger	ret = 0;
+  NSUInteger	len = [self length];
 
   if (len > 0)
     {
@@ -2479,8 +2477,8 @@ static UCollator *GSICUCollatorOpen(NSStringCompareOptions mask, NSLocale *local
   if (mask & NSLiteralSearch)
     {
       int prefix_len = 0;
-      unsigned	length = [self length];
-      unsigned	aLength = [aString length];
+      NSUInteger	length = [self length];
+      NSUInteger	aLength = [aString length];
       unichar *u;
       unichar a1[length+1];
       unichar *s1 = a1;
@@ -2525,10 +2523,10 @@ static UCollator *GSICUCollatorOpen(NSStringCompareOptions mask, NSLocale *local
       BOOL	gotFetchImps = NO;
       NSRange	sRange;
       NSRange	oRange;
-      unsigned	sLength = [self length];
-      unsigned	oLength = [aString length];
-      unsigned	sIndex = 0;
-      unsigned	oIndex = 0;
+      NSUInteger	sLength = [self length];
+      NSUInteger	oLength = [aString length];
+      NSUInteger	sIndex = 0;
+      NSUInteger	oIndex = 0;
 
       if (!sLength)
 	return IMMUTABLE(self);
@@ -2633,7 +2631,7 @@ static UCollator *GSICUCollatorOpen(NSStringCompareOptions mask, NSLocale *local
 	   lineSep: (BOOL)flag
 {
   unichar	thischar;
-  unsigned	start, end, len, termlen;
+  NSUInteger	start, end, len, termlen;
   unichar	(*caiImp)(NSString*, SEL, NSUInteger);
 
   len = [self length];
@@ -2832,9 +2830,9 @@ static UCollator *GSICUCollatorOpen(NSStringCompareOptions mask, NSLocale *local
 - (NSString*) capitalizedString
 {
   unichar	*s;
-  unsigned	count = 0;
+  NSUInteger	count = 0;
   BOOL		found = YES;
-  unsigned	len = [self length];
+  NSUInteger	len = [self length];
 
   if (len == 0)
     return IMMUTABLE(self);
@@ -2886,9 +2884,9 @@ static UCollator *GSICUCollatorOpen(NSStringCompareOptions mask, NSLocale *local
 {
   static NSCharacterSet	*uc = nil;
   unichar	*s;
-  unsigned	count;
+  NSUInteger	count;
   NSRange	start;
-  unsigned	len = [self length];
+  NSUInteger	len = [self length];
 
   if (len == 0)
     {
@@ -2923,9 +2921,9 @@ static UCollator *GSICUCollatorOpen(NSStringCompareOptions mask, NSLocale *local
 {
   static NSCharacterSet	*lc = nil;
   unichar	*s;
-  unsigned	count;
+  NSUInteger	count;
   NSRange	start;
-  unsigned	len = [self length];
+  NSUInteger	len = [self length];
 
   if (len == 0)
     {
@@ -3026,7 +3024,7 @@ static UCollator *GSICUCollatorOpen(NSStringCompareOptions mask, NSLocale *local
   if (NSUnicodeStringEncoding == encoding)
     {
       unichar	*u;
-      unsigned	l;
+      NSUInteger	l;
 
       l = [self length];
       m = [NSMutableData dataWithLength: (l + 1) * sizeof(unichar)];
@@ -3177,7 +3175,7 @@ static UCollator *GSICUCollatorOpen(NSStringCompareOptions mask, NSLocale *local
 {
   if (encoding == NSUnicodeStringEncoding)
     {
-      unsigned	length = [self length];
+      NSUInteger	length = [self length];
 
       if (maxLength > length * sizeof(unichar))
 	{
@@ -3194,7 +3192,7 @@ static UCollator *GSICUCollatorOpen(NSStringCompareOptions mask, NSLocale *local
   else
     {
       NSData	*d = [self dataUsingEncoding: encoding];
-      unsigned	length = [d length];
+      NSUInteger	length = [d length];
       BOOL	result = (length < maxLength) ? YES : NO;
 
       if (d == nil)
@@ -3240,7 +3238,7 @@ static UCollator *GSICUCollatorOpen(NSStringCompareOptions mask, NSLocale *local
 
 - (BOOL) boolValue
 {
-  unsigned	length = [self length];
+  NSUInteger	length = [self length];
 
   if (length > 0)
     {
@@ -3472,7 +3470,7 @@ static UCollator *GSICUCollatorOpen(NSStringCompareOptions mask, NSLocale *local
 - (NSData*) dataUsingEncoding: (NSStringEncoding)encoding
 	 allowLossyConversion: (BOOL)flag
 {
-  unsigned	len = [self length];
+  NSUInteger	len = [self length];
   NSData	*d;
 
   if (len == 0)
@@ -3482,7 +3480,7 @@ static UCollator *GSICUCollatorOpen(NSStringCompareOptions mask, NSLocale *local
   else if (encoding == NSUnicodeStringEncoding)
     {
       unichar	*u;
-      unsigned	l;
+      NSUInteger	l;
 
       u = (unichar*)NSZoneMalloc(NSDefaultMallocZone(),
 	(len + 1) * sizeof(unichar));
@@ -3506,7 +3504,7 @@ static UCollator *GSICUCollatorOpen(NSStringCompareOptions mask, NSLocale *local
       unichar		*u = buf;
       unsigned int	options;
       unsigned char	*b = 0;
-      unsigned int	l = 0;
+      NSUInteger l = 0;
 
       /* Build a fake object on the stack and copy unicode characters
        * into its buffer from the receiver.
@@ -3712,9 +3710,9 @@ static NSFileManager *fm = nil;
 
 - (NSString*) lastPathComponent
 {
-  unsigned int	l = [self length];
+  NSUInteger	l = [self length];
   NSRange	range;
-  unsigned int	i;
+  NSUInteger	i;
 
   if (l == 0)
     {
@@ -3770,8 +3768,8 @@ static NSFileManager *fm = nil;
 - (NSString*) pathExtension
 {
   NSRange	range;
-  unsigned int	l = [self length];
-  unsigned int	root;
+  NSUInteger	l = [self length];
+  NSUInteger	root;
 
   if (l == 0)
     {
@@ -3821,10 +3819,10 @@ static NSFileManager *fm = nil;
 
 - (NSString*) stringByAppendingPathComponent: (NSString*)aString
 {
-  unsigned	originalLength = [self length];
-  unsigned	length = originalLength;
-  unsigned	aLength = [aString length];
-  unsigned	root;
+  NSUInteger	originalLength = [self length];
+  NSUInteger	length = originalLength;
+  NSUInteger	aLength = [aString length];
+  NSUInteger	root;
   unichar	buf[length+aLength+1];
 
   root = rootOf(aString, aLength);
@@ -3850,7 +3848,7 @@ static NSFileManager *fm = nil;
 	    }
 	  else if (root > 1 && pathSepMember(c))
 	    {
-	      int	i;
+	      NSUInteger	i;
 
 	      for (i = 1; i < root; i++)
 		{
@@ -3919,7 +3917,7 @@ static NSFileManager *fm = nil;
 		  buf[aLength] = pathSepChar();
 		  if (pathSepMember(buf[aLength-1]) == YES)
 		    {
-		      unsigned	pos;
+		      NSUInteger	pos;
 
 		      buf[aLength-1] = pathSepChar();
 		      for (pos = aLength+1; pos < length; pos++)
@@ -3938,9 +3936,9 @@ static NSFileManager *fm = nil;
 
 - (NSString*) stringByAppendingPathExtension: (NSString*)aString
 {
-  unsigned	l = [self length];
-  unsigned 	originalLength = l;
-  unsigned	root;
+  NSUInteger	l = [self length];
+  NSUInteger 	originalLength = l;
+  NSUInteger	root;
 
   if (l == 0)
     {
@@ -3989,10 +3987,10 @@ static NSFileManager *fm = nil;
 
 - (NSString*) stringByDeletingLastPathComponent
 {
-  unsigned int	length;
-  unsigned int	root;
-  unsigned int	end;
-  unsigned int	i;
+  NSUInteger	length;
+  NSUInteger	root;
+  NSUInteger	end;
+  NSUInteger	i;
 
   end = length = [self length];
   if (length == 0)
@@ -4035,8 +4033,8 @@ static NSFileManager *fm = nil;
     {
       NSString	*result;
       unichar	*to;
-      unsigned	o;
-      unsigned	lastComponent = root;
+      NSUInteger	o;
+      NSUInteger	lastComponent = root;
       GS_BEGINITEMBUF(from, (end * 2 * sizeof(unichar)), unichar)
 
       to = from + end;
@@ -4080,8 +4078,8 @@ static NSFileManager *fm = nil;
   NSRange	r0;
   NSRange	r1;
   NSString	*substring;
-  unsigned	l = [self length];
-  unsigned	root;
+  NSUInteger	l = [self length];
+  NSUInteger	root;
 
   if ((root = rootOf(self, l)) == l)
     {
@@ -4125,7 +4123,7 @@ static NSFileManager *fm = nil;
 {
   NSString	*homedir;
   NSRange	firstSlashRange;
-  unsigned	length;
+  NSUInteger	length;
 
   if ((length = [self length]) == 0)
     {
@@ -4165,7 +4163,7 @@ static NSFileManager *fm = nil;
   if (firstSlashRange.location != 1)
     {
       /* It is of the form `~username/blah/...' or '~username' */
-      int	userNameLen;
+      NSInteger	userNameLen;
       NSString	*uname;
 
       if (firstSlashRange.length != 0)
@@ -4243,8 +4241,8 @@ static NSFileManager *fm = nil;
 			   withString: (NSString*)padString
 		      startingAtIndex: (NSUInteger)padIndex
 {
-  unsigned	length = [self length];
-  unsigned	padLength;
+  NSUInteger	length = [self length];
+  NSUInteger	padLength;
 
   if (padString == nil || [padString isKindOfClass: [NSString class]] == NO)
     {
@@ -4331,9 +4329,9 @@ static NSFileManager *fm = nil;
   if (d != nil)
     {
       unsigned char	*p = (unsigned char*)[d mutableBytes];
-      unsigned		l = [d length];
-      unsigned		i = 0;
-      unsigned		j = 0;
+      NSUInteger		l = [d length];
+      NSUInteger		i = 0;
+      NSUInteger		j = 0;
 
       while (i < l)
 	{
@@ -4593,7 +4591,7 @@ static NSFileManager *fm = nil;
 
       if (lstat(&newBuf[8], &st) == 0)
 	{
-	  int	l = strlen(newBuf) - 7;
+	  NSUInteger	l = strlen(newBuf) - 7;
 
 	  memmove(newBuf, &newBuf[8], l);
 	}
@@ -4609,9 +4607,9 @@ static NSFileManager *fm = nil;
   NSMutableString	*s;
   NSRange		r;
   unichar		(*caiImp)(NSString*, SEL, NSUInteger);
-  unsigned int		l = [self length];
+  NSUInteger		l = [self length];
   unichar		c;
-  unsigned		root;
+  NSUInteger		root;
 
   if (l == 0)
     {
@@ -4646,7 +4644,7 @@ static NSFileManager *fm = nil;
    */
   if (root > 0 && YES == pathSepMember((*caiImp)(s, caiSel, root-1)))
     {
-      unsigned	i;
+      NSUInteger	i;
 
       for (i = root; i < l; i++)
 	{
@@ -4798,9 +4796,9 @@ static NSFileManager *fm = nil;
  */
 - (NSString*) stringByTrimmingCharactersInSet: (NSCharacterSet*)aSet
 {
-  unsigned	length = [self length];
-  unsigned	end = length;
-  unsigned	start = 0;
+  NSUInteger	length = [self length];
+  NSUInteger	end = length;
+  NSUInteger	start = 0;
 
   if (aSet == nil)
     {
@@ -4847,10 +4845,10 @@ static NSFileManager *fm = nil;
 }
 
 // private methods for Unicode level 3 implementation
-- (int) _baseLength
+- (NSUInteger) _baseLength
 {
-  int		blen = 0;
-  unsigned	len = [self length];
+  NSUInteger blen = 0;
+  NSUInteger len = [self length];
 
   if (len > 0)
     {
@@ -4872,8 +4870,8 @@ static NSFileManager *fm = nil;
 + (NSString*) pathWithComponents: (NSArray*)components
 {
   NSString	*s;
-  unsigned	c;
-  unsigned	i;
+  NSUInteger	c;
+  NSUInteger	i;
 
   c = [components count];
   if (c == 0)
@@ -4895,8 +4893,8 @@ static NSFileManager *fm = nil;
 - (BOOL) isAbsolutePath
 {
   unichar	c;
-  unsigned	l = [self length];
-  unsigned	root;
+  NSUInteger	l = [self length];
+  NSUInteger	root;
 
   if (l == 0)
     {
@@ -4951,9 +4949,9 @@ static NSFileManager *fm = nil;
   NSMutableArray	*a;
   NSArray		*r;
   NSString		*s = self;
-  unsigned int		l = [s length];
-  unsigned int		root;
-  unsigned int		i;
+  NSUInteger		l = [s length];
+  NSUInteger		root;
+  NSUInteger		i;
   NSRange		range;
 
   if (l == 0)
@@ -5007,7 +5005,7 @@ static NSFileManager *fm = nil;
 {
   NSMutableArray	*a;
   NSArray		*r;
-  unsigned		i, count = [paths count];
+  NSUInteger		i, count = [paths count];
 
   a = [[NSMutableArray allocWithZone: NSDefaultMallocZone()]
 	initWithCapacity: count];
@@ -5119,9 +5117,10 @@ static NSFileManager *fm = nil;
 
 	  [self getCharacters: charsSelf range: compareRange];
 	  [string getCharacters: charsOther range: NSMakeRange(0, countOther)];
-	  
+
+      NSCAssert(countSelf < INT32_MAX && countOther < INT32_MAX, @"String(s) too large");
 	  result = ucol_strcoll(coll,
-	    charsSelf, countSelf, charsOther, countOther);
+	    charsSelf, (int32_t)countSelf, charsOther, (int32_t)countOther);
 
 	  NSZoneFree(NSDefaultMallocZone(), charsSelf);
 	  NSZoneFree(NSDefaultMallocZone(), charsOther);	  
@@ -5295,7 +5294,7 @@ static NSFileManager *fm = nil;
     }
   else
     {
-      unsigned	count = [self length];
+      NSUInteger	count = [self length];
 
       [aCoder encodeValueOfObjCType: @encode(unsigned) at: &count];
       if (count > 0)
@@ -5769,7 +5768,7 @@ static NSFileManager *fm = nil;
                                     range: (NSRange)searchRange
 {
   NSRange	range;
-  unsigned int	count = 0;
+  NSUInteger	count = 0;
   GSRSFunc	func;
 
   if ([replace isKindOfClass: NSStringClass] == NO)
@@ -5792,7 +5791,7 @@ static NSFileManager *fm = nil;
 
   if (range.length > 0)
     {
-      unsigned	byLen = [by length];
+      NSUInteger	byLen = [by length];
       SEL	sel;
       void	(*imp)(id, SEL, NSRange, NSString*);
 
@@ -5808,7 +5807,7 @@ static NSFileManager *fm = nil;
 	    }
 	  else
 	    {
-	      unsigned int	newEnd;
+	      NSUInteger	newEnd;
 
 	      newEnd = NSMaxRange(searchRange) + byLen - range.length;
 	      searchRange.location = range.location + byLen;
diff --git a/Source/NSTask.m b/Source/NSTask.m
index b0f9370..ef2be59 100644
--- a/Source/NSTask.m
+++ b/Source/NSTask.m
@@ -1437,12 +1437,12 @@ GSPrivateCheckTasks()
   NSDictionary		*e = [self environment];
   NSArray		*k = [e allKeys];
   NSArray		*a = [self arguments];
-  int			ec = [e count];
-  int			ac = [a count];
+  NSUInteger			ec = [e count];
+  NSUInteger			ac = [a count];
   const char		*args[ac+2];
   const char		*envl[ec+1];
   id			hdl;
-  int			i;
+  NSUInteger			i;
 
   if (_hasLaunched)
     {
diff --git a/Source/NSThread.m b/Source/NSThread.m
index fdc34b9..e2e476a 100644
--- a/Source/NSThread.m
+++ b/Source/NSThread.m
@@ -159,7 +159,7 @@ static NSNotificationCenter *nc = nil;
  * If the date is in the past, this function simply allows other threads
  * (if any) to run.
  */
-void
+static void
 GSSleepUntilIntervalSinceReferenceDate(NSTimeInterval when)
 {
   NSTimeInterval delay;
@@ -341,7 +341,7 @@ GSCurrentThread(void)
   return thr;
 }
 
-NSMutableDictionary*
+static NSMutableDictionary*
 GSDictionaryForThread(NSThread *t)
 {
   if (nil == t)
@@ -573,6 +573,13 @@ unregisterActiveThread(NSThread *thread)
   return defaultThread;
 }
 
+/* On OSX <pthread.h> does not define _POSIX_THREAD_PRIORITY_SCHEDULING */
+#if !defined (__APPLE__)
+#  define HAVE_PRIORITY_SCHEDULING (defined(_POSIX_THREAD_PRIORITY_SCHEDULING) && (_POSIX_THREAD_PRIORITY_SCHEDULING > 0))
+#else
+#  define HAVE_PRIORITY_SCHEDULING 1
+#endif
+
 /**
  * Set the priority of the current thread.  This is a value in the
  * range 0.0 (lowest) to 1.0 (highest) which is mapped to the underlying
@@ -580,7 +587,7 @@ unregisterActiveThread(NSThread *thread)
  */
 + (void) setThreadPriority: (double)pri
 {
-#if defined(_POSIX_THREAD_PRIORITY_SCHEDULING) && (_POSIX_THREAD_PRIORITY_SCHEDULING > 0)
+#if HAVE_PRIORITY_SCHEDULING
   int	policy;
   struct sched_param param;
 
@@ -611,14 +618,13 @@ unregisterActiveThread(NSThread *thread)
   GSSleepUntilIntervalSinceReferenceDate([date timeIntervalSinceReferenceDate]);
 }
 
-
 /**
  * Return the priority of the current thread.
  */
 + (double) threadPriority
 {
   double pri = 0;
-#if defined(_POSIX_THREAD_PRIORITY_SCHEDULING) && (_POSIX_THREAD_PRIORITY_SCHEDULING > 0)
+#if HAVE_PRIORITY_SCHEDULING
   int policy;
   struct sched_param param;
 
@@ -629,18 +635,18 @@ unregisterActiveThread(NSThread *thread)
   pri /= (PTHREAD_MAX_PRIORITY - PTHREAD_MIN_PRIORITY);
 
 #else
-#warning Your pthread implementation does not support thread priorities
+#  warning Your pthread implementation does not support thread priorities
 #endif
   return pri;
 
 }
 
-
 
 /*
  * Thread instance methods.
  */
 
+
 - (void) cancel
 {
   _cancelled = YES;
@@ -735,7 +741,7 @@ unregisterActiveThread(NSThread *thread)
   if (_active == NO)
     {
       [NSException raise: NSInternalInconsistencyException
-                  format: @"[%@-$@] called on inactive thread",
+                  format: @"[%@-%@] called on inactive thread",
         NSStringFromClass([self class]),
         NSStringFromSelector(_cmd)];
     }
@@ -821,21 +827,21 @@ static void *nsthreadLauncher(void* thread)
   if (_active == YES)
     {
       [NSException raise: NSInternalInconsistencyException
-                  format: @"[%@-$@] called on active thread",
+                  format: @"[%@-%@] called on active thread",
         NSStringFromClass([self class]),
         NSStringFromSelector(_cmd)];
     }
   if (_cancelled == YES)
     {
       [NSException raise: NSInternalInconsistencyException
-                  format: @"[%@-$@] called on cancelled thread",
+                  format: @"[%@-%@] called on cancelled thread",
         NSStringFromClass([self class]),
         NSStringFromSelector(_cmd)];
     }
   if (_finished == YES)
     {
       [NSException raise: NSInternalInconsistencyException
-                  format: @"[%@-$@] called on finished thread",
+                  format: @"[%@-%@] called on finished thread",
         NSStringFromClass([self class]),
         NSStringFromSelector(_cmd)];
     }
@@ -1017,8 +1023,8 @@ static void *nsthreadLauncher(void* thread)
 - (void) fire
 {
   NSArray	*toDo;
-  unsigned int	i;
-  unsigned int	c;
+  NSUInteger	i;
+  NSUInteger	c;
 
   [lock lock];
 #if defined(__MINGW__)
diff --git a/Source/NSTimeZone.m b/Source/NSTimeZone.m
index 28ac99c..d51cbfa 100644
--- a/Source/NSTimeZone.m
+++ b/Source/NSTimeZone.m
@@ -124,6 +124,13 @@
 #undef id
 #endif
 
+#define INITALIZE_STATIC_OBJECT(name, value)    \
+do {                                            \
+    name = value;                               \
+    [NSObject leakAt:(id *)&name];              \
+    [name release];                             \
+} while (0)
+
 NSString * const NSSystemTimeZoneDidChangeNotification
   = @"NSSystemTimeZoneDidChangeNotification";
 
@@ -197,7 +204,7 @@ ICUCalendarSetup (NSTimeZone *tz, NSLocale *locale)
   UErrorCode err = U_ZERO_ERROR;
   
   tzStr = [tz name];
-  if ((tzLen = [tzStr length]) > BUFFER_SIZE)
+  if ((tzLen = (int32_t)[tzStr length]) > BUFFER_SIZE)
     tzLen = BUFFER_SIZE;
   [tzStr getCharacters: tzName range: NSMakeRange(0, tzLen)];
   cLocale = [[locale localeIdentifier] UTF8String];
@@ -342,7 +349,7 @@ static NSString *_time_zone_path(NSString *subpath, NSString *type)
 @public
   NSString	*name;
   id		detail;
-  int		offset; // Offset from UTC in seconds.
+  NSInteger offset; // Offset from UTC in seconds.
 }
 
 - (id) initWithOffset: (NSInteger)anOffset name: (NSString*)aName;
@@ -355,7 +362,7 @@ static NSString *_time_zone_path(NSString *subpath, NSString *type)
 {
   NSTimeZone	*timeZone; // Time zone which created this object.
   NSString	*abbrev; // Abbreviation for time zone detail.
-  int		offset; // Offset from UTC in seconds.
+  NSInteger		offset; // Offset from UTC in seconds.
   BOOL		is_dst; // Is it daylight savings time?
 }
 
@@ -396,7 +403,7 @@ static NSString *_time_zone_path(NSString *subpath, NSString *type)
 - (id) initWithName: (NSString*)name data: (NSData*)data
 {
   NSTimeZone	*zone;
-  unsigned	length = [name length];
+  NSUInteger	length = [name length];
 
   if (length == 0)
     {
@@ -663,11 +670,9 @@ static NSMapTable	*absolutes = 0;
 
 + (void) initialize
 {
-  if (self == [GSAbsTimeZone class])
+    if (self == [GSAbsTimeZone class])
     {
-      absolutes = NSCreateMapTable(NSIntegerMapKeyCallBacks,
-	NSNonOwnedPointerMapValueCallBacks, 0);
-      [[NSObject leakAt: (id*)&absolutes] release];
+        INITALIZE_STATIC_OBJECT(absolutes, NSCreateMapTable(NSIntegerMapKeyCallBacks, NSNonOwnedPointerMapValueCallBacks, 0));
     }
 }
 
@@ -698,9 +703,13 @@ static NSMapTable	*absolutes = 0;
 
 - (id) initWithOffset: (NSInteger)anOffset name: (NSString*)aName
 {
+  if (!(self = [super initWithName:aName]))
+  {
+      return nil;
+  }
   GSAbsTimeZone	*z;
-  int		extra;
-  int		sign = anOffset >= 0 ? 1 : -1;
+  NSInteger		extra;
+  NSInteger		sign = anOffset >= 0 ? 1 : -1;
 
   /*
    * Set the uninitialised offset so that dealloc before full
@@ -746,12 +755,12 @@ static NSMapTable	*absolutes = 0;
 	  if (anOffset % 60 == 0)
 	    {
 	      char	s = (anOffset >= 0) ? '+' : '-';
-	      int	i = (anOffset >= 0) ? anOffset / 60 : -anOffset / 60;
-	      int	h = i / 60;
-	      int	m = i % 60;
+	      NSInteger	i = (anOffset >= 0) ? anOffset / 60 : -anOffset / 60;
+	      NSInteger	h = i / 60;
+	      NSInteger	m = i % 60;
 	      char	buf[9];
 
-	      snprintf(buf, sizeof(buf), "GMT%c%02d%02d", s, h, m);
+	      snprintf(buf, sizeof(buf), "GMT%c%02ld%02ld", s, (long)h, (long)m);
 	      name = [[NSString alloc] initWithUTF8String: buf];
 	    }
 	  else
@@ -760,8 +769,8 @@ static NSMapTable	*absolutes = 0;
 	       * Should never happen now we round to the minute
 	       * for MacOS-X compatibnility.
 	       */
-	      name = [[NSString alloc] initWithFormat: @"NSAbsoluteTimeZone:%d",
-		anOffset];
+	      name = [[NSString alloc] initWithFormat: @"NSAbsoluteTimeZone:%ld",
+		(long)anOffset];
 	    }
 	}
       else
@@ -1045,7 +1054,7 @@ static NSMapTable	*absolutes = 0;
 		    }
 		}
 	    }
-	  [md makeImmutableCopyOnFail: NO];
+	  md = [md makeImmutable];
 	  abbreviationDictionary = md;
 	}
       [pool drain];
@@ -1091,7 +1100,7 @@ static NSMapTable	*absolutes = 0;
        * Read dictionary from file... fast mechanism because we don't have
        * to create all timezoneas and parse all their data files.
        */
-      md = [NSMutableDictionary dictionaryWithCapacity: 100];
+      md = [[NSMutableDictionary alloc] initWithCapacity: 100];
       path = _time_zone_path (ABBREV_MAP, nil);
       if (path != nil)
 	{
@@ -1192,8 +1201,8 @@ static NSMapTable	*absolutes = 0;
 	  [ma addObject: the_name];
 	}
 
-      [md makeImmutableCopyOnFail: NO];
-      abbreviationMap = RETAIN(md); 
+      md = [md makeImmutable];
+      abbreviationMap = md; 
       [pool drain];
     }
   if (zone_mutex != nil)
@@ -1237,7 +1246,7 @@ static NSMapTable	*absolutes = 0;
 	  [ma addObjectsFromArray: names];
 	}
 
-      [ma makeImmutableCopyOnFail: NO];
+      ma = [ma makeImmutable];
       namesArray = ma;
     }
   if (zone_mutex != nil)
@@ -1335,33 +1344,26 @@ static NSMapTable	*absolutes = 0;
 
 + (void) initialize
 {
-  if (self == [NSTimeZone class])
+    if (self == [NSTimeZone class])
     {
-      NSTimeZoneClass = self;
-      GSPlaceholderTimeZoneClass = [GSPlaceholderTimeZone class];
-      zoneDictionary = [[NSMutableDictionary alloc] init];
-      [[NSObject leakAt: &zoneDictionary] release];
-
-      /*
-       * Set up infrastructure for placeholder timezones.
-       */
-      defaultPlaceholderTimeZone = (GSPlaceholderTimeZone*)
-	NSAllocateObject(GSPlaceholderTimeZoneClass, 0, NSDefaultMallocZone());
-      [[NSObject leakAt: &defaultPlaceholderTimeZone] release];
-      placeholderMap = NSCreateMapTable(NSNonOwnedPointerMapKeyCallBacks,
-	NSNonRetainedObjectMapValueCallBacks, 0);
-      [[NSObject leakAt: (id*)&placeholderMap] release];
-
-      localTimeZone = [[NSLocalTimeZone alloc] init];
-      [[NSObject leakAt: (id*)&localTimeZone] release];
-
-      zone_mutex = [GSLazyRecursiveLock new];
-      [[NSObject leakAt: (id*)&zone_mutex] release];
-
-      [[NSNotificationCenter defaultCenter] addObserver: self
-        selector: @selector(_notified:)
-        name: NSUserDefaultsDidChangeNotification
-        object: nil];
+        NSTimeZoneClass = self;
+        GSPlaceholderTimeZoneClass = [GSPlaceholderTimeZone class];
+        INITALIZE_STATIC_OBJECT(zoneDictionary, [[NSMutableDictionary alloc] init]);
+        
+        /*
+         * Set up infrastructure for placeholder timezones.
+         */
+        INITALIZE_STATIC_OBJECT(defaultPlaceholderTimeZone, (GSPlaceholderTimeZone *)NSAllocateObject(GSPlaceholderTimeZoneClass, 0, NSDefaultMallocZone()));
+        INITALIZE_STATIC_OBJECT(placeholderMap, NSCreateMapTable(NSNonOwnedPointerMapKeyCallBacks, NSNonRetainedObjectMapValueCallBacks, 0));
+        
+        INITALIZE_STATIC_OBJECT(localTimeZone, [[NSLocalTimeZone alloc] init]);
+        
+        INITALIZE_STATIC_OBJECT(zone_mutex, [GSLazyRecursiveLock new]);
+        
+        [[NSNotificationCenter defaultCenter] addObserver: self
+                                                 selector: @selector(_notified:)
+                                                     name: NSUserDefaultsDidChangeNotification
+                                                   object: nil];
     }
 }
 
@@ -1885,7 +1887,7 @@ localZoneString, [zone name], sign, s/3600, (s/60)%60);
 			}
 		      if (zone != nil)
 			{
-			  int			offset;
+			  NSInteger			offset;
 			  NSArray		*details;
 			  NSTimeZoneDetail	*detail;
 			  NSEnumerator		*e;
@@ -2086,8 +2088,12 @@ localZoneString, [zone name], sign, s/3600, (s/60)%60);
  */
 - (id) initWithName: (NSString*)name data: (NSData*)data
 {
-  [self notImplemented: _cmd];
-  return nil;
+    if ([self class] == NSTimeZoneClass)
+    {
+        [self notImplemented: _cmd];
+        return nil;
+    }
+    return [super init];
 }
 
 /**
@@ -2174,7 +2180,7 @@ localZoneString, [zone name], sign, s/3600, (s/60)%60);
 - (NSInteger) secondsFromGMTForDate: (NSDate*)aDate
 {
   NSTimeZoneDetail	*detail;
-  int			offset;
+  NSInteger			offset;
 
   detail = [self timeZoneDetailForDate: aDate];
   offset = [detail timeZoneSecondsFromGMT];
@@ -2288,10 +2294,10 @@ localZoneString, [zone name], sign, s/3600, (s/60)%60);
 
 - (NSString*) description
 {
-  return [NSString stringWithFormat: @"%@(%@, %s%d)", [self name],
+  return [NSString stringWithFormat: @"%@(%@, %s%ld)", [self name],
     [self timeZoneAbbreviation],
     ([self isDaylightSavingTimeZone]? "IS_DST, ": ""),
-    [self timeZoneSecondsFromGMT]];
+    (long)[self timeZoneSecondsFromGMT]];
 }
 
 /**
@@ -2441,12 +2447,6 @@ lastDayOfGregorianMonth(int month, int year)
     }
 }
 
-/* IMPORT from NSCalendar date */
-void
-GSBreakTime(NSTimeInterval when, NSInteger*year, NSInteger*month, NSInteger*day,
-  NSInteger*hour, NSInteger*minute, NSInteger*second, NSInteger*mil);
-
-
 @implementation GSWindowsTimeZone
 
 - (NSString*) abbreviationForDate: (NSDate*)aDate
@@ -2965,10 +2965,10 @@ newDetailInZoneForType(GSTimeZone *zone, TypeInfo *type)
   NS_DURING
     {
       const void	*bytes = [timeZoneData bytes];
-      unsigned		length = [timeZoneData length];
+      NSUInteger		length = [timeZoneData length];
       void		*buf;
-      unsigned		pos = 0;
-      unsigned		i, charcnt;
+      NSUInteger		pos = 0;
+      NSUInteger		i, charcnt;
       unsigned char	*abbr;
       struct tzhead	*header;
 
diff --git a/Source/NSTimer.m b/Source/NSTimer.m
index 6a8dcea..1ab8fb1 100644
--- a/Source/NSTimer.m
+++ b/Source/NSTimer.m
@@ -93,6 +93,10 @@ static Class	NSDate_class;
 	       userInfo: (id)info
 		repeats: (BOOL)f
 {
+    if (!(self = [super init]))
+    {
+        return nil;
+    }
   if (ti <= 0.0)
     {
       ti = 0.0001;
diff --git a/Source/NSURL.m b/Source/NSURL.m
index 40d8544..6909c43 100644
--- a/Source/NSURL.m
+++ b/Source/NSURL.m
@@ -76,10 +76,10 @@ NSString * const NSErrorFailingURLStringKey = @"NSErrorFailingURLStringKey";
   if (data != nil)
     {
       unsigned char	*src = (unsigned char*)[data bytes];
-      unsigned int	slen = [data length];
+      NSUInteger	slen = [data length];
       unsigned char	*dst;
-      unsigned int	spos = 0;
-      unsigned int	dpos = 0;
+      NSUInteger	spos = 0;
+      NSUInteger	dpos = 0;
 
       dst = (unsigned char*)NSZoneMalloc(NSDefaultMallocZone(), slen * 3);
       while (spos < slen)
@@ -203,8 +203,8 @@ static char *buildURL(parsedURL *base, parsedURL *rel, BOOL standardize)
   char		*buf;
   char		*ptr;
   char		*tmp;
-  int		l;
-  unsigned int	len = 1;
+  NSInteger		l;
+  NSUInteger	len = 1;
 
   if (rel->scheme != 0)
     {
@@ -252,6 +252,7 @@ static char *buildURL(parsedURL *base, parsedURL *rel, BOOL standardize)
       len += strlen(rel->fragment) + 1;		// #fragment
     }
 
+  len += 1; // '\0' byte
 #if	GS_WITH_GC
   ptr = buf = (char*)NSAllocateCollectable(len, 0);
 #else
@@ -824,7 +825,7 @@ static NSUInteger	urlAlign;
     {
       parsedURL	*buf;
       parsedURL	*base = baseData;
-      unsigned	size = [_urlString length];
+      NSUInteger	size = [_urlString length];
       char	*end;
       char	*start;
       char	*ptr;
@@ -1347,7 +1348,7 @@ static NSUInteger	urlAlign;
   if (absString == nil)
     {
       char	*url = buildURL(baseData, myData, NO);
-      unsigned	len = strlen(url);
+      NSUInteger	len = strlen(url);
 
       absString = [[NSString alloc] initWithCStringNoCopy: url
 						   length: len
@@ -1428,7 +1429,7 @@ static NSUInteger	urlAlign;
 {
   char	*ptr = buf;
   char	*tmp = buf;
-  int	l;
+  NSInteger	l;
 
   if (myData->pathIsAbsolute == YES)
     {
@@ -1853,7 +1854,7 @@ static NSUInteger	urlAlign;
 - (NSURL*) standardizedURL
 {
   char		*url = buildURL(baseData, myData, YES);
-  unsigned	len = strlen(url);
+  NSUInteger	len = strlen(url);
   NSString	*str;
   NSURL		*tmp;
 
diff --git a/Source/NSURLAuthenticationChallenge.m b/Source/NSURLAuthenticationChallenge.m
index b14419d..49e86b8 100644
--- a/Source/NSURLAuthenticationChallenge.m
+++ b/Source/NSURLAuthenticationChallenge.m
@@ -33,7 +33,7 @@
 typedef struct {
   NSURLProtectionSpace				*space;
   NSURLCredential				*credential;
-  int						previousFailureCount;
+  NSInteger						previousFailureCount;
   NSURLResponse					*response;
   NSError					*error;
   id<NSURLAuthenticationChallengeSender>	sender;
diff --git a/Source/NSURLCache.m b/Source/NSURLCache.m
index 06ebb44..b73af41 100644
--- a/Source/NSURLCache.m
+++ b/Source/NSURLCache.m
@@ -30,10 +30,10 @@
 
 // FIXME ... locking and disk storage needed
 typedef struct {
-  unsigned		diskCapacity;
-  unsigned		memoryCapacity;
-  unsigned		diskUsage;
-  unsigned		memoryUsage;
+  NSUInteger		diskCapacity;
+  NSUInteger		memoryCapacity;
+  NSUInteger		diskUsage;
+  NSUInteger		memoryUsage;
   NSString		*path;
   NSMutableDictionary	*memory;
 } Internal;
@@ -180,7 +180,7 @@ static NSURLCache	*shared = nil;
 
       case NSURLCacheStorageAllowedInMemoryOnly:
         {
-	  unsigned		size = [[cachedResponse data] length];
+	  NSUInteger		size = [[cachedResponse data] length];
 
 	  if (size < this->memoryCapacity)
 	    {
diff --git a/Source/NSURLConnection.m b/Source/NSURLConnection.m
index c051955..dd77e1e 100644
--- a/Source/NSURLConnection.m
+++ b/Source/NSURLConnection.m
@@ -25,328 +25,383 @@
 #import "common.h"
 
 #define	EXPOSE_NSURLConnection_IVARS	1
+#import "Foundation/NSBundle.h"
 #import "Foundation/NSError.h"
 #import "Foundation/NSRunLoop.h"
 #import "GSURLPrivate.h"
+#import "GNUstepBase/NSURL+GNUstepBase.h"
+#import "GNUstepBase/NSString+GNUstepBase.h"
 
-@interface _NSURLConnectionDataCollector : NSObject
-{
-  NSURLConnection	*_connection;	// Not retained
-  NSMutableData		*_data;
-  NSError		*_error;
-  NSURLResponse		*_response;
-  BOOL			_done;
+@interface _NSURLConnectionDataCollector : NSObject {
+    NSURLConnection	*_connection; /* not retained */
+    NSMutableData   *_data;
+    NSError         *_error;
+    NSURLResponse   *_response;
+    BOOL            _done;
 }
 
-- (NSData*) data;
-- (BOOL) done;
-- (NSError*) error;
-- (NSURLResponse*) response;
-- (void) setConnection: (NSURLConnection *)c;
+- (BOOL)done;
+- (NSData *)data;
+- (NSError *)error;
+- (NSURLResponse *)response;
+
+- (NSURLConnection *)connection;
+- (void)setConnection:(NSURLConnection *)aConnection;
 
 @end
 
+
 @implementation _NSURLConnectionDataCollector
 
-- (void) dealloc
+- (id)init
 {
-  [_data release];
-  [_error release];
-  [_response release];
-  [super dealloc];
+    if (self = [super init])
+    {
+        _data = [NSMutableData new]; /* empty data unless we get an error */
+    }
+    return self;
 }
 
-- (BOOL) done
+- (void)dealloc
 {
-  return _done;
+    [_data release];
+    [_error release];
+    [_response release];
+    [super dealloc];
 }
 
-- (NSData*) data
+- (BOOL)done
 {
-  return _data;
+    return _done;
 }
 
-- (id) init
+- (NSData *)data
 {
-  if (nil != (self = [super init]))
-    {
-      _data = [NSMutableData new];      // Empty data unless we get an error
-    }
-  return self;
+    return _data;
 }
 
-- (NSError*) error
+- (NSError *)error
 {
-  return _error;
+    return _error;
 }
 
-- (NSURLResponse*) response
+- (NSURLResponse *)response
 {
-  return _response;
+    return _response;
 }
 
-- (void) setConnection: (NSURLConnection*)c
+- (NSURLConnection *)connection
 {
-  _connection = c;	// Not retained ... the connection retains us
+    return _connection;
 }
 
-- (void) connection: (NSURLConnection *)connection
-   didFailWithError: (NSError *)error
+- (void)setConnection:(NSURLConnection *)aConnection
 {
-  ASSIGN(_error, error);
-  DESTROY(_data);       // On error, we make the data nil
-  _done = YES;
+    _connection = aConnection; /* not retained ... the connection retains us */
 }
 
-- (void) connection: (NSURLConnection *)connection
- didReceiveResponse: (NSURLResponse*)response
+- (void)connection:(NSURLConnection *)connection didFailWithError:(NSError *)error
 {
-  ASSIGN(_response, response);
+    ASSIGN(_error, error);
+    DESTROY(_data); /* on error, we make the data nil */
+    _done = YES;
 }
 
-- (void) connectionDidFinishLoading: (NSURLConnection *)connection
+- (void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response
 {
-  _done = YES;
+    ASSIGN(_response, response);
 }
 
+- (void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data
+{
+    [_data appendData:data];
+}
 
-- (void) connection: (NSURLConnection *)connection
-     didReceiveData: (NSData *)data
+- (void)connectionDidFinishLoading:(NSURLConnection *)connection
 {
-  [_data appendData: data];
+    _done = YES;
 }
 
 @end
 
+
 typedef struct
 {
-  NSMutableURLRequest		*_request;
-  NSURLProtocol			*_protocol;
-  id				_delegate;	// Not retained
-  BOOL				_debug;
+    NSMutableURLRequest   *_request;
+    NSURLProtocol         *_protocol;
+    id                    _delegate; /* retained */
+    BOOL                  _debug;
 } Internal;
- 
-#define	this	((Internal*)(self->_NSURLConnectionInternal))
-#define	inst	((Internal*)(o->_NSURLConnectionInternal))
+
+#define	this ((Internal*)(self->_NSURLConnectionInternal))
+#define	inst ((Internal*)(o->_NSURLConnectionInternal))
+
+#if __has_feature(objc_arc)
+#  define RETAIN_AUTORELEASE(object) __strong id __strong_##object = object;
+#else
+#  define RETAIN_AUTORELEASE(object) [[self retain] autorelease];
+#endif
 
 @implementation	NSURLConnection
 
-+ (id) allocWithZone: (NSZone*)z
++ (id)allocWithZone:(NSZone *)zone
 {
-  NSURLConnection	*o = [super allocWithZone: z];
-
-  if (o != nil)
+    NSURLConnection	*connection = [super allocWithZone: zone];
+    
+    if (connection != nil)
     {
 #if	GS_WITH_GC
-      o->_NSURLConnectionInternal
-	= NSAllocateCollectable(sizeof(Internal), NSScannedOption);
+        connection->_NSURLConnectionInternal = NSAllocateCollectable(sizeof(Internal), NSScannedOption);
 #else
-      o->_NSURLConnectionInternal = NSZoneCalloc([self zone],
-	1, sizeof(Internal));
+        connection->_NSURLConnectionInternal = NSZoneCalloc([self zone], 1, sizeof(Internal));
 #endif
     }
-  return o;
+    return connection;
 }
 
-+ (BOOL) canHandleRequest: (NSURLRequest *)request
++ (BOOL)canHandleRequest:(NSURLRequest *)request
 {
-  return ([NSURLProtocol _classToHandleRequest: request] != nil);
+    return [NSURLProtocol _classToHandleRequest:request] != nil;
 }
 
-+ (NSURLConnection *) connectionWithRequest: (NSURLRequest *)request
-				   delegate: (id)delegate
++ (NSURLConnection *)connectionWithRequest:(NSURLRequest *)request delegate:(id)delegate
 {
-  NSURLConnection	*o = [self alloc];
+    return AUTORELEASE([[self alloc] initWithRequest:request delegate:delegate]);
+}
 
-  o = [o initWithRequest: request delegate: delegate];
-  return AUTORELEASE(o);
+- (id)initWithRequest:(NSURLRequest *)request delegate:(id)delegate startImmediately:(BOOL)startImmediately
+{
+    /* If request is nil, Apple's implemenation will produce seg.fault. We should crash too, but may do it more gracefully. */
+    if (!request)
+    {
+        [NSException raise:NSInvalidArgumentException format:@"Tried to init NSURLConnection with nil request"];
+    }
+    if (self = [super init])
+    {
+        this->_request = [request mutableCopyWithZone:[self zone]];
+        this->_protocol = nil;
+        /*
+         * According to bug #35686, Cocoa has a bizarre deviation from the convention that delegates are not retained here.
+         * For compatibility we retain the delegate and release it again when the operation is over.
+         */
+        this->_delegate = [delegate retain];
+        this->_debug = GSDebugSet(@"NSURLConnection");
+    }
+    if (startImmediately) {
+        [self start];
+    }
+    return self;
 }
 
-- (void) cancel
+- (id)initWithRequest:(NSURLRequest *)request delegate:(id)delegate
 {
-  [this->_protocol stopLoading];
-  DESTROY(this->_protocol);
-  DESTROY(this->_delegate);
+    return [self initWithRequest:request delegate:delegate startImmediately:YES];
 }
 
-- (void) dealloc
+- (void)dealloc
 {
-  if (this != 0)
-    {
-      [self cancel];
-      DESTROY(this->_request);
-      DESTROY(this->_delegate);
-      NSZoneFree([self zone], this);
-      _NSURLConnectionInternal = 0;
-    }
-  [super dealloc];
+    [self cancel];
+    DESTROY(this->_request);
+    NSZoneFree([self zone], this);
+    _NSURLConnectionInternal = 0;
+    [super dealloc];
 }
 
-- (void) finalize
+- (NSError *)_errorWithCode:(NSInteger)errorCode description:(NSString *)description
 {
-  if (this != 0)
-    {
-      [self cancel];
-    }
+    NSURL *url = [this->_request URL];
+    NSString *urlString = [url absoluteString];
+    NSMutableDictionary *userInfo = [NSMutableDictionary dictionaryWithObject:NSLocalizedString(description, @"") forKey:NSLocalizedDescriptionKey];
+    [userInfo setObject:url forKey:NSURLErrorKey];
+    [userInfo setObject:url forKey:@"NSURLErrorFailingURLErrorKey"]; /* deprecated in Mac' Foundation */
+    [userInfo setObject:urlString forKey:NSErrorFailingURLStringKey];
+    [userInfo setObject:urlString forKey:@"NSURLErrorFailingURLStringErrorKey"]; /* deprecated in Mac' Foundation */
+    return [NSError errorWithDomain:NSURLErrorDomain code:errorCode userInfo:userInfo];
 }
 
-- (id) initWithRequest: (NSURLRequest *)request delegate: (id)delegate
+- (void)start
 {
-  if ((self = [super init]) != nil)
+    /* enrich the request with the appropriate HTTP cookies, if desired */
+    if ([this->_request HTTPShouldHandleCookies] == YES)
+    {
+        NSArray *cookies = [[NSHTTPCookieStorage sharedHTTPCookieStorage] cookiesForURL:[this->_request URL]];
+        if ([cookies count] > 0)
+        {
+            NSDictionary *headers = [NSHTTPCookie requestHeaderFieldsWithCookies:cookies];
+            NSEnumerator *enumerator = [headers keyEnumerator];
+            
+            NSString *header;
+            while ((header = [enumerator nextObject]))
+            {
+                [this->_request addValue:[headers valueForKey:header] forHTTPHeaderField:header];
+            }
+        }
+    }
+    
+    /* FIXME!
+     * This code is currently no.op. because it's impossible to create NSURL object
+     * with query and without a leading slash (e.g. http://example.com?id=123 )
+     */
+    if ([[[this->_request URL] fullPath] length] == 0)
+    {
+        NSString *urlString = [[this->_request URL] absoluteString];
+        
+        if ([urlString rangeOfString:@"?"].length > 0)
+        {
+            urlString = [urlString stringByReplacingString:@"?" withString:@"/?"];
+        }
+        else if ([urlString rangeOfString:@"#"].length > 0)
+        {
+            urlString = [urlString stringByReplacingString:@"#" withString:@"/#"];
+        }
+        else
+        {
+            urlString = [urlString stringByAppendingString:@"/"];
+        }
+        
+        NSURL *url = [NSURL URLWithString:urlString];
+        if (url == nil)
+        {
+            [this->_delegate connection:self didFailWithError:[self _errorWithCode:NSURLErrorBadURL description:@"Invalid URL"]];
+            return;
+        }
+        
+        NSMutableURLRequest *request = [this->_request mutableCopy];
+        [this->_request release];
+        [request setURL:url];
+        this->_request = request;
+    }
+    
+    RETAIN_AUTORELEASE(self);
+    
+    /* Required for compatiblity with Apple's implementation */
+    NSURLRequest *request = [this->_delegate connection:self willSendRequest:this->_request redirectResponse:nil];
+    if (this->_delegate != nil && request != nil)
     {
-      this->_request = [request mutableCopyWithZone: [self zone]];
-
-      /* Enrich the request with the appropriate HTTP cookies,
-       * if desired.
-       */
-      if ([this->_request HTTPShouldHandleCookies] == YES)
-	{
-	  NSArray *cookies;
-
-	  cookies = [[NSHTTPCookieStorage sharedHTTPCookieStorage]
-	    cookiesForURL: [this->_request URL]];
-	  if ([cookies count] > 0)
-	    {
-	      NSDictionary	*headers;
-	      NSEnumerator	*enumerator;
-	      NSString		*header;
-
-	      headers = [NSHTTPCookie requestHeaderFieldsWithCookies: cookies];
-	      enumerator = [headers keyEnumerator];
-	      while (nil != (header = [enumerator nextObject]))
-		{
-		  [this->_request addValue: [headers valueForKey: header]
-			forHTTPHeaderField: header];
-		}
-	    }
-	}
-
-      /* According to bug #35686, Cocoa has a bizarre deviation from the
-       * convention that delegates are not retained here.
-       * For compatibility we retain the delegate and release it again
-       * when the operation is over.
-       */
-      this->_delegate = [delegate retain];
-      this->_protocol = [[NSURLProtocol alloc]
-	initWithRequest: this->_request
-	cachedResponse: nil
-	client: (id<NSURLProtocolClient>)self];
-      [this->_protocol startLoading];
-      this->_debug = GSDebugSet(@"NSURLConnection");
+        ASSIGNCOPY(this->_request, request); /* use new request */
+        this->_protocol = [[NSURLProtocol alloc] initWithRequest:this->_request
+                                                  cachedResponse:nil
+                                                          client:(id<NSURLProtocolClient>)self];
+        
+        [this->_protocol startLoading];
     }
-  return self;
 }
 
-@end
+- (void)_stop
+{
+    [this->_protocol stopLoading];
+    DESTROY(this->_protocol);
+}
 
+- (void)cancel
+{
+    [self _stop];
+    DESTROY(this->_delegate);
+}
+
+- (void)finalize
+{
+    [self cancel];
+}
+
+
+@end
 
 
 @implementation NSObject (NSURLConnectionDelegate)
 
-- (void) connection: (NSURLConnection *)connection
-  didCancelAuthenticationChallenge: (NSURLAuthenticationChallenge *)challenge
+- (void)connection:(NSURLConnection *)connection didCancelAuthenticationChallenge:(NSURLAuthenticationChallenge *)challenge
 {
-  return;
+    return;
 }
 
-- (void) connection: (NSURLConnection *)connection
-   didFailWithError: (NSError *)error
+- (void)connection:(NSURLConnection *)connection didFailWithError:(NSError *)error
 {
-  return;
+    return;
 }
 
-- (void) connectionDidFinishLoading: (NSURLConnection *)connection
+- (void)connectionDidFinishLoading:(NSURLConnection *)connection
 {
-  return;
+    return;
 }
 
-- (void) connection: (NSURLConnection *)connection
-  didReceiveAuthenticationChallenge: (NSURLAuthenticationChallenge *)challenge
+- (void)connection:(NSURLConnection *)connection didReceiveAuthenticationChallenge:(NSURLAuthenticationChallenge *)challenge
 {
-  [[challenge sender]
-    continueWithoutCredentialForAuthenticationChallenge: challenge];
+    [[challenge sender] continueWithoutCredentialForAuthenticationChallenge:challenge];
 }
 
-- (void) connection: (NSURLConnection *)connection
-     didReceiveData: (NSData *)data
+- (void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data
 {
-  return;
+    return;
 }
 
-- (void) connection: (NSURLConnection *)connection
- didReceiveResponse: (NSURLResponse *)response
+- (void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response
 {
-  return;
+    return;
 }
 
-- (NSCachedURLResponse *) connection: (NSURLConnection *)connection
-  willCacheResponse: (NSCachedURLResponse *)cachedResponse
+- (NSCachedURLResponse *)connection:(NSURLConnection *)connection willCacheResponse:(NSCachedURLResponse *)cachedResponse
 {
-  return cachedResponse;
+    return cachedResponse;
 }
 
-- (NSURLRequest *) connection: (NSURLConnection *)connection
-	      willSendRequest: (NSURLRequest *)request
-	     redirectResponse: (NSURLResponse *)response
+- (NSURLRequest *)connection:(NSURLConnection *)connection willSendRequest:(NSURLRequest *)request redirectResponse:(NSURLResponse *)response
 {
-  return request;
+    return request;
 }
 
 @end
 
 
-
 @implementation NSURLConnection (NSURLConnectionSynchronousLoading)
 
-+ (NSData *) sendSynchronousRequest: (NSURLRequest *)request
-		  returningResponse: (NSURLResponse **)response
-			      error: (NSError **)error
++ (NSData *)sendSynchronousRequest:(NSURLRequest *)request returningResponse:(NSURLResponse **)response error:(NSError **)error
 {
-  NSData	*data = nil;
-
-  if (0 != response)
+    NSData *data = nil;
+    
+    if (response)
     {
-      *response = nil;
+        *response = nil;
     }
-  if (0 != error)
+    if (error)
     {
-      *error = nil;
+        *error = nil;
     }
-  if ([self canHandleRequest: request] == YES)
+    if ([self canHandleRequest: request] == YES)
     {
-      _NSURLConnectionDataCollector	*collector;
-      NSURLConnection			*conn;
-
-      collector = [_NSURLConnectionDataCollector new];
-      conn = [[self alloc] initWithRequest: request delegate: collector];
-      [collector release];	// retained by connection
-      if (nil != conn)
+        _NSURLConnectionDataCollector *collector;
+        NSURLConnection *connection;
+        
+        collector = [_NSURLConnectionDataCollector new];
+        connection = [[self alloc] initWithRequest:request delegate:collector];
+        if (connection)
         {
-          NSRunLoop	*loop;
-
-          [collector setConnection: conn];
-          loop = [NSRunLoop currentRunLoop];
-          while ([collector done] == NO)
+            NSRunLoop *loop;
+            
+            [collector setConnection:connection];
+            loop = [NSRunLoop currentRunLoop];
+            while ([collector done] == NO)
             {
-              NSDate	*limit;
-
-              limit = [[NSDate alloc] initWithTimeIntervalSinceNow: 1.0];
-              [loop runMode: NSDefaultRunLoopMode beforeDate: limit];
-              RELEASE(limit);
+                NSDate *limit;
+                
+                limit = [[NSDate alloc] initWithTimeIntervalSinceNow:1.0];
+                [loop runMode:NSDefaultRunLoopMode beforeDate:limit];
+                RELEASE(limit);
             }
-          data = [[[collector data] retain] autorelease];
-          if (0 != response)
+            data = [[[collector data] retain] autorelease];
+            if (response)
             {
-              *response = [[[collector response] retain] autorelease];
+                *response = [[[collector response] retain] autorelease];
             }
-          if (0 != error)
+            if (error)
             {
-              *error = [[[collector error] retain] autorelease];
+                *error = [[[collector error] retain] autorelease];
             }
-          [conn release];
         }
+        [connection release];
+        [collector release];
     }
-  return data;
+    return data;
 }
 
 @end
@@ -354,99 +409,80 @@ typedef struct
 
 @implementation	NSURLConnection (URLProtocolClient)
 
-- (void) URLProtocol: (NSURLProtocol *)protocol
-  cachedResponseIsValid: (NSCachedURLResponse *)cachedResponse
+- (void)URLProtocol:(NSURLProtocol *)protocol cachedResponseIsValid:(NSCachedURLResponse *)cachedResponse
 {
-  return;
+    return;
 }
 
-- (void) URLProtocol: (NSURLProtocol *)protocol
-    didFailWithError: (NSError *)error
+- (void)URLProtocol:(NSURLProtocol *)protocol didFailWithError:(NSError *)error
 {
-  [this->_delegate connection: self didFailWithError: error];
+    [this->_delegate connection: self didFailWithError: error];
 }
 
-- (void) URLProtocol: (NSURLProtocol *)protocol
-	 didLoadData: (NSData *)data
+- (void)URLProtocol:(NSURLProtocol *)protocol didLoadData:(NSData *)data
 {
-  [this->_delegate connection: self didReceiveData: data];
+    [this->_delegate connection:self didReceiveData:data];
 }
 
-- (void) URLProtocol: (NSURLProtocol *)protocol
-  didReceiveAuthenticationChallenge: (NSURLAuthenticationChallenge *)challenge
+- (void)URLProtocol: (NSURLProtocol *)protocol didReceiveAuthenticationChallenge:(NSURLAuthenticationChallenge *)challenge
 {
-  [this->_delegate connection: self
-    didReceiveAuthenticationChallenge: challenge];
+    [this->_delegate connection:self didReceiveAuthenticationChallenge:challenge];
 }
 
-- (void) URLProtocol: (NSURLProtocol *)protocol
-  didReceiveResponse: (NSURLResponse *)response
-  cacheStoragePolicy: (NSURLCacheStoragePolicy)policy
+- (void)URLProtocol:(NSURLProtocol *)protocol didReceiveResponse:(NSURLResponse *)response cacheStoragePolicy:(NSURLCacheStoragePolicy)policy
 {
-  [this->_delegate connection: self didReceiveResponse: response];
-  if (policy == NSURLCacheStorageAllowed
-    || policy == NSURLCacheStorageAllowedInMemoryOnly)
+    [this->_delegate connection:self didReceiveResponse:response];
+    if (policy == NSURLCacheStorageAllowed || policy == NSURLCacheStorageAllowedInMemoryOnly)
     {
-      // FIXME ... cache response here?
+        /* FIXME ... cache response here? */
     }
 }
 
-- (void) URLProtocol: (NSURLProtocol *)protocol
-  wasRedirectedToRequest: (NSURLRequest *)request
-  redirectResponse: (NSURLResponse *)redirectResponse
+- (void)URLProtocol:(NSURLProtocol *)protocol wasRedirectedToRequest:(NSURLRequest *)request redirectResponse:(NSURLResponse *)redirectResponse
 {
-  if (this->_debug)
+    RETAIN_AUTORELEASE(self);
+    
+    if (this->_debug)
     {
-      NSLog(@"%@ tell delegate %@ about redirect to %@ as a result of %@",
-        self, this->_delegate, request, redirectResponse);
+        NSLog(@"%@ tell delegate %@ about redirect to %@ as a result of %@", self, this->_delegate, request, redirectResponse);
     }
-  request = [this->_delegate connection: self
-			willSendRequest: request
-		       redirectResponse: redirectResponse];
-  if (this->_protocol == nil)
+    request = [this->_delegate connection:self willSendRequest:request redirectResponse:redirectResponse];
+    if (this->_protocol != nil)
     {
-      if (this->_debug)
-	{
-          NSLog(@"%@ delegate cancelled request", self);
-	}
-      /* Our protocol is nil, so we have been cancelled by the delegate.
-       */
-      return;
-    }
-  if (request != nil)
-    {
-      if (this->_debug)
-	{
-          NSLog(@"%@ delegate allowed redirect to %@", self, request);
-	}
-      /* Follow the redirect ... stop the old load and start a new one.
-       */
-      [this->_protocol stopLoading];
-      DESTROY(this->_protocol);
-      ASSIGNCOPY(this->_request, request);
-      this->_protocol = [[NSURLProtocol alloc]
-	initWithRequest: this->_request
-	cachedResponse: nil
-	client: (id<NSURLProtocolClient>)self];
-      [this->_protocol startLoading];
+        if (request != nil)
+        {
+            if (this->_debug)
+            {
+                NSLog(@"%@ delegate allowed redirect to %@", self, request);
+            }
+            /* follow the redirect ... stop the old load and start a new one */
+            [self _stop];
+            ASSIGNCOPY(this->_request, request);
+            [self start];
+        }
+        else if (this->_debug)
+        {
+            NSLog(@"%@ delegate cancelled redirect", self);
+        }
     }
-  else if (this->_debug)
+    else
     {
-      NSLog(@"%@ delegate cancelled redirect", self);
+        /* our protocol is nil, so we have been cancelled by the delegate */
+        if (this->_debug)
+        {
+            NSLog(@"%@ delegate cancelled request", self);
+        }
     }
 }
 
-- (void) URLProtocolDidFinishLoading: (NSURLProtocol *)protocol
+- (void)URLProtocolDidFinishLoading:(NSURLProtocol *)protocol
 {
-  [this->_delegate connectionDidFinishLoading: self];
+    [this->_delegate connectionDidFinishLoading:self];
 }
 
-- (void) URLProtocol: (NSURLProtocol *)protocol
-  didCancelAuthenticationChallenge: (NSURLAuthenticationChallenge *)challenge
+- (void)URLProtocol:(NSURLProtocol *)protocol didCancelAuthenticationChallenge:(NSURLAuthenticationChallenge *)challenge
 {
-  [this->_delegate connection: self
-  didCancelAuthenticationChallenge: challenge];
+    [this->_delegate connection:self didCancelAuthenticationChallenge:challenge];
 }
 
-@end
-
+@end
\ No newline at end of file
diff --git a/Source/NSURLHandle.m b/Source/NSURLHandle.m
index 2641a92..ad4f8a0 100644
--- a/Source/NSURLHandle.m
+++ b/Source/NSURLHandle.m
@@ -216,7 +216,7 @@ static Class		NSURLHandleClass = 0;
  */
 + (Class) URLHandleClassForURL: (NSURL*)url
 {
-  unsigned	count;
+  NSUInteger	count;
   Class		c = 0;
 
   [registryLock lock];
diff --git a/Source/NSURLProtectionSpace.m b/Source/NSURLProtectionSpace.m
index afac9cd..914a3de 100644
--- a/Source/NSURLProtectionSpace.m
+++ b/Source/NSURLProtectionSpace.m
@@ -44,7 +44,7 @@ NSString * const NSURLAuthenticationMethodHTTPDigest
 // Internal data storage
 typedef struct {
   NSString	*host;
-  int		port;
+  NSInteger port;
   NSString	*protocol;
   NSString	*realm;
   NSString	*proxyType;		// Not retained
diff --git a/Source/NSURLProtocol.m b/Source/NSURLProtocol.m
index 0c8ec9c..908c191 100644
--- a/Source/NSURLProtocol.m
+++ b/Source/NSURLProtocol.m
@@ -26,6 +26,7 @@
 #import "common.h"
 
 #define	EXPOSE_NSURLProtocol_IVARS	1
+#import "Foundation/NSBundle.h"
 #import "Foundation/NSError.h"
 #import "Foundation/NSHost.h"
 #import "Foundation/NSNotification.h"
@@ -110,7 +111,7 @@ static NSLock		*pairLock = nil;
 + (void) purge: (NSNotification*)n
 {
   NSDate	*now = [NSDate date];
-  unsigned	count;
+  NSUInteger	count;
 
   [pairLock lock];
   count = [pairCache count];
@@ -184,7 +185,7 @@ static NSLock		*pairLock = nil;
 
 - (id) initWithHost: (NSHost*)h port: (uint16_t)p forSSL: (BOOL)s;
 {
-  unsigned		count;
+  NSUInteger		count;
   NSDate		*now;
 
   now = [NSDate date];
@@ -259,33 +260,58 @@ static NSLock		*pairLock = nil;
 @interface _NSFileURLProtocol : NSURLProtocol
 @end
 
-@interface _NSHTTPURLProtocol : NSURLProtocol
-  <NSURLAuthenticationChallengeSender>
-{
-  GSMimeParser		*_parser;	// Parser handling incoming data
-  unsigned		_parseOffset;	// Bytes of body loaded in parser.
-  float			_version;	// The HTTP version in use.
-  int			_statusCode;	// The HTTP status code returned.
-  NSInputStream		*_body;		// for sending the body
-  unsigned		_writeOffset;	// Request data to write
-  NSData		*_writeData;	// Request bytes written so far
-  BOOL			_complete;
-  BOOL			_debug;
-  BOOL			_isLoading;
-  BOOL			_shouldClose;
-  NSURLAuthenticationChallenge	*_challenge;
-  NSURLCredential		*_credential;
-  NSHTTPURLResponse		*_response;
-}
-- (void) setDebug: (BOOL)flag;
+enum {
+    NSHTTPURLProtocolStateStopped = 0,
+    NSHTTPURLProtocolStateStarted,
+    NSHTTPURLProtocolStateHasHeaders,
+    NSHTTPURLProtocolStateFormedResponse,
+    NSHTTPURLProtocolStateAwaitsHandshake,
+    NSHTTPURLProtocolStateReceivedChallenge,
+    NSHTTPURLProtocolStateRepliesToChallenge,
+    NSHTTPURLProtocolStateReceivesContent,
+    NSHTTPURLProtocolStateFinished
+};
+typedef uint8_t NSHTTPURLProtocolState;
+
+@interface _NSHTTPURLProtocol : NSURLProtocol<NSURLAuthenticationChallengeSender>
+{
+    GSMimeParser    *_parser;       // Parser handling incoming data
+    NSUInteger      _parseOffset;	// Bytes of body loaded in parser.
+    float           _version;       // The HTTP version in use.
+    int             _statusCode;	// The HTTP status code returned.
+    NSInputStream   *_body;         // for sending the body
+    NSUInteger		_writeOffset;	// Request data to write
+    NSData          *_writeData;	// Request bytes written so far
+    BOOL            _eof;
+    BOOL            _debug;
+    BOOL            _shouldClose;
+    NSHTTPURLProtocolState          _state;
+    NSURLAuthenticationChallenge    *_challenge;
+    NSURLCredential                 *_credential;
+    NSHTTPURLResponse               *_response;
+}
+
+- (void)setDebug:(BOOL)flag;
+
 @end
 
-@interface _NSHTTPSURLProtocol : _NSHTTPURLProtocol
+@interface _NSHTTPURLProtocol (Private)
+
+- (void)_processNewData;
+- (BOOL)_processHeadersAndCreateReditrectedRequest:(NSURLRequest **)aRequest error:(NSError **)error;
+- (NSURLAuthenticationChallenge *)_handleAuthenticationChallenge;
+- (BOOL)_fulfillAuthenticationRequest:(NSURLRequest **)request error:(NSError **)error;
+- (NSData *)_handleBody;
+- (void)_handleFinish;
+
 @end
 
 @interface _NSDataURLProtocol : NSURLProtocol
 @end
 
+@interface _NSHTTPSURLProtocol : _NSHTTPURLProtocol
+@end
+
 
 // Internal data storage
 typedef struct {
@@ -340,204 +366,192 @@ static NSURLProtocol	*placeholder = nil;
 
 + (id) allocWithZone: (NSZone*)z
 {
-  NSURLProtocol	*o;
-
-  if ((self == abstractClass) && (z == 0 || z == NSDefaultMallocZone()))
+    NSURLProtocol	*o;
+    
+    if ((self == abstractClass) && (z == 0 || z == NSDefaultMallocZone()))
     {
-      /* Return a default placeholder instance to avoid the overhead of
-       * creating and destroying instances of the abstract class.
-       */
-      o = placeholder;
+        /* return a default placeholder instance to avoid the overhead of creating and destroying instances of the abstract class */
+        o = placeholder;
     }
-  else
+    else
     {
-      /* Create and return an instance of the concrete subclass.
-       */
-      o = (NSURLProtocol*)NSAllocateObject(self, 0, z);
+        /* Create and return an instance of the concrete subclass */
+        o = (NSURLProtocol*)NSAllocateObject(self, 0, z);
     }
-  return o;
+    return o;
 }
 
 + (void) initialize
 {
-  if (registered == nil)
+    if (registered == nil)
     {
-      abstractClass = [NSURLProtocol class];
-      placeholderClass = [NSURLProtocolPlaceholder class];
-      placeholder = (NSURLProtocol*)NSAllocateObject(placeholderClass, 0,
-	NSDefaultMallocZone());
-      registered = [NSMutableArray new];
-      regLock = [NSLock new];
-      [self registerClass: [_NSHTTPURLProtocol class]];
-      [self registerClass: [_NSHTTPSURLProtocol class]];
-      [self registerClass: [_NSFTPURLProtocol class]];
-      [self registerClass: [_NSFileURLProtocol class]];
-      [self registerClass: [_NSAboutURLProtocol class]];
-      [self registerClass: [_NSDataURLProtocol class]];
+        abstractClass = [NSURLProtocol class];
+        placeholderClass = [NSURLProtocolPlaceholder class];
+        
+        placeholder = (NSURLProtocol*)NSAllocateObject(placeholderClass, 0, NSDefaultMallocZone());
+        placeholder = [NSObject leakRetained:placeholder];
+        
+        registered = [NSObject leakRetained:[NSMutableArray new]];
+        regLock = [NSObject leakRetained:[NSLock new]];
+        
+        [self registerClass: [_NSHTTPURLProtocol class]];
+        [self registerClass: [_NSHTTPSURLProtocol class]];
+        [self registerClass: [_NSFTPURLProtocol class]];
+        [self registerClass: [_NSFileURLProtocol class]];
+        [self registerClass: [_NSAboutURLProtocol class]];
+        [self registerClass: [_NSDataURLProtocol class]];
     }
 }
 
 + (id) propertyForKey: (NSString *)key inRequest: (NSURLRequest *)request
 {
-  return [request _propertyForKey: key];
+    return [request _propertyForKey: key];
 }
 
 + (BOOL) registerClass: (Class)protocolClass
 {
-  if ([protocolClass isSubclassOfClass: [NSURLProtocol class]] == YES)
+    if ([protocolClass isSubclassOfClass: [NSURLProtocol class]] == YES)
     {
-      [regLock lock];
-      [registered addObject: protocolClass];
-      [regLock unlock];
-      return YES;
+        [regLock lock];
+        [registered addObject: protocolClass];
+        [regLock unlock];
+        return YES;
     }
-  return NO;
+    return NO;
 }
 
 + (Class) _classToHandleRequest:(NSURLRequest *)request
 {
-  Class protoClass = nil;
-  int count;
-  [regLock lock];
-
-  count = [registered count];
-  while (count-- > 0)
+    Class protoClass = nil;
+    NSInteger count;
+    [regLock lock];
+    
+    count = [registered count];
+    while (count-- > 0)
     {
-      Class	proto = [registered objectAtIndex: count];
-
-      if ([proto canInitWithRequest: request] == YES)
-	{
-	  protoClass = proto;
-	  break;
-	}
+        Class	proto = [registered objectAtIndex: count];
+        
+        if ([proto canInitWithRequest: request] == YES)
+        {
+            protoClass = proto;
+            break;
+        }
     }
-  [regLock unlock];
-  return protoClass;
+    [regLock unlock];
+    return protoClass;
 }
 
 
 + (void) setProperty: (id)value
-	      forKey: (NSString *)key
-	   inRequest: (NSMutableURLRequest *)request
+              forKey: (NSString *)key
+           inRequest: (NSMutableURLRequest *)request
 {
-  [request _setProperty: value forKey: key];
+    [request _setProperty: value forKey: key];
 }
 
 + (void) unregisterClass: (Class)protocolClass
 {
-  [regLock lock];
-  [registered removeObjectIdenticalTo: protocolClass];
-  [regLock unlock];
+    [regLock lock];
+    [registered removeObjectIdenticalTo: protocolClass];
+    [regLock unlock];
 }
 
 - (NSCachedURLResponse *) cachedResponse
 {
-  return this->cachedResponse;
+    return this->cachedResponse;
 }
 
 - (id <NSURLProtocolClient>) client
 {
-  return this->client;
+    return this->client;
 }
 
 - (void) dealloc
 {
-  if (this != 0)
+    if (this != 0)
     {
-      [self stopLoading];
-      if (this->input != nil)
-	{
-	  [this->input setDelegate: nil];
-	  [this->output setDelegate: nil];
-	  [this->input removeFromRunLoop: [NSRunLoop currentRunLoop]
-				 forMode: NSDefaultRunLoopMode];
-	  [this->output removeFromRunLoop: [NSRunLoop currentRunLoop]
-				  forMode: NSDefaultRunLoopMode];
-          [this->input close];
-          [this->output close];
-          DESTROY(this->input);
-          DESTROY(this->output);
-	}
-      DESTROY(this->cachedResponse);
-      DESTROY(this->request);
+        [self stopLoading];
+        
+        DESTROY(this->cachedResponse);
+        DESTROY(this->request);
 #if	USE_ZLIB
-      if (this->compressing == YES)
-	{
-	  deflateEnd(&this->z);
-	}
-      else if (this->decompressing == YES)
-	{
-	  inflateEnd(&this->z);
-	}
-      DESTROY(this->compressed);
+        if (this->compressing == YES)
+        {
+            deflateEnd(&this->z);
+        }
+        else if (this->decompressing == YES)
+        {
+            inflateEnd(&this->z);
+        }
+        DESTROY(this->compressed);
 #endif
-      NSZoneFree([self zone], this);
-      _NSURLProtocolInternal = 0;
+        NSZoneFree([self zone], this);
+        _NSURLProtocolInternal = 0;
     }
-  [super dealloc];
+    [super dealloc];
 }
 
 - (NSString*) description
 {
-  return [NSString stringWithFormat:@"%@ %@",
-    [super description], this ? (id)this->request : nil];
+    return [NSString stringWithFormat:@"%@ %@",
+            [super description], this ? (id)this->request : nil];
 }
 
 - (id) init
 {
-  if ((self = [super init]) != nil)
+    if ((self = [super init]) != nil)
     {
-      Class	c = object_getClass(self);
-
-      if (c != abstractClass && c != placeholderClass)
-	{
-	  _NSURLProtocolInternal = NSZoneCalloc([self zone],
-	    1, sizeof(Internal));
-	}
+        Class	c = object_getClass(self);
+        
+        if (c != abstractClass && c != placeholderClass)
+        {
+            _NSURLProtocolInternal = NSZoneCalloc([self zone],
+                                                  1, sizeof(Internal));
+        }
     }
-  return self;
+    return self;
 }
 
 - (id) initWithRequest: (NSURLRequest *)request
-	cachedResponse: (NSCachedURLResponse *)cachedResponse
-		client: (id <NSURLProtocolClient>)client
+        cachedResponse: (NSCachedURLResponse *)cachedResponse
+                client: (id <NSURLProtocolClient>)client
 {
-  Class	c = object_getClass(self);
-
-  if (c == abstractClass || c == placeholderClass)
+    Class	c = object_getClass(self);
+    
+    if (c == abstractClass || c == placeholderClass)
     {
-      unsigned	count;
-
-      DESTROY(self);
-      [regLock lock];
-      count = [registered count];
-      while (count-- > 0)
+        NSUInteger	count;
+        
+        DESTROY(self);
+        [regLock lock];
+        count = [registered count];
+        while (count-- > 0)
         {
-	  Class	proto = [registered objectAtIndex: count];
-
-	  if ([proto canInitWithRequest: request] == YES)
-	    {
-	      self = [proto alloc];
-	      break;
-	    }
-	}
-      [regLock unlock];
-      return [self initWithRequest: request
-		    cachedResponse: cachedResponse
-			    client: client];
+            Class	proto = [registered objectAtIndex: count];
+            
+            if ([proto canInitWithRequest: request] == YES)
+            {
+                self = [proto alloc];
+                break;
+            }
+        }
+        [regLock unlock];
+        return [self initWithRequest: request
+                      cachedResponse: cachedResponse
+                              client: client];
     }
-  if ((self = [self init]) != nil)
+    if ((self = [self init]) != nil)
     {
-      this->request = [request copy];
-      this->cachedResponse = RETAIN(cachedResponse);
-      this->client = client;	// Not retained
+        this->request = [request copy];
+        this->cachedResponse = RETAIN(cachedResponse);
+        this->client = client;	// Not retained
     }
-  return self;
+    return self;
 }
 
 - (NSURLRequest *) request
 {
-  return this->request;
+    return this->request;
 }
 
 /* This method is here so that it's safe to set debug on any NSURLProtocol
@@ -545,7 +559,7 @@ static NSURLProtocol	*placeholder = nil;
  */
 - (void) setDebug: (BOOL)flag
 {
-  return;
+    return;
 }
 
 @end
@@ -587,1195 +601,1108 @@ static NSURLProtocol	*placeholder = nil;
 
 
 
+@implementation _NSHTTPURLProtocol
 
++ (BOOL)canInitWithRequest:(NSURLRequest *)request
+{
+    return [[[request URL] scheme] isEqualToString:@"http"];
+}
 
-@implementation _NSHTTPURLProtocol
++ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request
+{
+    return request;
+}
 
-+ (BOOL) canInitWithRequest: (NSURLRequest*)request
+- (id)init
 {
-  return [[[request URL] scheme] isEqualToString: @"http"];
+    if (self = [super init])
+    {
+        _parser = nil;
+        _body = nil;
+        _writeData = nil;
+        _challenge = nil;
+        _credential = nil;
+        _response = nil;
+        _state = NSHTTPURLProtocolStateStopped;
+        _debug = GSDebugSet(@"NSURLProtocol");
+    }
+    return self;
 }
 
-+ (NSURLRequest*) canonicalRequestForRequest: (NSURLRequest*)request
+- (void)dealloc
 {
-  return request;
+    [_parser release];  /* received headers */
+    [_body release];    /* for sending the body */
+    [_writeData release];
+    [_challenge release];
+    [_credential release];
+    [_response release];
+    [super dealloc];
 }
 
-- (void) cancelAuthenticationChallenge: (NSURLAuthenticationChallenge*)c
+- (void)cancelAuthenticationChallenge:(NSURLAuthenticationChallenge *)c
 {
-  if (c == _challenge)
+    if (c == _challenge)
     {
-      DESTROY(_challenge);	// We should cancel the download
+        DESTROY(_challenge); /* We should cancel the download */
     }
 }
 
-- (void) continueWithoutCredentialForAuthenticationChallenge:
-  (NSURLAuthenticationChallenge*)c
+- (void)continueWithoutCredentialForAuthenticationChallenge:(NSURLAuthenticationChallenge *)c
 {
-  if (c == _challenge)
+    if (c == _challenge)
     {
-      DESTROY(_credential);	// We download the challenge page
+        DESTROY(_credential); /* We download the challenge page */
     }
 }
 
-- (void) dealloc
+- (void)setDebug:(BOOL)flag
 {
-  [_parser release];			// received headers
-  [_body release];			// for sending the body
-  [_response release];
-  [_credential release];
-  [super dealloc];
+    _debug = flag;
 }
 
-- (id) init
+- (NSURLRequestCachePolicy)_resolveCachePolicy
 {
-  if (nil != (self = [super init]))
+    NSURLRequestCachePolicy policy = [this->request cachePolicy];
+    if (policy == (NSURLCacheStoragePolicy)NSURLRequestUseProtocolCachePolicy)
     {
-      _debug = GSDebugSet(@"NSURLProtocol");
+        if ([self isKindOfClass: [_NSHTTPSURLProtocol class]])
+        {
+            /* For HTTPS we should not allow caching unless the request explicitly wants it */
+            policy = NSURLCacheStorageNotAllowed;
+        }
+        else
+        {
+            /* For HTTP we allow caching unless the request specifically denies it */
+            policy = NSURLCacheStorageAllowed;
+        }
     }
-  return self;
+    return policy;
 }
 
-- (void) setDebug: (BOOL)flag
+NS_INLINE void
+PostponeSelector(id self, SEL _cmd, id argument)
 {
-  _debug = flag;
+    [[NSRunLoop currentRunLoop] performSelector:_cmd target:self argument:argument order:0 modes:[NSArray arrayWithObject:NSDefaultRunLoopMode]];
 }
 
-- (void) startLoading
+- (void)_wasRedirectedToRequest:(NSURLRequest *)aRequest
 {
-  static NSDictionary *methods = nil;
-
-  if (methods == nil)
-    {
-      methods = [[NSDictionary alloc] initWithObjectsAndKeys: 
-	self, @"HEAD",
-	self, @"GET",
-	self, @"POST",
-	self, @"PUT",
-	self, @"DELETE",
-	self, @"TRACE",
-	self, @"OPTIONS",
-	self, @"CONNECT",
-	nil];
-      }
-  if ([methods objectForKey: [this->request HTTPMethod]] == nil)
-    {
-      NSLog(@"Invalid HTTP Method: %@", this->request);
-      [self stopLoading];
-      [this->client URLProtocol: self didFailWithError:
-	[NSError errorWithDomain: @"Invalid HTTP Method"
-			    code: 0
-			userInfo: nil]];
-      return;
+    PostponeSelector(self, @selector(_processNewData), nil);
+    [this->client URLProtocol:self wasRedirectedToRequest:aRequest redirectResponse:_response];
+}
+
+- (void)_didReceiveAuthenticationChallenge:(NSURLAuthenticationChallenge *)aChallenge
+{
+    PostponeSelector(self, @selector(_processNewData), nil);
+    [this->client URLProtocol:self didReceiveAuthenticationChallenge:aChallenge];
+}
+
+- (void)_didReceiveResponse
+{
+    PostponeSelector(self, @selector(_processNewData), nil);
+    [this->client URLProtocol:self didReceiveResponse:_response cacheStoragePolicy:(NSURLCacheStoragePolicy)[self _resolveCachePolicy]];
+}
+
+- (void)_didLoadData:(NSData *)data
+{
+    PostponeSelector(self, @selector(_processNewData), nil);
+    [this->client URLProtocol:self didLoadData:data];
+}
+
+- (void)_didFinishLoading
+{
+    [this->client URLProtocolDidFinishLoading:self];
+}
+
+- (void)_didFailWithError:(NSError *)anError
+{
+    NSURL *url = [this->request URL];
+    NSString *urlString = [url absoluteString];
+    NSMutableDictionary *userInfo = [[anError userInfo] mutableCopy];
+    
+    [userInfo setObject:url forKey:NSURLErrorKey];
+    [userInfo setObject:url forKey:@"NSURLErrorFailingURLErrorKey"]; /* deprecated in Mac' Foundation */
+    [userInfo setObject:urlString forKey:NSErrorFailingURLStringKey];
+    [userInfo setObject:urlString forKey:@"NSURLErrorFailingURLStringErrorKey"]; /* deprecated in Mac' Foundation */
+    
+    NSError *error = [NSError errorWithDomain:[anError domain] code:[anError code] userInfo:userInfo];
+    [userInfo release];
+    
+    [self stopLoading];
+    [this->client URLProtocol:self didFailWithError:error];
+}
+
+- (NSError *)_errorWithCode:(NSInteger)aCode description:(NSString *)aDescription
+{
+    NSDictionary *userInfo = [NSDictionary dictionaryWithObject:NSLocalizedString(aDescription, @"") forKey:NSLocalizedDescriptionKey];
+    return [NSError errorWithDomain:NSURLErrorDomain code:aCode userInfo:userInfo];
+}
+
+- (void)_didFailWithErrorDescription:(NSString *)aDescription code:(NSInteger)aCode
+{
+    [self _didFailWithError:[self _errorWithCode:aCode description:aDescription]];
+}
+
+- (void)_didFailWithErrorDescription:(NSString *)aDescription
+{
+    [self _didFailWithErrorDescription:aDescription code:NSURLErrorUnknown];
+}
+
+- (void)startLoading
+{
+    static NSDictionary *methods = nil;
+    
+    if (methods == nil)
+    {
+        methods = [[NSDictionary alloc] initWithObjectsAndKeys: 
+                   self, @"HEAD",
+                   self, @"GET",
+                   self, @"POST",
+                   self, @"PUT",
+                   self, @"DELETE",
+                   self, @"TRACE",
+                   self, @"OPTIONS",
+                   self, @"CONNECT",
+                   nil];
     }
-  if (_isLoading == YES)
+    if ([methods objectForKey:[this->request HTTPMethod]] == nil)
     {
-      NSLog(@"startLoading when load in progress");
-      return;
+        NSLog(@"Invalid HTTP Method: %@", this->request);
+        [self _didFailWithErrorDescription:@"Invalid HTTP Method"];
+        return;
     }
-
-  _statusCode = 0;	/* No status returned yet.	*/
-  _isLoading = YES;
-  _complete = NO;
-
-  /* Perform a redirect if the path is empty.
-   * As per MacOs-X documentation.
-   */
-  if ([[[this->request URL] fullPath] length] == 0)
+    if (_state != NSHTTPURLProtocolStateStopped)
     {
-      NSString		*s = [[this->request URL] absoluteString];
-      NSURL		*url;
+        NSLog(@"-[NSURLProtocol startLoading] can not be called while load is in progress");
+        return;
+    }
+    
+    _statusCode = 0;	/* No status returned yet.	*/
+    _eof = NO;
+    _state = NSHTTPURLProtocolStateStarted;
+    _response = nil;
+    
+    if (0 && this->cachedResponse)
+    {
+        /* todo: handle cachedResponse */
+    }
 
-      if ([s rangeOfString: @"?"].length > 0)
-        {
-	  s = [s stringByReplacingString: @"?" withString: @"/?"];
-	}
-      else if ([s rangeOfString: @"#"].length > 0)
+    NSURL *url = [this->request URL];
+    NSHost *host = [NSHost hostWithName:[url host]];
+    int	port = [[url port] intValue];
+    
+    _parseOffset = 0;
+    DESTROY(_parser);
+    
+    if (host == nil)
+    {
+        host = [NSHost hostWithAddress:[url host]];	/* try dotted notation */
+    }
+    if (host == nil)
+    {
+        host = [NSHost hostWithAddress:@"127.0.0.1"]; /* final default */
+    }
+    if (port == 0)
+    {
+        /* default if not specified */
+        port = [[url scheme] isEqualToString:@"https"] ? 443 : 80;
+    }
+    
+    /* todo: support keep-alive, check if we already have a connection to this host */
+    
+    [NSStream getStreamsToHost:host
+                          port:port
+                   inputStream:&this->input
+                  outputStream:&this->output];
+    if (!this->input || !this->output)
+    {
+        if (_debug == YES)
         {
-	  s = [s stringByReplacingString: @"#" withString: @"/#"];
-	}
-      else
+            NSLog(@"%@ did not create streams for %@:%@", self, host, [url port]);
+        }
+        [self _didFailWithErrorDescription:@"Can not find host" code:NSURLErrorCannotFindHost]; /* todo: specify host in error description */
+        return;
+    }
+#if	!GS_WITH_GC
+    [this->input retain];
+    [this->output retain];
+#endif
+    if ([[url scheme] isEqualToString: @"https"] == YES)
+    {
+        static NSArray *keys;
+        NSUInteger count;
+        
+        [this->input setProperty:NSStreamSocketSecurityLevelNegotiatedSSL forKey:NSStreamSocketSecurityLevelKey];
+        [this->output setProperty:NSStreamSocketSecurityLevelNegotiatedSSL forKey:NSStreamSocketSecurityLevelKey];
+        if (nil == keys)
         {
-          s = [s stringByAppendingString: @"/"];
-	}
-      url = [NSURL URLWithString: s];
-      if (url == nil)
-	{
-	  NSError	*e;
-
-	  e = [NSError errorWithDomain: @"Invalid redirect request"
-				  code: 0
-			      userInfo: nil];
-	  [self stopLoading];
-	  [this->client URLProtocol: self
-		   didFailWithError: e];
-	}
-      else
-	{
-	  NSMutableURLRequest	*request;
-
-	  request = [[this->request mutableCopy] autorelease];
-	  [request setURL: url];
-	  [this->client URLProtocol: self
-	     wasRedirectedToRequest: request
-		   redirectResponse: nil];
-	}
-      if (NO == _isLoading)
+            keys = [[NSArray alloc] initWithObjects:
+                    GSTLSCAFile,
+                    GSTLSCertificateFile,
+                    GSTLSCertificateKeyFile,
+                    GSTLSCertificateKeyPassword,
+                    GSTLSDebug,
+                    GSTLSPriority,
+                    GSTLSRemoteHosts,
+                    GSTLSRevokeFile,
+                    GSTLSVerify,
+                    nil];
+        }
+        count = [keys count];
+        while (count-- > 0)
         {
-	  return;	// Loading cancelled
-	}
-      if (nil != this->input)
-	{
-	  return;	// Following redirection
-	}
-      // Fall through to continue original connect.
+            NSString *key = [keys objectAtIndex:count];
+            NSString *str = [this->request _propertyForKey:key];
+            
+            if (nil != str)
+            {
+                [this->output setProperty:str forKey:key];
+            }
+        }
+        if (_debug) {
+            [this->output setProperty:@"YES" forKey:GSTLSDebug];
+        }
     }
+    [this->input setDelegate:self];
+    [this->output setDelegate:self];
+    [this->input scheduleInRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];
+    [this->output scheduleInRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];
+    [this->input open];
+    [this->output open];
+}
 
-  if (0 && this->cachedResponse)
+- (void)stopLoading
+{    
+    if (_debug == YES)
     {
+        NSLog(@"%@ stopLoading", self);
     }
-  else
+    
+    [[NSRunLoop currentRunLoop] cancelPerformSelectorsWithTarget:self];
+    _state = NSHTTPURLProtocolStateStopped;
+    DESTROY(_writeData);
+    
+    /* todo: support keep-alive, check _shouldClose */
+    
+    [this->input setDelegate:nil];
+    [this->output setDelegate:nil];
+    [this->input removeFromRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];
+    [this->output removeFromRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];
+    [this->input close];
+    [this->output close];
+    DESTROY(this->input);
+    DESTROY(this->output);
+}
+
+- (void)_got:(NSStream *)stream
+{
+    uint8_t buffer[BUFSIZ * 64];
+    NSInteger readCount = [(NSInputStream *)stream read:buffer maxLength:sizeof(buffer)];
+    if (readCount < 0)
     {
-      NSURL	*url = [this->request URL];
-      NSHost	*host = [NSHost hostWithName: [url host]];
-      int	port = [[url port] intValue];
-
-      _parseOffset = 0;
-      DESTROY(_parser);
-
-      if (host == nil)
+        if ([stream streamStatus] == NSStreamStatusError)
         {
-	  host = [NSHost hostWithAddress: [url host]];	// try dotted notation
-	}
-      if (host == nil)
+            NSError *error = [stream streamError];
+            if (_debug)
+            {
+                NSLog(@"%@ receive error %@", self, error);
+            }
+            [self _didFailWithError:error];
+        }
+        return;
+    }
+    if (_debug)
+    {
+        NSLog(@"%@ read %ld bytes: '%*.*s'", self, (long)readCount, (int)readCount, (int)readCount, buffer);
+    }
+    
+    if (_parser == nil)
+    {
+        _parser = [GSMimeParser new];
+        [_parser setIsHttp];
+    }
+    
+    NSData *data = [NSData dataWithBytes:buffer length:readCount];
+    if ([_parser parse:data] == NO && [_parser isComplete] == NO)
+    {
+        if (_debug == YES)
         {
-	  host = [NSHost hostWithAddress: @"127.0.0.1"];	// final default
-	}
-      if (port == 0)
+            NSLog(@"%@ HTTP parse failure - %@", self, _parser);
+        }
+        [self _didFailWithErrorDescription:@"Parse error" code:NSURLErrorBadServerResponse];
+        return;
+    }
+    
+    _eof = readCount == 0;
+    if (_eof && ![_parser isComplete])
+    {
+        /* Premature EOF, the read failed ... dropped, but parsing is not complete */
+        /* The request was sent, so we can't know whether it was lost in the network or the remote end received it and the response was lost */
+        if (_debug == YES)
         {
-	  // default if not specified
-	  port = [[url scheme] isEqualToString: @"https"] ? 443 : 80;
-	}
+            NSLog(@"%@ HTTP response not received - %@", self, _parser);
+        }
+        [self _didFailWithErrorDescription:@"Failed to receive data" code:NSURLErrorCannotLoadFromNetwork];
+        return;
+    }
+    
+    [self _processNewData];
+}
 
-      [NSStream getStreamsToHost: host
-			    port: port
-		     inputStream: &this->input
-		    outputStream: &this->output];
-      if (!this->input || !this->output)
-	{
-	  if (_debug == YES)
-	    {
-	      NSLog(@"%@ did not create streams for %@:%@",
-		self, host, [url port]);
-	    }
-	  [self stopLoading];
-	  [this->client URLProtocol: self didFailWithError:
-	    [NSError errorWithDomain: @"can't connect" code: 0 userInfo: 
-	      [NSDictionary dictionaryWithObjectsAndKeys: 
-		url, @"NSErrorFailingURLKey",
-		host, @"NSErrorFailingURLStringKey",
-		@"can't find host", @"NSLocalizedDescription",
-		nil]]];
-	  return;
-	}
-#if	!GS_WITH_GC
-      [this->input retain];
-      [this->output retain];
-#endif
-      if ([[url scheme] isEqualToString: @"https"] == YES)
+/* 
+ * NOTE:
+ * this method returns immediately after calling any method of the client,
+ * and reschedules itself via -[NSRunLoop performSelector:target:argument:order:modes:],
+ * this is done to ensure that client can safely release protocol object while being called by it
+ */
+- (void)_processNewData
+{
+    /* check if the client cancelled URL loading */
+    if (_state == NSHTTPURLProtocolStateStopped)
+    {
+        return;
+    }
+    NSError *error = nil;
+    switch (_state) {
+        case NSHTTPURLProtocolStateStarted:
         {
-          static NSArray        *keys;
-          NSUInteger            count;
-
-          [this->input setProperty: NSStreamSocketSecurityLevelNegotiatedSSL
-                            forKey: NSStreamSocketSecurityLevelKey];
-          [this->output setProperty: NSStreamSocketSecurityLevelNegotiatedSSL
-                             forKey: NSStreamSocketSecurityLevelKey];
-          if (nil == keys)
+            if ([_parser isInHeaders])
             {
-              keys = [[NSArray alloc] initWithObjects:
-                GSTLSCAFile,
-                GSTLSCertificateFile,
-                GSTLSCertificateKeyFile,
-                GSTLSCertificateKeyPassword,
-                GSTLSDebug,
-                GSTLSPriority,
-                GSTLSRemoteHosts,
-                GSTLSRevokeFile,
-                GSTLSVerify,
-                nil];
+                break;
             }
-          count = [keys count];
-          while (count-- > 0)
-            {
-              NSString      *key = [keys objectAtIndex: count];
-              NSString      *str = [this->request _propertyForKey: key];
-
-              if (nil != str)
-                {
-                  [this->output setProperty: str forKey: key];
+            _state = NSHTTPURLProtocolStateHasHeaders;
+        }
+        case NSHTTPURLProtocolStateHasHeaders:
+        {
+            NSURLRequest *request = nil;
+            if (![self _processHeadersAndCreateReditrectedRequest:&request error:&error]) {
+                [self _didFailWithError:error];
+                return;
+            }
+            _state = NSHTTPURLProtocolStateFormedResponse;
+            /* this behavior matches Apple's implemenation: it does not honor 201 and 300 status codes, as opposed to behavior suggested by standard */
+            if (request && (_statusCode == 301 || _statusCode == 302 || _statusCode == 303 || _statusCode == 305 || _statusCode == 307)) {
+                [self _wasRedirectedToRequest:request];
+                return;
+            }
+        }
+        case NSHTTPURLProtocolStateFormedResponse:
+        {
+            if (_statusCode != 401) {
+                if (_statusCode == 204 || _statusCode == 304) { /* 1xx? */
+                    _state = NSHTTPURLProtocolStateFinished; /* no body expected */
+                } else {
+                    _state = NSHTTPURLProtocolStateReceivesContent;
                 }
+                [self _didReceiveResponse];
+                return;
+            }
+            /* 401 Unauthorized */
+            _state = NSHTTPURLProtocolStateAwaitsHandshake;
+        }
+        case NSHTTPURLProtocolStateAwaitsHandshake:
+        {
+            if (![_parser isComplete]) {
+                break;
             }
-          if (_debug) [this->output setProperty: @"YES" forKey: GSTLSDebug];
+            _state = NSHTTPURLProtocolStateReceivedChallenge;
+        }
+        case NSHTTPURLProtocolStateReceivedChallenge:
+        {
+            NSURLAuthenticationChallenge *challenge = [self _handleAuthenticationChallenge];
+            _state = NSHTTPURLProtocolStateRepliesToChallenge;
+            [self _didReceiveAuthenticationChallenge:challenge];
+            return;
+        }
+        case NSHTTPURLProtocolStateRepliesToChallenge:
+        {
+            NSURLRequest *request = nil;
+            if (![self _fulfillAuthenticationRequest:&request error:&error]) {
+                [self _didFailWithError:error];
+                return;
+            }
+            if (!request)
+            {
+                /* We have no authentication credentials so we treat this as a download of the challenge page */
+                _state = NSHTTPURLProtocolStateReceivesContent;
+                [self _didReceiveResponse];
+                return;
+            }
+            /* handshake will continue with new request */
+            [this->request release];
+            this->request = [request retain];
+            DESTROY(this->cachedResponse);
+            [self stopLoading];
+            [self startLoading];
+            break;
+        }
+        case NSHTTPURLProtocolStateReceivesContent:
+        {
+            NSData *chunk = [self _handleBody];
+            if ([_parser isComplete]) {
+                _state = NSHTTPURLProtocolStateFinished;
+            }
+            if (chunk) {
+                [self _didLoadData:chunk];
+                return;
+            }
+            if (_state != NSHTTPURLProtocolStateFinished) {
+                break;
+            }
+        }
+        case NSHTTPURLProtocolStateFinished:
+        {
+            [self _handleFinish];
+            _state = NSHTTPURLProtocolStateStopped;
+            [self _didFinishLoading];
+            return;
+        }
+        default:
+        {
+            [self _didFailWithErrorDescription:@"Unsupported HTTP protocol state"];
+            break;
         }
-      [this->input setDelegate: self];
-      [this->output setDelegate: self];
-      [this->input scheduleInRunLoop: [NSRunLoop currentRunLoop]
-			     forMode: NSDefaultRunLoopMode];
-      [this->output scheduleInRunLoop: [NSRunLoop currentRunLoop]
-			      forMode: NSDefaultRunLoopMode];
-      [this->input open];
-      [this->output open];
     }
 }
 
-- (void) stopLoading
-{
-  if (_debug == YES)
+- (BOOL)_processHeadersAndCreateReditrectedRequest:(NSURLRequest **)aRequest error:(NSError **)error
+{
+    *aRequest = nil;
+    GSMimeDocument *document = [_parser mimeDocument];
+    GSMimeHeader *info;
+    NSString    *enc;
+    int         len = -1;
+    NSString    *ct;
+    NSString    *st;
+    NSString    *s;
+    
+    info = [document headerNamed:@"http"];
+    
+    _version = [[info value] floatValue];
+    if (_version < 1.1)
+    {
+        _shouldClose = YES;
+    }
+    else if ((s = [[document headerNamed:@"connection"] value]) != nil && [s caseInsensitiveCompare:@"close"] == NSOrderedSame)
     {
-      NSLog(@"%@ stopLoading", self);
+        _shouldClose = YES;
     }
-  _isLoading = NO;
-  DESTROY(_writeData);
-  if (this->input != nil)
+    else
     {
-      [this->input setDelegate: nil];
-      [this->output setDelegate: nil];
-      [this->input removeFromRunLoop: [NSRunLoop currentRunLoop]
-			     forMode: NSDefaultRunLoopMode];
-      [this->output removeFromRunLoop: [NSRunLoop currentRunLoop]
-			      forMode: NSDefaultRunLoopMode];
-      [this->input close];
-      [this->output close];
-      DESTROY(this->input);
-      DESTROY(this->output);
+        _shouldClose = NO;	/* Keep connection alive */
     }
+    
+    s = [info objectForKey:NSHTTPPropertyStatusCodeKey];
+    _statusCode = [s intValue];
+    
+    s = [[document headerNamed:@"content-length"] value];
+    if ([s length] > 0)
+    {
+        len = [s intValue];
+    }
+    
+    s = [info objectForKey:NSHTTPPropertyStatusReasonKey];
+    enc = [[document headerNamed:@"content-transfer-encoding"] value];
+    if (enc == nil)
+    {
+        enc = [[document headerNamed:@"transfer-encoding"] value];
+    }
+    /* todo: trasfer encoding support */
+    
+    info = [document headerNamed:@"content-type"];
+    ct = [document contentType];
+    st = [document contentSubtype];
+    if (ct && st)
+    {
+        ct = [ct stringByAppendingFormat:@"/%@", st];
+    }
+    else
+    {
+        ct = nil;
+    }
+    _response = [[NSHTTPURLResponse alloc] initWithURL:[this->request URL]
+                                              MIMEType:ct
+                                 expectedContentLength:len
+                                      textEncodingName:[info parameterForKey:@"charset"]];
+    [_response _setStatusCode:_statusCode text:s];
+    [document deleteHeaderNamed:@"http"];
+    [_response _setHeaders:[document allHeaders]];
+    
+    /* get cookies from the response and accept them into shared storage if policy permits */
+    if ([this->request HTTPShouldHandleCookies] == YES && [_response isKindOfClass:[NSHTTPURLResponse class]] == YES)
+    {
+        NSDictionary *hdrs;
+        NSArray *cookies;
+        NSURL *url;
+        
+        url = [_response URL];
+        hdrs = [_response allHeaderFields];
+        cookies = [NSHTTPCookie cookiesWithResponseHeaderFields:hdrs forURL:url];
+        [[NSHTTPCookieStorage sharedHTTPCookieStorage] setCookies:cookies
+                                                           forURL:url
+                                                  mainDocumentURL:[this->request mainDocumentURL]];
+    }
+    /* get redirect location, if any */
+    if ((s = [[document headerNamed:@"location"] value]) != nil)
+    {
+        NSURL *url = [NSURL URLWithString:s relativeToURL:[this->request URL]];
+        
+        if (url == nil)
+        {   
+            if (error != nil)
+            {
+                *error = [self _errorWithCode:NSURLErrorBadServerResponse description:@"Invalid redirect URL"];
+            }
+            return NO;
+        }
+        
+        NSMutableURLRequest	*request = [this->request mutableCopy];
+        [request setURL:url];
+        *aRequest = [request autorelease];
+        return YES;
+    }
+    
+#if	USE_ZLIB
+    s = [[document headerNamed:@"content-encoding"] value];
+    if ([s isEqualToString:@"gzip"] || [s isEqualToString:@"x-gzip"])
+    {
+        this->decompressing = YES;
+        this->z.opaque = 0;
+        this->z.zalloc = zalloc;
+        this->z.zfree = zfree;
+        this->z.next_in = 0;
+        this->z.avail_in = 0;
+        inflateInit2(&this->z, 1);	// FIXME
+    }
+#endif
+    return YES;
 }
 
-- (void) _didLoad: (NSData*)d
+- (NSString *)_wwwAuthenticate
 {
-  [this->client URLProtocol: self didLoadData: d];
+    return [[[_parser mimeDocument] headerNamed:@"WWW-Authenticate"] value];
 }
 
-- (void) _got: (NSStream*)stream
+- (NSURLAuthenticationChallenge *)_handleAuthenticationChallenge
 {
-  unsigned char	buffer[BUFSIZ*64];
-  int 		readCount;
-  NSError	*e;
-  NSData	*d;
-  BOOL		wasInHeaders = NO;
-
-  readCount = [(NSInputStream *)stream read: buffer
-				  maxLength: sizeof(buffer)];
-  if (readCount < 0)
+    NSInteger   failures = 0;
+    
+    NSURL *url = [this->request URL];
+    NSURLProtectionSpace *space = [GSHTTPAuthentication protectionSpaceForAuthentication:[self _wwwAuthenticate] requestURL:url];
+    DESTROY(_credential);	
+    if (space != nil)
     {
-      if ([stream  streamStatus] == NSStreamStatusError)
+        /*
+         * Create credential from user and password stored in the URL.
+         * Returns nil if we have no username or password.
+         */
+        _credential = [[NSURLCredential alloc] initWithUser:[url user]
+                                                   password:[url password]
+                                                persistence:NSURLCredentialPersistenceForSession];
+        if (_credential == nil)
         {
-	  e = [stream streamError];
-	  if (_debug)
-	    {
-	      NSLog(@"%@ receive error %@", self, e);
-	    }
-	  [self stopLoading];
-	  [this->client URLProtocol: self didFailWithError: e];
-	}
-      return;
+            /* No credential from the URL, so we try using the default credential for the protection space */
+            ASSIGN(_credential, [[NSURLCredentialStorage sharedCredentialStorage] defaultCredentialForProtectionSpace:space]);
+        }
+    }
+    
+    if (_challenge != nil)
+    {
+        /*
+         * The failure count is incremented if we have just
+         * tried a request in the same protection space.
+         */
+        if (YES == [[_challenge protectionSpace] isEqual: space])
+        {
+            failures = [_challenge previousFailureCount] + 1; 
+        }
     }
-  if (_debug)
+    else if ([this->request valueForHTTPHeaderField:@"Authorization"])
     {
-      NSLog(@"%@ read %d bytes: '%*.*s'",
-	self, readCount, readCount, readCount, buffer);
+        /*
+         * Our request had an authorization header, so we should
+         * count that as a failure or we wouldn't have been
+         * challenged.
+         */
+        failures = 1;
     }
-
-  if (_parser == nil)
+    DESTROY(_challenge);
+    
+    _challenge = [[NSURLAuthenticationChallenge alloc] initWithProtectionSpace:space
+                                                            proposedCredential:_credential
+                                                          previousFailureCount:failures
+                                                               failureResponse:_response
+                                                                         error:nil
+                                                                        sender:self];
+    
+    /* Allow the client to control the credential we send or whether we actually send at all */
+    return _challenge;
+}
+
+- (BOOL)_fulfillAuthenticationRequest:(NSURLRequest **)aRequest error:(NSError **)error
+{
+    *aRequest = nil;
+    if (_challenge == nil)
     {
-      _parser = [GSMimeParser new];
-      [_parser setIsHttp];
+        /* The client cancelled the authentication challenge so we must cancel the download */
+        if (error != nil) {
+            *error = [self _errorWithCode:NSURLErrorUserCancelledAuthentication description:@"Authentication cancelled"];
+        }
+        return NO;
     }
-  wasInHeaders = [_parser isInHeaders];
-  d = [NSData dataWithBytes: buffer length: readCount];
-  if ([_parser parse: d] == NO && (_complete = [_parser isComplete]) == NO)
+    
+    NSString *auth = nil;
+    if (_credential != nil)
     {
-      if (_debug == YES)
-	{
-	  NSLog(@"%@ HTTP parse failure - %@", self, _parser);
-	}
-      e = [NSError errorWithDomain: @"parse error"
-			      code: 0
-			  userInfo: nil];
-      [self stopLoading];
-      [this->client URLProtocol: self didFailWithError: e];
-      return;
+        NSString *wwwAuthenticate = [self _wwwAuthenticate];
+        NSURL *url = [this->request URL];
+        NSURLProtectionSpace *space = [GSHTTPAuthentication protectionSpaceForAuthentication:wwwAuthenticate requestURL:url];
+        
+        /* Get information about basic or digest authentication */
+        GSHTTPAuthentication *authentication = [GSHTTPAuthentication authenticationWithCredential:_credential
+                                                                                inProtectionSpace:space];
+        
+        /* Generate authentication header value for the authentication type in the challenge */
+        auth = [authentication authorizationForAuthentication:wwwAuthenticate
+                                                       method:[this->request HTTPMethod]
+                                                         path:[url fullPath]];
     }
-  else
+    
+    if (auth == nil)
     {
-      BOOL		isInHeaders = [_parser isInHeaders];
-      GSMimeDocument	*document = [_parser mimeDocument];
-      unsigned		bodyLength;
-
-      _complete = [_parser isComplete];
-      if (YES == wasInHeaders && NO == isInHeaders)
+        return YES;
+    }
+    
+    /*
+     * To answer the authentication challenge, we must retry 
+     * with a modified request and with the cached response cleared.
+     */
+    NSMutableURLRequest	*request = [this->request mutableCopy];
+    [request setValue:auth forHTTPHeaderField:@"Authorization"];
+    *aRequest = [request autorelease];
+    
+    return YES;
+}
+
+- (NSData *)_handleBody
+{
+    /* Report partial data if possible */
+    NSData *data = [_parser data];
+    NSUInteger bodyLength = [data length];
+    if (bodyLength > _parseOffset)
+    {
+        if (_parseOffset > 0)
         {
-	  GSMimeHeader		*info;
-	  int			len = -1;
-	  NSString		*ct;
-	  NSString		*st;
-	  NSString		*s;
-
-	  info = [document headerNamed: @"http"];
-
-	  _version = [[info value] floatValue];
-	  if (_version < 1.1)
-	    {
-	      _shouldClose = YES;
-	    }
-	  else if ((s = [[document headerNamed: @"connection"] value]) != nil
-	    && [s caseInsensitiveCompare: @"close"] == NSOrderedSame)
-	    {
-	      _shouldClose = YES;
-	    }
-	  else
-	    {
-	      _shouldClose = NO;	// Keep connection alive.
-	    }
-
-	  s = [info objectForKey: NSHTTPPropertyStatusCodeKey];
-	  _statusCode = [s intValue];
-
-	  s = [[document headerNamed: @"content-length"] value];
-	  if ([s length] > 0)
-	    {
-	      len = [s intValue];
-	    }
-
-	  s = [info objectForKey: NSHTTPPropertyStatusReasonKey];
-
-/* Should use this?
-	  NSString		*enc;
-	  enc = [[document headerNamed: @"content-transfer-encoding"] value];
-	  if (enc == nil)
-	    {
-	      enc = [[document headerNamed: @"transfer-encoding"] value];
-	    }
-*/
-
-	  info = [document headerNamed: @"content-type"];
-	  ct = [document contentType];
-	  st = [document contentSubtype];
-	  if (ct && st)
-	    {
-	      ct = [ct stringByAppendingFormat: @"/%@", st];
-	    }
-	  else
-	    {
-	      ct = nil;
-	    }
-	  _response = [[NSHTTPURLResponse alloc]
-	    initWithURL: [this->request URL]
-	    MIMEType: ct
-	    expectedContentLength: len
-	    textEncodingName: [info parameterForKey: @"charset"]];
-	  [_response _setStatusCode: _statusCode text: s];
-	  [document deleteHeaderNamed: @"http"];
-	  [_response _setHeaders: [document allHeaders]];
-
-	  if (_statusCode == 204 || _statusCode == 304)
-	    {
-	      _complete = YES;	// No body expected.
-	    }
-	  else if (_complete == NO && [d length] == 0)
-	    {
-	      _complete = YES;	// Had EOF ... terminate
-	    }
-
-	  if (_statusCode == 401)
-	    {
-	      /* This is an authentication challenge, so we keep reading
-	       * until the challenge is complete, then try to deal with it.
-	       */
-	    }
-	  else if ((s = [[document headerNamed: @"location"] value]) != nil)
-	    {
-	      NSURL	*url;
-
-	      url = [NSURL URLWithString: s];
-	      if (url == nil)
-	        {
-		  NSError	*e;
-
-		  e = [NSError errorWithDomain: @"Invalid redirect request"
-					  code: 0
-				      userInfo: nil];
-		  [self stopLoading];
-		  [this->client URLProtocol: self
-			   didFailWithError: e];
-		}
-	      else
-	        {
-		  NSMutableURLRequest	*request;
-
-		  request = [[this->request mutableCopy] autorelease];
-		  [request setURL: url];
-		  [this->client URLProtocol: self
-		     wasRedirectedToRequest: request
-			   redirectResponse: _response];
-		}
-	    }
-	  else
-	    {
-	      NSURLCacheStoragePolicy policy;
-
-	      /* Get cookies from the response and accept them into
-	       * shared storage if policy permits
-	       */
-	      if ([this->request HTTPShouldHandleCookies] == YES
-		&& [_response isKindOfClass: [NSHTTPURLResponse class]] == YES)
-		{
-		  NSDictionary	*hdrs;
-		  NSArray	*cookies;
-		  NSURL		*url;
-
-		  url = [_response URL];
-		  hdrs = [_response allHeaderFields];
-		  cookies = [NSHTTPCookie cookiesWithResponseHeaderFields: hdrs
-								   forURL: url];
-		  [[NSHTTPCookieStorage sharedHTTPCookieStorage]
-		    setCookies: cookies
-		    forURL: url
-		    mainDocumentURL: [this->request mainDocumentURL]];
-		}
-
-	      /* Tell the client that we have a response and how
-	       * it should be cached.
-	       */
-	      policy = [this->request cachePolicy];
-	      if (policy
-		== (NSURLCacheStoragePolicy)NSURLRequestUseProtocolCachePolicy)
-		{
-		  if ([self isKindOfClass: [_NSHTTPSURLProtocol class]] == YES)
-		    {
-		      /* For HTTPS we should not allow caching unless the
-		       * request explicitly wants it.
-		       */
-		      policy = NSURLCacheStorageNotAllowed;
-		    }
-		  else
-		    {
-		      /* For HTTP we allow caching unless the request
-		       * specifically denies it.
-		       */
-		      policy = NSURLCacheStorageAllowed;
-		    }
-		}
-	      [this->client URLProtocol: self
-		     didReceiveResponse: _response
-		     cacheStoragePolicy: policy];
-	    }
-	  
-#if	USE_ZLIB
-	  s = [[document headerNamed: @"content-encoding"] value];
-	  if ([s isEqualToString: @"gzip"] || [s isEqualToString: @"x-gzip"])
-	    {
-	      this->decompressing = YES;
-	      this->z.opaque = 0;
-	      this->z.zalloc = zalloc;
-	      this->z.zfree = zfree;
-	      this->z.next_in = 0;
-	      this->z.avail_in = 0;
-	      inflateInit2(&this->z, 1);	// FIXME
-	    }
-#endif
-	}
-
-      if (_complete == YES)
-	{
-	  if (_statusCode == 401)
-	    {
-	      NSURLProtectionSpace	*space;
-	      NSString			*hdr;
-	      NSURL			*url;
-	      int			failures = 0;
-
-	      /* This was an authentication challenge.
-	       */
-	      hdr = [[document headerNamed: @"WWW-Authenticate"] value];
-	      url = [this->request URL];
-	      space = [GSHTTPAuthentication
-		protectionSpaceForAuthentication: hdr requestURL: url];
-	      DESTROY(_credential);	
-	      if (space != nil)
-		{
-		  /* Create credential from user and password
-		   * stored in the URL.
-		   * Returns nil if we have no username or password.
-		   */
-		  _credential = [[NSURLCredential alloc]
-		    initWithUser: [url user]
-		    password: [url password]
-		    persistence: NSURLCredentialPersistenceForSession];
-		  if (_credential == nil)
-		    {
-		      /* No credential from the URL, so we try using the
-		       * default credential for the protection space.
-		       */
-		      ASSIGN(_credential,
-			[[NSURLCredentialStorage sharedCredentialStorage]
-			  defaultCredentialForProtectionSpace: space]);
-		    }
-		}
-
-	      if (_challenge != nil)
-		{
-		  /* The failure count is incremented if we have just
-		   * tried a request in the same protection space.
-		   */
-		  if (YES == [[_challenge protectionSpace] isEqual: space])
-		    {
-		      failures = [_challenge previousFailureCount] + 1; 
-		    }
-		}
-	      else if ([this->request valueForHTTPHeaderField:@"Authorization"])
-		{
-		  /* Our request had an authorization header, so we should
-		   * count that as a failure or we wouldn't have been
-		   * challenged.
-		   */
-		  failures = 1;
-		}
-	      DESTROY(_challenge);
-
-	      _challenge = [[NSURLAuthenticationChallenge alloc]
-		initWithProtectionSpace: space
-		proposedCredential: _credential
-		previousFailureCount: failures
-		failureResponse: _response
-		error: nil
-		sender: self];
-
-	      /* Allow the client to control the credential we send
-	       * or whether we actually send at all.
-	       */
-	      [this->client URLProtocol: self
-		didReceiveAuthenticationChallenge: _challenge];
-
-	      if (_challenge == nil)
-		{
-		  NSError	*e;
-
-		  /* The client cancelled the authentication challenge
-		   * so we must cancel the download.
-		   */
-		  e = [NSError errorWithDomain: @"Authentication cancelled"
-					  code: 0
-				      userInfo: nil];
-		  [self stopLoading];
-		  [this->client URLProtocol: self
-			   didFailWithError: e];
-		}
-	      else
-		{
-		  NSString	*auth = nil;
-
-		  if (_credential != nil)
-		    {
-		      GSHTTPAuthentication	*authentication;
-
-		      /* Get information about basic or
-		       * digest authentication.
-		       */
-		      authentication = [GSHTTPAuthentication
-			authenticationWithCredential: _credential
-			inProtectionSpace: space];
-
-		      /* Generate authentication header value for the
-		       * authentication type in the challenge.
-		       */
-		      auth = [authentication
-			authorizationForAuthentication: hdr
-			method: [this->request HTTPMethod]
-			path: [url fullPath]];
-		    }
-
-		  if (auth == nil)
-		    {
-		      NSURLCacheStoragePolicy policy;
-
-		      /* We have no authentication credentials so we
-		       * treat this as a download of the challenge page.
-		       */
-
-		      /* Tell the client that we have a response and how
-		       * it should be cached.
-		       */
-		      policy = [this->request cachePolicy];
-		      if (policy == (NSURLCacheStoragePolicy)
-			NSURLRequestUseProtocolCachePolicy)
-			{
-			  if ([self isKindOfClass: [_NSHTTPSURLProtocol class]])
-			    {
-			      /* For HTTPS we should not allow caching unless
-			       * the request explicitly wants it.
-			       */
-			      policy = NSURLCacheStorageNotAllowed;
-			    }
-			  else
-			    {
-			      /* For HTTP we allow caching unless the request
-			       * specifically denies it.
-			       */
-			      policy = NSURLCacheStorageAllowed;
-			    }
-			}
-		      [this->client URLProtocol: self
-			     didReceiveResponse: _response
-			     cacheStoragePolicy: policy];
-		      /* Fall through to code providing page data.
-		       */
-		    }
-		  else
-		    {
-		      NSMutableURLRequest	*request;
-
-		      /* To answer the authentication challenge,
-		       * we must retry with a modified request and
-		       * with the cached response cleared.
-		       */
-		      request = [this->request mutableCopy];
-		      [request setValue: auth
-			forHTTPHeaderField: @"Authorization"];
-		      [self stopLoading];
-		      [this->request release];
-		      this->request = request;
-		      DESTROY(this->cachedResponse);
-		      [self startLoading];
-		      return;
-		    }
-		}
-	    }
-
-	  [this->input removeFromRunLoop: [NSRunLoop currentRunLoop]
-				 forMode: NSDefaultRunLoopMode];
-	  [this->output removeFromRunLoop: [NSRunLoop currentRunLoop]
-				  forMode: NSDefaultRunLoopMode];
-	  if (_shouldClose == YES)
-	    {
-	      [this->input setDelegate: nil];
-	      [this->output setDelegate: nil];
-	      [this->input close];
-	      [this->output close];
-	      DESTROY(this->input);
-	      DESTROY(this->output);
-	    }
-
-	  /*
-	   * Tell superclass that we have successfully loaded the data
-	   * (as long as we haven't had the load terminated by the client).
-	   */
-	  if (_isLoading == YES)
-	    {
-	      d = [_parser data];
-	      bodyLength = [d length];
-	      if (bodyLength > _parseOffset)
-		{
-		  if (_parseOffset > 0)
-		    {
-		      d = [d subdataWithRange: 
-			NSMakeRange(_parseOffset, bodyLength - _parseOffset)];
-		    }
-		  _parseOffset = bodyLength;
-		  [self _didLoad: d];
-		}
-
-	      /* Check again in case the client cancelled the load inside
-	       * the URLProtocol:didLoadData: callback.
-	       */
-	      if (_isLoading == YES)
-	        {
-		  _isLoading = NO;
-	          [this->client URLProtocolDidFinishLoading: self];
-		}
-	    }
-	}
-      else if (_isLoading == YES && _statusCode != 401)
-	{
-	  /*
-	   * Report partial data if possible.
-	   */
-	  if ([_parser isInBody])
-	    {
-	      d = [_parser data];
-	      bodyLength = [d length];
-	      if (bodyLength > _parseOffset)
-	        {
-		  if (_parseOffset > 0)
-		    {
-		      d = [d subdataWithRange: 
-			NSMakeRange(_parseOffset, [d length] - _parseOffset)];
-		    }
-		  _parseOffset = bodyLength;
-		  [self _didLoad: d];
-		}
-	    }
-	}
-
-      if (_complete == NO && readCount == 0 && _isLoading == YES)
-	{
-	  /* The read failed ... dropped, but parsing is not complete.
-	   * The request was sent, so we can't know whether it was
-	   * lost in the network or the remote end received it and
-	   * the response was lost.
-	   */
-	  if (_debug == YES)
-	    {
-	      NSLog(@"%@ HTTP response not received - %@", self, _parser);
-	    }
-	  [self stopLoading];
-	  [this->client URLProtocol: self didFailWithError:
-	    [NSError errorWithDomain: @"receive incomplete"
-				code: 0
-			    userInfo: nil]];
-	}
+            data = [data subdataWithRange:NSMakeRange(_parseOffset, [data length] - _parseOffset)];
+        }
+        _parseOffset = bodyLength;
+        return data;
     }
+    return nil;
 }
 
-- (void) stream: (NSStream*) stream handleEvent: (NSStreamEvent) event
+- (void)_handleFinish
 {
-  /* Make sure no action triggered by anything else destroys us prematurely.
-   */
-  IF_NO_GC([[self retain] autorelease];)
+    [self stopLoading];
+}
 
+- (void)stream:(NSStream *)stream handleEvent:(NSStreamEvent)event
+{    
 #if 0
-  NSLog(@"stream: %@ handleEvent: %x for: %@ (ip %p, op %p)",
-    stream, event, self, this->input, this->output);
+    NSLog(@"stream: %@ handleEvent: %x for: %@ (ip %p, op %p)", stream, event, self, this->input, this->output);
 #endif
-
-  if (stream == this->input) 
+    
+    if (stream == this->input)
     {
-      switch(event)
-	{
-	  case NSStreamEventHasBytesAvailable: 
-	  case NSStreamEventEndEncountered:
-	    [self _got: stream];
-	    return;
-
-	  case NSStreamEventOpenCompleted: 
-	    if (_debug == YES)
-	      {
-		NSLog(@"%@ HTTP input stream opened", self);
-	      }
-	    return;
-
-	  default: 
-	    break;
-	}
+        switch(event)
+        {
+            case NSStreamEventHasBytesAvailable: 
+            case NSStreamEventEndEncountered:
+                [self _got: stream];
+                return;
+                
+            case NSStreamEventOpenCompleted: 
+                if (_debug == YES)
+                {
+                    NSLog(@"%@ HTTP input stream opened", self);
+                }
+                return;
+                
+            default: 
+                break;
+        }
     }
-  else if (stream == this->output)
+    else if (stream == this->output)
     {
-      switch(event)
-	{
-	  case NSStreamEventOpenCompleted: 
-	    {
-	      NSMutableString	*m;
-	      NSDictionary	*d;
-	      NSEnumerator	*e;
-	      NSString		*s;
-	      NSURL		*u;
-	      int		l;		
-
-	      if (_debug == YES)
-	        {
-	          NSLog(@"%@ HTTP output stream opened", self);
-	        }
-	      DESTROY(_writeData);
-	      _writeOffset = 0;
-	      if ([this->request HTTPBodyStream] == nil)
-	        {
-		  // Not streaming
-		  l = [[this->request HTTPBody] length];
-		  _version = 1.1;
-		}
-	      else
-	        {
-		  // Stream and close
-		  l = -1;
-	          _version = 1.0;
-		  _shouldClose = YES;
-		}
-
-	      m = [[NSMutableString alloc] initWithCapacity: 1024];
-
-	      /* The request line is of the form:
-	       * method /path?query HTTP/version
-	       * where the query part may be missing
-	       */
-	      [m appendString: [this->request HTTPMethod]];
-	      [m appendString: @" "];
-	      u = [this->request URL];
-	      s = [[u fullPath] stringByAddingPercentEscapesUsingEncoding:
-		NSUTF8StringEncoding];
-	      if ([s hasPrefix: @"/"] == NO)
-	        {
-		  [m appendString: @"/"];
-		}
-	      [m appendString: s];
-	      s = [u query];
-	      if ([s length] > 0)
-	        {
-		  [m appendString: @"?"];
-		  [m appendString: s];
-		}
-	      [m appendFormat: @" HTTP/%0.1f\r\n", _version];
-
-	      d = [this->request allHTTPHeaderFields];
-	      e = [d keyEnumerator];
-	      while ((s = [e nextObject]) != nil)
-	        {
-		  [m appendString: s];
-		  [m appendString: @": "];
-		  [m appendString: [d objectForKey: s]];
-		  [m appendString: @"\r\n"];
-		}
-	      /* Use valueForHTTPHeaderField: to check for content-type
-	       * header as that does a case insensitive comparison and
-	       * we therefore won't end up adding a second header by
-	       * accident because the two header names differ in case.
-	       */
-	      if ([[this->request HTTPMethod] isEqual: @"POST"]
-	        && [this->request valueForHTTPHeaderField:
-		  @"Content-Type"] == nil)
-		{
-		  /* On MacOSX, this is automatically added to POST methods */
-		  [m appendString:
-		    @"Content-Type: application/x-www-form-urlencoded\r\n"];
-		}
-	      if ([this->request valueForHTTPHeaderField: @"Host"] == nil)
-		{
-		  id	p = [u port];
-		  id	h = [u host];
-
-		  if (h == nil)
-		    {
-		      h = @"";	// Must send an empty host header
-		    }
-		  if (p == nil)
-		    {
-		      [m appendFormat: @"Host: %@\r\n", h];
-		    }
-		  else
-		    {
-		      [m appendFormat: @"Host: %@:%@\r\n", h, p];
-		    }
-		}
-	      if (l >= 0 && [this->request
-	        valueForHTTPHeaderField: @"Content-Length"] == nil)
-		{
-		  [m appendFormat: @"Content-Length: %d\r\n", l];
-		}
-	      [m appendString: @"\r\n"];	// End of headers
-	      _writeData = RETAIN([m dataUsingEncoding: NSASCIIStringEncoding]);
-	      RELEASE(m);
-	    }			// Fall through to do the write
-
-	  case NSStreamEventHasSpaceAvailable: 
-	    {
-	      int	written;
-	      BOOL	sent = NO;
-
-	      // FIXME: should also send out relevant Cookies
-	      if (_writeData != nil)
-		{
-		  const unsigned char	*bytes = [_writeData bytes];
-		  unsigned		len = [_writeData length];
-
-		  written = [this->output write: bytes + _writeOffset
-				      maxLength: len - _writeOffset];
-		  if (written > 0)
-		    {
-		      if (_debug == YES)
-		        {
-			  NSLog(@"%@ wrote %d bytes: '%*.*s'", self, written,
-			    written, written, bytes + _writeOffset);
-			}
-		      _writeOffset += written;
-		      if (_writeOffset >= len)
-		        {
-			  DESTROY(_writeData);
-			  if (_body == nil)
-			    {
-			      _body = RETAIN([this->request HTTPBodyStream]);
-			      if (_body == nil)
-				{
-				  NSData	*d = [this->request HTTPBody];
-
-				  if (d != nil)
-				    {
-				      _body = [NSInputStream alloc];
-				      _body = [_body initWithData: d];
-				      [_body open];
-				    }
-				  else
-				    {
-				      sent = YES;
-				    }
-				}
-			    }
-			}
-		    }
-		}
-	      else if (_body != nil)
-		{
-		  if ([_body hasBytesAvailable])
-		    {
-		      unsigned char	buffer[BUFSIZ*64];
-		      int		len;
-
-		      len = [_body read: buffer maxLength: sizeof(buffer)];
-		      if (len < 0)
-			{
-			  if (_debug == YES)
-			    {
-			      NSLog(@"%@ error reading from HTTPBody stream %@",
-				self, [NSError _last]);
-			    }
-			  [self stopLoading];
-			  [this->client URLProtocol: self didFailWithError:
-			    [NSError errorWithDomain: @"can't read body"
-						code: 0
-					    userInfo: nil]];
-			  return;
-			}
-		      else if (len > 0)
-		        {
-			  written = [this->output write: buffer maxLength: len];
-			  if (written > 0)
-			    {
-			      if (_debug == YES)
-				{
-				  NSLog(@"%@ wrote %d bytes: '%*.*s'", self,
-				    written, written, written, buffer);
-				}
-			      len -= written;
-			      if (len > 0)
-			        {
-				  /* Couldn't write it all now, save and try
-				   * again later.
-				   */
-				  _writeData = [[NSData alloc] initWithBytes:
-				    buffer + written length: len];
-				  _writeOffset = 0;
-				}
-			    }
-                          else if ([this->output streamStatus]
-                            == NSStreamStatusWriting)
+        switch(event)
+        {
+            case NSStreamEventOpenCompleted: 
+            {
+                NSMutableString	*m;
+                NSDictionary	*d;
+                NSEnumerator	*e;
+                NSString		*s;
+                NSURL		*u;
+                NSInteger		l;		
+                
+                if (_debug == YES)
+                {
+                    NSLog(@"%@ HTTP output stream opened", self);
+                }
+                DESTROY(_writeData);
+                _writeOffset = 0;
+                if ([this->request HTTPBodyStream] == nil)
+                {
+                    // Not streaming
+                    l = [[this->request HTTPBody] length];
+                    _version = 1.1;
+                }
+                else
+                {
+                    // Stream and close
+                    l = -1;
+                    _version = 1.0;
+                    _shouldClose = YES;
+                }
+                
+                m = [[NSMutableString alloc] initWithCapacity: 1024];
+                
+                /* The request line is of the form:
+                 * method /path?query HTTP/version
+                 * where the query part may be missing
+                 */
+                [m appendString: [this->request HTTPMethod]];
+                [m appendString: @" "];
+                u = [this->request URL];
+                s = [[u fullPath] stringByAddingPercentEscapesUsingEncoding:
+                     NSUTF8StringEncoding];
+                if ([s hasPrefix: @"/"] == NO)
+                {
+                    [m appendString: @"/"];
+                }
+                [m appendString: s];
+                s = [u query];
+                if ([s length] > 0)
+                {
+                    [m appendString: @"?"];
+                    [m appendString: s];
+                }
+                [m appendFormat: @" HTTP/%0.1f\r\n", _version];
+                
+                d = [this->request allHTTPHeaderFields];
+                e = [d keyEnumerator];
+                while ((s = [e nextObject]) != nil)
+                {
+                    [m appendString: s];
+                    [m appendString: @": "];
+                    [m appendString: [d objectForKey: s]];
+                    [m appendString: @"\r\n"];
+                }
+                /* Use valueForHTTPHeaderField: to check for content-type
+                 * header as that does a case insensitive comparison and
+                 * we therefore won't end up adding a second header by
+                 * accident because the two header names differ in case.
+                 */
+                if ([[this->request HTTPMethod] isEqual: @"POST"] && [this->request valueForHTTPHeaderField:@"Content-Type"] == nil)
+                {
+                    /* On MacOSX, this is automatically added to POST methods */
+                    [m appendString:@"Content-Type: application/x-www-form-urlencoded\r\n"];
+                }
+                if ([this->request valueForHTTPHeaderField: @"Host"] == nil)
+                {
+                    id	p = [u port];
+                    id	h = [u host];
+                    
+                    if (h == nil)
+                    {
+                        h = @"";	// Must send an empty host header
+                    }
+                    if (p == nil)
+                    {
+                        [m appendFormat: @"Host: %@\r\n", h];
+                    }
+                    else
+                    {
+                        [m appendFormat: @"Host: %@:%@\r\n", h, p];
+                    }
+                }
+                if (l >= 0 && [this->request valueForHTTPHeaderField: @"Content-Length"] == nil)
+                {
+                    [m appendFormat: @"Content-Length: %ld\r\n", (long)l];
+                }
+                [m appendString: @"\r\n"];	// End of headers
+                _writeData = RETAIN([m dataUsingEncoding: NSASCIIStringEncoding]);
+                RELEASE(m);
+            }			// Fall through to do the write
+                
+            case NSStreamEventHasSpaceAvailable: 
+            {
+                NSInteger	written;
+                BOOL	sent = NO;
+                
+                // FIXME: should also send out relevant Cookies
+                if (_writeData != nil)
+                {
+                    const unsigned char	*bytes = [_writeData bytes];
+                    NSUInteger len = [_writeData length];
+                    
+                    written = [this->output write:bytes + _writeOffset maxLength:len - _writeOffset];
+                    if (written > 0)
+                    {
+                        if (_debug == YES)
+                        {
+                            NSLog(@"%@ wrote %ld bytes: '%*.*s'", self, (long)written, (int)written, (int)written, bytes + _writeOffset);
+                        }
+                        _writeOffset += written;
+                        if (_writeOffset >= len)
+                        {
+                            DESTROY(_writeData);
+                            if (_body == nil)
                             {
-                              /* Couldn't write it all now, save and try
-                               * again later.
-                               */
-                              _writeData = [[NSData alloc] initWithBytes:
-                                buffer length: len];
-                              _writeOffset = 0;
+                                _body = RETAIN([this->request HTTPBodyStream]);
+                                if (_body == nil)
+                                {
+                                    NSData	*data = [this->request HTTPBody];
+                                    
+                                    if (data != nil)
+                                    {
+                                        _body = [NSInputStream alloc];
+                                        _body = [_body initWithData:data];
+                                        [_body open];
+                                    }
+                                    else
+                                    {
+                                        sent = YES;
+                                    }
+                                }
                             }
-			}
-		      else
-		        {
-			  [_body close];
-			  DESTROY(_body);
-			  sent = YES;
-			}
-		    }
-		  else
-		    {
-		      [_body close];
-		      DESTROY(_body);
-		      sent = YES;
-		    }
-		}
-	      if (sent == YES)
-		{
-		  if (_debug)
-		    {
-		      NSLog(@"%@ request sent", self);
-		    }
-		  if (_shouldClose == YES)
-		    {
-		      [this->output setDelegate: nil];
-		      [this->output removeFromRunLoop:
-			[NSRunLoop currentRunLoop]
-			forMode: NSDefaultRunLoopMode];
-		      [this->output close];
-		      DESTROY(this->output);
-		    }
-		}
-	      return;  // done
-	    }
-	  default: 
-	    break;
-	}
+                        }
+                    }
+                }
+                else if (_body != nil)
+                {
+                    if ([_body hasBytesAvailable])
+                    {
+                        unsigned char   buffer[BUFSIZ*64];
+                        NSInteger       len;
+                        
+                        len = [_body read:buffer maxLength:sizeof(buffer)];
+                        if (len < 0)
+                        {
+                            if (_debug == YES)
+                            {
+                                NSLog(@"%@ error reading from HTTPBody stream %@", self, [NSError _last]);
+                            }
+                            [self stopLoading];
+                            [this->client URLProtocol:self didFailWithError:[NSError errorWithDomain:@"can't read body" code:0 userInfo:nil]];
+                            return;
+                        }
+                        else if (len > 0)
+                        {
+                            written = [this->output write:buffer maxLength:len];
+                            if (written > 0)
+                            {
+                                if (_debug == YES)
+                                {
+                                    NSLog(@"%@ wrote %ld bytes: '%*.*s'", self, (long)written, (int)written, (int)written, buffer);
+                                }
+                                len -= written;
+                                if (len > 0)
+                                {
+                                    /* Couldn't write it all now, save and try
+                                     * again later.
+                                     */
+                                    _writeData = [[NSData alloc] initWithBytes:buffer + written length:len];
+                                    _writeOffset = 0;
+                                }
+                            }
+                            else if ([this->output streamStatus] == NSStreamStatusWriting)
+                            {
+                                /* Couldn't write it all now, save and try again later */
+                                _writeData = [[NSData alloc] initWithBytes:buffer length:len];
+                                _writeOffset = 0;
+                            }
+                        }
+                        else
+                        {
+                            [_body close];
+                            DESTROY(_body);
+                            sent = YES;
+                        }
+                    }
+                    else
+                    {
+                        [_body close];
+                        DESTROY(_body);
+                        sent = YES;
+                    }
+                }
+                if (sent == YES)
+                {
+                    if (_debug)
+                    {
+                        NSLog(@"%@ request sent", self);
+                    }
+                }
+                return;  // done
+            }
+            default: 
+                break;
+        }
     }
-  else
+    else
     {
-      NSLog(@"Unexpected event %"PRIuPTR
-	" occurred on stream %@ not being used by %@",
-	event, stream, self);
+        NSLog(@"Unexpected event %"PRIuPTR" occurred on stream %@ not being used by %@", event, stream, self);
     }
-  if (event == NSStreamEventErrorOccurred)
+    if (event == NSStreamEventErrorOccurred)
     {
-      NSError	*error = [[[stream streamError] retain] autorelease];
-
-      [self stopLoading];
-      [this->client URLProtocol: self didFailWithError: error];
+        NSError	*error = [[[stream streamError] retain] autorelease];
+        
+        [self stopLoading];
+        [this->client URLProtocol: self didFailWithError: error];
     }
-  else
+    else
     {
-      NSLog(@"Unexpected event %"PRIuPTR" ignored on stream %@ of %@",
-	event, stream, self);
+        NSLog(@"Unexpected event %"PRIuPTR" ignored on stream %@ of %@", event, stream, self);
     }
 }
 
-- (void) useCredential: (NSURLCredential*)credential
-  forAuthenticationChallenge: (NSURLAuthenticationChallenge*)challenge
+- (void)useCredential:(NSURLCredential *)credential forAuthenticationChallenge:(NSURLAuthenticationChallenge *)challenge
 {
-  if (challenge == _challenge)
+    if (challenge == _challenge)
     {
-      ASSIGN(_credential, credential);
+        ASSIGN(_credential, credential);
     }
 }
+
 @end
 
 @implementation _NSHTTPSURLProtocol
 
-+ (BOOL) canInitWithRequest: (NSURLRequest*)request
++ (BOOL)canInitWithRequest:(NSURLRequest *)request
 {
-  return [[[request URL] scheme] isEqualToString: @"https"];
+  return [[[request URL] scheme] isEqualToString:@"https"];
 }
 
 @end
 
 @implementation _NSFTPURLProtocol
 
-+ (BOOL) canInitWithRequest: (NSURLRequest*)request
++ (BOOL)canInitWithRequest:(NSURLRequest *)request
 {
-  return [[[request URL] scheme] isEqualToString: @"ftp"];
+  return [[[request URL] scheme] isEqualToString:@"ftp"];
 }
 
-+ (NSURLRequest*) canonicalRequestForRequest: (NSURLRequest*)request
++ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request
 {
   return request;
 }
 
-- (void) startLoading
+- (void)startLoading
 {
-  if (this->cachedResponse)
-    { // handle from cache
+    if (this->cachedResponse)
+    { 
+        // todo: handle from cache
     }
-  else
+    else
     {
-      NSURL	*url = [this->request URL];
-      NSHost	*host = [NSHost hostWithName: [url host]];
-
-      if (host == nil)
+        NSURL	*url = [this->request URL];
+        NSHost	*host = [NSHost hostWithName:[url host]];
+        
+        if (host == nil)
         {
-	  host = [NSHost hostWithAddress: [url host]];
-	}
-      [NSStream getStreamsToHost: host
-			    port: [[url port] intValue]
-		     inputStream: &this->input
-		    outputStream: &this->output];
-      if (this->input == nil || this->output == nil)
-	{
-	  [this->client URLProtocol: self didFailWithError:
-	    [NSError errorWithDomain: @"can't connect"
-				code: 0
-			    userInfo: nil]];
-	  return;
-	}
+            host = [NSHost hostWithAddress:[url host]];
+        }
+        [NSStream getStreamsToHost:host
+                              port:[[url port] intValue]
+                       inputStream:&this->input
+                      outputStream:&this->output];
+        if (this->input == nil || this->output == nil)
+        {
+            NSError *error = [NSError errorWithDomain:@"can't connect" code:0 userInfo:nil];
+            [this->client URLProtocol:self didFailWithError:error];
+            return;
+        }
 #if	!GS_WITH_GC
-      [this->input retain];
-      [this->output retain];
+        [this->input retain];
+        [this->output retain];
 #endif
-      if ([[url scheme] isEqualToString: @"https"] == YES)
+        if ([[url scheme] isEqualToString: @"https"] == YES)
         {
-          [this->input setProperty: NSStreamSocketSecurityLevelNegotiatedSSL
-                            forKey: NSStreamSocketSecurityLevelKey];
-          [this->output setProperty: NSStreamSocketSecurityLevelNegotiatedSSL
-                             forKey: NSStreamSocketSecurityLevelKey];
+            [this->input setProperty: NSStreamSocketSecurityLevelNegotiatedSSL
+                              forKey: NSStreamSocketSecurityLevelKey];
+            [this->output setProperty: NSStreamSocketSecurityLevelNegotiatedSSL
+                               forKey: NSStreamSocketSecurityLevelKey];
         }
-      [this->input setDelegate: self];
-      [this->output setDelegate: self];
-      [this->input scheduleInRunLoop: [NSRunLoop currentRunLoop]
-			     forMode: NSDefaultRunLoopMode];
-      [this->output scheduleInRunLoop: [NSRunLoop currentRunLoop]
-			      forMode: NSDefaultRunLoopMode];
-      // set socket options for ftps requests
-      [this->input open];
-      [this->output open];
+        [this->input setDelegate:self];
+        [this->output setDelegate:self];
+        [this->input scheduleInRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];
+        [this->output scheduleInRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];
+        /* set socket options for ftps requests */
+        [this->input open];
+        [this->output open];
     }
 }
 
-- (void) stopLoading
+- (void)stopLoading
 {
-  if (this->input)
+    if (this->input)
     {
-      [this->input setDelegate: nil];
-      [this->output setDelegate: nil];
-      [this->input removeFromRunLoop: [NSRunLoop currentRunLoop]
-			     forMode: NSDefaultRunLoopMode];
-      [this->output removeFromRunLoop: [NSRunLoop currentRunLoop]
-			      forMode: NSDefaultRunLoopMode];
-      [this->input close];
-      [this->output close];
-      DESTROY(this->input);
-      DESTROY(this->output);
+        [this->input setDelegate:nil];
+        [this->output setDelegate:nil];
+        [this->input removeFromRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];
+        [this->output removeFromRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];
+        [this->input close];
+        [this->output close];
+        DESTROY(this->input);
+        DESTROY(this->output);
     }
 }
 
-- (void) stream: (NSStream *) stream handleEvent: (NSStreamEvent) event
+- (void)stream:(NSStream *)stream handleEvent:(NSStreamEvent)event
 {
-  if (stream == this->input) 
+    if (stream == this->input) 
     {
-      switch(event)
-	{
-	  case NSStreamEventHasBytesAvailable: 
-	    {
-	    NSLog(@"FTP input stream has bytes available");
-	    // implement FTP protocol
-//			[this->client URLProtocol: self didLoadData: [NSData dataWithBytes: buffer length: len]];	// notify
-	    return;
-	    }
-	  case NSStreamEventEndEncountered: 	// can this occur in parallel to NSStreamEventHasBytesAvailable???
-		  NSLog(@"FTP input stream did end");
-		  [this->client URLProtocolDidFinishLoading: self];
-		  return;
-	  case NSStreamEventOpenCompleted: 
-		  // prepare to receive header
-		  NSLog(@"FTP input stream opened");
-		  return;
-	  default: 
-		  break;
-	}
+        switch(event)
+        {
+            case NSStreamEventHasBytesAvailable: 
+            {
+                NSLog(@"FTP input stream has bytes available");
+                // todo: implement FTP protocol
+                // [this->client URLProtocol: self didLoadData: [NSData dataWithBytes: buffer length: len]];
+                return;
+            }
+            case NSStreamEventEndEncountered: 	// can this occur in parallel to NSStreamEventHasBytesAvailable???
+                NSLog(@"FTP input stream did end");
+                [this->client URLProtocolDidFinishLoading: self];
+                return;
+            case NSStreamEventOpenCompleted: 
+                // prepare to receive header
+                NSLog(@"FTP input stream opened");
+                return;
+            default: 
+                break;
+        }
     }
-  else if (stream == this->output)
+    else if (stream == this->output)
     {
-      NSLog(@"An event occurred on the output stream.");
-  	// if successfully opened, send out FTP request header
+        NSLog(@"An event occurred on the output stream.");
+        /* if successfully opened, send out FTP request header */
     }
-  else
+    else
     {
-      NSLog(@"Unexpected event %"PRIuPTR
-	" occurred on stream %@ not being used by %@",
-	event, stream, self);
+        NSLog(@"Unexpected event %"PRIuPTR" occurred on stream %@ not being used by %@", event, stream, self);
     }
-  if (event == NSStreamEventErrorOccurred)
+    if (event == NSStreamEventErrorOccurred)
     {
-      NSLog(@"An error %@ occurred on stream %@ of %@",
-	[stream streamError], stream, self);
-      [self stopLoading];
-      [this->client URLProtocol: self didFailWithError: [stream streamError]];
+        NSLog(@"An error %@ occurred on stream %@ of %@", [stream streamError], stream, self);
+        [self stopLoading];
+        [this->client URLProtocol: self didFailWithError: [stream streamError]];
     }
-  else
+    else
     {
-      NSLog(@"Unexpected event %"PRIuPTR" ignored on stream %@ of %@",
-	event, stream, self);
+        NSLog(@"Unexpected event %"PRIuPTR" ignored on stream %@ of %@", event, stream, self);
     }
 }
 
diff --git a/Source/NSURLResponse.m b/Source/NSURLResponse.m
index 2531420..4ea6e11 100644
--- a/Source/NSURLResponse.m
+++ b/Source/NSURLResponse.m
@@ -43,7 +43,7 @@ typedef struct {
   NSString		*textEncodingName;
   NSString		*statusText;
   NSMutableDictionary	*headers; /* _GSMutableInsensitiveDictionary */
-  int			statusCode;
+  NSInteger			statusCode;
 } Internal;
  
 #define	this	((Internal*)(self->_NSURLResponseInternal))
@@ -342,7 +342,7 @@ typedef struct {
 + (NSString *) localizedStringForStatusCode: (NSInteger)statusCode
 {
 // FIXME ... put real responses in here
-  return [NSString stringWithFormat: @"%d", statusCode];
+  return [NSString stringWithFormat: @"%ld", (long)statusCode];
 }
 
 - (NSDictionary *) allHeaderFields
diff --git a/Source/NSUnarchiver.m b/Source/NSUnarchiver.m
index 84dcf22..3aa3724 100644
--- a/Source/NSUnarchiver.m
+++ b/Source/NSUnarchiver.m
@@ -27,7 +27,7 @@
 
 #import "common.h"
 
-#if !defined (__GNU_LIBOBJC__)
+#if !defined (__GNU_LIBOBJC__) && !defined (NeXT_RUNTIME)
 #  include <objc/encoding.h>
 #endif
 
@@ -498,7 +498,7 @@ static unsigned	encodingVersion;
 	{
 	  src = self;		/* Default object to handle serialisation */
 	  desImp = [src methodForSelector: desSel];
-	  tagImp = (void (*)(id, SEL, unsigned char*, unsigned*, unsigned*))
+	  tagImp = (void (*)(id, SEL, unsigned char*, unsigned*, NSUInteger*))
 	      [src methodForSelector: tagSel];
 	}
       /*
@@ -587,8 +587,8 @@ static unsigned	encodingVersion;
   if (count != expected)
     {
       [NSException raise: NSInternalInconsistencyException
-		  format: @"expected array count %u and got %u",
-			expected, count];
+		  format: @"expected array count %lu and got %lu",
+			(unsigned long)expected, (unsigned long)count];
     }
 
   switch (*type)
@@ -704,16 +704,16 @@ static unsigned	encodingVersion;
 		  rep = [obj initWithCoder: self];
 		  if (rep != obj)
 		    {
-		      obj = rep;
-		      GSIArraySetItemAtIndex(objMap, (GSIArrayItem)obj, xref);
+		      GSIArraySetItemAtIndex(objMap, (GSIArrayItem)rep, xref);
 		    }
+		  obj = rep;
 
 		  rep = [obj awakeAfterUsingCoder: self];
 		  if (rep != obj)
 		    {
-		      obj = rep;
-		      GSIArraySetItemAtIndex(objMap, (GSIArrayItem)obj, xref);
+		      GSIArraySetItemAtIndex(objMap, (GSIArrayItem)rep, xref);
 		    }
+		  obj = rep;
 		  /*
 		   * The objMap does not retain objects, so in order to
 		   * be sure that a decoded object is not deallocated by
@@ -902,6 +902,7 @@ static unsigned	encodingVersion;
 
 	      (*dValImp)(self, dValSel, ftype, (char*)address + offset);
 	    }
+  	objc_layout_finish_structure(&layout, NULL, NULL);
 	  return;
 	}
 
@@ -927,7 +928,7 @@ static unsigned	encodingVersion;
 	    }
 	  else
 	    {
-	      unsigned	size;
+	      size_t	size;
 
 	      if (GSIArrayCount(ptrMap) != xref)
 		{
@@ -1438,7 +1439,7 @@ static unsigned	encodingVersion;
  */
 - (void) replaceObject: (id)anObject withObject: (id)replacement
 {
-  unsigned i;
+  NSUInteger i;
 
   if (replacement == anObject)
     return;
@@ -1479,7 +1480,7 @@ static unsigned	encodingVersion;
 /**
  *  Return current position within archive byte array.
  */
-- (unsigned) cursor
+- (NSUInteger) cursor
 {
   return cursor;
 }
@@ -1490,11 +1491,11 @@ static unsigned	encodingVersion;
  *  anObject, starting at pos.  Reads archive header.
  */
 - (void) resetUnarchiverWithData: (NSData*)anObject
-			 atIndex: (unsigned)pos
+			 atIndex: (NSUInteger)pos
 {
-  unsigned	sizeC;
-  unsigned	sizeO;
-  unsigned	sizeP;
+  NSUInteger	sizeC;
+  NSUInteger	sizeO;
+  NSUInteger	sizeP;
 
   if (anObject == nil)
     {
@@ -1517,7 +1518,7 @@ static unsigned	encodingVersion;
 	       *	Cache methods for deserialising from the data object.
 	       */
 	      desImp = [src methodForSelector: desSel];
-	      tagImp = (void (*)(id, SEL, unsigned char*, unsigned*, unsigned*))
+	      tagImp = (void (*)(id, SEL, unsigned char*, unsigned*, NSUInteger*))
 		  [src methodForSelector: tagSel];
 	    }
 	}
@@ -1570,11 +1571,11 @@ static unsigned	encodingVersion;
 /**
  *  Reads in header for GNUstep archive format.
  */
-- (void) deserializeHeaderAt: (unsigned*)pos
+- (void) deserializeHeaderAt: (NSUInteger*)pos
 		     version: (unsigned*)v
-		     classes: (unsigned*)c
-		     objects: (unsigned*)o
-		    pointers: (unsigned*)p
+		     classes: (NSUInteger*)c
+		     objects: (NSUInteger*)o
+		    pointers: (NSUInteger*)p
 {
   unsigned	plen = strlen(PREFIX);
   unsigned	size = plen+36;
@@ -1588,11 +1589,16 @@ static unsigned	encodingVersion;
       [NSException raise: NSInternalInconsistencyException
 		  format: @"Archive has wrong prefix"];
     }
-  if (sscanf(&header[plen], "%x:%x:%x:%x:", v, c, o, p) != 4)
+  unsigned ver, cls, obj, ptr;
+  if (sscanf(&header[plen], "%x:%x:%x:%x:", &ver, &cls, &obj, &ptr) != 4)
     {
       [NSException raise: NSInternalInconsistencyException
 		  format: @"Archive has wrong prefix"];
     }
+    *v = ver;
+    *c = cls;
+    *o = obj;
+    *p = ptr;
 }
 
 /**
diff --git a/Source/NSUndoManager.m b/Source/NSUndoManager.m
index 3e8b807..58f96dd 100644
--- a/Source/NSUndoManager.m
+++ b/Source/NSUndoManager.m
@@ -109,7 +109,7 @@
 {
   if (actions != nil)
     {
-      unsigned	i = [actions count];
+      NSUInteger	i = [actions count];
 
       while (i-- > 0)
 	{
@@ -122,7 +122,7 @@
 {
   if (actions != nil)
     {
-      unsigned	i = [actions count];
+      NSUInteger	i = [actions count];
 
       while (i-- > 0)
 	{
@@ -797,7 +797,7 @@
  */
 - (void) removeAllActionsWithTarget: (id)target
 {
-  unsigned 	i;
+  NSUInteger 	i;
 
   i = [_redoStack count];
   while (i-- > 0)
diff --git a/Source/NSUserDefaults.m b/Source/NSUserDefaults.m
index 598155c..b04bebf 100644
--- a/Source/NSUserDefaults.m
+++ b/Source/NSUserDefaults.m
@@ -232,7 +232,7 @@ updateCache(NSUserDefaults *self)
       debug = [self arrayForKey: @"GNU-Debug"];
       if (debug != nil)
         {
-	  unsigned	c = [debug count];
+	  NSUInteger	c = [debug count];
 	  NSMutableSet	*s;
 
 	  s = [[NSProcessInfo processInfo] debugSet];
@@ -262,8 +262,8 @@ setPermissions(NSString *file)
 {
   NSFileManager	*mgr = [NSFileManager defaultManager];
   NSDictionary	*attr;
-  uint32_t	desired;
-  uint32_t	attributes;
+  NSUInteger	desired;
+  NSUInteger	attributes;
 
   attr = [mgr fileAttributesAtPath: file
 		      traverseLink: YES];
@@ -904,7 +904,7 @@ newLanguages(NSArray *oldNames)
       enumerator = [nL objectEnumerator];
       while ((lang = [enumerator nextObject]))
         {
-          unsigned	index = [defs->_searchList count] - 1;
+          NSUInteger	index = [defs->_searchList count] - 1;
 
           [defs->_searchList insertObject: lang atIndex: index];
         }
@@ -2038,7 +2038,7 @@ static BOOL isPlistObject(id o)
                   (*addImp)(dictRep, addSel, dict);
                 }
 	    }
-          [dictRep makeImmutableCopyOnFail: NO];
+          dictRep = [dictRep makeImmutable];
           _dictionaryRep = dictRep;
         }
       rep = [[_dictionaryRep retain] autorelease];
diff --git a/Source/NSValue.m b/Source/NSValue.m
index 0f6eeb3..d3e4075 100644
--- a/Source/NSValue.m
+++ b/Source/NSValue.m
@@ -101,14 +101,12 @@ static NSLock			*placeholderLock;
       /*
        * Set up infrastructure for placeholder values.
        */
-      defaultPlaceholderValue = (GSPlaceholderValue*)
-	NSAllocateObject(GSPlaceholderValueClass, 0, NSDefaultMallocZone());
-      [[NSObject leakAt: (id*)&defaultPlaceholderValue] release];
-      placeholderMap = NSCreateMapTable(NSNonOwnedPointerMapKeyCallBacks,
-	NSNonRetainedObjectMapValueCallBacks, 0);
-      [[NSObject leakAt: (id*)&placeholderMap] release];
+      defaultPlaceholderValue = (GSPlaceholderValue *)NSAllocateObject(GSPlaceholderValueClass, 0, NSDefaultMallocZone());
+      [NSObject leakAt: (id*)&defaultPlaceholderValue];
+      placeholderMap = NSCreateMapTable(NSNonOwnedPointerMapKeyCallBacks, NSNonRetainedObjectMapValueCallBacks, 0);
+      [NSObject leakAt: (id*)&placeholderMap];
       placeholderLock = [NSLock new];
-      [[NSObject leakAt: (id*)&placeholderLock] release];
+      [NSObject leakAt: (id*)&placeholderLock];
     }
 }
 
@@ -404,13 +402,13 @@ static NSLock			*placeholderLock;
 - (void) encodeWithCoder: (NSCoder *)coder
 {
   NSUInteger	tsize;
-  unsigned	size;
+  NSUInteger	size;
   const char	*data;
   const char	*objctype = [self objCType];
   NSMutableData	*d;
 
   size = strlen(objctype)+1;
-  [coder encodeValueOfObjCType: @encode(unsigned) at: &size];
+  [coder encodeValueOfObjCType: @encode(NSUInteger) at: &size];
   [coder encodeArrayOfObjCType: @encode(signed char) count: size at: objctype];
   if (strncmp("{_NSSize=", objctype, 9) == 0)
     {
@@ -447,7 +445,7 @@ static NSLock			*placeholderLock;
   d = [NSMutableData new];
   [d serializeDataAt: data ofObjCType: objctype context: nil];
   size = [d length];
-  [coder encodeValueOfObjCType: @encode(unsigned) at: &size];
+  [coder encodeValueOfObjCType: @encode(NSUInteger) at: &size];
   NSZoneFree(NSDefaultMallocZone(), (void*)data);
   data = [d bytes];
   [coder encodeArrayOfObjCType: @encode(unsigned char) count: size at: data];
@@ -461,10 +459,10 @@ static NSLock			*placeholderLock;
   Class		c;
   id		o;
   NSUInteger	tsize;
-  unsigned	size;
-  int		ver;
+  NSUInteger	size;
+  NSInteger		ver;
 
-  [coder decodeValueOfObjCType: @encode(unsigned) at: &size];
+  [coder decodeValueOfObjCType: @encode(NSUInteger) at: &size];
   /*
    * For almost all type encodings, we can use space on the stack,
    * but to handle exceptionally large ones (possibly some huge structs)
@@ -566,7 +564,7 @@ static NSLock			*placeholderLock;
 	    {
 	      unsigned char	*data;
 
-	      [coder decodeValueOfObjCType: @encode(unsigned) at: &size];
+	      [coder decodeValueOfObjCType: @encode(NSUInteger) at: &size];
 	      data = (void *)NSZoneMalloc(NSDefaultMallocZone(), size);
 	      [coder decodeArrayOfObjCType: @encode(unsigned char)
 				     count: size
@@ -578,7 +576,7 @@ static NSLock			*placeholderLock;
       else
 	{
 	  NSData        *d;
-	  unsigned      cursor = 0;
+	  NSUInteger      cursor = 0;
 
 	  /*
 	   * For performance, decode small values directly onto the stack,
@@ -616,7 +614,7 @@ static NSLock			*placeholderLock;
   else
     {
       static NSData	*d = nil;
-      unsigned  	cursor = 0;
+      NSUInteger  	cursor = 0;
 
       if (d == nil)
 	{
@@ -631,7 +629,7 @@ static NSLock			*placeholderLock;
 	{
 	  unsigned char	data[tsize];
 
-	  [coder decodeValueOfObjCType: @encode(unsigned) at: &size];
+	  [coder decodeValueOfObjCType: @encode(NSUInteger) at: &size];
 	  {
 	    unsigned char	serialized[size];
 
@@ -653,7 +651,7 @@ static NSLock			*placeholderLock;
 	  void	*data;
 
 	  data = (void *)NSZoneMalloc(NSDefaultMallocZone(), tsize);
-	  [coder decodeValueOfObjCType: @encode(unsigned) at: &size];
+	  [coder decodeValueOfObjCType: @encode(NSUInteger) at: &size];
 	  {
 	    void	*serialized;
 
diff --git a/Source/NSXMLDTD.m b/Source/NSXMLDTD.m
index 2b5653b..d382935 100644
--- a/Source/NSXMLDTD.m
+++ b/Source/NSXMLDTD.m
@@ -169,27 +169,28 @@ GS_PRIVATE_INTERNAL(NSXMLDTD)
             options: (NSUInteger)mask
               error: (NSError**)error
 {
-  NSXMLDocument *tempDoc = 
+    NSXMLDocument *tempDoc = 
     [[NSXMLDocument alloc] initWithData: data
                                 options: mask
                                   error: error];
-  if (tempDoc != nil)
+    if (tempDoc == nil)
     {
-      NSArray *children = [tempDoc children];
-      NSEnumerator *enumerator = [children objectEnumerator];
-      NSXMLNode *child;
-
-      self = [self initWithKind: NSXMLDTDKind options: mask];
-      
-      while ((child = [enumerator nextObject]) != nil)
-        {
-          [child detach]; // detach from document.
-          [self addChild: child];
-        }
-      [tempDoc release];
+        return nil;
     }
-
-  return self;
+    NSArray *children = [tempDoc children];
+    NSEnumerator *enumerator = [children objectEnumerator];
+    NSXMLNode *child;
+    
+    self = [self initWithKind: NSXMLDTDKind options: mask];
+    
+    while ((child = [enumerator nextObject]) != nil)
+    {
+        [child detach]; // detach from document.
+        [self addChild: child];
+    }
+    [tempDoc release];
+    
+    return self;
 }
 
 - (id) initWithKind: (NSXMLNodeKind)theKind options: (NSUInteger)theOptions
diff --git a/Source/NSXMLDocument.m b/Source/NSXMLDocument.m
index ba09b85..b742faf 100644
--- a/Source/NSXMLDocument.m
+++ b/Source/NSXMLDocument.m
@@ -128,8 +128,9 @@ GS_PRIVATE_INTERNAL(NSXMLDocument)
           xmlOptions |= XML_PARSE_NOBLANKS;
           //xmlKeepBlanksDefault(0);
         }
-      doc = xmlReadMemory([data bytes], [data length], 
-                          url, encoding, xmlOptions);
+        NSUInteger length = [data length];
+        NSAssert(length < INT_MAX, @"Data size should not exceed size of int (libxml limitation)");
+        doc = xmlReadMemory([data bytes], (int)length, url, encoding, xmlOptions);
       if (doc == NULL)
 	{
           DESTROY(self);
@@ -424,8 +425,9 @@ GS_PRIVATE_INTERNAL(NSXMLDocument)
 {
 #ifdef HAVE_LIBXSLT
   xmlChar **params = NULL;
-  xmlDocPtr stylesheetDoc = xmlReadMemory([xslt bytes], [xslt length],
-                                          NULL, NULL, XML_PARSE_NOERROR);
+  NSUInteger length = [xslt length];
+  NSAssert(length < INT_MAX, @"XSLT data size should not exceed size of int (libxml limitation)");
+  xmlDocPtr stylesheetDoc = xmlReadMemory([xslt bytes], (int)length, NULL, NULL, XML_PARSE_NOERROR);
   xsltStylesheetPtr stylesheet = xsltParseStylesheetDoc(stylesheetDoc);
   xmlDocPtr resultDoc = NULL;
  
@@ -435,7 +437,7 @@ GS_PRIVATE_INTERNAL(NSXMLDocument)
       NSEnumerator *en = [arguments keyEnumerator];
       NSString *key = nil;
       NSUInteger index = 0;
-      int count = [[arguments allKeys] count];
+      NSUInteger count = [[arguments allKeys] count];
 
       params = NSZoneCalloc([self zone], ((count + 1) * 2), sizeof(xmlChar *));
       while ((key = [en nextObject]) != nil)
diff --git a/Source/NSXMLElement.m b/Source/NSXMLElement.m
index edf84b0..5a87b76 100644
--- a/Source/NSXMLElement.m
+++ b/Source/NSXMLElement.m
@@ -33,9 +33,6 @@
 #import "GSInternal.h"
 GS_PRIVATE_INTERNAL(NSXMLElement)
 
-extern void cleanup_namespaces(xmlNodePtr node, xmlNsPtr ns);
-extern void ensure_oldNs(xmlNodePtr node);
-
 @implementation NSXMLElement
 
 - (void) dealloc
diff --git a/Source/NSXMLNode.m b/Source/NSXMLNode.m
index 95d9ee1..002e4c8 100644
--- a/Source/NSXMLNode.m
+++ b/Source/NSXMLNode.m
@@ -970,7 +970,7 @@ execute_xpath(xmlNodePtr node, NSString *xpath_exp, NSDictionary *constants,
   NSXMLElement *e;
   
   e = [[NSXMLElement alloc] initWithName: name stringValue: string];
-  return e;
+  return [e autorelease];
 }
 
 + (NSString*) localNameForName: (NSString*)name
diff --git a/Source/NSXMLParser.m b/Source/NSXMLParser.m
index c49d4b2..627ad79 100644
--- a/Source/NSXMLParser.m
+++ b/Source/NSXMLParser.m
@@ -603,7 +603,7 @@ static  NSNull  *null = nil;
 @end
 
 static inline NSString *
-NewUTF8STR(const void *ptr, int len)
+NewUTF8STR(const void *ptr, NSUInteger len)
 {
   NSString	*s;
 
@@ -611,7 +611,7 @@ NewUTF8STR(const void *ptr, int len)
 			       length: len
 			     encoding: NSUTF8StringEncoding];
   if (s == nil)
-    NSLog(@"could not convert to UTF8 string! bytes=%p len=%d", ptr, len);
+    NSLog(@"could not convert to UTF8 string! bytes=%p len=%lu", ptr, (unsigned long)len);
   return s;
 }
 
@@ -924,7 +924,7 @@ static SEL	foundIgnorableSel;
  */
 - (NSString*) _uriForPrefix: (NSString*)p
 {
-  unsigned      i = [this->namespaces count];
+  NSUInteger      i = [this->namespaces count];
   NSString      *uri = nil;
 
   while (uri == nil && i-- > 0)
@@ -1362,7 +1362,7 @@ NSLog(@"_processTag <%@%@ %@>", flag?@"/": @"", tag, attributes);
     }
 }
 
-- (NSString*) _newEntity: (const unsigned char *)ep length: (int)len
+- (NSString*) _newEntity: (const unsigned char *)ep length: (NSUInteger)len
 {
   NSString      *entity;
 
@@ -1379,12 +1379,12 @@ NSLog(@"_processTag <%@%@ %@>", flag?@"/": @"", tag, attributes);
           if (sscanf(buf, "x%x;", &val))
             {
               // &#xhh; hex value
-              return [[NSString alloc] initWithFormat: @"%C", val];
+              return [[NSString alloc] initWithFormat: @"%C", (unichar)val];
             }
           else if (sscanf(buf, "%d;", &val))
             {
               // &ddd; decimal value
-              return [[NSString alloc] initWithFormat: @"%C", val];
+              return [[NSString alloc] initWithFormat: @"%C", (unichar)val];
             }
         }
     }
@@ -1430,7 +1430,7 @@ NSLog(@"_processTag <%@%@ %@>", flag?@"/": @"", tag, attributes);
 {
   int c;
   const unsigned char *ep = this->cp;  // should be position behind &
-  int len;
+  NSInteger len;
   NSString *entity;
 
   if (0 == result) result = &entity;
@@ -1458,7 +1458,7 @@ NSLog(@"_processTag <%@%@ %@>", flag?@"/": @"", tag, attributes);
 // get argument (might be quoted)
   const unsigned char *ap = --this->cp;  // argument start pointer
   int c = cget();  // refetch first character
-  int len;
+  NSInteger len;
   BOOL containsEntity = NO;
 
 #if EXTRA_DEBUG
@@ -1759,9 +1759,9 @@ NSLog(@"_processTag <%@%@ %@>", flag?@"/": @"", tag, attributes);
 
           case '<': 
             {
-              NSString                  *tag;
-              NSMutableDictionary       *attributes;
-              NSString                  *arg;
+              NSString                  *tag = nil;
+              NSMutableDictionary       *attributes = nil;
+              NSString                  *arg = nil;
               const unsigned char       *tp = this->cp;  // tag pointer
 	      const unsigned char	*sp = tp - 1;	// Open angle bracket
 
@@ -1946,8 +1946,9 @@ NSLog(@"_processTag <%@%@ %@>", flag?@"/": @"", tag, attributes);
 #endif
                   if (!this->acceptHTML && [arg length] == 0)
                     {
-                      return [self _parseError: @"empty attribute name"
-			code: NSXMLParserAttributeNotStartedError];
+                      [attributes release];
+                      [arg release];
+                      return [self _parseError: @"empty attribute name" code: NSXMLParserAttributeNotStartedError];
                     }
                   c = cget();
                   while (isspace(c))
diff --git a/Source/NSXMLPrivate.h b/Source/NSXMLPrivate.h
index 8a16dff..0e5d96c 100644
--- a/Source/NSXMLPrivate.h
+++ b/Source/NSXMLPrivate.h
@@ -66,10 +66,11 @@
  */
 #define	XMLSTRING(X)	((const unsigned char*)[X UTF8String])
 
-inline static unsigned char *XMLStringCopy(NSString *source)
+inline static unsigned char *
+XMLStringCopy(NSString *source)
 {
   char *xmlstr;
-  unsigned int len;
+  NSUInteger len;
 
   len = [source maximumLengthOfBytesUsingEncoding:NSUTF8StringEncoding] + 1;
   if (len == 0)
@@ -83,7 +84,7 @@ inline static NSString*
 StringFromXMLStringPtr(const unsigned char *bytes)
 {
   NSString	*str;
-  unsigned int length;
+  NSUInteger length;
 
   if (bytes == NULL)
     return @"";
@@ -109,6 +110,12 @@ StringFromXMLString(const unsigned char *bytes, unsigned length)
   return AUTORELEASE(str);
 }
 
+void
+cleanup_namespaces(xmlNodePtr node, xmlNsPtr ns);
+
+void
+ensure_oldNs(xmlNodePtr node);
+
 /* Instance variables for NSXMLNode.  This macro needs to be defined before
  * the NSXMLNode.h header is imported and before GSInternal.h is imported.
  *
diff --git a/Source/callframe.h b/Source/callframe.h
index 2da30f6..dfd2879 100644
--- a/Source/callframe.h
+++ b/Source/callframe.h
@@ -38,11 +38,11 @@ typedef struct _callframe_t {
 
 extern callframe_t *callframe_from_signature (NSMethodSignature *info,
   void **retval);
-extern void callframe_set_arg(callframe_t *cframe, int index, void *buffer,
+extern void callframe_set_arg(callframe_t *cframe, NSInteger index, void *buffer,
 			      int size);
-extern void callframe_get_arg(callframe_t *cframe, int index, void *buffer,
+extern void callframe_get_arg(callframe_t *cframe, NSInteger index, void *buffer,
 			      int size);
-extern void *callframe_arg_addr(callframe_t *cframe, int index);
+extern void *callframe_arg_addr(callframe_t *cframe, NSInteger index);
 
 #endif
 
diff --git a/Source/callframe.m b/Source/callframe.m
index 0e37a25..704fd22 100644
--- a/Source/callframe.m
+++ b/Source/callframe.m
@@ -156,7 +156,7 @@ callframe_from_signature (NSMethodSignature *info, void **retval)
 }
 
 void
-callframe_set_arg(callframe_t *cframe, int index, void *buffer, int size)
+callframe_set_arg(callframe_t *cframe, NSInteger index, void *buffer, int size)
 {
   if (index < 0 || index >= cframe->nargs)
      return;
@@ -164,7 +164,7 @@ callframe_set_arg(callframe_t *cframe, int index, void *buffer, int size)
 }
 
 void
-callframe_get_arg(callframe_t *cframe, int index, void *buffer, int size)
+callframe_get_arg(callframe_t *cframe, NSInteger index, void *buffer, int size)
 {
   if (index < 0 || index >= cframe->nargs)
      return;
@@ -172,7 +172,7 @@ callframe_get_arg(callframe_t *cframe, int index, void *buffer, int size)
 }
 
 void *
-callframe_arg_addr(callframe_t *cframe, int index)
+callframe_arg_addr(callframe_t *cframe, NSInteger index)
 {
   if (index < 0 || index >= cframe->nargs)
      return NULL;
diff --git a/Source/cifframe.h b/Source/cifframe.h
index 87edf17..5a53306 100644
--- a/Source/cifframe.h
+++ b/Source/cifframe.h
@@ -57,11 +57,11 @@ extern NSMutableData *cifframe_from_signature (NSMethodSignature *info);
 
 extern GSCodeBuffer* cifframe_closure (NSMethodSignature *sig, void (*func)());
 
-extern void cifframe_set_arg(cifframe_t *cframe, int index, void *buffer, 
+extern void cifframe_set_arg(cifframe_t *cframe, NSInteger index, void *buffer, 
 			     int size);
-extern void cifframe_get_arg(cifframe_t *cframe, int index, void *buffer,
+extern void cifframe_get_arg(cifframe_t *cframe, NSInteger index, void *buffer,
 			     int size);
-extern void *cifframe_arg_addr(cifframe_t *cframe, int index);
+extern void *cifframe_arg_addr(cifframe_t *cframe, NSInteger index);
 extern BOOL cifframe_decode_arg (const char *type, void* buffer);
 extern BOOL cifframe_encode_arg (const char *type, void* buffer);
 
diff --git a/Source/cifframe.m b/Source/cifframe.m
index 11c3a48..50946c2 100644
--- a/Source/cifframe.m
+++ b/Source/cifframe.m
@@ -25,7 +25,7 @@
 
 #import "common.h"
 
-#if !defined (__GNU_LIBOBJC__)
+#if !defined (__GNU_LIBOBJC__) && !defined (NeXT_RUNTIME)
 #  include <objc/encoding.h>
 #endif
 
@@ -101,11 +101,11 @@ ffi_type *cifframe_type(const char *typePtr, const char **advance);
 
 /* Best guess at the space needed for a structure, since we don't know
    for sure until it's calculated in ffi_prep_cif, which is too late */
-int
+static size_t
 cifframe_guess_struct_size(ffi_type *stype)
 {
-  int      i, size;
-  unsigned align = __alignof(double);
+  size_t size;
+  NSUInteger i, align = __alignof(double);
 
   if (stype->elements == NULL)
     return stype->size;
@@ -139,7 +139,7 @@ cifframe_from_signature (NSMethodSignature *info)
   NSMutableData	*result;
   void          *buf;
   int           i;
-  int		numargs = [info numberOfArguments];
+  int		numargs = (int)[info numberOfArguments];
   ffi_type      *rtype;
   ffi_type      *arg_types[numargs];
   cifframe_t    *cframe;
@@ -230,7 +230,7 @@ cifframe_from_signature (NSMethodSignature *info)
 }
 
 void
-cifframe_set_arg(cifframe_t *cframe, int index, void *buffer, int size)
+cifframe_set_arg(cifframe_t *cframe, NSInteger index, void *buffer, int size)
 {
   if (index < 0 || index >= cframe->nargs)
      return;
@@ -238,7 +238,7 @@ cifframe_set_arg(cifframe_t *cframe, int index, void *buffer, int size)
 }
 
 void
-cifframe_get_arg(cifframe_t *cframe, int index, void *buffer, int size)
+cifframe_get_arg(cifframe_t *cframe, NSInteger index, void *buffer, int size)
 {
   if (index < 0 || index >= cframe->nargs)
      return;
@@ -246,7 +246,7 @@ cifframe_get_arg(cifframe_t *cframe, int index, void *buffer, int size)
 }
 
 void *
-cifframe_arg_addr(cifframe_t *cframe, int index)
+cifframe_arg_addr(cifframe_t *cframe, NSInteger index)
 {
   if (index < 0 || index >= cframe->nargs)
      return NULL;
@@ -491,7 +491,7 @@ cifframe_type(const char *typePtr, const char **advance)
 	while (*typePtr != _C_UNION_E)
 	  {
 	    ffi_type *local;
-	    int align = objc_alignof_type(typePtr);
+	    int align = (int)objc_alignof_type(typePtr);
 	    local = cifframe_type(typePtr, &adv);
 	    typePtr = adv;
 	    NSCAssert(typePtr, @"End of signature while parsing");
diff --git a/Source/externs.m b/Source/externs.m
index a0e4b90..7da5537 100644
--- a/Source/externs.m
+++ b/Source/externs.m
@@ -300,6 +300,10 @@ GSPrivateBuildStrings()
 }
 
 
-
+#if (__GNUC__ == 3) && (__GNUC_MINOR__ == 1)
 /* For bug in gcc 3.1. See NSByteOrder.h */
-void _gcc3_1_hack(void){}
+void _gcc3_1_hack(void);
+void _gcc3_1_hack(void)
+{
+}
+#endif
\ No newline at end of file
diff --git a/Source/objc-load.m b/Source/objc-load.m
index 99de92e..15a941f 100644
--- a/Source/objc-load.m
+++ b/Source/objc-load.m
@@ -41,16 +41,23 @@
 #import "GSPrivate.h"
 
 /* include the interface to the dynamic linker */
-#include "dynamic-load.h"
+#if !defined (__APPLE__)
+#  include "dynamic-load.h"
+#else
+#  /* Sorry, but copying ?-load.h to dynamic-load.h with xCode is a real mess */
+#  include "simple-load.h" 
+#endif
 
 /* dynamic_loaded is YES if the dynamic loader was sucessfully initialized. */
 static BOOL	dynamic_loaded;
 
+#if !defined (NeXT_RUNTIME)
 /* Our current callback function */
 static void (*_objc_load_load_callback)(Class, struct objc_category *) = 0;
 
-/* Check to see if there are any undefined symbols. Print them out.
-*/
+/* 
+ * Check to see if there are any undefined symbols. Print them out.
+ */
 static int
 objc_check_undefineds(FILE *errorStream)
 {
@@ -78,7 +85,9 @@ objc_check_undefineds(FILE *errorStream)
   return 0;
 }
 
-/* Initialize for dynamic loading */
+/* 
+ * Initialize for dynamic loading
+ */
 static int
 objc_initialize_loading(FILE *errorStream)
 {
@@ -91,32 +100,33 @@ objc_initialize_loading(FILE *errorStream)
 
   dynamic_loaded = NO;
   path = GSPrivateExecutablePath();
-
+  
   NSDebugFLLog(@"NSBundle",
-    @"Debug (objc-load): initializing dynamic loader for %@", path);
-
+               @"Debug (objc-load): initializing dynamic loader for %@", path);
+  
   fsPath = [[path stringByDeletingLastPathComponent] fileSystemRepresentation];
-
+  
   if (__objc_dynamic_init(fsPath))
     {
       if (errorStream)
-	{
-	  __objc_dynamic_error(errorStream,
-           "Error (objc-load): Cannot initialize dynamic linker");
-	}
+        {
+          __objc_dynamic_error(errorStream,
+                               "Error (objc-load): Cannot initialize dynamic linker");
+        }
       return 1;
     }
   else
     {
       dynamic_loaded = YES;
     }
-
+  
   return 0;
 }
 
-/* A callback received from the Object initializer (_objc_exec_class).
-   Do what we need to do and call our own callback.
-*/
+/* 
+ * A callback received from the Object initializer (_objc_exec_class).
+ * Do what we need to do and call our own callback.
+ */
 static void
 objc_load_callback(Class class, struct objc_category * category)
 {
@@ -125,23 +135,63 @@ objc_load_callback(Class class, struct objc_category * category)
       _objc_load_load_callback(class, category);
     }
 }
+#endif /* NeXT_RUNTIME */
 
 #if	defined(__MINGW__)
-#define	FSCHAR	unichar
+#  define	FSCHAR unichar
 #else
-#define	FSCHAR	char
+#  define	FSCHAR char
 #endif
 
+/* returns zero on success */
 long
 GSPrivateLoadModule(NSString *filename, FILE *errorStream,
   void (*loadCallback)(Class, struct objc_category *),
   void **header, NSString *debugFilename)
 {
-#ifdef NeXT_RUNTIME
+#if defined (NeXT_RUNTIME)
+#ifndef __OBJC2__
+    
   int errcode;
   dynamic_loaded = YES;
-  return objc_loadModule([filename fileSystemRepresentation],
-    loadCallback, &errcode);
+  return objc_loadModule([filename fileSystemRepresentation], loadCallback, &errcode);
+    
+#else
+  
+  unsigned initialImageCount, imageCount;
+  const char **names = objc_copyImageNames(&initialImageCount);
+  if (names)
+    {
+      free(names);
+    }
+  
+  /* current NSBundle implementation does not support unloding
+   * and handle is never returned
+   */
+  void *handle = dlopen([filename fileSystemRepresentation], RTLD_NOW);
+  if (!handle && errorStream)
+    {
+      fprintf(errorStream, "%s\n", dlerror());
+    }
+  
+  names = objc_copyImageNames(&imageCount);
+  for (unsigned imageIndex = initialImageCount; imageIndex < imageCount; ++imageIndex)
+    {
+      unsigned classCount;
+      const char **classes = objc_copyClassNamesForImage(names[imageIndex], &classCount);
+      for (unsigned classIndex = 0; classIndex < classCount; ++classIndex)
+        {
+          loadCallback(objc_getClass(classes[classIndex]), NULL);
+        }
+      free(classes);
+    }
+  if (names)
+    {
+      free(names);
+    }
+  return handle == NULL;
+    
+#endif
 #else
   typedef void (*void_fn)();
   dl_handle_t handle;
@@ -222,7 +272,7 @@ GSPrivateLoadModule(NSString *filename, FILE *errorStream,
 
 long
 GSPrivateUnloadModule(FILE *errorStream,
-  void (*unloadCallback)(Class, struct objc_category *))
+                      void (*unloadCallback)(Class, struct objc_category *))
 {
   if (!dynamic_loaded)
     {
diff --git a/Source/simple-load.h b/Source/simple-load.h
index 347643b..d82a9d5 100644
--- a/Source/simple-load.h
+++ b/Source/simple-load.h
@@ -37,28 +37,32 @@ Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 #define CTOR_LIST       "__CTOR_LIST__"
 
 #ifndef RTLD_GLOBAL
-#define RTLD_GLOBAL 0
+#  define RTLD_GLOBAL 0
 #endif
+
 #ifndef RTLD_DEFAULT
-#define RTLD_DEFAULT 0
+#  define RTLD_DEFAULT 0
 #endif
 
 /* Types defined appropriately for the dynamic linker */
 typedef void* dl_handle_t;
 typedef void* dl_symbol_t;
 
-/* Do any initialization necessary.  Return 0 on success (or
-   if no initialization needed. 
-*/
+#if !defined (NeXT_RUNTIME)
+/* 
+ * Do any initialization necessary.  Return 0 on success (or
+ * if no initialization needed. 
+ */
 static int 
 __objc_dynamic_init(const char* exec_path)
 {
     return 0;
 }
 
-/* Link in the module given by the name 'module'.  Return a handle which can
-   be used to get information about the loded code.
-*/
+/* 
+ * Link in the module given by the name 'module'.  Return a handle which can
+ * be used to get information about the loded code.
+ */
 static dl_handle_t
 __objc_dynamic_link(const char* module, int mode, const char* debug_file)
 {
@@ -74,10 +78,11 @@ __objc_dynamic_link(const char* module, int mode, const char* debug_file)
 		return handle;
 	}
 #endif
-    return (dl_handle_t)dlopen(module, RTLD_LAZY | RTLD_GLOBAL);
+  return (dl_handle_t)dlopen(module, RTLD_LAZY | RTLD_GLOBAL);
 }
 
-/* Return the address of a symbol given by the name 'symbol' from the module
+/* 
+ * Return the address of a symbol given by the name 'symbol' from the module
  * associated with 'handle'
  * This function is not always used, so we mark it as unused to avoid warnings.
  */ 
@@ -90,23 +95,28 @@ __objc_dynamic_find_symbol(dl_handle_t handle, const char* symbol)
     return dlsym(handle, (char*)symbol);
 }
 
-/* remove the code from memory associated with the module 'handle' */
+/* 
+ * remove the code from memory associated with the module 'handle'
+ */
 static int 
 __objc_dynamic_unlink(dl_handle_t handle)
 {
     return dlclose(handle);
 }
 
-/* Print an error message (prefaced by 'error_string') relevant to the
-   last error encountered
-*/
+/*
+ * Print an error message (prefaced by 'error_string') relevant to the
+ * last error encountered
+ */
 static void 
 __objc_dynamic_error(FILE *error_stream, const char *error_string)
 {
     fprintf(error_stream, "%s:%s\n", error_string, dlerror());
 }
 
-/* Debugging:  define these if they are available */
+/* 
+ * Debugging:  define these if they are available
+ */
 static int 
 __objc_dynamic_undefined_symbol_count(void)
 {
@@ -143,4 +153,5 @@ __objc_dynamic_get_symbol_path(dl_handle_t handle, dl_symbol_t symbol)
 #endif
 }
 
-#endif /* __simple_load_h_INCLUDE */
+#endif /* NeXT_RUNTIME */
+#endif /* __simple_load_h_INCLUDE */
\ No newline at end of file
diff --git a/Source/unix/GSRunLoopCtxt.m b/Source/unix/GSRunLoopCtxt.m
index ac24293..a2660ba 100644
--- a/Source/unix/GSRunLoopCtxt.m
+++ b/Source/unix/GSRunLoopCtxt.m
@@ -114,7 +114,7 @@ static const NSMapTableValueCallBacks WatcherMapValueCallBacks =
 {
   if (completed == NO)
     {
-      unsigned i = GSIArrayCount(_trigger);
+      NSUInteger i = GSIArrayCount(_trigger);
 
       while (i-- > 0)
 	{
@@ -281,8 +281,8 @@ static void setPollfd(int fd, int event, GSRunLoopCtxt *ctxt)
   int		fdEnd;	/* Number of descriptors being monitored. */
   int		fdIndex;
   int		fdFinish;
-  unsigned	count;
-  unsigned int	i;
+  NSUInteger	count;
+  NSUInteger	i;
   BOOL		immediate = NO;
 
   i = GSIArrayCount(watchers);
@@ -692,19 +692,19 @@ static void setPollfd(int fd, int event, GSRunLoopCtxt *ctxt)
 - (BOOL) pollUntil: (int)milliseconds within: (NSArray*)contexts
 {
   GSRunLoopThreadInfo   *threadInfo = GSRunLoopInfoForThread(nil);
-  struct timeval	timeout;
-  void			*select_timeout;
-  int			select_return;
-  int			fdIndex;
-  int			fdFinish;
-  fd_set 		read_fds;	// Mask for read-ready fds.
-  fd_set 		exception_fds;	// Mask for exception fds.
-  fd_set 		write_fds;	// Mask for write-ready fds.
-  int			fd;
-  int			fdEnd = -1;
-  unsigned		count;
-  unsigned		i;
-  BOOL			immediate = NO;
+  struct timeval timeout;
+  void        *select_timeout;
+  int         select_return;
+  int         fdIndex;
+  int         fdFinish;
+  fd_set      read_fds;	// Mask for read-ready fds.
+  fd_set      exception_fds;	// Mask for exception fds.
+  fd_set      write_fds;	// Mask for write-ready fds.
+  int         fd;
+  int         fdEnd = -1;
+  NSUInteger  count;
+  NSUInteger  i;
+  BOOL        immediate = NO;
 
   i = GSIArrayCount(watchers);
 
@@ -719,7 +719,7 @@ static void setPollfd(int fd, int event, GSRunLoopCtxt *ctxt)
   else if (milliseconds > 0)
     {
       timeout.tv_sec = milliseconds/1000;
-      timeout.tv_usec = (milliseconds - 1000 * timeout.tv_sec) * 1000;
+      timeout.tv_usec = (suseconds_t) (milliseconds - 1000 * timeout.tv_sec) * 1000;
       select_timeout = &timeout;
     }
   else 
@@ -802,7 +802,7 @@ static void setPollfd(int fd, int event, GSRunLoopCtxt *ctxt)
 	      case ET_RPORT: 
 		{
 		  id port = info->receiver;
-                  NSInteger port_fd_size = FDCOUNT;
+      NSInteger port_fd_size = FDCOUNT;
 		  NSInteger port_fd_count = FDCOUNT;
 		  NSInteger port_fd_buffer[FDCOUNT];
 		  NSInteger *port_fd_array = port_fd_buffer;
@@ -816,11 +816,11 @@ static void setPollfd(int fd, int event, GSRunLoopCtxt *ctxt)
                       port_fd_array = malloc(sizeof(NSInteger)*port_fd_size);
                       [port getFds: port_fd_array count: &port_fd_count];
                     }
-		  NSDebugMLLog(@"NSRunLoop", @"listening to %d port sockets",
-		    port_fd_count);
+		  NSDebugMLLog(@"NSRunLoop", @"listening to %ld port sockets",
+		    (long)port_fd_count);
 		  while (port_fd_count--)
 		    {
-		      fd = port_fd_array[port_fd_count];
+		      fd = (int) port_fd_array[port_fd_count];
 		      if (fd > fdEnd)
 			fdEnd = fd;
 		      FD_SET (fd, &read_fds);
@@ -1083,7 +1083,7 @@ static void setPollfd(int fd, int event, GSRunLoopCtxt *ctxt)
   memset(&read_fds, '\0', sizeof(read_fds));
   memset(&write_fds, '\0', sizeof(write_fds));
   timeout.tv_sec = milliseconds/1000;
-  timeout.tv_usec = (milliseconds - 1000 * timeout.tv_sec) * 1000;
+  timeout.tv_usec = (suseconds_t) (milliseconds - 1000 * timeout.tv_sec) * 1000;
   FD_SET (threadInfo->inputFd, &read_fds);
   if (select (threadInfo->inputFd, &read_fds, &write_fds,
     &exception_fds, &timeout) > 0)
diff --git a/Source/unix/NSStream.m b/Source/unix/NSStream.m
index 14c7f3a..5cfc605 100644
--- a/Source/unix/NSStream.m
+++ b/Source/unix/NSStream.m
@@ -103,7 +103,7 @@
 
 - (NSInteger) read: (uint8_t *)buffer maxLength: (NSUInteger)len
 {
-  int readLen;
+  ssize_t readLen;
 
   if (buffer == 0)
     {
@@ -123,7 +123,7 @@
       return 0;
     }
 
-  readLen = read((intptr_t)_loopID, buffer, len);
+  readLen = read((int)_loopID, buffer, len);
   if (readLen < 0 && errno != EAGAIN && errno != EINTR)
     {
       [self _recordError];
@@ -155,7 +155,7 @@
       off_t offset = 0;
 
       if ([self _isOpened])
-        offset = lseek((intptr_t)_loopID, 0, SEEK_CUR);
+        offset = lseek((int)_loopID, 0, SEEK_CUR);
       return [NSNumber numberWithLong: offset];
     }
   return [super propertyForKey: key];
@@ -177,7 +177,7 @@
 
 - (void) close
 {
-  int closeReturn = close((intptr_t)_loopID);
+  int closeReturn = close((int)_loopID);
 
   if (closeReturn < 0)
     [self _recordError];
@@ -239,7 +239,7 @@
 
 - (NSInteger) write: (const uint8_t *)buffer maxLength: (NSUInteger)len
 {
-  int writeLen;
+  ssize_t writeLen;
 
   if (buffer == 0)
     {
@@ -259,7 +259,7 @@
       return 0;
     }
 
-  writeLen = write((intptr_t)_loopID, buffer, len);
+  writeLen = write((int)_loopID, buffer, len);
   if (writeLen < 0 && errno != EAGAIN && errno != EINTR)
     [self _recordError];
   return writeLen;
@@ -294,7 +294,7 @@
 
 - (void) close
 {
-  int closeReturn = close((intptr_t)_loopID);
+  int closeReturn = close((int)_loopID);
   if (closeReturn < 0)
     [self _recordError];
   [super close];
@@ -307,7 +307,7 @@
       off_t offset = 0;
 
       if ([self _isOpened])
-        offset = lseek((intptr_t)_loopID, 0, SEEK_CUR);
+        offset = lseek((int)_loopID, 0, SEEK_CUR);
       return [NSNumber numberWithLong: offset];
     }
   return [super propertyForKey: key];
diff --git a/Support/Foundation/Foundation-Info.plist b/Support/Foundation/Foundation-Info.plist
new file mode 100644
index 0000000..1ecc08b
--- /dev/null
+++ b/Support/Foundation/Foundation-Info.plist
@@ -0,0 +1,30 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
+<plist version="1.0">
+<dict>
+	<key>CFBundleDevelopmentRegion</key>
+	<string>English</string>
+	<key>CFBundleExecutable</key>
+	<string>${EXECUTABLE_NAME}</string>
+	<key>CFBundleIconFile</key>
+	<string></string>
+	<key>CFBundleIdentifier</key>
+	<string>org.gnustep.${PRODUCT_NAME:rfc1034identifier}</string>
+	<key>CFBundleInfoDictionaryVersion</key>
+	<string>6.0</string>
+	<key>CFBundleName</key>
+	<string>${PRODUCT_NAME}</string>
+	<key>CFBundlePackageType</key>
+	<string>FMWK</string>
+	<key>CFBundleShortVersionString</key>
+	<string>1.0</string>
+	<key>CFBundleSignature</key>
+	<string>????</string>
+	<key>CFBundleVersion</key>
+	<string>1</string>
+	<key>NSHumanReadableCopyright</key>
+	<string>Copyright © 2012 __MyCompanyName__. All rights reserved.</string>
+	<key>NSPrincipalClass</key>
+	<string></string>
+</dict>
+</plist>
diff --git a/Support/Foundation/Foundation-Prefix.pch b/Support/Foundation/Foundation-Prefix.pch
new file mode 100644
index 0000000..64d4f37
--- /dev/null
+++ b/Support/Foundation/Foundation-Prefix.pch
@@ -0,0 +1,3 @@
+//
+// Prefix header for all source files of the 'Foundation' target in the 'Foundation' project
+//
\ No newline at end of file
diff --git a/Tests/base/KVO/TestInfo b/Tests/base/KVO/TestInfo
new file mode 100644
index 0000000..e69de29
diff --git a/Tests/base/KVO/test00.m b/Tests/base/KVO/test00.m
new file mode 100644
index 0000000..24adbfc
--- /dev/null
+++ b/Tests/base/KVO/test00.m
@@ -0,0 +1,510 @@
+/*
+ * Implementation of GNUSTEP key value observing
+ * Copyright (C) 2013 Free Software Foundation, Inc.
+ *
+ * Written by Marat Ibadinov <ibadinov@me.com>
+ * Date: 2013
+ *
+ * This file is part of the GNUstep Base Library.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free
+ * Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110 USA.
+ *
+ * $Date$ $Revision$
+ */
+
+#import "Testing.h"
+#import <Foundation/Foundation.h>
+
+#define AssignRetained(property, value) \
+do {                                    \
+    id backup = property;               \
+    property = [value retain];          \
+    [backup release];                   \
+} while (0)
+
+
+@interface Account : NSObject {
+    NSUInteger uploaded;
+    NSUInteger dowloaded;
+}
+
+- (NSUInteger)uploaded;
+- (NSUInteger)downloaded;
+- (NSUInteger)ratio;
+
+- (void)setUploaded:(NSUInteger)uploadedDataSize;
+- (void)setDownloaded:(NSUInteger)downloadedDataSize;
+
+@end
+
+@implementation Account
+
+- (id)init
+{
+    if (self = [super init]) {
+        uploaded = dowloaded = 0;
+    }
+    return self;
+}
+
+- (NSUInteger)uploaded
+{
+    return uploaded;
+}
+
+- (NSUInteger)downloaded
+{
+    return dowloaded;
+}
+
+- (NSUInteger)ratio
+{
+    static NSUInteger InitialThreshold = 4096;
+    
+    double ratio = (double)uploaded / (double)dowloaded;
+    return dowloaded > InitialThreshold ? floor(ratio * 100) : 1;
+}
+
+- (void)setUploaded:(NSUInteger)uploadedDataSize
+{
+    [self willChangeValueForKey:@"uploaded"];
+    uploaded = uploadedDataSize;
+    [self didChangeValueForKey:@"uploaded"];
+}
+
+-(void)setDownloaded:(NSUInteger)downloadedDataSize
+{
+    [self willChangeValueForKey:@"downloaded"];
+    dowloaded = downloadedDataSize;
+    [self didChangeValueForKey:@"downloaded"];
+}
+
++ (NSSet *)keyPathsForValuesAffectingValueForKey:(NSString *)key
+{
+    NSSet *keyPaths = [super keyPathsForValuesAffectingValueForKey:key];
+    if ([key isEqualToString:@"ratio"]) {
+        NSArray *affectingKeys = [NSArray arrayWithObjects:@"uploaded", @"downloaded", nil];
+        return [keyPaths setByAddingObjectsFromArray:affectingKeys];
+    }
+    return keyPaths;
+}
+
++ (BOOL)automaticallyNotifiesObserversForKey:(NSString *)key
+{
+    if ([key isEqualToString:@"uploaded"] || [key isEqualToString:@"downloaded"]) {
+        return NO;
+    }
+    return [super automaticallyNotifiesObserversForKey:key];
+}
+
+@end
+
+
+@interface Person : NSObject {
+    NSString    *firstName;
+    NSString    *lastName;
+    Account     *account;
+}
+
+- (id)initWithFirstName:(NSString *)aFirstName lastName:(NSString *)aLastName;
+
+- (NSString *)firstName;
+- (NSString *)lastName;
+- (NSString *)fullName;
+
+- (void)setFirstName:(NSString *)aName;
+- (void)setLastName:(NSString *)aName;
+
+- (Account *)account;
+- (void)setAccount:(Account *)anAccount;
+
+@end
+
+@implementation Person
+
+- (id)initWithFirstName:(NSString *)aFirstName lastName:(NSString *)aLastName
+{
+    if (self = [super init]) {
+        AssignRetained(firstName, aFirstName);
+        AssignRetained(lastName, aLastName);
+        account = [[Account alloc] init];
+    }
+    return self;
+}
+
+- (void)dealloc
+{
+    [lastName release];
+    [firstName release];
+    [super dealloc];
+}
+
+- (NSString *)firstName
+{
+    return firstName;
+}
+
+- (NSString *)lastName
+{
+    return lastName;
+}
+
+- (NSString *)fullName
+{
+    return [NSString stringWithFormat:@"%@ %@", firstName, lastName];
+}
+
+- (void)setFirstName:(NSString *)aName
+{
+    [self willChangeValueForKey:@"firstName"];
+    AssignRetained(firstName, aName);
+    [self didChangeValueForKey:@"firstName"];
+}
+
+- (void)setLastName:(NSString *)aName
+{
+    [self willChangeValueForKey:@"lastName"];
+    AssignRetained(lastName, aName);
+    [self didChangeValueForKey:@"lastName"];
+}
+
+- (Account *)account
+{
+    return account;
+}
+
+- (void)setAccount:(Account *)anAccount
+{
+    [self willChangeValueForKey:@"account"];
+    AssignRetained(account, anAccount);
+    [self didChangeValueForKey:@"account"];
+}
+
+- (NSString *)description
+{
+    return [NSString stringWithFormat:@"%@: %ld", [self fullName], (long)[account ratio]];
+}
+
++ (NSSet *)keyPathsForValuesAffectingValueForKey:(NSString *)key
+{
+    NSSet *keyPaths = [super keyPathsForValuesAffectingValueForKey:key];
+    if ([key isEqualToString:@"fullName"]) {
+        NSArray *affectingKeys = [NSArray arrayWithObjects:@"firstName", @"lastName", nil];
+        keyPaths = [keyPaths setByAddingObjectsFromArray:affectingKeys];
+    } 
+    if ([key isEqualToString:@"description"]) {
+        NSArray *affectingKeys = [NSArray arrayWithObjects:@"fullName", @"account.ratio", nil];
+        keyPaths = [keyPaths setByAddingObjectsFromArray:affectingKeys];
+    }
+    return keyPaths;
+}
+
++ (BOOL)automaticallyNotifiesObserversForKey:(NSString *)key
+{
+    if ([key isEqualToString:@"firstName"] || [key isEqualToString:@"lastName"] || [key isEqualToString:@"account"]) {
+        return NO;
+    }
+    return [super automaticallyNotifiesObserversForKey:key];
+}
+
+@end
+
+
+@interface Observer : NSObject {
+    NSMutableArray *log;
+}
+
+- (NSArray *)log;
+- (void)reset;
+
+@end
+
+@implementation Observer
+
+- (id)init
+{
+    if (self = [super init]) {
+        log = [NSMutableArray new];
+    }
+    return self;
+}
+
+- (void)dealloc
+{
+    [log dealloc];
+    [super dealloc];
+}
+
+- (NSArray *)log
+{
+    return [[log copy] autorelease];
+}
+
+- (void)reset
+{
+    [log removeAllObjects];
+}
+
+- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context
+{
+    NSMutableDictionary *logEntry = [NSMutableDictionary new];    
+    NSEnumerator *enumerator = [change keyEnumerator];
+    NSString *key;
+    while ((key = [enumerator nextObject])) {
+        id object = [change objectForKey:key];
+        if ([object isKindOfClass:[NSNumber class]]) {
+            [logEntry setObject:[(NSNumber *)object stringValue] forKey:key];
+        } else {
+            [logEntry setObject:object forKey:key];
+        }
+    }
+    [logEntry setObject:keyPath forKey:@"path"];
+    [log addObject:logEntry];
+    [logEntry release];
+}
+
+@end
+
+
+@interface RecursionObserver : Observer {
+    NSObject    *value;
+    NSString    *key;
+    NSUInteger  depth;
+}
+
+- (id)initWithIntermediateValue:(NSObject *)aValue forKey:(NSString *)aKey;
+
+@end
+
+@implementation RecursionObserver
+
+- (id)initWithIntermediateValue:(NSObject *)aValue forKey:(NSString *)aKey
+{
+    if (self = [super init]) {
+        AssignRetained(value, aValue);
+        AssignRetained(key, aKey);
+        depth = 0;
+    }
+    return self;
+}
+
+- (void)dealloc
+{
+    [key release];
+    [value release];
+    [super dealloc];
+}
+
+- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context
+{
+    [super observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context];
+    if (++depth == 1) {
+        [object setValue:value forKey:key];
+    }
+}
+
+@end
+
+
+@interface StackCurruptionObserver : Observer {
+    NSString *path;
+}
+
+- (id)initWithKeyPath:(NSString *)aPath;
+
+@end
+
+@implementation StackCurruptionObserver
+
+- (id)initWithKeyPath:(NSString *)aPath
+{
+    if (self = [super init]) {
+        path = [aPath retain];
+    }
+    return self;
+}
+
+- (void)dealloc
+{
+    [path release];
+    [super dealloc];
+}
+
+- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context
+{
+    [super observeValueForKeyPath:keyPath ofObject:object change:change context:context];
+    if ([[change objectForKey:NSKeyValueChangeNotificationIsPriorKey] boolValue]) {
+        [object didChangeValueForKey:path];
+    }
+}
+
+
+@end
+
+
+int main()
+{
+    NSAutoreleasePool *pool = [NSAutoreleasePool new];
+    NSString *firstNameKey = @"firstName";
+    NSString *lastNameKey = @"lastName";
+    NSString *fullNameKey = @"fullName";
+    NSString *descriptionKey = @"description";
+    [[NSFileManager defaultManager] changeCurrentDirectoryPath:@"test00"];
+    
+    NSArray *log;
+    NSKeyValueObservingOptions options = NSKeyValueObservingOptionOld | NSKeyValueObservingOptionNew | NSKeyValueObservingOptionPrior;
+    Person *observable = [[Person alloc] initWithFirstName:@"James" lastName:@"Watson"];
+    
+    
+    RecursionObserver *recursionObserver = [[RecursionObserver alloc] initWithIntermediateValue:@"John" forKey:firstNameKey];
+    [observable addObserver:recursionObserver forKeyPath:firstNameKey options:options context:NULL];
+    [observable setValue:@"Emma" forKey:firstNameKey];
+    [observable removeObserver:recursionObserver forKeyPath:firstNameKey];
+    
+    log = [NSArray arrayWithContentsOfFile:@"ChangeStack.plist"];
+    PASS([[recursionObserver log] isEqual:log], "KVO maintains change stack");
+    [recursionObserver release];
+    
+    
+    [observable setValue:@"James" forKey:firstNameKey];
+    StackCurruptionObserver *stackObserver = [[StackCurruptionObserver alloc] initWithKeyPath:lastNameKey];
+    [observable addObserver:stackObserver forKeyPath:firstNameKey options:options context:NULL];
+    [observable addObserver:stackObserver forKeyPath:lastNameKey options:options context:NULL];
+    [observable setValue:@"Emma" forKey:firstNameKey];
+    [observable removeObserver:stackObserver forKeyPath:lastNameKey];
+    [observable removeObserver:stackObserver forKeyPath:firstNameKey];
+        
+    log = [NSArray arrayWithContentsOfFile:@"StackCorruption.plist"];
+    PASS([[stackObserver log] isEqual:log], "KVO is robust against stack corruption");
+    [stackObserver release];
+    
+    
+    [observable setValue:@"John" forKey:firstNameKey];
+    Observer *simpleObserver = [Observer new];
+    [observable addObserver:simpleObserver forKeyPath:firstNameKey options:NSKeyValueObservingOptionNew context:NULL];
+    [observable addObserver:simpleObserver forKeyPath:firstNameKey options:NSKeyValueObservingOptionNew context:NULL];
+    [observable setValue:@"James" forKey:firstNameKey];    
+    [observable removeObserver:simpleObserver forKeyPath:firstNameKey];
+    [observable removeObserver:simpleObserver forKeyPath:firstNameKey];
+    
+    log = [NSArray arrayWithContentsOfFile:@"Observance.plist"];
+    PASS([[simpleObserver log] isEqual:log], "KVO sends notifications to each observance");
+    
+    
+    [observable setValue:@"James" forKey:firstNameKey];
+    [simpleObserver reset];
+    [observable addObserver:simpleObserver forKeyPath:firstNameKey options:NSKeyValueObservingOptionNew context:NULL];
+    [observable addObserver:simpleObserver forKeyPath:firstNameKey options:options context:NULL];
+    [observable setValue:@"John" forKey:firstNameKey];
+    [observable removeObserver:simpleObserver forKeyPath:firstNameKey];
+    [observable setValue:@"Emma" forKey:firstNameKey];
+    [observable removeObserver:simpleObserver forKeyPath:firstNameKey];
+    
+    log = [NSArray arrayWithContentsOfFile:@"ObservanceStack.plist"];
+    PASS([[simpleObserver log] isEqual:log], "KVO processes observances as a stack");    
+    
+    
+    [observable setValue:@"Emma" forKey:firstNameKey];
+    [simpleObserver reset];
+    [observable addObserver:simpleObserver forKeyPath:fullNameKey options:options context:NULL];
+    [observable addObserver:simpleObserver forKeyPath:firstNameKey options:options context:NULL];
+    [observable addObserver:simpleObserver forKeyPath:fullNameKey options:NSKeyValueObservingOptionPrior | NSKeyValueObservingOptionNew context:NULL];
+    [observable setValue:@"John" forKey:firstNameKey];
+    [observable removeObserver:simpleObserver forKeyPath:fullNameKey];
+    [observable removeObserver:simpleObserver forKeyPath:firstNameKey];
+    [observable removeObserver:simpleObserver forKeyPath:fullNameKey];
+    
+    log = [NSArray arrayWithContentsOfFile:@"DependencyObservance.plist"];
+    PASS([[simpleObserver log] isEqual:log], "KVO adds observances to affecting keys");
+    
+    
+    [simpleObserver reset];
+    [observable setValue:@"John" forKey:firstNameKey];
+    [observable addObserver:simpleObserver forKeyPath:descriptionKey options:options context:NULL];
+    [observable addObserver:simpleObserver forKeyPath:fullNameKey options:options context:NULL];
+    [observable addObserver:simpleObserver forKeyPath:firstNameKey options:options context:NULL];
+    [observable setValue:@"Emma" forKey:firstNameKey];
+    [observable removeObserver:simpleObserver forKeyPath:firstNameKey];
+    [observable removeObserver:simpleObserver forKeyPath:fullNameKey];
+    [observable removeObserver:simpleObserver forKeyPath:descriptionKey];
+    
+    log = [NSArray arrayWithContentsOfFile:@"ComplexDependency.plist"];
+    PASS([[simpleObserver log] isEqual:log], "KVO supports complex dependencies");
+    
+    
+    NSString *accountKey = @"account";
+    NSString *uploadedKeyPath = @"account.uploaded";
+    NSString *downloadedKeyPath = @"account.downloaded";
+    NSString *ratioKeyPath = @"account.ratio";    
+    
+    
+    [simpleObserver reset];
+    [observable addObserver:simpleObserver forKeyPath:uploadedKeyPath options:options context:NULL];
+    [observable setValue:[NSNumber numberWithInteger:1024] forKeyPath:uploadedKeyPath];
+    [observable removeObserver:simpleObserver forKeyPath:uploadedKeyPath];
+    
+    log = [NSArray arrayWithContentsOfFile:@"NestedProperty.plist"];
+    PASS([[simpleObserver log] isEqual:log], "KVO supports nested properties");
+    
+    
+    [simpleObserver reset];
+    [observable setValue:[NSNumber numberWithInteger:4096] forKeyPath:uploadedKeyPath];
+    [observable addObserver:simpleObserver forKeyPath:uploadedKeyPath options:options context:NULL];
+    [observable addObserver:simpleObserver forKeyPath:downloadedKeyPath options:options context:NULL];
+    [observable setValue:[[Account new] autorelease] forKey:accountKey];
+    [observable setValue:[NSNumber numberWithInteger:512] forKeyPath:downloadedKeyPath];
+    [observable removeObserver:simpleObserver forKeyPath:downloadedKeyPath];
+    [observable removeObserver:simpleObserver forKeyPath:uploadedKeyPath];
+    
+    log = [NSArray arrayWithContentsOfFile:@"NestedPropertyLevels.plist"];
+    PASS([[simpleObserver log] isEqual:log], "KVO observes nested properties at all levels");
+    
+    
+    [simpleObserver reset];
+    [observable setValue:[NSNumber numberWithInteger:0] forKeyPath:downloadedKeyPath];
+    [observable addObserver:simpleObserver forKeyPath:ratioKeyPath options:options context:NULL];
+    [observable addObserver:simpleObserver forKeyPath:uploadedKeyPath options:options context:NULL];
+    [observable addObserver:simpleObserver forKeyPath:downloadedKeyPath options:options context:NULL];
+    [observable addObserver:simpleObserver forKeyPath:ratioKeyPath options:options context:NULL];
+    [observable setValue:[NSNumber numberWithInteger:1024] forKeyPath:uploadedKeyPath];
+    [observable setValue:[NSNumber numberWithInteger:4096] forKeyPath:downloadedKeyPath];
+    [observable removeObserver:simpleObserver forKeyPath:ratioKeyPath];
+    [observable removeObserver:simpleObserver forKeyPath:downloadedKeyPath];
+    [observable removeObserver:simpleObserver forKeyPath:uploadedKeyPath];
+    [observable removeObserver:simpleObserver forKeyPath:ratioKeyPath];
+    
+    log = [NSArray arrayWithContentsOfFile:@"DependentNestedProperty.plist"];
+    PASS([[simpleObserver log] isEqual:log], "KVO supports nested properties with dependencies");
+    
+    [simpleObserver reset];
+    [observable setValue:@"James" forKey:firstNameKey];
+    [observable setValue:[[Account new] autorelease] forKey:accountKey];
+    [observable addObserver:simpleObserver forKeyPath:descriptionKey options:options context:NULL];
+    [observable addObserver:simpleObserver forKeyPath:ratioKeyPath options:options context:NULL];
+    [observable addObserver:simpleObserver forKeyPath:downloadedKeyPath options:options context:NULL];
+    [observable setValue:[NSNumber numberWithInt:8192] forKeyPath:downloadedKeyPath];
+    [observable removeObserver:simpleObserver forKeyPath:downloadedKeyPath];
+    [observable removeObserver:simpleObserver forKeyPath:ratioKeyPath];
+    [observable removeObserver:simpleObserver forKeyPath:descriptionKey];
+    
+    log = [NSArray arrayWithContentsOfFile:@"NestedPropertyDependency.plist"];
+    PASS([[simpleObserver log] isEqual:log], "KVO supports dependencies on nested properties");
+    [simpleObserver release];
+    
+    
+    [observable release];
+    [pool release];
+}
\ No newline at end of file
diff --git a/Tests/base/KVO/test00/ChangeStack.plist b/Tests/base/KVO/test00/ChangeStack.plist
new file mode 100644
index 0000000..c69a2cf
--- /dev/null
+++ b/Tests/base/KVO/test00/ChangeStack.plist
@@ -0,0 +1,26 @@
+(
+    {
+        kind = 1;
+        notificationIsPrior = 1;
+        old = James;
+        path = firstName;
+    },
+    {
+        kind = 1;
+        notificationIsPrior = 1;
+        old = James;
+        path = firstName;
+    },
+    {
+        kind = 1;
+        new = John;
+        old = James;
+        path = firstName;
+    },
+    {
+        kind = 1;
+        new = Emma;
+        old = James;
+        path = firstName;
+    }
+)
\ No newline at end of file
diff --git a/Tests/base/KVO/test00/ComplexDependency.plist b/Tests/base/KVO/test00/ComplexDependency.plist
new file mode 100644
index 0000000..706e7a2
--- /dev/null
+++ b/Tests/base/KVO/test00/ComplexDependency.plist
@@ -0,0 +1,38 @@
+(
+    {
+        kind = 1;
+        notificationIsPrior = 1;
+        old = "John Watson: 1";
+        path = description;
+    },
+        {
+        kind = 1;
+        notificationIsPrior = 1;
+        old = "John Watson";
+        path = fullName;
+    },
+        {
+        kind = 1;
+        notificationIsPrior = 1;
+        old = John;
+        path = firstName;
+    },
+        {
+        kind = 1;
+        new = Emma;
+        old = John;
+        path = firstName;
+    },
+        {
+        kind = 1;
+        new = "Emma Watson";
+        old = "John Watson";
+        path = fullName;
+    },
+        {
+        kind = 1;
+        new = "Emma Watson: 1";
+        old = "John Watson: 1";
+        path = description;
+    }
+)
\ No newline at end of file
diff --git a/Tests/base/KVO/test00/DependencyObservance.plist b/Tests/base/KVO/test00/DependencyObservance.plist
new file mode 100644
index 0000000..d62ffba
--- /dev/null
+++ b/Tests/base/KVO/test00/DependencyObservance.plist
@@ -0,0 +1,36 @@
+(
+    {
+        kind = 1;
+        notificationIsPrior = 1;
+        old = "Emma Watson";
+        path = fullName;
+    },
+    {
+        kind = 1;
+        notificationIsPrior = 1;
+        old = Emma;
+        path = firstName;
+    },
+    {
+        kind = 1;
+        notificationIsPrior = 1;
+        path = fullName;
+    },
+    {
+        kind = 1;
+        new = "John Watson";
+        path = fullName;
+    },
+    {
+        kind = 1;
+        new = John;
+        old = Emma;
+        path = firstName;
+    },
+    {
+        kind = 1;
+        new = "John Watson";
+        old = "Emma Watson";
+        path = fullName;
+    }
+)
diff --git a/Tests/base/KVO/test00/DependentNestedProperty.plist b/Tests/base/KVO/test00/DependentNestedProperty.plist
new file mode 100644
index 0000000..d46b53b
--- /dev/null
+++ b/Tests/base/KVO/test00/DependentNestedProperty.plist
@@ -0,0 +1,74 @@
+(
+    {
+        kind = 1;
+        notificationIsPrior = 1;
+        old = 1;
+        path = "account.ratio";
+    },
+        {
+        kind = 1;
+        notificationIsPrior = 1;
+        old = 0;
+        path = "account.uploaded";
+    },
+        {
+        kind = 1;
+        notificationIsPrior = 1;
+        old = 1;
+        path = "account.ratio";
+    },
+        {
+        kind = 1;
+        new = 1;
+        old = 1;
+        path = "account.ratio";
+    },
+        {
+        kind = 1;
+        new = 1024;
+        old = 0;
+        path = "account.uploaded";
+    },
+        {
+        kind = 1;
+        new = 1;
+        old = 1;
+        path = "account.ratio";
+    },
+        {
+        kind = 1;
+        notificationIsPrior = 1;
+        old = 1;
+        path = "account.ratio";
+    },
+        {
+        kind = 1;
+        notificationIsPrior = 1;
+        old = 0;
+        path = "account.downloaded";
+    },
+        {
+        kind = 1;
+        notificationIsPrior = 1;
+        old = 1;
+        path = "account.ratio";
+    },
+        {
+        kind = 1;
+        new = 1;
+        old = 1;
+        path = "account.ratio";
+    },
+        {
+        kind = 1;
+        new = 4096;
+        old = 0;
+        path = "account.downloaded";
+    },
+        {
+        kind = 1;
+        new = 1;
+        old = 1;
+        path = "account.ratio";
+    }
+)
\ No newline at end of file
diff --git a/Tests/base/KVO/test00/NestedProperty.plist b/Tests/base/KVO/test00/NestedProperty.plist
new file mode 100644
index 0000000..6521a48
--- /dev/null
+++ b/Tests/base/KVO/test00/NestedProperty.plist
@@ -0,0 +1,14 @@
+(
+    {
+        kind = 1;
+        notificationIsPrior = 1;
+        old = 0;
+        path = "account.uploaded";
+    },
+        {
+        kind = 1;
+        new = 1024;
+        old = 0;
+        path = "account.uploaded";
+    }
+)
\ No newline at end of file
diff --git a/Tests/base/KVO/test00/NestedPropertyDependency.plist b/Tests/base/KVO/test00/NestedPropertyDependency.plist
new file mode 100644
index 0000000..ccd04dd
--- /dev/null
+++ b/Tests/base/KVO/test00/NestedPropertyDependency.plist
@@ -0,0 +1,38 @@
+(
+    {
+        kind = 1;
+        notificationIsPrior = 1;
+        old = "James Watson: 1";
+        path = description;
+    },
+        {
+        kind = 1;
+        notificationIsPrior = 1;
+        old = 1;
+        path = "account.ratio";
+    },
+        {
+        kind = 1;
+        notificationIsPrior = 1;
+        old = 0;
+        path = "account.downloaded";
+    },
+        {
+        kind = 1;
+        new = 8192;
+        old = 0;
+        path = "account.downloaded";
+    },
+        {
+        kind = 1;
+        new = 0;
+        old = 1;
+        path = "account.ratio";
+    },
+        {
+        kind = 1;
+        new = "James Watson: 0";
+        old = "James Watson: 1";
+        path = description;
+    }
+)
\ No newline at end of file
diff --git a/Tests/base/KVO/test00/NestedPropertyLevels.plist b/Tests/base/KVO/test00/NestedPropertyLevels.plist
new file mode 100644
index 0000000..56b835e
--- /dev/null
+++ b/Tests/base/KVO/test00/NestedPropertyLevels.plist
@@ -0,0 +1,38 @@
+(
+    {
+        kind = 1;
+        notificationIsPrior = 1;
+        old = 4096;
+        path = "account.uploaded";
+    },
+        {
+        kind = 1;
+        notificationIsPrior = 1;
+        old = 0;
+        path = "account.downloaded";
+    },
+        {
+        kind = 1;
+        new = 0;
+        old = 0;
+        path = "account.downloaded";
+    },
+        {
+        kind = 1;
+        new = 0;
+        old = 4096;
+        path = "account.uploaded";
+    },
+        {
+        kind = 1;
+        notificationIsPrior = 1;
+        old = 0;
+        path = "account.downloaded";
+    },
+        {
+        kind = 1;
+        new = 512;
+        old = 0;
+        path = "account.downloaded";
+    }
+)
diff --git a/Tests/base/KVO/test00/Observance.plist b/Tests/base/KVO/test00/Observance.plist
new file mode 100644
index 0000000..25be313
--- /dev/null
+++ b/Tests/base/KVO/test00/Observance.plist
@@ -0,0 +1,12 @@
+(
+    {
+        kind = 1;
+        new = James;
+        path = firstName;
+    },
+    {
+        kind = 1;
+        new = James;
+        path = firstName;
+    }
+)
\ No newline at end of file
diff --git a/Tests/base/KVO/test00/ObservanceStack.plist b/Tests/base/KVO/test00/ObservanceStack.plist
new file mode 100644
index 0000000..06cac09
--- /dev/null
+++ b/Tests/base/KVO/test00/ObservanceStack.plist
@@ -0,0 +1,24 @@
+(
+    {
+        kind = 1;
+        notificationIsPrior = 1;
+        old = James;
+        path = firstName;
+    },
+    {
+        kind = 1;
+        new = John;
+        old = James;
+        path = firstName;
+    },
+    {
+        kind = 1;
+        new = John;
+        path = firstName;
+    },
+    {
+        kind = 1;
+        new = Emma;
+        path = firstName;
+    }
+)
\ No newline at end of file
diff --git a/Tests/base/KVO/test00/StackCorruption.plist b/Tests/base/KVO/test00/StackCorruption.plist
new file mode 100644
index 0000000..e8afcd5
--- /dev/null
+++ b/Tests/base/KVO/test00/StackCorruption.plist
@@ -0,0 +1,14 @@
+(
+    {
+        kind = 1;
+        notificationIsPrior = 1;
+        old = James;
+        path = firstName;
+    },
+    {
+        kind = 1;
+        new = Emma;
+        old = James;
+        path = firstName;
+    }
+)
\ No newline at end of file
diff --git a/Tests/base/KVO/test01.m b/Tests/base/KVO/test01.m
new file mode 100644
index 0000000..dfefde0
--- /dev/null
+++ b/Tests/base/KVO/test01.m
@@ -0,0 +1,270 @@
+/*
+ * Implementation of GNUSTEP key value observing
+ * Copyright (C) 2013 Free Software Foundation, Inc.
+ *
+ * Written by Marat Ibadinov <ibadinov@me.com>
+ * Date: 2013
+ *
+ * This file is part of the GNUstep Base Library.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free
+ * Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110 USA.
+ *
+ * $Date$ $Revision$
+ */
+
+#import <Foundation/Foundation.h>
+#import "Testing.h"
+
+@interface DirectObservable : NSObject {
+    id          _id;
+    char        _char;
+    double      _double;
+    float       _float;
+    int         _int;
+    long        _long;
+    long long   _longLong;
+    short       _short;
+    NSRange range;
+    NSPoint point;
+    NSSize  size;
+    NSRect  rect;
+    id      manual;
+}
+
+@end
+
+@interface Observable : DirectObservable {
+}
+
+- (void)setId:(id)value;
+- (void)setChar:(unsigned char)value;
+- (void)setDouble:(double)value;
+- (void)setFloat:(float)value;
+- (void)setInt:(unsigned int)value;
+- (void)setLong:(unsigned long)value;
+- (void)setLongLong:(unsigned long long)value;
+- (void)setShort:(unsigned short)value;
+
+- (void)setRange:(NSRange)value;
+- (void)setPoint:(NSPoint)value;
+- (void)setSize:(NSSize)value;
+- (void)setRect:(NSRect)value;
+
+@end
+
+
+@implementation DirectObservable
+
+- (NSString *)description
+{
+    return @"direct property access";
+}
+
++ (BOOL)automaticallyNotifiesObserversForKey:(NSString *)aKey
+{
+    if ([aKey isEqualToString:@"manual"]) {
+        return NO;
+    }
+    return [super automaticallyNotifiesObserversForKey:aKey];
+}
+
+@end
+
+@implementation Observable
+
+- (void)setId:(id)value
+{
+    _id = value;
+}
+
+- (void)setChar:(unsigned char)value
+{
+    _char = value;
+}
+
+- (void)setDouble:(double)value
+{
+    _double = value;
+}
+
+- (void)setFloat:(float)value
+{
+    _float = value;
+}
+
+- (void)setInt:(unsigned int)value
+{
+    _int = value;
+}
+
+- (void)setLong:(unsigned long)value
+{
+    _long = value;
+}
+
+- (void)setLongLong:(unsigned long long)value
+{
+    _longLong = value;
+}
+
+- (void)setShort:(unsigned short)value
+{
+    _short = value;
+}
+
+- (void)setRange:(NSRange)value
+{
+    range = value;
+}
+
+- (void)setPoint:(NSPoint)value
+{
+    point = value;
+}
+
+- (void)setSize:(NSSize)value
+{
+    size = value;
+}
+
+- (void)setRect:(NSRect)value
+{
+    rect = value;
+}
+
+- (NSString *)description
+{
+    return @"setters";
+}
+
+@end
+
+
+@interface Observer : NSObject {
+    NSMutableArray *log;
+}
+
+- (id)init;
+- (void)reset;
+- (void)observeValueForKeyPath:(NSString *)aPath ofObject:(id)anObject change:(NSDictionary *)aChange context:(void *)aContext;
+- (NSArray *)log;
+
+@end
+
+@implementation Observer
+
+- (id)init
+{
+    if (self = [super init]) {
+        log = [NSMutableArray new];
+    }
+    return self;
+}
+
+- (void)dealloc
+{
+    [log release];
+    [super dealloc];
+}
+
+- (void)reset
+{
+    [log removeAllObjects];
+}
+
+- (void)observeValueForKeyPath:(NSString *)aPath ofObject:(id)anObject change:(NSDictionary *)aChange context:(void *)aContext
+{
+    [log addObject:aChange];
+}
+
+- (NSArray *)log
+{
+    return log;
+}
+
+@end
+
+
+static void TestAutoKVO(NSObject *observable, NSArray *keys, NSArray *values)
+{
+    Observer *observer = [Observer new];
+    for (NSUInteger index = 0, count = [keys count]; index < count; ++index) {
+        NSAutoreleasePool *pool = [NSAutoreleasePool new];
+        
+        NSString *key = [keys objectAtIndex:index];
+        [observer reset];
+        [observable addObserver:observer forKeyPath:key options:NSKeyValueObservingOptionPrior | NSKeyValueObservingOptionNew context:NULL];
+        [observable setValue:[values objectAtIndex:index] forKey:key];
+        [observable removeObserver:observer forKeyPath:key];
+        
+        NSMutableArray *log = [NSMutableArray arrayWithCapacity:2];
+        NSMutableDictionary *change = [NSMutableDictionary dictionaryWithCapacity:4];
+        
+        [change setObject:[NSNumber numberWithUnsignedInteger:NSKeyValueChangeSetting] forKey:NSKeyValueChangeKindKey];
+        [change setObject:[NSNumber numberWithBool:YES] forKey:NSKeyValueChangeNotificationIsPriorKey];
+        [log addObject:[[change copy] autorelease]];
+        
+        [change removeObjectForKey:NSKeyValueChangeNotificationIsPriorKey];
+        [change setObject:[values objectAtIndex:index] forKey:NSKeyValueChangeNewKey];
+        [log addObject:[[change copy] autorelease]];
+        
+        PASS([[observer log] isEqual:log], "Automatic KVO works (using %s) for key '%s'", [[observable description] UTF8String], [key UTF8String]);
+        
+        [pool release];
+    }
+}
+
+int main()
+{
+    NSAutoreleasePool *pool = [NSAutoreleasePool new];
+    
+    NSArray *keys = [NSArray arrayWithObjects:@"id", @"char", @"double", @"float", @"int", @"long", @"longLong", @"short", @"range", @"point", @"size", @"rect", nil];
+    NSArray *values = [NSArray arrayWithObjects:
+                       keys,
+                       [NSNumber numberWithChar:CHAR_MAX],
+                       [NSNumber numberWithDouble:DBL_MAX],
+                       [NSNumber numberWithFloat:FLT_MAX],
+                       [NSNumber numberWithInt:INT_MAX],
+                       [NSNumber numberWithLong:LONG_MAX],
+#if defined (_C_LNG_LNG)
+                       [NSNumber numberWithLongLong:LLONG_MAX],
+#endif
+                       [NSNumber numberWithShort:SHRT_MAX],
+                       [NSValue valueWithRange:NSMakeRange(0, NSUIntegerMax)],
+                       [NSValue valueWithPoint:NSMakePoint(0, CGFLOAT_MAX)],
+                       [NSValue valueWithSize:NSMakeSize(0, CGFLOAT_MAX)],
+                       [NSValue valueWithRect:NSMakeRect(0, 0, CGFLOAT_MAX, CGFLOAT_MAX)],
+                       nil];
+    id observable;
+    
+    observable = [DirectObservable new];
+    Observer *observer = [Observer new];
+    [observable addObserver:observer forKeyPath:@"manual" options:NSKeyValueObservingOptionPrior context:NULL];
+    [observable setValue:keys forKey:@"manual"];
+    [observable removeObserver:observer forKeyPath:@"manual"];
+    PASS([[observer log] count] == 0, "Direct property access respects +[automaticallyNotifiesObserversForKey:]");
+    [observer release];
+    TestAutoKVO(observable, keys, values);
+    [observable release];
+    
+    observable = [Observable new];
+    Class isa = object_getClass(observable);
+    TestAutoKVO(observable, keys, values);
+    PASS(object_getClass(observable) == isa, "Object's isa pointer is back to normal");
+    [observable release];
+    
+    [pool release];
+}
\ No newline at end of file
diff --git a/Tests/base/KVO/test02.m b/Tests/base/KVO/test02.m
new file mode 100644
index 0000000..6c587cb
--- /dev/null
+++ b/Tests/base/KVO/test02.m
@@ -0,0 +1,283 @@
+/*
+ * Implementation of GNUSTEP key value observing
+ * Copyright (C) 2013 Free Software Foundation, Inc.
+ *
+ * Written by Marat Ibadinov <ibadinov@me.com>
+ * Date: 2013
+ *
+ * This file is part of the GNUstep Base Library.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free
+ * Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110 USA.
+ *
+ * $Date$ $Revision$
+ */
+
+#import "Testing.h"
+#import <Foundation/Foundation.h>
+
+@interface Observable : NSObject {
+    id _id;
+    NSMutableArray *_array;
+    NSMutableSet   *_set;
+}
+
+- (void)insertElements:(NSArray *)elements;
+- (void)removeElementsAtIndexes:(NSIndexSet *)indexes;
+- (void)replaceElementsAtIndexes:(NSIndexSet *)indexes withElements:(NSArray *)replacement;
+
+- (void)unionSet:(NSSet *)set;
+- (void)minusSet:(NSSet *)set;
+- (void)intersectSet:(NSSet *)set;
+- (void)setSet:(NSSet *)set;
+
+@end
+
+@implementation Observable
+
+- (id)init
+{
+    if (self = [super init]) {
+        _id = nil;
+        _array = [NSMutableArray new];
+        _set = [NSMutableSet new];
+    }
+    return self;
+}
+
+- (void)dealloc
+{
+    [_set release];
+    [_array release];
+    [super dealloc];
+}
+
+- (void)insertElements:(NSArray *)elements
+{
+    NSIndexSet *indexes = [NSIndexSet indexSetWithIndexesInRange:NSMakeRange([_array count], [elements count])];
+    [self willChange:NSKeyValueChangeInsertion valuesAtIndexes:indexes forKey:@"array"];
+    [_array addObjectsFromArray:elements];
+    [self didChange:NSKeyValueChangeInsertion valuesAtIndexes:indexes forKey:@"array"];
+}
+
+- (void)removeElementsAtIndexes:(NSIndexSet *)indexes
+{
+    [self willChange:NSKeyValueChangeRemoval valuesAtIndexes:indexes forKey:@"array"];
+    [_array removeObjectsAtIndexes:indexes];
+    [self didChange:NSKeyValueChangeRemoval valuesAtIndexes:indexes forKey:@"array"];
+}
+
+- (void)replaceElementsAtIndexes:(NSIndexSet *)indexes withElements:(NSArray *)replacement
+{
+    [self willChange:NSKeyValueChangeReplacement valuesAtIndexes:indexes forKey:@"array"];
+    [_array replaceObjectsAtIndexes:indexes withObjects:replacement];
+    [self didChange:NSKeyValueChangeReplacement valuesAtIndexes:indexes forKey:@"array"];
+}
+
+- (void)unionSet:(NSSet *)set
+{
+    [self willChangeValueForKey:@"set" withSetMutation:NSKeyValueUnionSetMutation usingObjects:set];
+    [_set unionSet:set];
+    [self didChangeValueForKey:@"set" withSetMutation:NSKeyValueUnionSetMutation usingObjects:set];
+}
+
+- (void)minusSet:(NSSet *)set
+{
+    [self willChangeValueForKey:@"set" withSetMutation:NSKeyValueMinusSetMutation usingObjects:set];
+    [_set minusSet:set];
+    [self didChangeValueForKey:@"set" withSetMutation:NSKeyValueMinusSetMutation usingObjects:set];
+}
+
+- (void)intersectSet:(NSSet *)set
+{
+    [self willChangeValueForKey:@"set" withSetMutation:NSKeyValueIntersectSetMutation usingObjects:set];
+    [_set intersectSet:set];
+    [self didChangeValueForKey:@"set" withSetMutation:NSKeyValueIntersectSetMutation usingObjects:set];
+}
+
+- (void)setSet:(NSSet *)set
+{
+    [self willChangeValueForKey:@"set" withSetMutation:NSKeyValueSetSetMutation usingObjects:set];
+    _set = [set mutableCopy];
+    [self didChangeValueForKey:@"set" withSetMutation:NSKeyValueSetSetMutation usingObjects:set];
+}
+
+@end
+
+
+@interface Observer1 : NSObject {
+    NSMutableArray *log;
+}
+
+- (NSArray *)log;
+- (void)reset;
+
+@end
+
+@implementation Observer1
+
+- (id)init
+{
+    if (self = [super init]) {
+        log = [NSMutableArray new];
+    }
+    return self;
+}
+
+- (void)dealloc
+{
+    [log release];
+    [super dealloc];
+}
+
+- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context
+{
+    NSMutableDictionary *preparedChange = [[NSMutableDictionary alloc] initWithCapacity:[change count]];
+    NSEnumerator *enumerator = [change keyEnumerator];
+    id key;
+    while ((key = [enumerator nextObject])) {
+        id object = [change objectForKey:key];
+        if ([object isKindOfClass:[NSIndexSet class]]) {
+            NSUInteger *indexes = alloca(sizeof(NSUInteger) * 16);
+            NSUInteger count = [object getIndexes:indexes maxCount:16 inIndexRange:nil];
+            object = [NSMutableArray arrayWithCapacity:count];
+            for (NSUInteger index = 0; index < count; ++index) {
+                [object addObject:[NSString stringWithFormat:@"%lu", (unsigned long)indexes[index]]];
+            }
+        } else if ([object isKindOfClass:[NSSet class]]) {
+            object = [[object allObjects] sortedArrayUsingSelector:@selector(compare:)];
+        } else if ([object isKindOfClass:[NSNumber class]]) {
+            object = [object stringValue];
+        } else if (object == [NSNull null]) {
+            object = [object description];
+        } else if (![object isKindOfClass:[NSString class]] && ![object isKindOfClass:[NSArray class]]) {
+            object = [object className];
+        }
+        [preparedChange setObject:object forKey:key];
+    }
+    [log addObject:preparedChange];
+    [preparedChange release];
+}
+
+- (NSArray *)log
+{
+    return log;
+}
+
+- (void)reset
+{
+    [log removeAllObjects];
+}
+
+@end
+
+
+int main()
+{
+    NSAutoreleasePool *pool = [NSAutoreleasePool new];
+    Observable *observable = [Observable new];
+    Observer1 *observer = [Observer1 new];
+    NSArray *log;
+    NSKeyValueObservingOptions options = NSKeyValueObservingOptionPrior | NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld;
+    NSString *idKey = @"id";
+    NSString *arrayKey = @"array";
+    NSString *setKey = @"set";
+    [[NSFileManager defaultManager] changeCurrentDirectoryPath:@"test02"];
+    
+    
+    [observable addObserver:observer forKeyPath:idKey options:options context:NULL];
+    [observable setValue:observable forKey:idKey];
+    [observable setValue:nil forKey:idKey];
+    [observable removeObserver:observer forKeyPath:idKey];
+    log = [NSArray arrayWithContentsOfFile:@"NilValue.plist"];
+    PASS([[observer log] isEqual:log], "KVO correctly handles nil values");
+    
+    
+    [observer reset];
+    [observable addObserver:observer forKeyPath:arrayKey options:options context:NULL];
+    [observable insertElements:[NSArray arrayWithObjects:@"a", @"b", @"c", @"d", @"e", @"f", nil]];
+    [observable removeObserver:observer forKeyPath:arrayKey];
+    log = [NSArray arrayWithContentsOfFile:@"ItemInsertion.plist"];
+    PASS([[observer log] isEqual:log], "KVO correctly handles array item insertion");
+    
+    
+    [observer reset];
+    [observable addObserver:observer forKeyPath:arrayKey options:options context:NULL];
+    [observable removeElementsAtIndexes:[NSIndexSet indexSetWithIndexesInRange:NSMakeRange(3, 2)]];
+    [observable removeObserver:observer forKeyPath:arrayKey];
+    log = [NSArray arrayWithContentsOfFile:@"ItemRemoval.plist"];
+    PASS([[observer log] isEqual:log], "KVO correctly handles array item removal");
+    
+    
+    [observer reset];
+    [observable addObserver:observer forKeyPath:arrayKey options:options context:NULL];
+    [observable replaceElementsAtIndexes:[NSIndexSet indexSetWithIndexesInRange:NSMakeRange(0, 3)] withElements:[NSArray arrayWithObjects:@"c", @"d", @"e", nil]];
+    [observable removeObserver:observer forKeyPath:arrayKey];
+    log = [NSArray arrayWithContentsOfFile:@"ItemReplacement.plist"];
+    PASS([[observer log] isEqual:log], "KVO correctly handles array item replacement");
+    
+    
+    [observer reset];
+    [observable addObserver:observer forKeyPath:setKey options:options context:NULL];
+    [observable setSet:nil];
+    [observable removeObserver:observer forKeyPath:setKey];
+    log = [NSArray arrayWithContentsOfFile:@"SetSettingNil.plist"];
+    PASS([[observer log] isEqual:log], "KVO corretly handles set setting (empty -> nil)");
+    
+    
+    [observer reset];
+    [observable addObserver:observer forKeyPath:setKey options:options context:NULL];
+    [observable setSet:[NSSet set]];
+    [observable removeObserver:observer forKeyPath:setKey];
+    log = [NSArray arrayWithContentsOfFile:@"SetSettingEmpty.plist"];
+    PASS([[observer log] isEqual:log], "KVO corretly handles set setting (nil -> empty)");
+    
+    
+    [observer reset];
+    [observable addObserver:observer forKeyPath:setKey options:options context:NULL];
+    [observable setSet:[NSSet setWithObjects:@"a", @"b", @"c", @"d", nil]];
+    [observable removeObserver:observer forKeyPath:setKey];
+    log = [NSArray arrayWithContentsOfFile:@"SetSettingNotEmpty.plist"];
+    PASS([[observer log] isEqual:log], "KVO corretly handles set setting (empty -> not empty)");
+    
+    
+    [observer reset];
+    [observable addObserver:observer forKeyPath:setKey options:options context:NULL];
+    [observable unionSet:[NSSet setWithObjects:@"c", @"d", @"e", @"f", nil]];
+    [observable removeObserver:observer forKeyPath:setKey];
+    log = [NSArray arrayWithContentsOfFile:@"SetUnion.plist"];
+    PASS([[observer log] isEqual:log], "KVO corretly handles set union");
+    
+    
+    [observer reset];
+    [observable addObserver:observer forKeyPath:setKey options:options context:NULL];
+    [observable minusSet:[NSSet setWithObjects:@"b", @"d", @"x", nil]];
+    [observable removeObserver:observer forKeyPath:setKey];
+    log = [NSArray arrayWithContentsOfFile:@"SetComplementation.plist"];
+    PASS([[observer log] isEqual:log], "KVO corretly handles relative set complementation");
+    
+    
+    [observer reset];
+    [observable addObserver:observer forKeyPath:setKey options:options context:NULL];
+    [observable intersectSet:[NSSet setWithObjects:@"a", @"c", @"e", @"x", @"y", @"z", nil]];
+    [observable removeObserver:observer forKeyPath:setKey];
+    log = [NSArray arrayWithContentsOfFile:@"SetIntersection.plist"];
+    PASS([[observer log] isEqual:log], "KVO corretly handles set intersection");
+    
+    
+    [observer release];
+    [observable release];
+    [pool release];
+}
\ No newline at end of file
diff --git a/Tests/base/KVO/test02/ItemInsertion.plist b/Tests/base/KVO/test02/ItemInsertion.plist
new file mode 100644
index 0000000..4d87097
--- /dev/null
+++ b/Tests/base/KVO/test02/ItemInsertion.plist
@@ -0,0 +1,33 @@
+(
+    {
+        indexes = (
+            0,
+            1,
+            2,
+            3,
+            4,
+            5
+        );
+        kind = 2;
+        notificationIsPrior = 1;
+    },
+    {
+        indexes = (
+            0,
+            1,
+            2,
+            3,
+            4,
+            5
+        );
+        kind = 2;
+        new = (
+            a,
+            b,
+            c,
+            d,
+            e,
+            f
+        );
+    }
+)
\ No newline at end of file
diff --git a/Tests/base/KVO/test02/ItemRemoval.plist b/Tests/base/KVO/test02/ItemRemoval.plist
new file mode 100644
index 0000000..1f67f43
--- /dev/null
+++ b/Tests/base/KVO/test02/ItemRemoval.plist
@@ -0,0 +1,25 @@
+(
+    {
+        indexes = (
+            3,
+            4
+        );
+        kind = 3;
+        notificationIsPrior = 1;
+        old = (
+            d,
+            e
+        );
+    },
+    {
+        indexes = (
+            3,
+            4
+        );
+        kind = 3;
+        old = (
+            d,
+            e
+        );
+    }
+)
\ No newline at end of file
diff --git a/Tests/base/KVO/test02/ItemReplacement.plist b/Tests/base/KVO/test02/ItemReplacement.plist
new file mode 100644
index 0000000..c9f5233
--- /dev/null
+++ b/Tests/base/KVO/test02/ItemReplacement.plist
@@ -0,0 +1,34 @@
+(
+    {
+        indexes = (
+            0,
+            1,
+            2
+        );
+        kind = 4;
+        notificationIsPrior = 1;
+        old = (
+            a,
+            b,
+            c
+        );
+    },
+    {
+        indexes = (
+            0,
+            1,
+            2
+        );
+        kind = 4;
+        new = (
+            c,
+            d,
+            e
+        );
+        old = (
+            a,
+            b,
+            c
+        );
+    }
+)
\ No newline at end of file
diff --git a/Tests/base/KVO/test02/NilValue.plist b/Tests/base/KVO/test02/NilValue.plist
new file mode 100644
index 0000000..66c5dc3
--- /dev/null
+++ b/Tests/base/KVO/test02/NilValue.plist
@@ -0,0 +1,22 @@
+(
+    {
+        kind = 1;
+        notificationIsPrior = 1;
+        old = "<null>";
+    },
+    {
+        kind = 1;
+        new = Observable;
+        old = "<null>";
+    },
+    {
+        kind = 1;
+        notificationIsPrior = 1;
+        old = Observable;
+    },
+    {
+        kind = 1;
+        new = "<null>";
+        old = Observable;
+    }
+)
\ No newline at end of file
diff --git a/Tests/base/KVO/test02/SetComplementation.plist b/Tests/base/KVO/test02/SetComplementation.plist
new file mode 100644
index 0000000..e6152cc
--- /dev/null
+++ b/Tests/base/KVO/test02/SetComplementation.plist
@@ -0,0 +1,17 @@
+(
+    {
+        kind = 3;
+        notificationIsPrior = 1;
+        old = (
+            b,
+            d
+        );
+    },
+    {
+        kind = 3;
+        old = (
+            b,
+            d
+        );
+    }
+)
\ No newline at end of file
diff --git a/Tests/base/KVO/test02/SetIntersection.plist b/Tests/base/KVO/test02/SetIntersection.plist
new file mode 100644
index 0000000..410231b
--- /dev/null
+++ b/Tests/base/KVO/test02/SetIntersection.plist
@@ -0,0 +1,15 @@
+(
+    {
+        kind = 3;
+        notificationIsPrior = 1;
+        old = (
+            f
+        );
+    },
+    {
+        kind = 3;
+        old = (
+            f
+        );
+    }
+)
\ No newline at end of file
diff --git a/Tests/base/KVO/test02/SetSettingEmpty.plist b/Tests/base/KVO/test02/SetSettingEmpty.plist
new file mode 100644
index 0000000..8d17834
--- /dev/null
+++ b/Tests/base/KVO/test02/SetSettingEmpty.plist
@@ -0,0 +1,24 @@
+(
+    {
+        kind = 1;
+        notificationIsPrior = 1;
+        old = "<null>";
+    },
+    {
+        kind = 4;
+        new = (
+        );
+        notificationIsPrior = 1;
+    },
+        {
+        kind = 4;
+        new = (
+        );
+    },
+        {
+        kind = 1;
+        new = (
+        );
+        old = "<null>";
+    }
+)
\ No newline at end of file
diff --git a/Tests/base/KVO/test02/SetSettingNil.plist b/Tests/base/KVO/test02/SetSettingNil.plist
new file mode 100644
index 0000000..26795aa
--- /dev/null
+++ b/Tests/base/KVO/test02/SetSettingNil.plist
@@ -0,0 +1,25 @@
+(
+        {
+        kind = 1;
+        notificationIsPrior = 1;
+        old =         (
+        );
+    },
+        {
+        kind = 4;
+        notificationIsPrior = 1;
+        old =         (
+        );
+    },
+        {
+        kind = 4;
+        old =         (
+        );
+    },
+        {
+        kind = 1;
+        new = "<null>";
+        old =         (
+        );
+    }
+)
\ No newline at end of file
diff --git a/Tests/base/KVO/test02/SetSettingNotEmpty.plist b/Tests/base/KVO/test02/SetSettingNotEmpty.plist
new file mode 100644
index 0000000..bed8134
--- /dev/null
+++ b/Tests/base/KVO/test02/SetSettingNotEmpty.plist
@@ -0,0 +1,42 @@
+(
+    {
+        kind = 1;
+        notificationIsPrior = 1;
+        old = (
+        );
+    },
+    {
+        kind = 4;
+        new = (
+            a,
+            b,
+            c,
+            d
+        );
+        notificationIsPrior = 1;
+        old = (
+        );
+    },
+        {
+        kind = 4;
+        new = (
+            a,
+            b,
+            c,
+            d
+        );
+        old = (
+        );
+    },
+        {
+        kind = 1;
+        new = (
+            a,
+            b,
+            c,
+            d
+        );
+        old = (
+        );
+    }
+)
\ No newline at end of file
diff --git a/Tests/base/KVO/test02/SetUnion.plist b/Tests/base/KVO/test02/SetUnion.plist
new file mode 100644
index 0000000..23391ba
--- /dev/null
+++ b/Tests/base/KVO/test02/SetUnion.plist
@@ -0,0 +1,17 @@
+(
+    {
+        kind = 2;
+        new = (
+            e,
+            f
+        );
+        notificationIsPrior = 1;
+    },
+    {
+        kind = 2;
+        new = (
+            e,
+            f
+        );
+    }
+)
\ No newline at end of file
diff --git a/Tests/base/NSAttributedString/basic.m b/Tests/base/NSAttributedString/basic.m
index 2d10f4b..a2e160d 100644
--- a/Tests/base/NSAttributedString/basic.m
+++ b/Tests/base/NSAttributedString/basic.m
@@ -1,6 +1,7 @@
 #import <Foundation/NSAutoreleasePool.h>
 #import <Foundation/NSAttributedString.h>
 #import "ObjectTesting.h"
+
 int main()
 {
   NSAutoreleasePool   *arp = [NSAutoreleasePool new];
@@ -15,5 +16,4 @@ int main()
 
   [arp release]; arp = nil;
   return 0;
-}
-
+}
\ No newline at end of file
diff --git a/Tests/base/NSInvocation/Resources/InvokeProxy.m b/Tests/base/NSInvocation/Resources/InvokeProxy.m
index f19a1de..6a8fd7e 100644
--- a/Tests/base/NSInvocation/Resources/InvokeProxy.m
+++ b/Tests/base/NSInvocation/Resources/InvokeProxy.m
@@ -139,6 +139,15 @@
   return self;
 }
 
+/*
+ * Apple's runtime does not support typed selectors, but everything 
+ * can be done the right way.
+ */
+- (NSMethodSignature *) methodSignatureForSelector: (SEL)aSelector
+{
+  return [[obj class] instanceMethodSignatureForSelector:aSelector];
+}
+
 - (void) forwardInvocation: (NSInvocation*)inv
 {
 #if 1
diff --git a/Tests/base/NSInvocation/test01.m b/Tests/base/NSInvocation/test01.m
index efda9f3..2308738 100644
--- a/Tests/base/NSInvocation/test01.m
+++ b/Tests/base/NSInvocation/test01.m
@@ -19,7 +19,7 @@ int main()
   Class tClass = Nil;
   NSString *bundlePath;
   NSBundle *bundle; 
-  int retc; 
+  NSUInteger retc; 
   bundlePath = [[[NSFileManager defaultManager] 
                               currentDirectoryPath] 
 			       stringByAppendingPathComponent:@"Resources"];
@@ -34,12 +34,7 @@ int main()
   
   tar = [tClass new];
   
-  /* 
-    Test if the return value is retained. It is in the Apple OpenStep edition
-    for Windows (YellowBox)
-    matt: this doesn't seem like a valid test as PASS/fail will vary on
-    platforms
-   */
+  /* Mac version of Apple's Foundation does not retain result objects */
   sig = [tar methodSignatureForSelector:@selector(retObject)];
   inv = [NSInvocation invocationWithMethodSignature: sig];
   retc = [[tar retObject] retainCount];
@@ -47,21 +42,26 @@ int main()
   [inv invokeWithTarget:tar];
   if (nil == [NSGarbageCollector defaultCollector])
     {
-      PASS(retc + 1 == [[tar retObject] retainCount],
-       "Retain return value")
+      PASS(retc == [[tar retObject] retainCount], "Will not retain return value by default")
     }
   
   sig = [tar methodSignatureForSelector:@selector(loopObject:)];
   inv = [NSInvocation invocationWithMethodSignature: sig];
-  retc = [tar retainCount];
   [inv setSelector:@selector(loopObject:)];
   [inv invokeWithTarget:tar];
+  /* target is an argument at index zero, so it should be retained */
+  retc = [tar retainCount];
   [inv retainArguments];
+  if (nil == [NSGarbageCollector defaultCollector])
+    {
+        PASS(retc + 1 == [tar retainCount], "Will retain arguments, that are set already, after sending -[retainArguments]")
+    }
+  /* and now the same object is set at index two */
+  retc = [tar retainCount];
   [inv setArgument:&tar atIndex:2];
   if (nil == [NSGarbageCollector defaultCollector])
     {
-      PASS(retc + 1 == [tar retainCount],
-       "Will Retain arguments after -retainArguments")
+      PASS(retc + 1 == [tar retainCount], "Will retain new arguments, if -[retainArguments] is sent")
     }
   
   sig = [tar methodSignatureForSelector:@selector(loopObject:)];
@@ -70,21 +70,27 @@ int main()
   [inv setSelector:@selector(loopObject:)];
   [inv invokeWithTarget:tar];
   [inv setArgument:&tar atIndex:2];
-  PASS(retc == [tar retainCount],
-       "default will not retain arguments");
+  PASS(retc == [tar retainCount], "Will not retain arguments by default");
   
   sig = [tar methodSignatureForSelector:@selector(retObject)];
   inv = [NSInvocation invocationWithMethodSignature: sig];
   [inv setSelector:@selector(retObject)];
   [inv invokeWithTarget:nil];
   [inv getReturnValue:&ret];
-  PASS(ret == nil,"Check if nil target works");
+  PASS(ret == nil, "Check if nil target works");
   
   sig = [tar methodSignatureForSelector:@selector(returnIdButThrowException)];
   inv = [NSInvocation invocationWithMethodSignature: sig];
   [inv setSelector:@selector(returnIdButThrowException)];
-  PASS_EXCEPTION([inv invokeWithTarget:tar];,@"AnException","Exception in invocation #1");
-  PASS_EXCEPTION([inv getReturnValue:&ret];,NSGenericException,"Exception getting return value #1");
+  PASS_EXCEPTION([inv invokeWithTarget:tar];, @"AnException", "Exception in invocation #1");
+  /* Apple's Foundation does not throw expceptions in -[getReturnValue:] */
+  BOOL raised = NO;
+  NS_DURING
+    [inv getReturnValue:&ret];
+  NS_HANDLER
+    raised = YES;
+  NS_ENDHANDLER
+  PASS(!raised, "Does not throw an exception while getting return value (test #1)");
  
   /* same as above but with a successful call first */
   sig = [tar methodSignatureForSelector:@selector(returnIdButThrowException)];
@@ -95,8 +101,15 @@ int main()
   [inv getReturnValue:&ret];
   
   [inv setSelector:@selector(returnIdButThrowException)];
-  PASS_EXCEPTION([inv invokeWithTarget:tar];,@"AnException","Exception in invocation #2");
-  PASS_EXCEPTION([inv getReturnValue:&ret];,NSGenericException,"Exception getting return value #2");
+  PASS_EXCEPTION([inv invokeWithTarget:tar];, @"AnException", "Exception in invocation #2");
+  /* Apple's Foundation does not throw expceptions in -[getReturnValue:] */
+  raised = NO;
+  NS_DURING
+    [inv getReturnValue:&ret];
+  NS_HANDLER
+    raised = YES;
+  NS_ENDHANDLER
+  PASS(!raised, "Does not throw an exception while getting return value (test #2)");
     
   
   [arp release]; arp = nil;
diff --git a/Tests/base/NSNotification/basic.m b/Tests/base/NSNotification/basic.m
index bac3ec7..9d86fda 100644
--- a/Tests/base/NSNotification/basic.m
+++ b/Tests/base/NSNotification/basic.m
@@ -27,7 +27,7 @@ int main()
   NSAutoreleasePool   *arp = [NSAutoreleasePool new];
 
   test_alloc(@"NSNotification"); 
-  obj = [NSNotification new];
+  obj = [NSNotification notificationWithName:@"" object:nil userInfo:[NSDictionary dictionary]];
   [testObjs addObject: obj];
   test_NSObject(@"NSNotification", testObjs);
   test_NSCoding(testObjs);
diff --git a/Tests/base/NSURL/basic.m b/Tests/base/NSURL/basic.m
index ffbfacf..84414cd 100644
--- a/Tests/base/NSURL/basic.m
+++ b/Tests/base/NSURL/basic.m
@@ -9,14 +9,14 @@ extern const char *GSPathHandling(const char *);
 int main()
 {
   NSAutoreleasePool   *arp = [NSAutoreleasePool new];
-  NSURL		*url;
-  NSURL		*rel;
-  NSData	*data;
+  NSURL     *url;
+  NSURL     *rel;
+  NSData    *data;
   NSString	*str;
-  NSNumber      *num;
-  unsigned      i;
-  unichar	u = 163;
-  unichar       buf[256];
+  NSNumber  *num;
+  unsigned  i;
+  unichar   u = 163;
+  unichar   buf[256];
   
   TEST_FOR_CLASS(@"NSURL", [NSURL alloc],
     "NSURL +alloc returns an NSURL");
diff --git a/Tests/base/NSUndoManager/NSUndoManager_basic.m b/Tests/base/NSUndoManager/NSUndoManager_basic.m
index fb7ceb0..30d15e4 100644
--- a/Tests/base/NSUndoManager/NSUndoManager_basic.m
+++ b/Tests/base/NSUndoManager/NSUndoManager_basic.m
@@ -103,7 +103,7 @@ int main()
   id obj = [Foo new]; 
   id one, two, three, four, five, six, seven, eight;
   id bar;
-  int rc;
+  NSUInteger rc;
 
   one = @"one";
   two = @"two";
diff --git a/Tests/base/coding/decoding.m b/Tests/base/coding/decoding.m
index 915f870..360094d 100644
--- a/Tests/base/coding/decoding.m
+++ b/Tests/base/coding/decoding.m
@@ -160,6 +160,13 @@ copyright 2004 Alexander Malmberg <alexander@malmberg.org>
 }
 @end
 
+@implementation NSNotification (DecodingTests)
++ (NSObject *) createTestInstance
+{
+    return [self notificationWithName:@"TestNotification" object:nil userInfo:[NSDictionary dictionary]];
+}
+@end
+
 
 /*
 If set, we write out new .data files for the current versions for classes
diff --git a/Tools/AGSHtml.m b/Tools/AGSHtml.m
index 8c5f231..605b784 100644
--- a/Tools/AGSHtml.m
+++ b/Tools/AGSHtml.m
@@ -44,9 +44,9 @@
 #define	GS_API_MACOSX	100000
 #endif
 
-static int      XML_ELEMENT_NODE;
-static int      XML_ENTITY_REF_NODE;
-static int      XML_TEXT_NODE;
+static NSInteger      XML_ELEMENT_NODE;
+static NSInteger      XML_ENTITY_REF_NODE;
+static NSInteger      XML_TEXT_NODE;
 
 static GSXMLNode	*firstElement(GSXMLNode *nodes)
 {
@@ -113,7 +113,7 @@ static NSString		*mainFont = nil;
 
 - (void) decIndent
 {
-  unsigned	len = [indent length];
+  NSUInteger	len = [indent length];
 
   if (len >= 2)
     {
@@ -318,8 +318,8 @@ static NSString		*mainFont = nil;
   NSDictionary	*refs = [localRefs refs];
   NSDictionary	*dict;
   NSArray	*a;
-  unsigned	c;
-  unsigned	i;
+  NSUInteger	c;
+  NSUInteger	i;
   BOOL		isBareStyle = [@"bare" isEqualToString: style];
 
   if (globalRefs != nil && [scope isEqual: @"global"] == YES)
@@ -2599,8 +2599,8 @@ static NSString		*mainFont = nil;
 {
   NSString	*str = [t stringByTrimmingSpaces];
   NSString	*s;
-  unsigned	end = [str length];
-  unsigned	start;
+  NSUInteger	end = [str length];
+  NSUInteger	start;
   NSMutableString	*ms = nil;
   NSRange		er;
   NSRange		sr;
diff --git a/Tools/AGSIndex.m b/Tools/AGSIndex.m
index 83d18b4..49bbe96 100644
--- a/Tools/AGSIndex.m
+++ b/Tools/AGSIndex.m
@@ -29,8 +29,8 @@
 #import "GNUstepBase/NSString+GNUstepBase.h"
 #import "GNUstepBase/NSMutableString+GNUstepBase.h"
 
-static int      XML_ELEMENT_NODE;
-static int      XML_TEXT_NODE;
+static NSInteger      XML_ELEMENT_NODE;
+static NSInteger      XML_TEXT_NODE;
 
 static void
 mergeDictionaries(NSMutableDictionary *dst, NSDictionary *src, BOOL override)
diff --git a/Tools/AGSOutput.h b/Tools/AGSOutput.h
index cdb438e..05916af 100644
--- a/Tools/AGSOutput.h
+++ b/Tools/AGSOutput.h
@@ -45,10 +45,10 @@
 - (NSString*) checkComment: (NSString*)comment
 		      unit: (NSString*)unit
 		      info: (NSMutableDictionary*)d;
-- (unsigned) fitWords: (NSArray*)a
-		 from: (unsigned)start
-		   to: (unsigned)end
-	      maxSize: (unsigned)limit
+- (NSUInteger) fitWords: (NSArray*)a
+		 from: (NSUInteger)start
+		   to: (NSUInteger)end
+	      maxSize: (NSUInteger)limit
 	       output: (NSMutableString*)buf;
 - (NSArray*) output: (NSMutableDictionary*)d;
 - (void) outputDecl: (NSMutableDictionary*)d
@@ -64,8 +64,8 @@
 		   to: (NSMutableString*)str
 		  for: (NSString*)unit;
 - (void) outputUnit: (NSMutableDictionary*)d to: (NSMutableString*)str;
-- (unsigned) reformat: (NSString*)str
-	   withIndent: (unsigned)ind
+- (NSUInteger) reformat: (NSString*)str
+	   withIndent: (NSUInteger)ind
 		   to: (NSMutableString*)buf;
 - (NSArray*) split: (NSString*)str;
 - (NSArray*) informalProtocols;
diff --git a/Tools/AGSOutput.m b/Tools/AGSOutput.m
index 7ca0a16..5cf498e 100644
--- a/Tools/AGSOutput.m
+++ b/Tools/AGSOutput.m
@@ -189,17 +189,17 @@ static BOOL snuggleStart(NSString *t)
   [super dealloc];
 }
 
-- (unsigned) fitWords: (NSArray*)a
-		 from: (unsigned)start
-		   to: (unsigned)end
-	      maxSize: (unsigned)limit
-	       output: (NSMutableString*)buf
+- (NSUInteger) fitWords: (NSArray*)a
+                   from: (NSUInteger)start
+                     to: (NSUInteger)end
+                maxSize: (NSUInteger)limit
+                 output: (NSMutableString*)buf
 {
-  unsigned	size = 0;
-  unsigned	nest = 0;
-  unsigned	i;
-  int		lastOk = -1;
-  BOOL		addSpace = NO;
+  NSUInteger	size = 0;
+  NSUInteger	nest = 0;
+  NSUInteger	i;
+  NSInteger		lastOk = -1;
+  BOOL          addSpace = NO;
 
   for (i = start; size < limit && i < end; i++)
     {
@@ -475,8 +475,8 @@ static BOOL snuggleStart(NSString *t)
   if ([classes count] > 0)
     {
       NSArray	*names;
-      unsigned	i;
-      unsigned	c = [classes count];
+      NSUInteger	i;
+      NSUInteger	c = [classes count];
 
       chapters += c;
       names = [classes allKeys];
@@ -493,8 +493,8 @@ static BOOL snuggleStart(NSString *t)
   if ([categories count] > 0)
     {
       NSArray	*names;
-      unsigned	i;
-      unsigned	c = [categories count];
+      NSUInteger	i;
+      NSUInteger	c = [categories count];
 
       chapters += c;
       names = [categories allKeys];
@@ -511,8 +511,8 @@ static BOOL snuggleStart(NSString *t)
   if ([protocols count] > 0)
     {
       NSArray	*names;
-      unsigned	i;
-      unsigned	c = [protocols count];
+      NSUInteger	i;
+      NSUInteger	c = [protocols count];
 
       chapters += c;
       names = [protocols allKeys];
@@ -530,8 +530,8 @@ static BOOL snuggleStart(NSString *t)
     {
       NSMutableString	*m = [NSMutableString new];
       NSArray		*names;
-      unsigned		i;
-      unsigned		c = [types count];
+      NSUInteger		i;
+      NSUInteger		c = [types count];
 
       [m appendString: @"    <chapter>\n"];
       [m appendFormat: @"      <heading>%@ types</heading>\n", base];
@@ -566,8 +566,8 @@ static BOOL snuggleStart(NSString *t)
     {
       NSMutableString	*m = [NSMutableString new];
       NSArray		*names;
-      unsigned		i;
-      unsigned		c = [constants count];
+      NSUInteger		i;
+      NSUInteger		c = [constants count];
 
       [m appendString: @"    <chapter>\n"];
       [m appendFormat: @"      <heading>%@ constants</heading>\n", base];
@@ -602,8 +602,8 @@ static BOOL snuggleStart(NSString *t)
     {
       NSMutableString	*m = [NSMutableString new];
       NSArray		*names;
-      unsigned		i;
-      unsigned		c = [macros count];
+      NSUInteger		i;
+      NSUInteger		c = [macros count];
 
       [m appendString: @"    <chapter>\n"];
       [m appendFormat: @"      <heading>%@ macros</heading>\n", base];
@@ -638,8 +638,8 @@ static BOOL snuggleStart(NSString *t)
     {
       NSMutableString	*m = [NSMutableString new];
       NSArray		*names;
-      unsigned		i;
-      unsigned		c = [variables count];
+      NSUInteger		i;
+      NSUInteger		c = [variables count];
 
       [m appendString: @"    <chapter>\n"];
       [m appendFormat: @"      <heading>%@ variables</heading>\n", base];
@@ -674,8 +674,8 @@ static BOOL snuggleStart(NSString *t)
     {
       NSMutableString	*m = [NSMutableString new];
       NSArray		*names;
-      unsigned		i;
-      unsigned		c = [functions count];
+      NSUInteger		i;
+      NSUInteger		c = [functions count];
 
       [m appendString: @"    <chapter>\n"];
       [m appendFormat: @"      <heading>%@ functions</heading>\n", base];
@@ -786,7 +786,7 @@ static BOOL snuggleStart(NSString *t)
   NSString	*name = [d objectForKey: @"Name"];
   NSString	*comment = [d objectForKey: @"Comment"];
   NSString	*declared = [d objectForKey: @"Declared"];
-  unsigned	i = [aa count];
+  NSUInteger	i = [aa count];
 
   if (warn == YES && [[d objectForKey: @"Implemented"] isEqual: @"YES"] == NO)
     {
@@ -1145,9 +1145,9 @@ static BOOL snuggleStart(NSString *t)
   NSString	*tmp;
   NSString	*unit = nil;
   NSRange	r;
-  unsigned	ind;
-  unsigned	i;
-  unsigned	j;
+  NSUInteger	ind;
+  NSUInteger	i;
+  NSUInteger	j;
 
   if ([[d objectForKey: @"Implemented"] isEqual: @"YES"] == NO)
     {
@@ -1189,7 +1189,7 @@ static BOOL snuggleStart(NSString *t)
       r = [comment rangeOfString: @"<unit>"];
       if (r.length > 0)
 	{
-	  unsigned	pos = r.location;
+	  NSUInteger	pos = r.location;
 
 	  r = [comment rangeOfString: @"</unit>"];
 	  if (r.length == 0 || r.location < pos)
@@ -1220,7 +1220,7 @@ static BOOL snuggleStart(NSString *t)
 		}
 	      else
 		{
-		  unsigned	end = NSMaxRange(r);
+		  NSUInteger	end = NSMaxRange(r);
 
 		  r = NSMakeRange(pos, end-pos);
 		  unit = [comment substringWithRange: r];
@@ -1350,16 +1350,16 @@ static BOOL snuggleStart(NSString *t)
 	      to: str];
 }
 
-- (unsigned) reformat: (NSString*)str
-	   withIndent: (unsigned)ind
+- (NSUInteger) reformat: (NSString*)str
+	   withIndent: (NSUInteger)ind
 		   to: (NSMutableString*)buf
 {
 #if GS_WITH_GC == 0
   CREATE_AUTORELEASE_POOL(arp);
 #endif
-  unsigned	l = [str length];
+  NSUInteger	l = [str length];
   NSRange	r = [str rangeOfString: @"<example"];
-  unsigned	i = 0;
+  NSUInteger	i = 0;
   NSArray	*a;
 
   /*
@@ -1442,8 +1442,8 @@ static BOOL snuggleStart(NSString *t)
 	}
       else
 	{
-	  unsigned	size = 70 - ind - [str length];
-	  unsigned	end;
+	  NSUInteger	size = 70 - ind - [str length];
+	  NSUInteger	end;
 
 	  for (j = 0; j < ind; j++)
 	    {
@@ -1485,7 +1485,7 @@ static BOOL snuggleStart(NSString *t)
 - (NSArray*) split: (NSString*)str
 {
   NSMutableArray	*a = [NSMutableArray arrayWithCapacity: 128];
-  unsigned		l = [str length];
+  NSUInteger		l = [str length];
   NSMutableData		*data;
   unichar		*ptr;
   unichar		*end;
@@ -1601,7 +1601,7 @@ static BOOL snuggleStart(NSString *t)
 	       */
 	      if (optr[-2] == '/' && optr[-3] != ' ')
 		{
-		  unsigned	len = optr - buf;
+		  NSUInteger	len = optr - buf;
 		  unichar	c[len + 1];
 
 		  memcpy(c, buf, (len+1)*sizeof(unichar));
@@ -1642,9 +1642,9 @@ static BOOL snuggleStart(NSString *t)
     {
       static NSArray	*constants = nil;
       static NSArray	*types = nil;
-      unsigned		count;
+      NSUInteger		count;
       NSString		*tmp = [a objectAtIndex: l];
-      unsigned		pos;
+      NSUInteger		pos;
       NSRange		r;
 
       if (constants == nil)
@@ -1878,14 +1878,14 @@ static BOOL snuggleStart(NSString *t)
       r = [tmp rangeOfString: @"["];
       if (r.length > 0)
 	{
-	  unsigned	sPos = NSMaxRange(r);
+	  NSUInteger	sPos = NSMaxRange(r);
 
 	  pos = sPos;
 	  r = NSMakeRange(pos, [tmp length] - pos);
 	  r = [tmp rangeOfString: @"]" options: NSLiteralSearch range: r];
 	  if (r.length > 0)
 	    {
-	      unsigned	ePos = r.location;
+	      NSUInteger	ePos = r.location;
 	      NSString	*cName = nil;
 	      NSString	*mName = nil;
 	      unichar	c = 0;
@@ -1973,7 +1973,7 @@ static BOOL snuggleStart(NSString *t)
 
 	      if (pos < ePos && (c == '+' || c == '-'))
 		{
-		  unsigned	mStart = pos;
+		  NSUInteger	mStart = pos;
 
 		  pos++;
 		  if (pos < ePos
@@ -2160,9 +2160,9 @@ static BOOL snuggleStart(NSString *t)
        */
       if ([tmp hasPrefix: @"-"] || [tmp hasPrefix: @"+"])
 	{
-	  unsigned	ePos = [tmp length];
+	  NSUInteger	ePos = [tmp length];
 	  NSString	*mName = nil;
-	  unsigned	c;
+	  NSUInteger	c;
 
 	  pos = 1;
 	  if (pos < ePos
@@ -2237,8 +2237,8 @@ static BOOL snuggleStart(NSString *t)
       r = [tmp rangeOfString: @"()"];
       if (r.length > 0)
 	{
-	  unsigned	c = [tmp characterAtIndex: 0];
-	  unsigned	len = [tmp length];
+	  NSUInteger	c = [tmp characterAtIndex: 0];
+	  NSUInteger	len = [tmp length];
 	  NSString	*str = [tmp substringToIndex: r.location];
 	  BOOL		ok = NO;
 
diff --git a/Tools/AGSParser.h b/Tools/AGSParser.h
index 951aef9..6bd4887 100644
--- a/Tools/AGSParser.h
+++ b/Tools/AGSParser.h
@@ -53,8 +53,8 @@
    * The next few ivars represent the data currently being parsed.
    */
   unichar	*buffer;
-  unsigned	length;
-  unsigned	pos;
+  NSUInteger	length;
+  NSUInteger	pos;
   BOOL		inHeader;
   BOOL		commentsRead;
   BOOL		haveOutput;
@@ -85,7 +85,7 @@
 - (NSDictionary *) orderedSymbolDeclarationsByUnit;
 - (id) init;	/** <init> Simple initialiser */
 - (NSMutableArray*) outputs;
-- (unsigned) parseComment;
+- (NSUInteger) parseComment;
 - (NSMutableDictionary*) parseDeclaration;
 - (NSMutableDictionary*) parseFile: (NSString*)name isSource: (BOOL)isSource;
 - (NSString*) parseIdentifier;
@@ -96,11 +96,11 @@
 - (NSMutableDictionary*) parseMethodIsDeclaration: (BOOL)flag;
 - (NSMutableDictionary*) parseMethodsAreDeclarations: (BOOL)flag;
 - (NSString*) parseMethodType;
-- (unsigned) parsePreprocessor;
+- (NSUInteger) parsePreprocessor;
 - (NSMutableDictionary*) parseProtocol;
 - (NSMutableArray*) parseProtocolList;
-- (unsigned) parseSpace: (NSCharacterSet*)spaceSet;
-- (unsigned) parseSpace;
+- (NSUInteger) parseSpace: (NSCharacterSet*)spaceSet;
+- (NSUInteger) parseSpace;
 - (NSString*) parseVersion;
 - (void) reset;
 - (void) setDeclared: (NSString*)name;
@@ -110,16 +110,16 @@
 - (void) setStandards: (NSMutableDictionary*)dict;
 - (void) setWordMap: (NSDictionary*)map;
 - (void) setupBuffer;
-- (unsigned) skipArray;
-- (unsigned) skipBlock;
-- (unsigned) skipBlock: (BOOL*)isEmpty;
-- (unsigned) skipLiteral;
-- (unsigned) skipRemainderOfLine;
-- (unsigned) skipSpaces;
-- (unsigned) skipStatement;
-- (unsigned) skipStatementLine;
-- (unsigned) skipToEndOfLine;
-- (unsigned) skipUnit;
+- (NSUInteger) skipArray;
+- (NSUInteger) skipBlock;
+- (NSUInteger) skipBlock: (BOOL*)isEmpty;
+- (NSUInteger) skipLiteral;
+- (NSUInteger) skipRemainderOfLine;
+- (NSUInteger) skipSpaces;
+- (NSUInteger) skipStatement;
+- (NSUInteger) skipStatementLine;
+- (NSUInteger) skipToEndOfLine;
+- (NSUInteger) skipUnit;
 - (NSMutableArray*) sources;
 @end
 
diff --git a/Tools/AGSParser.m b/Tools/AGSParser.m
index 044d0b9..84760cd 100644
--- a/Tools/AGSParser.m
+++ b/Tools/AGSParser.m
@@ -202,7 +202,7 @@ in the returned dictionary. */
 - (void) log: (NSString*)fmt arguments: (va_list)args
 {
   const char	*msg;
-  int		where;
+  NSInteger		where;
 
   /*
    * Take the current position in the character buffer and
@@ -529,7 +529,7 @@ patata
  * prsence of file header markup, which is extracted into the 'info'
  * dictionary.
  */
-- (unsigned) parseComment
+- (NSUInteger) parseComment
 {
   if (buffer[pos + 1] == '/')
     {
@@ -727,7 +727,7 @@ recheck:
            */
 	  if (commentsRead == NO && comment != nil)
 	    {
-	      unsigned		commentLength = [comment length];
+	      NSUInteger		commentLength = [comment length];
 	      NSMutableArray	*authors;
 	      NSEnumerator	*enumerator;
 	      NSArray		*keys;
@@ -745,7 +745,7 @@ recheck:
 				       range: r];
 		  if (r.length > 0)
 		    {
-		      unsigned	i = r.location;
+		      NSUInteger	i = r.location;
 
 		      r = NSMakeRange(i, commentLength - i);
 		      r = [comment rangeOfString: @"</author>"
@@ -833,7 +833,7 @@ recheck:
 
 		  if (r.length > 0)
 		    {
-		      unsigned	i = NSMaxRange(r);
+		      NSUInteger	i = NSMaxRange(r);
 		      NSString	*line;
 		      NSString	*author;
 
@@ -902,7 +902,7 @@ recheck:
 				       range: r];
 		  if (r.length > 0)
 		    {
-		      unsigned	i = NSMaxRange(r);
+		      NSUInteger	i = NSMaxRange(r);
 		      NSString	*line;
 
 		      r = NSMakeRange(i, commentLength - i);
@@ -1029,7 +1029,7 @@ recheck:
 		  r = [comment rangeOfString: s];
 		  if (r.length > 0)
 		    {
-		      unsigned	i = r.location;
+		      NSUInteger	i = r.location;
 
 		      r = NSMakeRange(i, commentLength - i);
 		      r = [comment rangeOfString: e
@@ -1066,7 +1066,7 @@ recheck:
 					   range: r];
 		      if (r.length > 0)
 			{
-			  unsigned	i = NSMaxRange(r);
+			  NSUInteger	i = NSMaxRange(r);
 			  NSString	*line;
 
 			  r = NSMakeRange(i, commentLength - i);
@@ -1095,7 +1095,7 @@ recheck:
 		  r = [comment rangeOfString: @"$Date:"];
 		  if (r.length > 0)
 		    {
-		      unsigned	i = NSMaxRange(r);
+		      NSUInteger	i = NSMaxRange(r);
 		      NSString	*date;
 
 		      r = NSMakeRange(i, commentLength - i);
@@ -1122,7 +1122,7 @@ recheck:
 		  r = [comment rangeOfString: @"$Revision:"];
 		  if (r.length > 0)
 		    {
-		      unsigned	i = NSMaxRange(r);
+		      NSUInteger	i = NSMaxRange(r);
 		      NSString	*version;
 
 		      r = NSMakeRange(i, commentLength - i);
@@ -1331,7 +1331,7 @@ recheck:
 	{
 	  if ([self skipSpaces] < length && buffer[pos] == '(')
 	    {
-	      unsigned	start = pos;
+	      NSUInteger	start = pos;
 
 	      [self skipBlock];	// Skip the attributes
 	      if (YES == verbose)
@@ -1578,7 +1578,7 @@ recheck:
     }
   else if ([a containsObject: @"long"] == YES)
     {
-      unsigned	c = [a count];
+      NSUInteger	c = [a count];
 
       /*
        * There may be more than one 'long' in a type spec
@@ -1676,7 +1676,7 @@ recheck:
 		       options: NSBackwardsSearch|NSLiteralSearch];
 	  if (r.length > 0)
 	    {
-	      unsigned	p = r.location;
+	      NSUInteger	p = r.location;
 
 	      isPointer = YES;
 	      if (isTypedef == NO)
@@ -1710,7 +1710,7 @@ recheck:
 	    }
 	  while (buffer[pos] == '[')
 	    {
-	      unsigned	old = pos;
+	      NSUInteger	old = pos;
 
 	      if ([self skipArray] == old)
 		{
@@ -1768,7 +1768,7 @@ recheck:
 		{
 		  if ([self skipSpaces] < length && buffer[pos] == '(')
 		    {
-		      unsigned	start = pos;
+		      NSUInteger	start = pos;
 		      NSString	*attr;
 
 		      [self skipBlock];	// Skip the attributes
@@ -1802,7 +1802,7 @@ recheck:
 		  [self skipSpaces];
 		  if (pos < length && buffer[pos] == '(')
 		    {
-		      unsigned	start = pos;
+		      NSUInteger	start = pos;
 		      NSString	*attr;
 
 		      [self skipBlock];
@@ -2425,7 +2425,7 @@ fail:
  */
 - (NSString*) parseIdentifier
 {
-  unsigned	start;
+  NSUInteger	start;
 
 try:
   [self parseSpace];
@@ -2630,7 +2630,7 @@ fail:
 	}
       else if (c == '/')
 	{
-	  unsigned	save = pos;
+	  NSUInteger	save = pos;
 
 	  if ([self parseComment] == save)
 	    {
@@ -2740,7 +2740,7 @@ fail:
 	{
 	  if ([self skipSpaces] < length && buffer[pos] == '(')
 	    {
-	      unsigned	start = pos;
+	      NSUInteger	start = pos;
 	      NSString	*attr;
 
 	      [self skipBlock];	// Skip the attributes
@@ -2841,7 +2841,7 @@ fail:
 	  [mname appendString: token];
 	  if (buffer[pos] != term)
 	    {
-	      unsigned	saved = pos;
+	      NSUInteger	saved = pos;
 
 	      /*
 	       * As a special case, try to cope with a method name separated
@@ -2870,7 +2870,7 @@ fail:
 	}
       else
 	{
-	  unsigned	saved = pos;
+	  NSUInteger	saved = pos;
 
 	  /*
 	   * As a special case, try to cope with a method name separated
@@ -3298,7 +3298,7 @@ fail:
  * #ifdef and #ifndef with some well-known constants to tell
  * us which standards are currently supported.
  */
-- (unsigned) parsePreprocessor
+- (NSUInteger) parsePreprocessor
 {
   [self parseSpace: spaces];
   if (pos < length && buffer[pos] != '\n')
@@ -3714,13 +3714,13 @@ fail:
  * Calls parseComment if neccesary, ensuring that any documentation
  * in comments is appended to our 'comment' ivar.
  */
-- (unsigned) parseSpace: (NSCharacterSet*)spaceSet
+- (NSUInteger) parseSpace: (NSCharacterSet*)spaceSet
 {
   BOOL		tryAgain;
 
   do
     {
-      unsigned	start;
+      NSUInteger	start;
 
       tryAgain = NO;
       while (pos < length)
@@ -3729,7 +3729,7 @@ fail:
 
 	  if (c == '/')
 	    {
-	      unsigned	old = pos;
+	      NSUInteger	old = pos;
 
 	      if ([self parseComment] > old)
 		{
@@ -3788,7 +3788,7 @@ fail:
   return pos;
 }
 
-- (unsigned) parseSpace
+- (NSUInteger) parseSpace
 {
   return [self parseSpace: spacenl];
 }
@@ -3796,7 +3796,7 @@ fail:
 - (NSString*) parseVersion
 {
   static NSDictionary   *known = nil;
-  unsigned	        i;
+  NSUInteger	        i;
   NSString	        *str;
   NSString	        *tmp;
 
@@ -4073,7 +4073,7 @@ fail:
 		{
 		  inptr++;
 		  outptr--;
-		  [a addObject: [NSNumber numberWithInt: outptr - buffer]];
+		  [a addObject: [NSNumber numberWithInteger: outptr - buffer]];
 		}
 	      else if (inptr[1] == '\r')
 		{
@@ -4083,7 +4083,7 @@ fail:
 		    {
 		      inptr++;
 		    }
-		  [a addObject: [NSNumber numberWithInt: outptr - buffer]];
+		  [a addObject: [NSNumber numberWithInteger: outptr - buffer]];
 		}
 	    }
 	}
@@ -4104,11 +4104,11 @@ fail:
 	    {
 	      outptr--;		// Ignore trailing carriage return.
 	    }
-	  [a addObject: [NSNumber numberWithInt: outptr - buffer]];
+	  [a addObject: [NSNumber numberWithInteger: outptr - buffer]];
 	}
       else if (c == '\n')
 	{
-	  [a addObject: [NSNumber numberWithInt: outptr - buffer]];
+	  [a addObject: [NSNumber numberWithInteger: outptr - buffer]];
 	}
     }
   length = outptr - buffer;
@@ -4125,7 +4125,7 @@ fail:
  * Expect the current character position to be pointing to the
  * '[' at the start of an array.
  */
-- (unsigned) skipArray
+- (NSUInteger) skipArray
 {
   pos++;
   while ([self parseSpace] < length)
@@ -4161,12 +4161,12 @@ fail:
  * Expect the current character position to be pointing to the
  * bracket at the start of a block.
  */
-- (unsigned) skipBlock
+- (NSUInteger) skipBlock
 {
   return [self skipBlock: 0];
 }
 
-- (unsigned) skipBlock: (BOOL*)isEmpty
+- (NSUInteger) skipBlock: (BOOL*)isEmpty
 {
   unichar	term = '}';
   BOOL		empty = YES;
@@ -4234,7 +4234,7 @@ fail:
   return pos;
 }
 
-- (unsigned) skipLiteral
+- (NSUInteger) skipLiteral
 {
   unichar	term = buffer[pos++];
 
@@ -4254,7 +4254,7 @@ fail:
   return pos;
 }
 
-- (unsigned) skipRemainderOfLine
+- (NSUInteger) skipRemainderOfLine
 {
   while (pos < length)
     {
@@ -4266,7 +4266,7 @@ fail:
   return pos;
 }
 
-- (unsigned) skipSpaces
+- (NSUInteger) skipSpaces
 {
   while (pos < length)
     {
@@ -4286,7 +4286,7 @@ fail:
  * Strictly speaking, we don't skip all statements that way,
  * since we only skip part of an if...else statement.
  */
-- (unsigned) skipStatement
+- (NSUInteger) skipStatement
 {
   while ([self parseSpace] < length)
     {
@@ -4326,7 +4326,7 @@ fail:
  * line it was on, discarding any comments so they don't get used by
  * the next construct that actually needs documenting.
  */
-- (unsigned) skipStatementLine
+- (NSUInteger) skipStatementLine
 {
   [self skipStatement];
   if (buffer[pos-1] == ';' || buffer[pos-1] == '}')
@@ -4337,7 +4337,7 @@ fail:
   return pos;
 }
 
-- (unsigned) skipToEndOfLine
+- (NSUInteger) skipToEndOfLine
 {
   while (pos < length)
     {
@@ -4354,7 +4354,7 @@ fail:
  * Skip until we encounter an '@end' marking the end of an interface,
  * implementation, or protocol.
  */
-- (unsigned) skipUnit
+- (NSUInteger) skipUnit
 {
   while ([self parseSpace] < length)
     {
diff --git a/Tools/HTMLLinker.m b/Tools/HTMLLinker.m
index d6cdbd1..462a218 100644
--- a/Tools/HTMLLinker.m
+++ b/Tools/HTMLLinker.m
@@ -183,7 +183,7 @@ static int verbose = 0;
 {
   /* The HTML code that we work on.  */
   unichar *chars;
-  unsigned length;
+  NSUInteger length;
 }
 /* Init with some HTML code to parse.  */
 - (id)initWithCode: (NSString *)HTML;
@@ -410,22 +410,22 @@ static int verbose = 0;
   struct stringFragment
     {
       unichar *chars;
-      unsigned length;
+      NSUInteger length;
       BOOL needsFreeing;
       struct stringFragment *next;
     } *head, *tail;
 
   /* The index of the beginning of the last string fragment (the tail).  */
-  unsigned tailIndex = 0;
+  NSUInteger tailIndex = 0;
 
   /* The temporary index.  */
-  unsigned i = 0;
+  NSUInteger i = 0;
 
   /* The total number of chars in the output string.  We don't know
      this beforehand because each time we fix up a link, we might add
      or remove characters from the output.  We update
      totalNumberOfChars each time we close a stringFragment.  */
-  unsigned totalNumberOfChars = 0;
+  NSUInteger totalNumberOfChars = 0;
   
 
   /* Initialize the linked list.  */
@@ -454,14 +454,14 @@ static int verbose = 0;
              where it ends, because we are going to replace it with a
              different one (the fixed up one) later on if we determine
              we should do it.  */
-	  unsigned hrefStart = 0, hrefEnd = 0;
+	  NSUInteger hrefStart = 0, hrefEnd = 0;
 
 	  i += 3;
 	  
 	  while (1)
 	    {
 	      /* A marker for the start of strings.  */
-	      unsigned s;
+	      NSUInteger s;
 
 	      /* If this is an interesting (href/rel) attribute or
 		 not, and which one.  */
@@ -915,7 +915,7 @@ static int verbose = 0;
     NSString *file = [NSString stringWithContentsOfFile: pathOnDisk];
     HTMLParser *p = [[HTMLParser alloc] initWithCode: file];
     NSArray *names = [p names];
-    unsigned i, count;
+    NSUInteger i, count;
     
     RELEASE (p);
 
@@ -1071,7 +1071,7 @@ build_relocation_table_for_directory (NSString *dir)
 	  NSString *file;
 	  HTMLParser *p;
 	  NSArray *names;
-	  unsigned i, count;
+	  NSUInteger i, count;
 
 	  fullPath = [dir stringByAppendingPathComponent: filename];	  
 
@@ -1127,7 +1127,7 @@ int main (int argc, char** argv, char** env)
   NSUserDefaults *userDefs;
   NSArray *args;
   NSMutableArray *inputFiles;
-  unsigned i, count;
+  NSUInteger i, count;
   BOOL warn;
   NSString *linksMarker;
   HTMLLinker *linker;
diff --git a/Tools/autogsdoc.m b/Tools/autogsdoc.m
index a725394..5733ee3 100644
--- a/Tools/autogsdoc.m
+++ b/Tools/autogsdoc.m
@@ -623,7 +623,7 @@ int
 main(int argc, char **argv, char **env)
 {
   NSProcessInfo		*proc;
-  unsigned		i;
+  NSUInteger		i;
   NSDictionary		*argsRecognized;
   NSUserDefaults	*defs;
   NSFileManager		*mgr;
@@ -638,8 +638,8 @@ main(int argc, char **argv, char **env)
   NSDate		*rDate = nil;
   NSString		*refsFile;
   id			obj;
-  unsigned		count;
-  unsigned		firstFile = 1;
+  NSUInteger		count;
+  NSUInteger		firstFile = 1;
   BOOL			generateHtml = YES;
   BOOL			ignoreDependencies = NO;
   BOOL			showDependencies = NO;
@@ -1104,7 +1104,7 @@ main(int argc, char **argv, char **env)
 		  NSMutableString	*ms;
 		  NSEnumerator		*e = [keys objectEnumerator];
 		  NSString		*k;
-		  unsigned		length;
+		  NSUInteger		length;
 
 		  ms = [[NSMutableString alloc] initWithContentsOfFile: path];
 		  if (ms == nil)
@@ -1502,7 +1502,7 @@ main(int argc, char **argv, char **env)
 		}
 	      else
 		{
-		  unsigned	c = [modified count];
+		  NSUInteger	c = [modified count];
 
 		  while (c-- > 0)
 		    {
@@ -2177,8 +2177,8 @@ main(int argc, char **argv, char **env)
 	      NSData		*d;
 	      NSMutableString	*s;
 	      NSRange		r;
-	      unsigned		l;
-	      unsigned		p;
+	      NSUInteger		l;
+	      NSUInteger		p;
 	      AGSHtml		*html;
 
 	      html = AUTORELEASE([AGSHtml new]);
@@ -2210,7 +2210,7 @@ main(int argc, char **argv, char **env)
 				 range: NSMakeRange(p, l - p)];
 		  if (r.length == 0)
 		    {
-		      NSLog(@"Unterminated gsdoc rel at %u", p);
+		      NSLog(@"Unterminated gsdoc rel at %lu", (unsigned long)p);
 		      break;
 		    }
 		  else
@@ -2306,7 +2306,7 @@ main(int argc, char **argv, char **env)
 		    }
 		  if (repstr != nil)
 		    {
-		      int	offset = [repstr length] - replace.length;
+		      NSInteger	offset = [repstr length] - replace.length;
 
 		      p += offset;
 		      l += offset;
diff --git a/Tools/cvtenc.m b/Tools/cvtenc.m
index 8cfd89c..ae7bb7d 100644
--- a/Tools/cvtenc.m
+++ b/Tools/cvtenc.m
@@ -164,7 +164,7 @@ main(int argc, char** argv, char **env)
 	    }
 	  else
 	    {
-	      unsigned		l = [myData length];
+	      NSUInteger		l = [myData length];
 	      const unichar	*b = (const unichar*)[myData bytes];
 	      NSStringEncoding	iEnc;
 	      NSStringEncoding	oEnc;
@@ -209,11 +209,11 @@ main(int argc, char** argv, char **env)
 		{
 		  if (eIn == YES)
 		    {
-		      unsigned	l = [myString length];
+		      NSUInteger	l = [myString length];
 		      unichar	*u;
 		      NSZone	*z = NSDefaultMallocZone();
-		      unsigned	i = 0;
-		      unsigned	o = 0;
+		      NSUInteger	i = 0;
+		      NSUInteger	o = 0;
 
 		      u = NSZoneMalloc(z, sizeof(unichar)*l);
 		      [myString getCharacters: u];
@@ -262,12 +262,12 @@ main(int argc, char** argv, char **env)
 		    }
 		  if (eOut == YES)
 		    {
-		      unsigned	l = [myString length];
+		      NSUInteger	l = [myString length];
 		      unichar	*u;
 		      char	*c;
 		      NSZone	*z = NSDefaultMallocZone();
-		      unsigned	o = 0;
-		      unsigned	i;
+		      NSUInteger	o = 0;
+		      NSUInteger	i;
 
 		      u = NSZoneMalloc(z, sizeof(unichar)*l);
 		      c = NSZoneMalloc(z, 6*l);
diff --git a/Tools/defaults.m b/Tools/defaults.m
index 8ef4d2b..c6dbded 100644
--- a/Tools/defaults.m
+++ b/Tools/defaults.m
@@ -478,9 +478,9 @@ main(int argc, char** argv, char **env)
 
       if ([args count] == ++i)
 	{
-	  int	size = BUFSIZ;
-	  int	got;
-	  int	off = 0;
+	  ssize_t	size = BUFSIZ;
+	  ssize_t	got;
+	  ssize_t	off = 0;
 	  char	*buf = malloc(size);
 	  char	*ptr;
 
@@ -664,9 +664,9 @@ main(int argc, char** argv, char **env)
     {
       if ([args count] == ++i)
 	{
-	  int	size = BUFSIZ;
-	  int	got;
-	  int	off = 0;
+	  ssize_t	size = BUFSIZ;
+	  ssize_t	got;
+	  ssize_t	off = 0;
 	  char	*buf = malloc(size);
 	  char	*ptr;
 
diff --git a/Tools/gdnc.m b/Tools/gdnc.m
index 3abdd1d..7dd791d 100644
--- a/Tools/gdnc.m
+++ b/Tools/gdnc.m
@@ -310,8 +310,11 @@ ihandler(int sig)
 
 - (id) init
 {
-  queue = [[NSMutableArray alloc] initWithCapacity: 1];
-  return self;
+    if (self = [super init])
+    {
+        queue = [[NSMutableArray alloc] initWithCapacity: 1];
+    }
+    return self;
 }
 @end
 
@@ -404,6 +407,10 @@ ihandler(int sig)
 
 - (id) init
 {
+    if (!(self = [super init]))
+    {
+        return nil;
+    }
   NSString		*hostname;
   NSString		*service;
   BOOL			isNetwork = NO;
@@ -500,7 +507,7 @@ ihandler(int sig)
       NSHost		*host = [NSHost hostWithName: hostname];
       NSPort		*port = [conn receivePort];
       NSArray		*a;
-      unsigned		c;
+      NSUInteger		c;
 
       if (host == nil)
 	{
@@ -743,7 +750,7 @@ ihandler(int sig)
   NSMutableArray	*observers = [NSMutableArray array];
   NSMutableArray	*byName;
   NSMutableArray	*byObject;
-  unsigned		pos;
+  NSUInteger		pos;
   GDNCNotification	*notification = nil;
 
   byName = [observersForNames objectForKey: notificationName];
@@ -953,7 +960,7 @@ ihandler(int sig)
 	{
 	  NSMutableArray	*byName;
 	  NSMutableArray	*byObject;
-	  unsigned		pos;
+	  NSUInteger		pos;
 
 	  /*
 	   *	Remove observers that match both name and object.
@@ -1002,7 +1009,7 @@ ihandler(int sig)
       info = (GDNCClient*)NSMapGet(table, client);
       if (info != nil)
 	{
-	  unsigned	pos = [info->observers count];
+	  NSUInteger	pos = [info->observers count];
 
 	  while (pos > 0)
 	    {
diff --git a/Tools/make_strings/StringsFile.m b/Tools/make_strings/StringsFile.m
index 296b94e..b4004d5 100644
--- a/Tools/make_strings/StringsFile.m
+++ b/Tools/make_strings/StringsFile.m
@@ -37,7 +37,7 @@ static NSString *parse_string(NSString **ptr)
 {
   NSString *str = *ptr;
   NSString *ret;
-  int i,c;
+  NSUInteger i,c;
   unichar ch;
 
   c = [str length];
@@ -252,7 +252,7 @@ static NSString *parse_string(NSString **ptr)
                                          withObject: trans];
 
 	    {
-	      int i,c = [update_list count];
+	      NSUInteger i, c = [update_list count];
               for (i = 0; i < c; i++)
                 {
 //		    printf("%4i : %@\n",i,[update_list objectAtIndex: i]);
@@ -330,7 +330,7 @@ static NSString *parse_string(NSString **ptr)
 
 -(void) _writeTo: (NSMutableString *)str  manyEntries: (NSMutableArray *)list
 {
-  int i,c;
+  NSUInteger i,c;
   StringsEntry *tr,*cur;
 
   [list sortUsingSelector: @selector(compareFileLine:)];
@@ -370,7 +370,7 @@ static NSString *parse_string(NSString **ptr)
 
 -(BOOL) writeToFile: (NSString *)filename
 {
-  unsigned int i,c;
+  NSUInteger i,c;
   BOOL result;
   NSMutableString *str = [[NSMutableString alloc] initWithCapacity: 32*1024];
   StringsEntry *se;
@@ -544,7 +544,7 @@ static NSString *parse_string(NSString **ptr)
   /* First try to find a match among our unmatched strings. We consider
      two entries to match if they have the same key, file and comment. This
      could be extended, but the risk of errors increases. */
-  int i,c;
+  NSUInteger i,c;
   StringsEntry *se;
 
   c = [strings count];
diff --git a/Tools/make_strings/make_strings.m b/Tools/make_strings/make_strings.m
index 44f026b..fa1973b 100644
--- a/Tools/make_strings/make_strings.m
+++ b/Tools/make_strings/make_strings.m
@@ -453,7 +453,7 @@ printf("  %3i : %i '%s'\n", i, arg_ok[i], args[i]);
 static void
 UpdateTable(NSArray *source_table, NSString *filename)
 {
-  int i, c;
+  NSUInteger i, c;
   StringsFile *sf;
 
   if (verbose)
@@ -570,7 +570,7 @@ int main(int argc, char **argv)
 
   /* Remove any empty language from the list.  */
   {
-    int k;
+    NSInteger k;
 
     for (k = [languages count] - 1; k >= 0; k--)
       {
@@ -605,7 +605,7 @@ int main(int argc, char **argv)
 
   if (!error)
     {
-      int i, c = [languages count];
+      NSUInteger i, c = [languages count];
 
       for (i = 0; i < c; i++)
 	{
diff --git a/Tools/pl.m b/Tools/pl.m
index b1c88bf..a104529 100644
--- a/Tools/pl.m
+++ b/Tools/pl.m
@@ -34,7 +34,7 @@
 #import	"Foundation/NSProcessInfo.h"
 #import	"Foundation/NSUserDefaults.h"
 
-void create_output(id propertyList)
+static void create_output(id propertyList)
 {
   NSFileHandle *fileHandle = nil;
   NSProcessInfo *processInfo = [NSProcessInfo processInfo];
@@ -68,7 +68,7 @@ void create_output(id propertyList)
     }
 }
 
-id process_plist(NSData *inputData)
+static id process_plist(NSData *inputData)
 {
   id propertyList = nil;
   NSString *string = nil;
@@ -88,7 +88,7 @@ id process_plist(NSData *inputData)
   return propertyList;
 }
 
-NSData *read_input()
+static NSData *read_input()
 {
   NSData *inputData = nil;
   NSFileHandle *fileHandle = nil;
diff --git a/Tools/pl2link.m b/Tools/pl2link.m
index ad12cb9..06d361e 100644
--- a/Tools/pl2link.m
+++ b/Tools/pl2link.m
@@ -205,7 +205,7 @@ main(int argc, char** argv, char **env)
       FILE *fp;
       char line[130];
       NSString *execPath = nil;
-      int l = 0;
+      ssize_t l = 0;
 
       fp = popen("which openapp","r");
       fgets(line,sizeof line,fp);
diff --git a/Tools/plget.m b/Tools/plget.m
index 4b8293a..b24acfc 100644
--- a/Tools/plget.m
+++ b/Tools/plget.m
@@ -47,7 +47,7 @@ main(int argc, char** argv, char **env)
   NSProcessInfo		*proc;
   NSArray		*args;
   int			status = EXIT_SUCCESS;
-  int			count;
+  NSUInteger			count;
 
 #ifdef GS_PASS_ARGUMENTS
   GSInitializeProcess(argc, argv, env);
diff --git a/Tools/plparse.m b/Tools/plparse.m
index 9eb57c4..5e3062d 100644
--- a/Tools/plparse.m
+++ b/Tools/plparse.m
@@ -35,7 +35,7 @@
  * it as unicode data, we return the location of the first
  * bad character, otherwise return -1;
  */
-static int
+static NSInteger
 firstBadCharacter(NSString *file, NSString *content)
 {
   static NSCharacterSet	*cs = nil;
@@ -108,7 +108,7 @@ main(int argc, char** argv, char **env)
 	    {
 	      NSString	*myString;
 	      id	result;
-	      int	bad;
+	      NSInteger	bad;
 
 	      myString = [NSString stringWithContentsOfFile: file];
 	      if (myString == nil)
diff --git a/Tools/sfparse.m b/Tools/sfparse.m
index c7505fe..5a4ce40 100644
--- a/Tools/sfparse.m
+++ b/Tools/sfparse.m
@@ -29,7 +29,7 @@
 #import	"Foundation/NSAutoreleasePool.h"
 #import "GNUstepBase/Additions.h"
 
-int
+static int
 convert_unicode(NSArray *args)
 {
   unsigned int i;
@@ -69,7 +69,7 @@ convert_unicode(NSArray *args)
   return 0;
 }
 
-int
+static int
 convert_utf8(NSArray *args)
 {
   unsigned int i;
diff --git a/Tools/xmlparse.m b/Tools/xmlparse.m
index d11b1d2..24d471c 100644
--- a/Tools/xmlparse.m
+++ b/Tools/xmlparse.m
@@ -40,7 +40,7 @@
 {
   char		buf[BUFSIZ];
   NSString	*str;
-  int		len;
+  ssize_t		len;
 
   GSPrintf(stdout, @"Enter filename to load entity '%@' at '%@': ",
     publicId, location);
@@ -65,8 +65,8 @@ main(int argc, char **argv, char **env)
 {
   NSProcessInfo		*proc;
   NSArray		*files;
-  unsigned int		count;
-  unsigned int		i;
+  NSUInteger		count;
+  NSUInteger		i;
   CREATE_AUTORELEASE_POOL(pool);
 
 #ifdef GS_PASS_ARGUMENTS
diff --git a/base.xcodeproj/project.pbxproj b/base.xcodeproj/project.pbxproj
new file mode 100644
index 0000000..84f6e32
--- /dev/null
+++ b/base.xcodeproj/project.pbxproj
@@ -0,0 +1,4238 @@
+// !$*UTF8*$!
+{
+	archiveVersion = 1;
+	classes = {
+	};
+	objectVersion = 46;
+	objects = {
+
+/* Begin PBXBuildFile section */
+		180878891618537A006EBD74 /* objc-load.m in Sources */ = {isa = PBXBuildFile; fileRef = 1890700B1610BF3C0003C892 /* objc-load.m */; };
+		180DFAEB165BF98C00573635 /* NSInvocation.x86_64.S in Sources */ = {isa = PBXBuildFile; fileRef = 180DFAE9165BF94E00573635 /* NSInvocation.x86_64.S */; };
+		1837DA141652D18400197E53 /* Foundation.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 18394B1C1610D8E300335E85 /* Foundation.framework */; };
+		18394B341610D95600335E85 /* Foundation-Prefix.pch in Headers */ = {isa = PBXBuildFile; fileRef = 18394B321610D95600335E85 /* Foundation-Prefix.pch */; settings = {ATTRIBUTES = (Private, ); }; };
+		18394B351610D9D000335E85 /* Foundation.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906E681610BF3C0003C892 /* Foundation.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B361610D9D000335E85 /* FoundationErrors.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906E691610BF3C0003C892 /* FoundationErrors.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B371610D9D000335E85 /* NSAffineTransform.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906E6A1610BF3C0003C892 /* NSAffineTransform.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B381610D9D000335E85 /* NSArchiver.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906E6B1610BF3C0003C892 /* NSArchiver.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B391610D9D000335E85 /* NSArray.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906E6C1610BF3C0003C892 /* NSArray.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B3A1610D9D000335E85 /* NSAttributedString.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906E6D1610BF3C0003C892 /* NSAttributedString.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B3B1610D9D000335E85 /* NSAutoreleasePool.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906E6E1610BF3C0003C892 /* NSAutoreleasePool.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B3C1610D9D000335E85 /* NSBundle.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906E6F1610BF3C0003C892 /* NSBundle.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B3D1610D9D000335E85 /* NSByteOrder.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906E701610BF3C0003C892 /* NSByteOrder.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B3E1610D9D000335E85 /* NSCache.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906E711610BF3C0003C892 /* NSCache.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B3F1610D9D000335E85 /* NSCalendar.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906E721610BF3C0003C892 /* NSCalendar.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B401610D9D000335E85 /* NSCalendarDate.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906E731610BF3C0003C892 /* NSCalendarDate.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B411610D9D000335E85 /* NSCharacterSet.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906E741610BF3C0003C892 /* NSCharacterSet.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B421610D9D000335E85 /* NSClassDescription.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906E751610BF3C0003C892 /* NSClassDescription.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B431610D9D000335E85 /* NSCoder.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906E761610BF3C0003C892 /* NSCoder.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B441610D9D000335E85 /* NSComparisonPredicate.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906E771610BF3C0003C892 /* NSComparisonPredicate.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B451610D9D000335E85 /* NSCompoundPredicate.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906E781610BF3C0003C892 /* NSCompoundPredicate.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B461610D9D000335E85 /* NSConnection.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906E791610BF3C0003C892 /* NSConnection.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B471610D9D000335E85 /* NSData.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906E7A1610BF3C0003C892 /* NSData.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B481610D9D000335E85 /* NSDate.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906E7B1610BF3C0003C892 /* NSDate.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B491610D9D000335E85 /* NSDateFormatter.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906E7C1610BF3C0003C892 /* NSDateFormatter.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B4A1610D9D000335E85 /* NSDebug.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906E7D1610BF3C0003C892 /* NSDebug.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B4B1610D9D000335E85 /* NSDecimal.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906E7E1610BF3C0003C892 /* NSDecimal.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B4C1610D9D000335E85 /* NSDecimalNumber.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906E7F1610BF3C0003C892 /* NSDecimalNumber.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B4D1610D9D000335E85 /* NSDictionary.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906E801610BF3C0003C892 /* NSDictionary.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B4E1610D9D000335E85 /* NSDistantObject.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906E811610BF3C0003C892 /* NSDistantObject.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B4F1610D9D000335E85 /* NSDistributedLock.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906E821610BF3C0003C892 /* NSDistributedLock.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B501610D9D000335E85 /* NSDistributedNotificationCenter.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906E831610BF3C0003C892 /* NSDistributedNotificationCenter.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B511610D9D000335E85 /* NSEnumerator.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906E841610BF3C0003C892 /* NSEnumerator.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B521610D9D000335E85 /* NSError.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906E851610BF3C0003C892 /* NSError.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B531610D9D000335E85 /* NSErrorRecoveryAttempting.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906E861610BF3C0003C892 /* NSErrorRecoveryAttempting.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B541610D9D000335E85 /* NSException.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906E871610BF3C0003C892 /* NSException.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B551610D9D000335E85 /* NSExpression.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906E881610BF3C0003C892 /* NSExpression.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B561610D9D000335E85 /* NSFileHandle.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906E891610BF3C0003C892 /* NSFileHandle.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B571610D9D000335E85 /* NSFileManager.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906E8A1610BF3C0003C892 /* NSFileManager.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B581610D9D000335E85 /* NSFormatter.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906E8B1610BF3C0003C892 /* NSFormatter.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B591610D9D000335E85 /* NSGarbageCollector.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906E8C1610BF3C0003C892 /* NSGarbageCollector.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B5A1610D9D000335E85 /* NSGeometry.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906E8D1610BF3C0003C892 /* NSGeometry.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B5B1610D9D000335E85 /* NSHTTPCookie.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906E8E1610BF3C0003C892 /* NSHTTPCookie.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B5C1610D9D000335E85 /* NSHTTPCookieStorage.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906E8F1610BF3C0003C892 /* NSHTTPCookieStorage.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B5D1610D9D000335E85 /* NSHashTable.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906E901610BF3C0003C892 /* NSHashTable.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B5E1610D9D000335E85 /* NSHost.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906E911610BF3C0003C892 /* NSHost.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B5F1610D9D000335E85 /* NSIndexPath.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906E921610BF3C0003C892 /* NSIndexPath.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B601610D9D000335E85 /* NSIndexSet.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906E931610BF3C0003C892 /* NSIndexSet.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B611610D9D000335E85 /* NSInvocation.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906E941610BF3C0003C892 /* NSInvocation.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B621610D9D000335E85 /* NSJSONSerialization.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906E951610BF3C0003C892 /* NSJSONSerialization.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B631610D9D000335E85 /* NSKeyValueCoding.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906E961610BF3C0003C892 /* NSKeyValueCoding.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B641610D9D000335E85 /* NSKeyValueObserving.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906E971610BF3C0003C892 /* NSKeyValueObserving.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B651610D9D000335E85 /* NSKeyedArchiver.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906E981610BF3C0003C892 /* NSKeyedArchiver.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B661610D9D000335E85 /* NSLocale.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906E991610BF3C0003C892 /* NSLocale.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B671610D9D000335E85 /* NSLock.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906E9A1610BF3C0003C892 /* NSLock.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B681610D9D000335E85 /* NSMapTable.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906E9B1610BF3C0003C892 /* NSMapTable.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B691610D9D000335E85 /* NSMethodSignature.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906E9C1610BF3C0003C892 /* NSMethodSignature.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B6A1610D9D000335E85 /* NSNetServices.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906E9D1610BF3C0003C892 /* NSNetServices.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B6B1610D9D000335E85 /* NSNotification.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906E9E1610BF3C0003C892 /* NSNotification.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B6C1610D9D000335E85 /* NSNotificationQueue.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906E9F1610BF3C0003C892 /* NSNotificationQueue.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B6D1610D9D000335E85 /* NSNull.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906EA01610BF3C0003C892 /* NSNull.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B6E1610D9D000335E85 /* NSNumberFormatter.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906EA11610BF3C0003C892 /* NSNumberFormatter.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B6F1610D9D000335E85 /* NSObjCRuntime.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906EA21610BF3C0003C892 /* NSObjCRuntime.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B701610D9D000335E85 /* NSObject.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906EA31610BF3C0003C892 /* NSObject.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B711610D9D000335E85 /* NSOperation.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906EA41610BF3C0003C892 /* NSOperation.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B721610D9D000335E85 /* NSPathUtilities.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906EA51610BF3C0003C892 /* NSPathUtilities.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B731610D9D000335E85 /* NSPointerArray.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906EA61610BF3C0003C892 /* NSPointerArray.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B741610D9D000335E85 /* NSPointerFunctions.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906EA71610BF3C0003C892 /* NSPointerFunctions.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B751610D9D000335E85 /* NSPort.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906EA81610BF3C0003C892 /* NSPort.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B761610D9D000335E85 /* NSPortCoder.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906EA91610BF3C0003C892 /* NSPortCoder.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B771610D9D000335E85 /* NSPortMessage.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906EAA1610BF3C0003C892 /* NSPortMessage.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B781610D9D000335E85 /* NSPortNameServer.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906EAB1610BF3C0003C892 /* NSPortNameServer.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B791610D9D000335E85 /* NSPredicate.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906EAC1610BF3C0003C892 /* NSPredicate.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B7A1610D9D000335E85 /* NSProcessInfo.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906EAD1610BF3C0003C892 /* NSProcessInfo.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B7B1610D9D000335E85 /* NSPropertyList.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906EAE1610BF3C0003C892 /* NSPropertyList.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B7C1610D9D000335E85 /* NSProtocolChecker.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906EAF1610BF3C0003C892 /* NSProtocolChecker.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B7D1610D9D000335E85 /* NSProxy.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906EB01610BF3C0003C892 /* NSProxy.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B7E1610D9D000335E85 /* NSRange.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906EB11610BF3C0003C892 /* NSRange.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B7F1610D9D000335E85 /* NSRegularExpression.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906EB21610BF3C0003C892 /* NSRegularExpression.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B801610D9D000335E85 /* NSRunLoop.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906EB31610BF3C0003C892 /* NSRunLoop.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B811610D9D000335E85 /* NSScanner.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906EB41610BF3C0003C892 /* NSScanner.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B821610D9D000335E85 /* NSScriptWhoseTests.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906EB51610BF3C0003C892 /* NSScriptWhoseTests.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B831610D9D000335E85 /* NSSerialization.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906EB61610BF3C0003C892 /* NSSerialization.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B841610D9D000335E85 /* NSSet.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906EB71610BF3C0003C892 /* NSSet.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B851610D9D000335E85 /* NSSortDescriptor.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906EB81610BF3C0003C892 /* NSSortDescriptor.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B861610D9D000335E85 /* NSSpellServer.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906EB91610BF3C0003C892 /* NSSpellServer.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B871610D9D000335E85 /* NSStream.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906EBA1610BF3C0003C892 /* NSStream.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B881610D9D000335E85 /* NSString.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906EBB1610BF3C0003C892 /* NSString.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B891610D9D000335E85 /* NSTask.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906EBC1610BF3C0003C892 /* NSTask.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B8A1610D9D000335E85 /* NSTextCheckingResult.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906EBD1610BF3C0003C892 /* NSTextCheckingResult.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B8B1610D9D000335E85 /* NSThread.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906EBE1610BF3C0003C892 /* NSThread.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B8C1610D9D000335E85 /* NSTimeZone.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906EBF1610BF3C0003C892 /* NSTimeZone.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B8D1610D9D000335E85 /* NSTimer.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906EC01610BF3C0003C892 /* NSTimer.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B8E1610D9D000335E85 /* NSURL.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906EC11610BF3C0003C892 /* NSURL.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B8F1610D9D000335E85 /* NSURLAuthenticationChallenge.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906EC21610BF3C0003C892 /* NSURLAuthenticationChallenge.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B901610D9D000335E85 /* NSURLCache.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906EC31610BF3C0003C892 /* NSURLCache.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B911610D9D000335E85 /* NSURLConnection.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906EC41610BF3C0003C892 /* NSURLConnection.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B921610D9D000335E85 /* NSURLCredential.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906EC51610BF3C0003C892 /* NSURLCredential.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B931610D9D000335E85 /* NSURLCredentialStorage.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906EC61610BF3C0003C892 /* NSURLCredentialStorage.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B941610D9D000335E85 /* NSURLDownload.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906EC71610BF3C0003C892 /* NSURLDownload.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B951610D9D000335E85 /* NSURLError.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906EC81610BF3C0003C892 /* NSURLError.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B961610D9D000335E85 /* NSURLHandle.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906EC91610BF3C0003C892 /* NSURLHandle.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B971610D9D000335E85 /* NSURLProtectionSpace.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906ECA1610BF3C0003C892 /* NSURLProtectionSpace.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B981610D9D000335E85 /* NSURLProtocol.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906ECB1610BF3C0003C892 /* NSURLProtocol.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B991610D9D000335E85 /* NSURLRequest.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906ECC1610BF3C0003C892 /* NSURLRequest.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B9A1610D9D000335E85 /* NSURLResponse.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906ECD1610BF3C0003C892 /* NSURLResponse.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B9B1610D9D000335E85 /* NSUndoManager.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906ECE1610BF3C0003C892 /* NSUndoManager.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B9C1610D9D000335E85 /* NSUserDefaults.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906ECF1610BF3C0003C892 /* NSUserDefaults.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B9D1610D9D000335E85 /* NSUtilities.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906ED01610BF3C0003C892 /* NSUtilities.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B9E1610D9D000335E85 /* NSValue.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906ED11610BF3C0003C892 /* NSValue.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394B9F1610D9D000335E85 /* NSValueTransformer.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906ED21610BF3C0003C892 /* NSValueTransformer.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394BA01610D9D000335E85 /* NSXMLDTD.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906ED31610BF3C0003C892 /* NSXMLDTD.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394BA11610D9D000335E85 /* NSXMLDTDNode.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906ED41610BF3C0003C892 /* NSXMLDTDNode.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394BA21610D9D000335E85 /* NSXMLDocument.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906ED51610BF3C0003C892 /* NSXMLDocument.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394BA31610D9D000335E85 /* NSXMLElement.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906ED61610BF3C0003C892 /* NSXMLElement.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394BA41610D9D000335E85 /* NSXMLNode.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906ED71610BF3C0003C892 /* NSXMLNode.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394BA51610D9D000335E85 /* NSXMLNodeOptions.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906ED81610BF3C0003C892 /* NSXMLNodeOptions.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394BA61610D9D000335E85 /* NSXMLParser.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906ED91610BF3C0003C892 /* NSXMLParser.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394BA71610D9D000335E85 /* NSZone.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906EDA1610BF3C0003C892 /* NSZone.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394BA81610D9ED00335E85 /* NSArray+GNUstepBase.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906EEE1610BF3C0003C892 /* NSArray+GNUstepBase.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394BA91610D9ED00335E85 /* NSAttributedString+GNUstepBase.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906EEF1610BF3C0003C892 /* NSAttributedString+GNUstepBase.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394BAA1610D9ED00335E85 /* NSBundle+GNUstepBase.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906EF01610BF3C0003C892 /* NSBundle+GNUstepBase.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394BAB1610D9ED00335E85 /* NSCalendarDate+GNUstepBase.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906EF11610BF3C0003C892 /* NSCalendarDate+GNUstepBase.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394BAC1610D9ED00335E85 /* NSData+GNUstepBase.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906EF21610BF3C0003C892 /* NSData+GNUstepBase.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394BAD1610D9ED00335E85 /* NSDebug+GNUstepBase.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906EF31610BF3C0003C892 /* NSDebug+GNUstepBase.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394BAE1610D9ED00335E85 /* NSFileHandle+GNUstepBase.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906EF41610BF3C0003C892 /* NSFileHandle+GNUstepBase.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394BAF1610D9ED00335E85 /* NSLock+GNUstepBase.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906EF51610BF3C0003C892 /* NSLock+GNUstepBase.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394BB01610D9ED00335E85 /* NSMutableString+GNUstepBase.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906EF61610BF3C0003C892 /* NSMutableString+GNUstepBase.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394BB11610D9ED00335E85 /* NSNetServices+GNUstepBase.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906EF71610BF3C0003C892 /* NSNetServices+GNUstepBase.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394BB21610D9ED00335E85 /* NSNumber+GNUstepBase.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906EF81610BF3C0003C892 /* NSNumber+GNUstepBase.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394BB31610D9ED00335E85 /* NSObject+GNUstepBase.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906EF91610BF3C0003C892 /* NSObject+GNUstepBase.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394BB41610D9ED00335E85 /* NSProcessInfo+GNUstepBase.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906EFA1610BF3C0003C892 /* NSProcessInfo+GNUstepBase.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394BB51610D9ED00335E85 /* NSStream+GNUstepBase.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906EFB1610BF3C0003C892 /* NSStream+GNUstepBase.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394BB61610D9ED00335E85 /* NSString+GNUstepBase.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906EFC1610BF3C0003C892 /* NSString+GNUstepBase.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394BB71610D9ED00335E85 /* NSTask+GNUstepBase.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906EFD1610BF3C0003C892 /* NSTask+GNUstepBase.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394BB81610D9ED00335E85 /* NSThread+GNUstepBase.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906EFE1610BF3C0003C892 /* NSThread+GNUstepBase.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394BB91610D9ED00335E85 /* NSURL+GNUstepBase.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906EFF1610BF3C0003C892 /* NSURL+GNUstepBase.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		18394C011610EB7F00335E85 /* NSAffineTransform.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F701610BF3C0003C892 /* NSAffineTransform.m */; };
+		18394C031610EB7F00335E85 /* NSArray.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F721610BF3C0003C892 /* NSArray.m */; };
+		18394C041610EB7F00335E85 /* NSAssertionHandler.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F731610BF3C0003C892 /* NSAssertionHandler.m */; };
+		18394C051610EB7F00335E85 /* NSAttributedString.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F741610BF3C0003C892 /* NSAttributedString.m */; };
+		18394C061610EB7F00335E85 /* NSAutoreleasePool.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F751610BF3C0003C892 /* NSAutoreleasePool.m */; };
+		18394C071610EB7F00335E85 /* NSBundle.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F761610BF3C0003C892 /* NSBundle.m */; };
+		18394C081610EB7F00335E85 /* NSCache.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F771610BF3C0003C892 /* NSCache.m */; };
+		18394C091610EB7F00335E85 /* NSCachedURLResponse.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F781610BF3C0003C892 /* NSCachedURLResponse.m */; };
+		18394C0A1610EB7F00335E85 /* NSCalendar.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F791610BF3C0003C892 /* NSCalendar.m */; };
+		18394C0B1610EB7F00335E85 /* NSCalendarDate.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F7A1610BF3C0003C892 /* NSCalendarDate.m */; };
+		18394C0C1610EB7F00335E85 /* NSCallBacks.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F7C1610BF3C0003C892 /* NSCallBacks.m */; };
+		18394C0D1610EB7F00335E85 /* NSCharacterSet.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F7D1610BF3C0003C892 /* NSCharacterSet.m */; };
+		18394C0E1610EB7F00335E85 /* NSClassDescription.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F7F1610BF3C0003C892 /* NSClassDescription.m */; };
+		18394C0F1610EB7F00335E85 /* NSCoder.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F801610BF3C0003C892 /* NSCoder.m */; };
+		18394C101610EB7F00335E85 /* NSConcreteHashTable.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F811610BF3C0003C892 /* NSConcreteHashTable.m */; };
+		18394C111610EB7F00335E85 /* NSConcreteMapTable.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F821610BF3C0003C892 /* NSConcreteMapTable.m */; };
+		18394C121610EB7F00335E85 /* NSConcretePointerFunctions.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F841610BF3C0003C892 /* NSConcretePointerFunctions.m */; };
+		18394C131610EB7F00335E85 /* NSConnection.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F851610BF3C0003C892 /* NSConnection.m */; };
+		18394C141610EB7F00335E85 /* NSCopyObject.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F861610BF3C0003C892 /* NSCopyObject.m */; };
+		18394C151610EB7F00335E85 /* NSCountedSet.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F871610BF3C0003C892 /* NSCountedSet.m */; };
+		18394C171610EB7F00335E85 /* NSDate.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F891610BF3C0003C892 /* NSDate.m */; };
+		18394C181610EB7F00335E85 /* NSDateFormatter.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F8A1610BF3C0003C892 /* NSDateFormatter.m */; };
+		18394C191610EB7F00335E85 /* NSDebug.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F8B1610BF3C0003C892 /* NSDebug.m */; };
+		18394C1A1610EB7F00335E85 /* NSDecimal.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F8C1610BF3C0003C892 /* NSDecimal.m */; };
+		18394C1B1610EB7F00335E85 /* NSDecimalNumber.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F8D1610BF3C0003C892 /* NSDecimalNumber.m */; };
+		18394C1C1610EB7F00335E85 /* NSDictionary.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F8E1610BF3C0003C892 /* NSDictionary.m */; };
+		18394C1D1610EB7F00335E85 /* NSDistantObject.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F8F1610BF3C0003C892 /* NSDistantObject.m */; };
+		18394C1E1610EB7F00335E85 /* NSDistributedLock.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F901610BF3C0003C892 /* NSDistributedLock.m */; };
+		18394C1F1610EB7F00335E85 /* NSDistributedNotificationCenter.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F911610BF3C0003C892 /* NSDistributedNotificationCenter.m */; };
+		18394C201610EB7F00335E85 /* NSEnumerator.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F921610BF3C0003C892 /* NSEnumerator.m */; };
+		18394C211610EB7F00335E85 /* NSError.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F931610BF3C0003C892 /* NSError.m */; };
+		18394C221610EB7F00335E85 /* NSException.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F941610BF3C0003C892 /* NSException.m */; };
+		18394C231610EB7F00335E85 /* NSFileHandle.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F951610BF3C0003C892 /* NSFileHandle.m */; };
+		18394C241610EB7F00335E85 /* NSFileManager.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F961610BF3C0003C892 /* NSFileManager.m */; };
+		18394C251610EB7F00335E85 /* NSFormatter.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F971610BF3C0003C892 /* NSFormatter.m */; };
+		18394C261610EB7F00335E85 /* NSGarbageCollector.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F981610BF3C0003C892 /* NSGarbageCollector.m */; };
+		18394C271610EB7F00335E85 /* NSGeometry.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F991610BF3C0003C892 /* NSGeometry.m */; };
+		18394C281610EB7F00335E85 /* NSHTTPCookie.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F9A1610BF3C0003C892 /* NSHTTPCookie.m */; };
+		18394C291610EB7F00335E85 /* NSHTTPCookieStorage.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F9B1610BF3C0003C892 /* NSHTTPCookieStorage.m */; };
+		18394C2A1610EB7F00335E85 /* NSHashTable.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F9C1610BF3C0003C892 /* NSHashTable.m */; };
+		18394C2B1610EB7F00335E85 /* NSHost.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F9D1610BF3C0003C892 /* NSHost.m */; };
+		18394C2C1610EB7F00335E85 /* NSIndexPath.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F9E1610BF3C0003C892 /* NSIndexPath.m */; };
+		18394C2D1610EB7F00335E85 /* NSIndexSet.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F9F1610BF3C0003C892 /* NSIndexSet.m */; };
+		18394C2E1610EB7F00335E85 /* NSInvocation.ff.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906FA01610BF3C0003C892 /* NSInvocation.ff.m */; };
+		18394C2F1610EB7F00335E85 /* NSJSONSerialization.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906FA11610BF3C0003C892 /* NSJSONSerialization.m */; };
+		18394C301610EB7F00335E85 /* NSKeyValueCoding.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906FA21610BF3C0003C892 /* NSKeyValueCoding.m */; };
+		18394C341610EB7F00335E85 /* NSKeyedArchiver.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906FA61610BF3C0003C892 /* NSKeyedArchiver.m */; };
+		18394C361610EB7F00335E85 /* NSLocale.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906FA81610BF3C0003C892 /* NSLocale.m */; };
+		18394C371610EB7F00335E85 /* NSLock.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906FA91610BF3C0003C892 /* NSLock.m */; };
+		18394C381610EB7F00335E85 /* NSLog.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906FAA1610BF3C0003C892 /* NSLog.m */; };
+		18394C391610EB7F00335E85 /* NSMapTable.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906FAB1610BF3C0003C892 /* NSMapTable.m */; };
+		18394C3A1610EB7F00335E85 /* NSMessagePort.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906FAC1610BF3C0003C892 /* NSMessagePort.m */; };
+		18394C3B1610EB7F00335E85 /* NSMessagePortNameServer.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906FAD1610BF3C0003C892 /* NSMessagePortNameServer.m */; };
+		18394C3C1610EB7F00335E85 /* NSMethodSignature.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906FAE1610BF3C0003C892 /* NSMethodSignature.m */; };
+		18394C3D1610EB7F00335E85 /* NSNetServices.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906FAF1610BF3C0003C892 /* NSNetServices.m */; };
+		18394C3E1610EB7F00335E85 /* NSNotification.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906FB01610BF3C0003C892 /* NSNotification.m */; };
+		18394C401610EB7F00335E85 /* NSNotificationQueue.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906FB21610BF3C0003C892 /* NSNotificationQueue.m */; };
+		18394C411610EB7F00335E85 /* NSNull.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906FB31610BF3C0003C892 /* NSNull.m */; };
+		18394C421610EB7F00335E85 /* NSNumber.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906FB41610BF3C0003C892 /* NSNumber.m */; };
+		18394C431610EB7F00335E85 /* NSNumberFormatter.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906FB51610BF3C0003C892 /* NSNumberFormatter.m */; };
+		18394C451610EB7F00335E85 /* NSObject.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906FB91610BF3C0003C892 /* NSObject.m */; };
+		18394C461610EB7F00335E85 /* NSOperation.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906FBA1610BF3C0003C892 /* NSOperation.m */; };
+		18394C471610EB7F00335E85 /* NSPage.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906FBB1610BF3C0003C892 /* NSPage.m */; };
+		18394C481610EB7F00335E85 /* NSPathUtilities.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906FBC1610BF3C0003C892 /* NSPathUtilities.m */; };
+		18394C491610EB7F00335E85 /* NSPipe.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906FBD1610BF3C0003C892 /* NSPipe.m */; };
+		18394C4A1610EB7F00335E85 /* NSPointerArray.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906FBE1610BF3C0003C892 /* NSPointerArray.m */; };
+		18394C4B1610EB7F00335E85 /* NSPointerFunctions.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906FBF1610BF3C0003C892 /* NSPointerFunctions.m */; };
+		18394C4C1610EB7F00335E85 /* NSPort.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906FC01610BF3C0003C892 /* NSPort.m */; };
+		18394C4E1610EB7F00335E85 /* NSPortMessage.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906FC21610BF3C0003C892 /* NSPortMessage.m */; };
+		18394C4F1610EB7F00335E85 /* NSPortNameServer.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906FC31610BF3C0003C892 /* NSPortNameServer.m */; };
+		18394C501610EB7F00335E85 /* NSPredicate.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906FC41610BF3C0003C892 /* NSPredicate.m */; };
+		18394C511610EB7F00335E85 /* NSProcessInfo.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906FC51610BF3C0003C892 /* NSProcessInfo.m */; };
+		18394C521610EB7F00335E85 /* NSPropertyList.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906FC61610BF3C0003C892 /* NSPropertyList.m */; };
+		18394C531610EB7F00335E85 /* NSProtocolChecker.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906FC71610BF3C0003C892 /* NSProtocolChecker.m */; };
+		18394C541610EB7F00335E85 /* NSProxy.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906FC81610BF3C0003C892 /* NSProxy.m */; };
+		18394C551610EB7F00335E85 /* NSRange.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906FC91610BF3C0003C892 /* NSRange.m */; };
+		18394C561610EB7F00335E85 /* NSRegularExpression.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906FCA1610BF3C0003C892 /* NSRegularExpression.m */; };
+		18394C571610EB7F00335E85 /* NSRunLoop.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906FCB1610BF3C0003C892 /* NSRunLoop.m */; };
+		18394C581610EB7F00335E85 /* NSScanner.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906FCC1610BF3C0003C892 /* NSScanner.m */; };
+		18394C591610EB7F00335E85 /* NSSerializer.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906FCD1610BF3C0003C892 /* NSSerializer.m */; };
+		18394C5A1610EB7F00335E85 /* NSSet.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906FCE1610BF3C0003C892 /* NSSet.m */; };
+		18394C5B1610EB7F00335E85 /* NSSocketPort.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906FCF1610BF3C0003C892 /* NSSocketPort.m */; };
+		18394C5C1610EB7F00335E85 /* NSSocketPortNameServer.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906FD01610BF3C0003C892 /* NSSocketPortNameServer.m */; };
+		18394C5D1610EB7F00335E85 /* NSSortDescriptor.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906FD11610BF3C0003C892 /* NSSortDescriptor.m */; };
+		18394C5E1610EB7F00335E85 /* NSSpellServer.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906FD21610BF3C0003C892 /* NSSpellServer.m */; };
+		18394C5F1610EB7F00335E85 /* NSString.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906FD31610BF3C0003C892 /* NSString.m */; };
+		18394C601610EB7F00335E85 /* NSTask.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906FD41610BF3C0003C892 /* NSTask.m */; };
+		18394C611610EB7F00335E85 /* NSTextCheckingResult.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906FD51610BF3C0003C892 /* NSTextCheckingResult.m */; };
+		18394C621610EB7F00335E85 /* NSThread.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906FD61610BF3C0003C892 /* NSThread.m */; };
+		18394C631610EB7F00335E85 /* NSTimeZone.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906FD71610BF3C0003C892 /* NSTimeZone.m */; };
+		18394C641610EB7F00335E85 /* NSTimer.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906FD81610BF3C0003C892 /* NSTimer.m */; };
+		18394C651610EB7F00335E85 /* NSURL.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906FD91610BF3C0003C892 /* NSURL.m */; };
+		18394C661610EB7F00335E85 /* NSURLAuthenticationChallenge.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906FDA1610BF3C0003C892 /* NSURLAuthenticationChallenge.m */; };
+		18394C671610EB7F00335E85 /* NSURLCache.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906FDB1610BF3C0003C892 /* NSURLCache.m */; };
+		18394C681610EB7F00335E85 /* NSURLConnection.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906FDC1610BF3C0003C892 /* NSURLConnection.m */; };
+		18394C691610EB7F00335E85 /* NSURLCredential.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906FDD1610BF3C0003C892 /* NSURLCredential.m */; };
+		18394C6A1610EB8000335E85 /* NSURLCredentialStorage.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906FDE1610BF3C0003C892 /* NSURLCredentialStorage.m */; };
+		18394C6B1610EB8000335E85 /* NSURLDownload.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906FDF1610BF3C0003C892 /* NSURLDownload.m */; };
+		18394C6C1610EB8000335E85 /* NSURLHandle.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906FE01610BF3C0003C892 /* NSURLHandle.m */; };
+		18394C6D1610EB8000335E85 /* NSURLProtectionSpace.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906FE11610BF3C0003C892 /* NSURLProtectionSpace.m */; };
+		18394C6E1610EB8000335E85 /* NSURLProtocol.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906FE21610BF3C0003C892 /* NSURLProtocol.m */; };
+		18394C6F1610EB8000335E85 /* NSURLRequest.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906FE31610BF3C0003C892 /* NSURLRequest.m */; };
+		18394C701610EB8000335E85 /* NSURLResponse.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906FE41610BF3C0003C892 /* NSURLResponse.m */; };
+		18394C721610EB8000335E85 /* NSUndoManager.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906FE61610BF3C0003C892 /* NSUndoManager.m */; };
+		18394C731610EB8000335E85 /* NSUserDefaults.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906FE71610BF3C0003C892 /* NSUserDefaults.m */; };
+		18394C741610EB8000335E85 /* NSValue.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906FE81610BF3C0003C892 /* NSValue.m */; };
+		18394C751610EB8000335E85 /* NSValueTransformer.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906FE91610BF3C0003C892 /* NSValueTransformer.m */; };
+		18394C761610EB8000335E85 /* NSXMLDTD.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906FEA1610BF3C0003C892 /* NSXMLDTD.m */; };
+		18394C771610EB8000335E85 /* NSXMLDTDNode.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906FEB1610BF3C0003C892 /* NSXMLDTDNode.m */; };
+		18394C781610EB8000335E85 /* NSXMLDocument.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906FEC1610BF3C0003C892 /* NSXMLDocument.m */; };
+		18394C791610EB8000335E85 /* NSXMLElement.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906FED1610BF3C0003C892 /* NSXMLElement.m */; };
+		18394C7A1610EB8000335E85 /* NSXMLNode.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906FEE1610BF3C0003C892 /* NSXMLNode.m */; };
+		18394C7B1610EB8000335E85 /* NSXMLParser.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906FEF1610BF3C0003C892 /* NSXMLParser.m */; };
+		18394C7C1610EB8000335E85 /* NSZone.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906FF11610BF3C0003C892 /* NSZone.m */; };
+		18394C7D1610EC5E00335E85 /* NSCallBacks.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906F7B1610BF3C0003C892 /* NSCallBacks.h */; settings = {ATTRIBUTES = (Private, ); }; };
+		18394C7E1610EC5E00335E85 /* NSCharacterSetData.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906F7E1610BF3C0003C892 /* NSCharacterSetData.h */; settings = {ATTRIBUTES = (Private, ); }; };
+		18394C7F1610EC5E00335E85 /* NSConcretePointerFunctions.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906F831610BF3C0003C892 /* NSConcretePointerFunctions.h */; settings = {ATTRIBUTES = (Private, ); }; };
+		18394C801610EC5E00335E85 /* NSNumberMethods.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906FB61610BF3C0003C892 /* NSNumberMethods.h */; settings = {ATTRIBUTES = (Private, ); }; };
+		18394C811610EC5E00335E85 /* NSXMLPrivate.h in Headers */ = {isa = PBXBuildFile; fileRef = 18906FF01610BF3C0003C892 /* NSXMLPrivate.h */; settings = {ATTRIBUTES = (Private, ); }; };
+		18408FF217271D3E00CFD080 /* NSKeyValueObserving.m in Sources */ = {isa = PBXBuildFile; fileRef = 18408FF017271D3D00CFD080 /* NSKeyValueObserving.m */; };
+		18408FF617271EAE00CFD080 /* NSArray+KVO.m in Sources */ = {isa = PBXBuildFile; fileRef = 18408FF417271EAD00CFD080 /* NSArray+KVO.m */; };
+		18408FFA1727200100CFD080 /* NSSet+KVO.m in Sources */ = {isa = PBXBuildFile; fileRef = 18408FF81727200100CFD080 /* NSSet+KVO.m */; };
+		184915A5163056E800B0ED83 /* libffi.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 184915A4163056E800B0ED83 /* libffi.dylib */; };
+		1852894F161243FC0016729B /* NSObjCRuntime.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906FB71610BF3C0003C892 /* NSObjCRuntime.m */; };
+		185289511613861E0016729B /* GSObjCRuntime.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F131610BF3C0003C892 /* GSObjCRuntime.m */; };
+		1852895216138A7D0016729B /* NSUnarchiver.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906FE51610BF3C0003C892 /* NSUnarchiver.m */; };
+		1852895316138C5C0016729B /* NSArchiver.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F711610BF3C0003C892 /* NSArchiver.m */; };
+		1852895416138CFB0016729B /* NSData.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F881610BF3C0003C892 /* NSData.m */; };
+		1852895516138E6F0016729B /* NSPortCoder.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906FC11610BF3C0003C892 /* NSPortCoder.m */; };
+		18528957161396130016729B /* GCArray.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F0B1610BF3C0003C892 /* GCArray.m */; };
+		18528958161396160016729B /* GCDictionary.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F0C1610BF3C0003C892 /* GCDictionary.m */; };
+		185289591613961A0016729B /* GCObject.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F0D1610BF3C0003C892 /* GCObject.m */; };
+		1852895A161396200016729B /* GSFunctions.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F0F1610BF3C0003C892 /* GSFunctions.m */; };
+		1852895B161396240016729B /* GSInsensitiveDictionary.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F101610BF3C0003C892 /* GSInsensitiveDictionary.m */; };
+		1852895C161396280016729B /* GSLock.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F111610BF3C0003C892 /* GSLock.m */; };
+		1852895D1613962B0016729B /* GSMime.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F121610BF3C0003C892 /* GSMime.m */; };
+		1852895E161396310016729B /* GSXML.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F141610BF3C0003C892 /* GSXML.m */; };
+		1852895F161396450016729B /* GSArray.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F391610BF3C0003C892 /* GSArray.m */; };
+		18528960161396450016729B /* GSAttributedString.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F3A1610BF3C0003C892 /* GSAttributedString.m */; };
+		18528961161396450016729B /* CXXException.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F351610BF3C0003C892 /* CXXException.m */; };
+		18528966161396450016729B /* GSBlocks.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F411610BF3C0003C892 /* GSBlocks.m */; };
+		18528967161396450016729B /* GSConcreteValue.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F421610BF3C0003C892 /* GSConcreteValue.m */; };
+		18528969161396450016729B /* GSCountedSet.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F441610BF3C0003C892 /* GSCountedSet.m */; };
+		1852896A161396450016729B /* GSDictionary.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F451610BF3C0003C892 /* GSDictionary.m */; };
+		1852896D161396450016729B /* GSFTPURLHandle.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F491610BF3C0003C892 /* GSFTPURLHandle.m */; };
+		1852896E161396450016729B /* GSFileHandle.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F4C1610BF3C0003C892 /* GSFileHandle.m */; };
+		1852896F161396450016729B /* GSFormat.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F4D1610BF3C0003C892 /* GSFormat.m */; };
+		18528970161396450016729B /* GSHTTPAuthentication.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F4E1610BF3C0003C892 /* GSHTTPAuthentication.m */; };
+		18528971161396450016729B /* GSHTTPURLHandle.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F4F1610BF3C0003C892 /* GSHTTPURLHandle.m */; };
+		18528972161396450016729B /* GSICUString.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F511610BF3C0003C892 /* GSICUString.m */; };
+		18528973161396450016729B /* GSLocale.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F541610BF3C0003C892 /* GSLocale.m */; };
+		18528974161396450016729B /* GSMDNSNetServices.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F551610BF3C0003C892 /* GSMDNSNetServices.m */; };
+		18528975161396450016729B /* GSQuickSort.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F5C1610BF3C0003C892 /* GSQuickSort.m */; };
+		18528976161396450016729B /* GSRunLoopWatcher.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F5F1610BF3C0003C892 /* GSRunLoopWatcher.m */; };
+		18528977161396450016729B /* GSSet.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F601610BF3C0003C892 /* GSSet.m */; };
+		18528978161396450016729B /* GSShellSort.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F611610BF3C0003C892 /* GSShellSort.m */; };
+		18528979161396450016729B /* GSSocketStream.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F631610BF3C0003C892 /* GSSocketStream.m */; };
+		1852897A161396450016729B /* GSStream.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F661610BF3C0003C892 /* GSStream.m */; };
+		1852897B161396450016729B /* GSString.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F671610BF3C0003C892 /* GSString.m */; };
+		1852897C161396450016729B /* GSTLS.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F691610BF3C0003C892 /* GSTLS.m */; };
+		1852897D161396450016729B /* GSTimSort.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F6A1610BF3C0003C892 /* GSTimSort.m */; };
+		1852897E161396450016729B /* GSValue.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F6C1610BF3C0003C892 /* GSValue.m */; };
+		18528984161398FF0016729B /* NSArray+GNUstepBase.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F171610BF3C0003C892 /* NSArray+GNUstepBase.m */; };
+		18528985161398FF0016729B /* NSAttributedString+GNUstepBase.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F181610BF3C0003C892 /* NSAttributedString+GNUstepBase.m */; };
+		18528986161398FF0016729B /* NSBundle+GNUstepBase.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F191610BF3C0003C892 /* NSBundle+GNUstepBase.m */; };
+		18528987161398FF0016729B /* NSCalendarDate+GNUstepBase.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F1A1610BF3C0003C892 /* NSCalendarDate+GNUstepBase.m */; };
+		18528988161398FF0016729B /* NSData+GNUstepBase.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F1B1610BF3C0003C892 /* NSData+GNUstepBase.m */; };
+		18528989161398FF0016729B /* NSDebug+GNUstepBase.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F1C1610BF3C0003C892 /* NSDebug+GNUstepBase.m */; };
+		1852898A161398FF0016729B /* NSError+GNUstepBase.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F1D1610BF3C0003C892 /* NSError+GNUstepBase.m */; };
+		1852898B161398FF0016729B /* NSFileHandle+GNUstepBase.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F1E1610BF3C0003C892 /* NSFileHandle+GNUstepBase.m */; };
+		1852898C161399000016729B /* NSLock+GNUstepBase.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F1F1610BF3C0003C892 /* NSLock+GNUstepBase.m */; };
+		1852898D161399000016729B /* NSMutableString+GNUstepBase.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F201610BF3C0003C892 /* NSMutableString+GNUstepBase.m */; };
+		1852898E161399000016729B /* NSNumber+GNUstepBase.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F211610BF3C0003C892 /* NSNumber+GNUstepBase.m */; };
+		1852898F161399000016729B /* NSObject+GNUstepBase.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F221610BF3C0003C892 /* NSObject+GNUstepBase.m */; };
+		18528990161399000016729B /* NSProcessInfo+GNUstepBase.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F231610BF3C0003C892 /* NSProcessInfo+GNUstepBase.m */; };
+		18528991161399000016729B /* NSPropertyList+GNUstepBase.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F241610BF3C0003C892 /* NSPropertyList+GNUstepBase.m */; };
+		18528992161399000016729B /* NSStream+GNUstepBase.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F251610BF3C0003C892 /* NSStream+GNUstepBase.m */; };
+		18528993161399000016729B /* NSString+GNUstepBase.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F261610BF3C0003C892 /* NSString+GNUstepBase.m */; };
+		18528994161399000016729B /* NSTask+GNUstepBase.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F271610BF3C0003C892 /* NSTask+GNUstepBase.m */; };
+		18528995161399000016729B /* NSThread+GNUstepBase.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F281610BF3C0003C892 /* NSThread+GNUstepBase.m */; };
+		18528996161399000016729B /* NSURL+GNUstepBase.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F291610BF3C0003C892 /* NSURL+GNUstepBase.m */; };
+		18528997161399000016729B /* Unicode.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906F2A1610BF3C0003C892 /* Unicode.m */; };
+		18528999161399720016729B /* libxml2.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 185289981613996F0016729B /* libxml2.dylib */; };
+		1852899B161399D70016729B /* libz.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 1852899A161399D40016729B /* libz.dylib */; };
+		1852899D161399FB0016729B /* libxslt.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 1852899C161399F80016729B /* libxslt.dylib */; };
+		1852899F16139A1B0016729B /* libiconv.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 1852899E16139A180016729B /* libiconv.dylib */; };
+		185289A216139AAF0016729B /* NSObject+NSComparisonMethods.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906FB81610BF3C0003C892 /* NSObject+NSComparisonMethods.m */; };
+		185289A516139AAF0016729B /* externs.m in Sources */ = {isa = PBXBuildFile; fileRef = 189070031610BF3C0003C892 /* externs.m */; };
+		185289AA16139AAF0016729B /* preface.m in Sources */ = {isa = PBXBuildFile; fileRef = 1890700C1610BF3C0003C892 /* preface.m */; };
+		185289FF1613A8840016729B /* NSNotificationCenter.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906FB11610BF3C0003C892 /* NSNotificationCenter.m */; };
+		18528A001613AB940016729B /* GSRunLoopCtxt.m in Sources */ = {isa = PBXBuildFile; fileRef = 189070101610BF3C0003C892 /* GSRunLoopCtxt.m */; };
+		18528A011613AB940016729B /* NSStream.m in Sources */ = {isa = PBXBuildFile; fileRef = 189070121610BF3C0003C892 /* NSStream.m */; };
+		185391931625FD0C0015BDFA /* NSKeyedUnarchiver.m in Sources */ = {isa = PBXBuildFile; fileRef = 18906FA71610BF3C0003C892 /* NSKeyedUnarchiver.m */; };
+		18641D1F1678AD34003C6E11 /* GSSocks4Parser.m in Sources */ = {isa = PBXBuildFile; fileRef = 18641D0F1678AD04003C6E11 /* GSSocks4Parser.m */; };
+		18641D201678AD39003C6E11 /* GSSocks5Parser.m in Sources */ = {isa = PBXBuildFile; fileRef = 18641D111678AD04003C6E11 /* GSSocks5Parser.m */; };
+		18641D211678AD41003C6E11 /* GSSocksParser.m in Sources */ = {isa = PBXBuildFile; fileRef = 18641D131678AD04003C6E11 /* GSSocksParser.m */; };
+		18641D221678AD46003C6E11 /* GSSocksParserPrivate.m in Sources */ = {isa = PBXBuildFile; fileRef = 18641D151678AD04003C6E11 /* GSSocksParserPrivate.m */; };
+		1890B34116F3BC3300187826 /* GSPrivateHash.m in Sources */ = {isa = PBXBuildFile; fileRef = 1890B34016F3BC3300187826 /* GSPrivateHash.m */; };
+		18D8BEA4164B5FF800942A5D /* NSInvocation.x86_64.m in Sources */ = {isa = PBXBuildFile; fileRef = 18D8BEA2164B5FF700942A5D /* NSInvocation.x86_64.m */; };
+		18EA6761172EC6170026AC34 /* GSTypeEncoding.c in Sources */ = {isa = PBXBuildFile; fileRef = 18EA675F172EC6170026AC34 /* GSTypeEncoding.c */; };
+		18EA6764172EC7F70026AC34 /* GSTypeEncoding.h in Headers */ = {isa = PBXBuildFile; fileRef = 18EA6763172EC7F70026AC34 /* GSTypeEncoding.h */; };
+		18EFCC1F172B0B9A003304CA /* gdnc.m in Sources */ = {isa = PBXBuildFile; fileRef = 1837D9DE1652D0FF00197E53 /* gdnc.m */; };
+		18F8D05D1724534E00420DA5 /* NSKeyValueNestedProperty.h in Headers */ = {isa = PBXBuildFile; fileRef = 18F8D0501724534E00420DA5 /* NSKeyValueNestedProperty.h */; };
+		18F8D05E1724534E00420DA5 /* NSKeyValueNestedProperty.m in Sources */ = {isa = PBXBuildFile; fileRef = 18F8D0511724534E00420DA5 /* NSKeyValueNestedProperty.m */; };
+		18F8D05F1724534E00420DA5 /* NSKeyValueObservance.h in Headers */ = {isa = PBXBuildFile; fileRef = 18F8D0521724534E00420DA5 /* NSKeyValueObservance.h */; };
+		18F8D0601724534E00420DA5 /* NSKeyValueObservance.m in Sources */ = {isa = PBXBuildFile; fileRef = 18F8D0531724534E00420DA5 /* NSKeyValueObservance.m */; };
+		18F8D0611724534E00420DA5 /* NSKeyValueObservationInfo.h in Headers */ = {isa = PBXBuildFile; fileRef = 18F8D0541724534E00420DA5 /* NSKeyValueObservationInfo.h */; };
+		18F8D0621724534E00420DA5 /* NSKeyValueObservationInfo.m in Sources */ = {isa = PBXBuildFile; fileRef = 18F8D0551724534E00420DA5 /* NSKeyValueObservationInfo.m */; };
+		18F8D0631724534E00420DA5 /* NSKeyValueObservingPrivate.h in Headers */ = {isa = PBXBuildFile; fileRef = 18F8D0561724534E00420DA5 /* NSKeyValueObservingPrivate.h */; };
+		18F8D0641724534E00420DA5 /* NSKeyValueObservingPrivate.m in Sources */ = {isa = PBXBuildFile; fileRef = 18F8D0571724534E00420DA5 /* NSKeyValueObservingPrivate.m */; };
+		18F8D0651724534E00420DA5 /* NSKeyValueProperty.h in Headers */ = {isa = PBXBuildFile; fileRef = 18F8D0581724534E00420DA5 /* NSKeyValueProperty.h */; };
+		18F8D0661724534E00420DA5 /* NSKeyValueProperty.m in Sources */ = {isa = PBXBuildFile; fileRef = 18F8D0591724534E00420DA5 /* NSKeyValueProperty.m */; };
+		18F8D0671724534E00420DA5 /* NSKeyValueUnnestedProperty.h in Headers */ = {isa = PBXBuildFile; fileRef = 18F8D05A1724534E00420DA5 /* NSKeyValueUnnestedProperty.h */; };
+		18F8D0681724534E00420DA5 /* NSKeyValueUnnestedProperty.m in Sources */ = {isa = PBXBuildFile; fileRef = 18F8D05B1724534E00420DA5 /* NSKeyValueUnnestedProperty.m */; };
+		18F8D0691724534E00420DA5 /* NSObject+KVO.m in Sources */ = {isa = PBXBuildFile; fileRef = 18F8D05C1724534E00420DA5 /* NSObject+KVO.m */; };
+		18F8D06C1725919A00420DA5 /* NSKVONotifying.h in Headers */ = {isa = PBXBuildFile; fileRef = 18F8D06A1725919700420DA5 /* NSKVONotifying.h */; };
+		18F8D06D1725919A00420DA5 /* NSKVONotifying.m in Sources */ = {isa = PBXBuildFile; fileRef = 18F8D06B1725919800420DA5 /* NSKVONotifying.m */; };
+/* End PBXBuildFile section */
+
+/* Begin PBXBuildRule section */
+		1801C64416B5A8E400999B34 /* PBXBuildRule */ = {
+			isa = PBXBuildRule;
+			compilerSpec = com.apple.compilers.proxy.script;
+			filePatterns = "*.S";
+			fileType = pattern.proxy;
+			isEditable = 1;
+			outputFiles = (
+				"${OBJECT_FILE_DIR}/${INPUT_FILE_NAME}.o",
+			);
+			script = "clang -DNeXT_RUNTIME -c $INPUT_FILE_DIR/$INPUT_FILE_NAME -o $SCRIPT_OUTPUT_FILE_0";
+		};
+/* End PBXBuildRule section */
+
+/* Begin PBXContainerItemProxy section */
+		1837DA0F1652D18400197E53 /* PBXContainerItemProxy */ = {
+			isa = PBXContainerItemProxy;
+			containerPortal = 18906E371610BC4C0003C892 /* Project object */;
+			proxyType = 1;
+			remoteGlobalIDString = 18394B1B1610D8E300335E85;
+			remoteInfo = Foundation;
+		};
+/* End PBXContainerItemProxy section */
+
+/* Begin PBXCopyFilesBuildPhase section */
+		1837DA151652D18400197E53 /* CopyFiles */ = {
+			isa = PBXCopyFilesBuildPhase;
+			buildActionMask = 2147483647;
+			dstPath = /usr/share/man/man1/;
+			dstSubfolderSpec = 0;
+			files = (
+			);
+			runOnlyForDeploymentPostprocessing = 1;
+		};
+/* End PBXCopyFilesBuildPhase section */
+
+/* Begin PBXFileReference section */
+		180DFAE9165BF94E00573635 /* NSInvocation.x86_64.S */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.asm; path = NSInvocation.x86_64.S; sourceTree = "<group>"; };
+		1837D9C61652D0FF00197E53 /* .cvsignore */ = {isa = PBXFileReference; lastKnownFileType = text; path = .cvsignore; sourceTree = "<group>"; };
+		1837D9C71652D0FF00197E53 /* AGSHtml.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = AGSHtml.h; sourceTree = "<group>"; };
+		1837D9C81652D0FF00197E53 /* AGSHtml.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = AGSHtml.m; sourceTree = "<group>"; };
+		1837D9C91652D0FF00197E53 /* AGSIndex.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = AGSIndex.h; sourceTree = "<group>"; };
+		1837D9CA1652D0FF00197E53 /* AGSIndex.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = AGSIndex.m; sourceTree = "<group>"; };
+		1837D9CB1652D0FF00197E53 /* AGSOutput.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = AGSOutput.h; sourceTree = "<group>"; };
+		1837D9CC1652D0FF00197E53 /* AGSOutput.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = AGSOutput.m; sourceTree = "<group>"; };
+		1837D9CD1652D0FF00197E53 /* AGSParser.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = AGSParser.h; sourceTree = "<group>"; };
+		1837D9CE1652D0FF00197E53 /* AGSParser.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = AGSParser.m; sourceTree = "<group>"; };
+		1837D9CF1652D0FF00197E53 /* BaseTools.gsdoc */ = {isa = PBXFileReference; lastKnownFileType = text.xml; path = BaseTools.gsdoc; sourceTree = "<group>"; };
+		1837D9D01652D0FF00197E53 /* DocMakefile */ = {isa = PBXFileReference; lastKnownFileType = text; path = DocMakefile; sourceTree = "<group>"; };
+		1837D9D11652D0FF00197E53 /* GNUmakefile */ = {isa = PBXFileReference; lastKnownFileType = text; path = GNUmakefile; sourceTree = "<group>"; };
+		1837D9D21652D0FF00197E53 /* HTMLLinker.gsdoc */ = {isa = PBXFileReference; lastKnownFileType = text; path = HTMLLinker.gsdoc; sourceTree = "<group>"; };
+		1837D9D31652D0FF00197E53 /* HTMLLinker.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = HTMLLinker.m; sourceTree = "<group>"; };
+		1837D9D41652D0FF00197E53 /* Makefile.postamble */ = {isa = PBXFileReference; lastKnownFileType = text; path = Makefile.postamble; sourceTree = "<group>"; };
+		1837D9D51652D0FF00197E53 /* Makefile.preamble */ = {isa = PBXFileReference; lastKnownFileType = text; path = Makefile.preamble; sourceTree = "<group>"; };
+		1837D9D61652D0FF00197E53 /* autogsdoc.1 */ = {isa = PBXFileReference; lastKnownFileType = text.man; path = autogsdoc.1; sourceTree = "<group>"; };
+		1837D9D71652D0FF00197E53 /* autogsdoc.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = autogsdoc.m; sourceTree = "<group>"; };
+		1837D9D81652D0FF00197E53 /* cvtenc.1 */ = {isa = PBXFileReference; lastKnownFileType = text.man; path = cvtenc.1; sourceTree = "<group>"; };
+		1837D9D91652D0FF00197E53 /* cvtenc.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = cvtenc.m; sourceTree = "<group>"; };
+		1837D9DA1652D0FF00197E53 /* defaults.1 */ = {isa = PBXFileReference; lastKnownFileType = text.man; path = defaults.1; sourceTree = "<group>"; };
+		1837D9DB1652D0FF00197E53 /* defaults.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = defaults.m; sourceTree = "<group>"; };
+		1837D9DC1652D0FF00197E53 /* gdnc.1 */ = {isa = PBXFileReference; lastKnownFileType = text.man; path = gdnc.1; sourceTree = "<group>"; };
+		1837D9DD1652D0FF00197E53 /* gdnc.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = gdnc.h; sourceTree = "<group>"; };
+		1837D9DE1652D0FF00197E53 /* gdnc.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = gdnc.m; sourceTree = "<group>"; };
+		1837D9DF1652D0FF00197E53 /* gdomap.8 */ = {isa = PBXFileReference; lastKnownFileType = text; path = gdomap.8; sourceTree = "<group>"; };
+		1837D9E01652D0FF00197E53 /* gdomap.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; path = gdomap.c; sourceTree = "<group>"; };
+		1837D9E11652D0FF00197E53 /* gdomap.gsdoc */ = {isa = PBXFileReference; lastKnownFileType = text.xml; path = gdomap.gsdoc; sourceTree = "<group>"; };
+		1837D9E21652D0FF00197E53 /* gdomap.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = gdomap.h; sourceTree = "<group>"; };
+		1837D9E31652D0FF00197E53 /* gsdoc-0_6_5.dtd */ = {isa = PBXFileReference; lastKnownFileType = text.xml; path = "gsdoc-0_6_5.dtd"; sourceTree = "<group>"; };
+		1837D9E41652D0FF00197E53 /* gsdoc-0_6_6.dtd */ = {isa = PBXFileReference; lastKnownFileType = text.xml; path = "gsdoc-0_6_6.dtd"; sourceTree = "<group>"; };
+		1837D9E51652D0FF00197E53 /* gsdoc-0_6_7.dtd */ = {isa = PBXFileReference; lastKnownFileType = text.xml; path = "gsdoc-0_6_7.dtd"; sourceTree = "<group>"; };
+		1837D9E61652D0FF00197E53 /* gsdoc-1_0_0.dtd */ = {isa = PBXFileReference; lastKnownFileType = text.xml; path = "gsdoc-1_0_0.dtd"; sourceTree = "<group>"; };
+		1837D9E71652D0FF00197E53 /* gsdoc-1_0_1.dtd */ = {isa = PBXFileReference; lastKnownFileType = text.xml; path = "gsdoc-1_0_1.dtd"; sourceTree = "<group>"; };
+		1837D9E81652D0FF00197E53 /* gsdoc-1_0_1.rnc */ = {isa = PBXFileReference; lastKnownFileType = text; path = "gsdoc-1_0_1.rnc"; sourceTree = "<group>"; };
+		1837D9E91652D0FF00197E53 /* gsdoc-1_0_2.dtd */ = {isa = PBXFileReference; lastKnownFileType = text.xml; path = "gsdoc-1_0_2.dtd"; sourceTree = "<group>"; };
+		1837D9EA1652D0FF00197E53 /* gsdoc-1_0_3.dtd */ = {isa = PBXFileReference; lastKnownFileType = text.xml; path = "gsdoc-1_0_3.dtd"; sourceTree = "<group>"; };
+		1837D9EB1652D0FF00197E53 /* gsdoc.7 */ = {isa = PBXFileReference; lastKnownFileType = text; path = gsdoc.7; sourceTree = "<group>"; };
+		1837D9EC1652D0FF00197E53 /* gsdoc.gsdoc */ = {isa = PBXFileReference; lastKnownFileType = text.xml; path = gsdoc.gsdoc; sourceTree = "<group>"; };
+		1837D9ED1652D0FF00197E53 /* gspath.1 */ = {isa = PBXFileReference; lastKnownFileType = text.man; path = gspath.1; sourceTree = "<group>"; };
+		1837D9EE1652D0FF00197E53 /* gspath.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = gspath.m; sourceTree = "<group>"; };
+		1837D9EF1652D0FF00197E53 /* locale_alias.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = locale_alias.m; sourceTree = "<group>"; };
+		1837D9F11652D0FF00197E53 /* .cvsignore */ = {isa = PBXFileReference; lastKnownFileType = text; path = .cvsignore; sourceTree = "<group>"; };
+		1837D9F21652D0FF00197E53 /* GNUmakefile */ = {isa = PBXFileReference; lastKnownFileType = text; path = GNUmakefile; sourceTree = "<group>"; };
+		1837D9F31652D0FF00197E53 /* GNUmakefile.preamble */ = {isa = PBXFileReference; lastKnownFileType = text; path = GNUmakefile.preamble; sourceTree = "<group>"; };
+		1837D9F41652D0FF00197E53 /* README */ = {isa = PBXFileReference; lastKnownFileType = text; path = README; sourceTree = "<group>"; };
+		1837D9F51652D0FF00197E53 /* SourceEntry.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = SourceEntry.h; sourceTree = "<group>"; };
+		1837D9F61652D0FF00197E53 /* SourceEntry.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = SourceEntry.m; sourceTree = "<group>"; };
+		1837D9F71652D0FF00197E53 /* StringsEntry.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = StringsEntry.h; sourceTree = "<group>"; };
+		1837D9F81652D0FF00197E53 /* StringsEntry.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = StringsEntry.m; sourceTree = "<group>"; };
+		1837D9F91652D0FF00197E53 /* StringsFile.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = StringsFile.h; sourceTree = "<group>"; };
+		1837D9FA1652D0FF00197E53 /* StringsFile.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = StringsFile.m; sourceTree = "<group>"; };
+		1837D9FB1652D0FF00197E53 /* Using.txt */ = {isa = PBXFileReference; lastKnownFileType = text; path = Using.txt; sourceTree = "<group>"; };
+		1837D9FC1652D0FF00197E53 /* make_strings.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = make_strings.h; sourceTree = "<group>"; };
+		1837D9FD1652D0FF00197E53 /* make_strings.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = make_strings.m; sourceTree = "<group>"; };
+		1837D9FE1652D0FF00197E53 /* test1.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = test1.m; sourceTree = "<group>"; };
+		1837D9FF1652D0FF00197E53 /* mkchlog.sh */ = {isa = PBXFileReference; lastKnownFileType = text.script.sh; path = mkchlog.sh; sourceTree = "<group>"; };
+		1837DA001652D0FF00197E53 /* pl.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = pl.m; sourceTree = "<group>"; };
+		1837DA011652D0FF00197E53 /* pl2link.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = pl2link.m; sourceTree = "<group>"; };
+		1837DA021652D0FF00197E53 /* pldes.1 */ = {isa = PBXFileReference; lastKnownFileType = text.man; path = pldes.1; sourceTree = "<group>"; };
+		1837DA031652D0FF00197E53 /* pldes.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = pldes.m; sourceTree = "<group>"; };
+		1837DA041652D0FF00197E53 /* plget.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = plget.m; sourceTree = "<group>"; };
+		1837DA051652D0FF00197E53 /* plist-0_9.dtd */ = {isa = PBXFileReference; lastKnownFileType = text.xml; path = "plist-0_9.dtd"; sourceTree = "<group>"; };
+		1837DA061652D0FF00197E53 /* plmerge.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = plmerge.m; sourceTree = "<group>"; };
+		1837DA071652D0FF00197E53 /* plparse.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = plparse.m; sourceTree = "<group>"; };
+		1837DA081652D0FF00197E53 /* plser.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = plser.m; sourceTree = "<group>"; };
+		1837DA091652D0FF00197E53 /* sfparse.1 */ = {isa = PBXFileReference; lastKnownFileType = text.man; path = sfparse.1; sourceTree = "<group>"; };
+		1837DA0A1652D0FF00197E53 /* sfparse.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = sfparse.m; sourceTree = "<group>"; };
+		1837DA0B1652D0FF00197E53 /* xmlparse.1 */ = {isa = PBXFileReference; lastKnownFileType = text.man; path = xmlparse.1; sourceTree = "<group>"; };
+		1837DA0C1652D0FF00197E53 /* xmlparse.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = xmlparse.m; sourceTree = "<group>"; };
+		1837DA191652D18400197E53 /* gdnc */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.executable"; includeInIndex = 0; path = gdnc; sourceTree = BUILT_PRODUCTS_DIR; };
+		18394A9C1610C04600335E85 /* configure */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.script.sh; path = configure; sourceTree = SOURCE_ROOT; };
+		18394AA31610CC4E00335E85 /* config.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = config.h; sourceTree = "<group>"; };
+		18394AA41610CC4E00335E85 /* GSConfig.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = GSConfig.h; sourceTree = "<group>"; };
+		18394B1C1610D8E300335E85 /* Foundation.framework */ = {isa = PBXFileReference; explicitFileType = wrapper.framework; includeInIndex = 0; path = Foundation.framework; sourceTree = BUILT_PRODUCTS_DIR; };
+		18394B311610D95600335E85 /* Foundation-Info.plist */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.plist.xml; name = "Foundation-Info.plist"; path = "Support/Foundation/Foundation-Info.plist"; sourceTree = SOURCE_ROOT; };
+		18394B321610D95600335E85 /* Foundation-Prefix.pch */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = "Foundation-Prefix.pch"; path = "Support/Foundation/Foundation-Prefix.pch"; sourceTree = SOURCE_ROOT; };
+		18394BF51610E73300335E85 /* libobjc.dylib */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.dylib"; name = libobjc.dylib; path = usr/lib/libobjc.dylib; sourceTree = SDKROOT; };
+		18394BF71610E84A00335E85 /* libicudata.48.1.dylib */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.dylib"; name = libicudata.48.1.dylib; path = /opt/local/lib/libicudata.48.1.dylib; sourceTree = "<absolute>"; };
+		18394BF91610E85A00335E85 /* libicucore.dylib */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.dylib"; name = libicucore.dylib; path = usr/lib/libicucore.dylib; sourceTree = SDKROOT; };
+		18394BFB1610E8FB00335E85 /* libicui18n.48.1.dylib */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.dylib"; name = libicui18n.48.1.dylib; path = /opt/local/lib/libicui18n.48.1.dylib; sourceTree = "<absolute>"; };
+		18394BFD1610E97A00335E85 /* libicuuc.48.1.dylib */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.dylib"; name = libicuuc.48.1.dylib; path = /opt/local/lib/libicuuc.48.1.dylib; sourceTree = "<absolute>"; };
+		18408FF017271D3D00CFD080 /* NSKeyValueObserving.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSKeyValueObserving.m; sourceTree = "<group>"; };
+		18408FF417271EAD00CFD080 /* NSArray+KVO.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = "NSArray+KVO.m"; sourceTree = "<group>"; };
+		18408FF81727200100CFD080 /* NSSet+KVO.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = "NSSet+KVO.m"; sourceTree = "<group>"; };
+		184915A4163056E800B0ED83 /* libffi.dylib */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.dylib"; name = libffi.dylib; path = usr/lib/libffi.dylib; sourceTree = SDKROOT; };
+		18528980161397F40016729B /* libgnutls.26.dylib */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.dylib"; name = libgnutls.26.dylib; path = /opt/local/lib/libgnutls.26.dylib; sourceTree = "<absolute>"; };
+		185289981613996F0016729B /* libxml2.dylib */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.dylib"; name = libxml2.dylib; path = usr/lib/libxml2.dylib; sourceTree = SDKROOT; };
+		1852899A161399D40016729B /* libz.dylib */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.dylib"; name = libz.dylib; path = usr/lib/libz.dylib; sourceTree = SDKROOT; };
+		1852899C161399F80016729B /* libxslt.dylib */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.dylib"; name = libxslt.dylib; path = usr/lib/libxslt.dylib; sourceTree = SDKROOT; };
+		1852899E16139A180016729B /* libiconv.dylib */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.dylib"; name = libiconv.dylib; path = usr/lib/libiconv.dylib; sourceTree = SDKROOT; };
+		185289A016139A470016729B /* libgcrypt.11.dylib */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.dylib"; name = libgcrypt.11.dylib; path = /opt/local/lib/libgcrypt.11.dylib; sourceTree = "<absolute>"; };
+		185289AB1613A06F0016729B /* configure.ac */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; path = configure.ac; sourceTree = SOURCE_ROOT; };
+		185289AE1613A1060016729B /* addlibrarypath.m4 */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; path = addlibrarypath.m4; sourceTree = "<group>"; };
+		185289AF1613A1060016729B /* codeset.m4 */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; path = codeset.m4; sourceTree = "<group>"; };
+		185289B01613A1060016729B /* config.align.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = config.align.c; sourceTree = "<group>"; };
+		185289B11613A1060016729B /* config.builtin_apply.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = config.builtin_apply.c; sourceTree = "<group>"; };
+		185289B21613A1060016729B /* config.constant-string-class.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = "config.constant-string-class.m"; sourceTree = "<group>"; };
+		185289B31613A1060016729B /* config.constant-string-encoding.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = "config.constant-string-encoding.c"; sourceTree = "<group>"; };
+		185289B41613A1060016729B /* config.ffi.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = config.ffi.c; sourceTree = "<group>"; };
+		185289B51613A1060016729B /* config.forward.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = config.forward.m; sourceTree = "<group>"; };
+		185289B61613A1060016729B /* config.forward2.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = config.forward2.m; sourceTree = "<group>"; };
+		185289B71613A1060016729B /* config.initialize.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = config.initialize.m; sourceTree = "<group>"; };
+		185289B81613A1060016729B /* config.joinable.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = config.joinable.m; sourceTree = "<group>"; };
+		185289B91613A1060016729B /* config.kvmopen.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = config.kvmopen.c; sourceTree = "<group>"; };
+		185289BA1613A1060016729B /* config.loadtest.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = config.loadtest.m; sourceTree = "<group>"; };
+		185289BB1613A1060016729B /* config.nested.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = config.nested.c; sourceTree = "<group>"; };
+		185289BC1613A1060016729B /* config.nextcc.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = config.nextcc.h; sourceTree = "<group>"; };
+		185289BD1613A1060016729B /* config.nextrt.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = config.nextrt.m; sourceTree = "<group>"; };
+		185289BE1613A1060016729B /* config.non-fragile-ivars.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = "config.non-fragile-ivars.m"; sourceTree = "<group>"; };
+		185289BF1613A1060016729B /* config.objc.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = config.objc.m; sourceTree = "<group>"; };
+		185289C01613A1060016729B /* config.poll-dev.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = "config.poll-dev.c"; sourceTree = "<group>"; };
+		185289C11613A1060016729B /* config.poll.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = config.poll.c; sourceTree = "<group>"; };
+		185289C21613A1060016729B /* config.printf.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = config.printf.c; sourceTree = "<group>"; };
+		185289C31613A1060016729B /* config.proccmd.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = config.proccmd.c; sourceTree = "<group>"; };
+		185289C41613A1060016729B /* config.psinfo.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = config.psinfo.c; sourceTree = "<group>"; };
+		185289C51613A1060016729B /* config.retframe.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = config.retframe.c; sourceTree = "<group>"; };
+		185289C61613A1060016729B /* config.reuseaddr.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = config.reuseaddr.c; sourceTree = "<group>"; };
+		185289C71613A1060016729B /* config.setUncaughtExceptionHandler.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = config.setUncaughtExceptionHandler.m; sourceTree = "<group>"; };
+		185289C81613A1060016729B /* config.set_unexpected.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = config.set_unexpected.m; sourceTree = "<group>"; };
+		185289C91613A1060016729B /* config.trampoline.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = config.trampoline.c; sourceTree = "<group>"; };
+		185289CA1613A1060016729B /* config.unexpected.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = config.unexpected.m; sourceTree = "<group>"; };
+		185289CB1613A1060016729B /* config.vasprintf.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = config.vasprintf.c; sourceTree = "<group>"; };
+		185289CC1613A1060016729B /* config.vsprintf.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = config.vsprintf.c; sourceTree = "<group>"; };
+		185289CD1613A1060016729B /* config.wprintf.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = config.wprintf.c; sourceTree = "<group>"; };
+		185289CE1613A1060016729B /* icu.m4 */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; path = icu.m4; sourceTree = "<group>"; };
+		185289CF1613A1060016729B /* objc-common.g */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; path = "objc-common.g"; sourceTree = "<group>"; };
+		185289D01613A1060016729B /* objc-con-autoload.m4 */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; path = "objc-con-autoload.m4"; sourceTree = "<group>"; };
+		185289D11613A1060016729B /* objc-sys-dynamic.m4 */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; path = "objc-sys-dynamic.m4"; sourceTree = "<group>"; };
+		185289D21613A1060016729B /* pathtls.m4 */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; path = pathtls.m4; sourceTree = "<group>"; };
+		185289D31613A1060016729B /* pathxml.m4 */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; path = pathxml.m4; sourceTree = "<group>"; };
+		185289D41613A1060016729B /* procfs-exe-link.m4 */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; path = "procfs-exe-link.m4"; sourceTree = "<group>"; };
+		185289D51613A1060016729B /* procfs.m4 */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; path = procfs.m4; sourceTree = "<group>"; };
+		1857833F17551CC200CB7160 /* TestInfo */ = {isa = PBXFileReference; lastKnownFileType = text; path = TestInfo; sourceTree = "<group>"; };
+		1857834017551CC200CB7160 /* basic.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = basic.m; sourceTree = "<group>"; };
+		1857834117551CC200CB7160 /* general.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = general.m; sourceTree = "<group>"; };
+		18578359175525A400CB7160 /* NSArray.1.32bit */ = {isa = PBXFileReference; lastKnownFileType = file; path = NSArray.1.32bit; sourceTree = "<group>"; };
+		1857835A175525A400CB7160 /* NSArray.1.64bit */ = {isa = PBXFileReference; lastKnownFileType = file; path = NSArray.1.64bit; sourceTree = "<group>"; };
+		1857835B175525A400CB7160 /* NSAttributedString.0.32bit */ = {isa = PBXFileReference; lastKnownFileType = file; path = NSAttributedString.0.32bit; sourceTree = "<group>"; };
+		1857835C175525A400CB7160 /* NSAttributedString.0.64bit */ = {isa = PBXFileReference; lastKnownFileType = file; path = NSAttributedString.0.64bit; sourceTree = "<group>"; };
+		1857835D175525A400CB7160 /* NSCharacterSet.0.32bit */ = {isa = PBXFileReference; lastKnownFileType = file; path = NSCharacterSet.0.32bit; sourceTree = "<group>"; };
+		1857835E175525A400CB7160 /* NSCharacterSet.0.64bit */ = {isa = PBXFileReference; lastKnownFileType = file; path = NSCharacterSet.0.64bit; sourceTree = "<group>"; };
+		1857835F175525A400CB7160 /* NSData.0.32bit */ = {isa = PBXFileReference; lastKnownFileType = file; path = NSData.0.32bit; sourceTree = "<group>"; };
+		18578360175525A400CB7160 /* NSData.0.64bit */ = {isa = PBXFileReference; lastKnownFileType = file; path = NSData.0.64bit; sourceTree = "<group>"; };
+		18578361175525A400CB7160 /* NSDate.1.32bit */ = {isa = PBXFileReference; lastKnownFileType = file; path = NSDate.1.32bit; sourceTree = "<group>"; };
+		18578362175525A400CB7160 /* NSDate.1.64bit */ = {isa = PBXFileReference; lastKnownFileType = file; path = NSDate.1.64bit; sourceTree = "<group>"; };
+		18578363175525A400CB7160 /* NSDateFormatter.0.32bit */ = {isa = PBXFileReference; lastKnownFileType = file; path = NSDateFormatter.0.32bit; sourceTree = "<group>"; };
+		18578364175525A400CB7160 /* NSDateFormatter.0.64bit */ = {isa = PBXFileReference; lastKnownFileType = file; path = NSDateFormatter.0.64bit; sourceTree = "<group>"; };
+		18578365175525A400CB7160 /* NSDictionary.0.32bit */ = {isa = PBXFileReference; lastKnownFileType = file; path = NSDictionary.0.32bit; sourceTree = "<group>"; };
+		18578366175525A400CB7160 /* NSDictionary.0.64bit */ = {isa = PBXFileReference; lastKnownFileType = file; path = NSDictionary.0.64bit; sourceTree = "<group>"; };
+		18578367175525A400CB7160 /* NSException.0.32bit */ = {isa = PBXFileReference; lastKnownFileType = file; path = NSException.0.32bit; sourceTree = "<group>"; };
+		18578368175525A400CB7160 /* NSException.0.64bit */ = {isa = PBXFileReference; lastKnownFileType = file; path = NSException.0.64bit; sourceTree = "<group>"; };
+		18578369175525A400CB7160 /* NSMutableData.0.32bit */ = {isa = PBXFileReference; lastKnownFileType = file; path = NSMutableData.0.32bit; sourceTree = "<group>"; };
+		1857836A175525A400CB7160 /* NSMutableData.0.64bit */ = {isa = PBXFileReference; lastKnownFileType = file; path = NSMutableData.0.64bit; sourceTree = "<group>"; };
+		1857836B175525A400CB7160 /* NSNotification.0.32bit */ = {isa = PBXFileReference; lastKnownFileType = file; path = NSNotification.0.32bit; sourceTree = "<group>"; };
+		1857836C175525A400CB7160 /* NSNotification.0.64bit */ = {isa = PBXFileReference; lastKnownFileType = file; path = NSNotification.0.64bit; sourceTree = "<group>"; };
+		1857836D175525A400CB7160 /* NSNull.0.32bit */ = {isa = PBXFileReference; lastKnownFileType = file; path = NSNull.0.32bit; sourceTree = "<group>"; };
+		1857836E175525A500CB7160 /* NSNull.0.64bit */ = {isa = PBXFileReference; lastKnownFileType = file; path = NSNull.0.64bit; sourceTree = "<group>"; };
+		1857836F175525A500CB7160 /* NSNumber.0.32bit */ = {isa = PBXFileReference; lastKnownFileType = file; path = NSNumber.0.32bit; sourceTree = "<group>"; };
+		18578370175525A500CB7160 /* NSNumber.0.64bit */ = {isa = PBXFileReference; lastKnownFileType = file; path = NSNumber.0.64bit; sourceTree = "<group>"; };
+		18578371175525A500CB7160 /* NSObject.0.32bit */ = {isa = PBXFileReference; lastKnownFileType = file; path = NSObject.0.32bit; sourceTree = "<group>"; };
+		18578372175525A500CB7160 /* NSObject.0.64bit */ = {isa = PBXFileReference; lastKnownFileType = file; path = NSObject.0.64bit; sourceTree = "<group>"; };
+		18578373175525A500CB7160 /* NSSet.0.32bit */ = {isa = PBXFileReference; lastKnownFileType = file; path = NSSet.0.32bit; sourceTree = "<group>"; };
+		18578374175525A500CB7160 /* NSSet.0.64bit */ = {isa = PBXFileReference; lastKnownFileType = file; path = NSSet.0.64bit; sourceTree = "<group>"; };
+		18578375175525A500CB7160 /* NSString.1.32bit */ = {isa = PBXFileReference; lastKnownFileType = file; path = NSString.1.32bit; sourceTree = "<group>"; };
+		18578376175525A500CB7160 /* NSString.1.64bit */ = {isa = PBXFileReference; lastKnownFileType = file; path = NSString.1.64bit; sourceTree = "<group>"; };
+		18578377175525A500CB7160 /* NSTableView.3.32bit */ = {isa = PBXFileReference; lastKnownFileType = file; path = NSTableView.3.32bit; sourceTree = "<group>"; };
+		18578378175525A500CB7160 /* NSURL.0.32bit */ = {isa = PBXFileReference; lastKnownFileType = file; path = NSURL.0.32bit; sourceTree = "<group>"; };
+		18578379175525A500CB7160 /* NSURL.0.64bit */ = {isa = PBXFileReference; lastKnownFileType = file; path = NSURL.0.64bit; sourceTree = "<group>"; };
+		1857837A175525A500CB7160 /* NSValue.3.32bit */ = {isa = PBXFileReference; lastKnownFileType = file; path = NSValue.3.32bit; sourceTree = "<group>"; };
+		1857837B175525A500CB7160 /* NSValue.3.64bit */ = {isa = PBXFileReference; lastKnownFileType = file; path = NSValue.3.64bit; sourceTree = "<group>"; };
+		18641D0E1678AD04003C6E11 /* GSSocks4Parser.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = GSSocks4Parser.h; sourceTree = "<group>"; };
+		18641D0F1678AD04003C6E11 /* GSSocks4Parser.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = GSSocks4Parser.m; sourceTree = "<group>"; };
+		18641D101678AD04003C6E11 /* GSSocks5Parser.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = GSSocks5Parser.h; sourceTree = "<group>"; };
+		18641D111678AD04003C6E11 /* GSSocks5Parser.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = GSSocks5Parser.m; sourceTree = "<group>"; };
+		18641D121678AD04003C6E11 /* GSSocksParser.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = GSSocksParser.h; sourceTree = "<group>"; };
+		18641D131678AD04003C6E11 /* GSSocksParser.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = GSSocksParser.m; sourceTree = "<group>"; };
+		18641D141678AD04003C6E11 /* GSSocksParserPrivate.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = GSSocksParserPrivate.h; sourceTree = "<group>"; };
+		18641D151678AD04003C6E11 /* GSSocksParserPrivate.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = GSSocksParserPrivate.m; sourceTree = "<group>"; };
+		18906E621610BEC80003C892 /* README */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; path = README; sourceTree = SOURCE_ROOT; };
+		18906E681610BF3C0003C892 /* Foundation.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Foundation.h; sourceTree = "<group>"; };
+		18906E691610BF3C0003C892 /* FoundationErrors.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = FoundationErrors.h; sourceTree = "<group>"; };
+		18906E6A1610BF3C0003C892 /* NSAffineTransform.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSAffineTransform.h; sourceTree = "<group>"; };
+		18906E6B1610BF3C0003C892 /* NSArchiver.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSArchiver.h; sourceTree = "<group>"; };
+		18906E6C1610BF3C0003C892 /* NSArray.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSArray.h; sourceTree = "<group>"; };
+		18906E6D1610BF3C0003C892 /* NSAttributedString.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSAttributedString.h; sourceTree = "<group>"; };
+		18906E6E1610BF3C0003C892 /* NSAutoreleasePool.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSAutoreleasePool.h; sourceTree = "<group>"; };
+		18906E6F1610BF3C0003C892 /* NSBundle.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSBundle.h; sourceTree = "<group>"; };
+		18906E701610BF3C0003C892 /* NSByteOrder.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSByteOrder.h; sourceTree = "<group>"; };
+		18906E711610BF3C0003C892 /* NSCache.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSCache.h; sourceTree = "<group>"; };
+		18906E721610BF3C0003C892 /* NSCalendar.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSCalendar.h; sourceTree = "<group>"; };
+		18906E731610BF3C0003C892 /* NSCalendarDate.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSCalendarDate.h; sourceTree = "<group>"; };
+		18906E741610BF3C0003C892 /* NSCharacterSet.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSCharacterSet.h; sourceTree = "<group>"; };
+		18906E751610BF3C0003C892 /* NSClassDescription.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSClassDescription.h; sourceTree = "<group>"; };
+		18906E761610BF3C0003C892 /* NSCoder.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSCoder.h; sourceTree = "<group>"; };
+		18906E771610BF3C0003C892 /* NSComparisonPredicate.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSComparisonPredicate.h; sourceTree = "<group>"; };
+		18906E781610BF3C0003C892 /* NSCompoundPredicate.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSCompoundPredicate.h; sourceTree = "<group>"; };
+		18906E791610BF3C0003C892 /* NSConnection.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSConnection.h; sourceTree = "<group>"; };
+		18906E7A1610BF3C0003C892 /* NSData.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSData.h; sourceTree = "<group>"; };
+		18906E7B1610BF3C0003C892 /* NSDate.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSDate.h; sourceTree = "<group>"; };
+		18906E7C1610BF3C0003C892 /* NSDateFormatter.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSDateFormatter.h; sourceTree = "<group>"; };
+		18906E7D1610BF3C0003C892 /* NSDebug.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSDebug.h; sourceTree = "<group>"; };
+		18906E7E1610BF3C0003C892 /* NSDecimal.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSDecimal.h; sourceTree = "<group>"; };
+		18906E7F1610BF3C0003C892 /* NSDecimalNumber.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSDecimalNumber.h; sourceTree = "<group>"; };
+		18906E801610BF3C0003C892 /* NSDictionary.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSDictionary.h; sourceTree = "<group>"; };
+		18906E811610BF3C0003C892 /* NSDistantObject.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSDistantObject.h; sourceTree = "<group>"; };
+		18906E821610BF3C0003C892 /* NSDistributedLock.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSDistributedLock.h; sourceTree = "<group>"; };
+		18906E831610BF3C0003C892 /* NSDistributedNotificationCenter.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSDistributedNotificationCenter.h; sourceTree = "<group>"; };
+		18906E841610BF3C0003C892 /* NSEnumerator.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSEnumerator.h; sourceTree = "<group>"; };
+		18906E851610BF3C0003C892 /* NSError.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSError.h; sourceTree = "<group>"; };
+		18906E861610BF3C0003C892 /* NSErrorRecoveryAttempting.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSErrorRecoveryAttempting.h; sourceTree = "<group>"; };
+		18906E871610BF3C0003C892 /* NSException.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSException.h; sourceTree = "<group>"; };
+		18906E881610BF3C0003C892 /* NSExpression.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSExpression.h; sourceTree = "<group>"; };
+		18906E891610BF3C0003C892 /* NSFileHandle.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSFileHandle.h; sourceTree = "<group>"; };
+		18906E8A1610BF3C0003C892 /* NSFileManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSFileManager.h; sourceTree = "<group>"; };
+		18906E8B1610BF3C0003C892 /* NSFormatter.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSFormatter.h; sourceTree = "<group>"; };
+		18906E8C1610BF3C0003C892 /* NSGarbageCollector.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSGarbageCollector.h; sourceTree = "<group>"; };
+		18906E8D1610BF3C0003C892 /* NSGeometry.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSGeometry.h; sourceTree = "<group>"; };
+		18906E8E1610BF3C0003C892 /* NSHTTPCookie.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSHTTPCookie.h; sourceTree = "<group>"; };
+		18906E8F1610BF3C0003C892 /* NSHTTPCookieStorage.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSHTTPCookieStorage.h; sourceTree = "<group>"; };
+		18906E901610BF3C0003C892 /* NSHashTable.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSHashTable.h; sourceTree = "<group>"; };
+		18906E911610BF3C0003C892 /* NSHost.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSHost.h; sourceTree = "<group>"; };
+		18906E921610BF3C0003C892 /* NSIndexPath.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSIndexPath.h; sourceTree = "<group>"; };
+		18906E931610BF3C0003C892 /* NSIndexSet.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSIndexSet.h; sourceTree = "<group>"; };
+		18906E941610BF3C0003C892 /* NSInvocation.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSInvocation.h; sourceTree = "<group>"; };
+		18906E951610BF3C0003C892 /* NSJSONSerialization.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSJSONSerialization.h; sourceTree = "<group>"; };
+		18906E961610BF3C0003C892 /* NSKeyValueCoding.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSKeyValueCoding.h; sourceTree = "<group>"; };
+		18906E971610BF3C0003C892 /* NSKeyValueObserving.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSKeyValueObserving.h; sourceTree = "<group>"; };
+		18906E981610BF3C0003C892 /* NSKeyedArchiver.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSKeyedArchiver.h; sourceTree = "<group>"; };
+		18906E991610BF3C0003C892 /* NSLocale.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSLocale.h; sourceTree = "<group>"; };
+		18906E9A1610BF3C0003C892 /* NSLock.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSLock.h; sourceTree = "<group>"; };
+		18906E9B1610BF3C0003C892 /* NSMapTable.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSMapTable.h; sourceTree = "<group>"; };
+		18906E9C1610BF3C0003C892 /* NSMethodSignature.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSMethodSignature.h; sourceTree = "<group>"; };
+		18906E9D1610BF3C0003C892 /* NSNetServices.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSNetServices.h; sourceTree = "<group>"; };
+		18906E9E1610BF3C0003C892 /* NSNotification.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSNotification.h; sourceTree = "<group>"; };
+		18906E9F1610BF3C0003C892 /* NSNotificationQueue.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSNotificationQueue.h; sourceTree = "<group>"; };
+		18906EA01610BF3C0003C892 /* NSNull.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSNull.h; sourceTree = "<group>"; };
+		18906EA11610BF3C0003C892 /* NSNumberFormatter.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSNumberFormatter.h; sourceTree = "<group>"; };
+		18906EA21610BF3C0003C892 /* NSObjCRuntime.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSObjCRuntime.h; sourceTree = "<group>"; };
+		18906EA31610BF3C0003C892 /* NSObject.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSObject.h; sourceTree = "<group>"; };
+		18906EA41610BF3C0003C892 /* NSOperation.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSOperation.h; sourceTree = "<group>"; };
+		18906EA51610BF3C0003C892 /* NSPathUtilities.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSPathUtilities.h; sourceTree = "<group>"; };
+		18906EA61610BF3C0003C892 /* NSPointerArray.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSPointerArray.h; sourceTree = "<group>"; };
+		18906EA71610BF3C0003C892 /* NSPointerFunctions.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSPointerFunctions.h; sourceTree = "<group>"; };
+		18906EA81610BF3C0003C892 /* NSPort.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSPort.h; sourceTree = "<group>"; };
+		18906EA91610BF3C0003C892 /* NSPortCoder.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSPortCoder.h; sourceTree = "<group>"; };
+		18906EAA1610BF3C0003C892 /* NSPortMessage.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSPortMessage.h; sourceTree = "<group>"; };
+		18906EAB1610BF3C0003C892 /* NSPortNameServer.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSPortNameServer.h; sourceTree = "<group>"; };
+		18906EAC1610BF3C0003C892 /* NSPredicate.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSPredicate.h; sourceTree = "<group>"; };
+		18906EAD1610BF3C0003C892 /* NSProcessInfo.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSProcessInfo.h; sourceTree = "<group>"; };
+		18906EAE1610BF3C0003C892 /* NSPropertyList.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSPropertyList.h; sourceTree = "<group>"; };
+		18906EAF1610BF3C0003C892 /* NSProtocolChecker.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSProtocolChecker.h; sourceTree = "<group>"; };
+		18906EB01610BF3C0003C892 /* NSProxy.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSProxy.h; sourceTree = "<group>"; };
+		18906EB11610BF3C0003C892 /* NSRange.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSRange.h; sourceTree = "<group>"; };
+		18906EB21610BF3C0003C892 /* NSRegularExpression.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSRegularExpression.h; sourceTree = "<group>"; };
+		18906EB31610BF3C0003C892 /* NSRunLoop.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSRunLoop.h; sourceTree = "<group>"; };
+		18906EB41610BF3C0003C892 /* NSScanner.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSScanner.h; sourceTree = "<group>"; };
+		18906EB51610BF3C0003C892 /* NSScriptWhoseTests.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSScriptWhoseTests.h; sourceTree = "<group>"; };
+		18906EB61610BF3C0003C892 /* NSSerialization.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSSerialization.h; sourceTree = "<group>"; };
+		18906EB71610BF3C0003C892 /* NSSet.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSSet.h; sourceTree = "<group>"; };
+		18906EB81610BF3C0003C892 /* NSSortDescriptor.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSSortDescriptor.h; sourceTree = "<group>"; };
+		18906EB91610BF3C0003C892 /* NSSpellServer.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSSpellServer.h; sourceTree = "<group>"; };
+		18906EBA1610BF3C0003C892 /* NSStream.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSStream.h; sourceTree = "<group>"; };
+		18906EBB1610BF3C0003C892 /* NSString.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSString.h; sourceTree = "<group>"; };
+		18906EBC1610BF3C0003C892 /* NSTask.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSTask.h; sourceTree = "<group>"; };
+		18906EBD1610BF3C0003C892 /* NSTextCheckingResult.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSTextCheckingResult.h; sourceTree = "<group>"; };
+		18906EBE1610BF3C0003C892 /* NSThread.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSThread.h; sourceTree = "<group>"; };
+		18906EBF1610BF3C0003C892 /* NSTimeZone.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSTimeZone.h; sourceTree = "<group>"; };
+		18906EC01610BF3C0003C892 /* NSTimer.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSTimer.h; sourceTree = "<group>"; };
+		18906EC11610BF3C0003C892 /* NSURL.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSURL.h; sourceTree = "<group>"; };
+		18906EC21610BF3C0003C892 /* NSURLAuthenticationChallenge.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSURLAuthenticationChallenge.h; sourceTree = "<group>"; };
+		18906EC31610BF3C0003C892 /* NSURLCache.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSURLCache.h; sourceTree = "<group>"; };
+		18906EC41610BF3C0003C892 /* NSURLConnection.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSURLConnection.h; sourceTree = "<group>"; };
+		18906EC51610BF3C0003C892 /* NSURLCredential.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSURLCredential.h; sourceTree = "<group>"; };
+		18906EC61610BF3C0003C892 /* NSURLCredentialStorage.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSURLCredentialStorage.h; sourceTree = "<group>"; };
+		18906EC71610BF3C0003C892 /* NSURLDownload.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSURLDownload.h; sourceTree = "<group>"; };
+		18906EC81610BF3C0003C892 /* NSURLError.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSURLError.h; sourceTree = "<group>"; };
+		18906EC91610BF3C0003C892 /* NSURLHandle.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSURLHandle.h; sourceTree = "<group>"; };
+		18906ECA1610BF3C0003C892 /* NSURLProtectionSpace.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSURLProtectionSpace.h; sourceTree = "<group>"; };
+		18906ECB1610BF3C0003C892 /* NSURLProtocol.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSURLProtocol.h; sourceTree = "<group>"; };
+		18906ECC1610BF3C0003C892 /* NSURLRequest.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSURLRequest.h; sourceTree = "<group>"; };
+		18906ECD1610BF3C0003C892 /* NSURLResponse.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSURLResponse.h; sourceTree = "<group>"; };
+		18906ECE1610BF3C0003C892 /* NSUndoManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSUndoManager.h; sourceTree = "<group>"; };
+		18906ECF1610BF3C0003C892 /* NSUserDefaults.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSUserDefaults.h; sourceTree = "<group>"; };
+		18906ED01610BF3C0003C892 /* NSUtilities.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSUtilities.h; sourceTree = "<group>"; };
+		18906ED11610BF3C0003C892 /* NSValue.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSValue.h; sourceTree = "<group>"; };
+		18906ED21610BF3C0003C892 /* NSValueTransformer.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSValueTransformer.h; sourceTree = "<group>"; };
+		18906ED31610BF3C0003C892 /* NSXMLDTD.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSXMLDTD.h; sourceTree = "<group>"; };
+		18906ED41610BF3C0003C892 /* NSXMLDTDNode.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSXMLDTDNode.h; sourceTree = "<group>"; };
+		18906ED51610BF3C0003C892 /* NSXMLDocument.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSXMLDocument.h; sourceTree = "<group>"; };
+		18906ED61610BF3C0003C892 /* NSXMLElement.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSXMLElement.h; sourceTree = "<group>"; };
+		18906ED71610BF3C0003C892 /* NSXMLNode.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSXMLNode.h; sourceTree = "<group>"; };
+		18906ED81610BF3C0003C892 /* NSXMLNodeOptions.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSXMLNodeOptions.h; sourceTree = "<group>"; };
+		18906ED91610BF3C0003C892 /* NSXMLParser.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSXMLParser.h; sourceTree = "<group>"; };
+		18906EDA1610BF3C0003C892 /* NSZone.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSZone.h; sourceTree = "<group>"; };
+		18906EDC1610BF3C0003C892 /* .cvsignore */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; path = .cvsignore; sourceTree = "<group>"; };
+		18906EDD1610BF3C0003C892 /* Additions.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Additions.h; sourceTree = "<group>"; };
+		18906EDE1610BF3C0003C892 /* CXXException.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = CXXException.h; sourceTree = "<group>"; };
+		18906EDF1610BF3C0003C892 /* DistributedObjects.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = DistributedObjects.h; sourceTree = "<group>"; };
+		18906EE01610BF3C0003C892 /* GCObject.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = GCObject.h; sourceTree = "<group>"; };
+		18906EE11610BF3C0003C892 /* GNUstep.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = GNUstep.h; sourceTree = "<group>"; };
+		18906EE21610BF3C0003C892 /* GSBlocks.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = GSBlocks.h; sourceTree = "<group>"; };
+		18906EE31610BF3C0003C892 /* GSConfig.h.in */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; path = GSConfig.h.in; sourceTree = "<group>"; };
+		18906EE41610BF3C0003C892 /* GSFunctions.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = GSFunctions.h; sourceTree = "<group>"; };
+		18906EE51610BF3C0003C892 /* GSIArray.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = GSIArray.h; sourceTree = "<group>"; };
+		18906EE61610BF3C0003C892 /* GSIMap.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = GSIMap.h; sourceTree = "<group>"; };
+		18906EE71610BF3C0003C892 /* GSLocale.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = GSLocale.h; sourceTree = "<group>"; };
+		18906EE81610BF3C0003C892 /* GSLock.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = GSLock.h; sourceTree = "<group>"; };
+		18906EE91610BF3C0003C892 /* GSMime.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = GSMime.h; sourceTree = "<group>"; };
+		18906EEA1610BF3C0003C892 /* GSObjCRuntime.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = GSObjCRuntime.h; sourceTree = "<group>"; };
+		18906EEB1610BF3C0003C892 /* GSUnion.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = GSUnion.h; sourceTree = "<group>"; };
+		18906EEC1610BF3C0003C892 /* GSVersionMacros.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = GSVersionMacros.h; sourceTree = "<group>"; };
+		18906EED1610BF3C0003C892 /* GSXML.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = GSXML.h; sourceTree = "<group>"; };
+		18906EEE1610BF3C0003C892 /* NSArray+GNUstepBase.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = "NSArray+GNUstepBase.h"; path = "../GNUstepBase/NSArray+GNUstepBase.h"; sourceTree = "<group>"; };
+		18906EEF1610BF3C0003C892 /* NSAttributedString+GNUstepBase.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = "NSAttributedString+GNUstepBase.h"; path = "../GNUstepBase/NSAttributedString+GNUstepBase.h"; sourceTree = "<group>"; };
+		18906EF01610BF3C0003C892 /* NSBundle+GNUstepBase.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = "NSBundle+GNUstepBase.h"; path = "../GNUstepBase/NSBundle+GNUstepBase.h"; sourceTree = "<group>"; };
+		18906EF11610BF3C0003C892 /* NSCalendarDate+GNUstepBase.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = "NSCalendarDate+GNUstepBase.h"; path = "../GNUstepBase/NSCalendarDate+GNUstepBase.h"; sourceTree = "<group>"; };
+		18906EF21610BF3C0003C892 /* NSData+GNUstepBase.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = "NSData+GNUstepBase.h"; path = "../GNUstepBase/NSData+GNUstepBase.h"; sourceTree = "<group>"; };
+		18906EF31610BF3C0003C892 /* NSDebug+GNUstepBase.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = "NSDebug+GNUstepBase.h"; path = "../GNUstepBase/NSDebug+GNUstepBase.h"; sourceTree = "<group>"; };
+		18906EF41610BF3C0003C892 /* NSFileHandle+GNUstepBase.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = "NSFileHandle+GNUstepBase.h"; path = "../GNUstepBase/NSFileHandle+GNUstepBase.h"; sourceTree = "<group>"; };
+		18906EF51610BF3C0003C892 /* NSLock+GNUstepBase.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = "NSLock+GNUstepBase.h"; path = "../GNUstepBase/NSLock+GNUstepBase.h"; sourceTree = "<group>"; };
+		18906EF61610BF3C0003C892 /* NSMutableString+GNUstepBase.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = "NSMutableString+GNUstepBase.h"; path = "../GNUstepBase/NSMutableString+GNUstepBase.h"; sourceTree = "<group>"; };
+		18906EF71610BF3C0003C892 /* NSNetServices+GNUstepBase.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = "NSNetServices+GNUstepBase.h"; path = "../GNUstepBase/NSNetServices+GNUstepBase.h"; sourceTree = "<group>"; };
+		18906EF81610BF3C0003C892 /* NSNumber+GNUstepBase.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = "NSNumber+GNUstepBase.h"; path = "../GNUstepBase/NSNumber+GNUstepBase.h"; sourceTree = "<group>"; };
+		18906EF91610BF3C0003C892 /* NSObject+GNUstepBase.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = "NSObject+GNUstepBase.h"; path = "../GNUstepBase/NSObject+GNUstepBase.h"; sourceTree = "<group>"; };
+		18906EFA1610BF3C0003C892 /* NSProcessInfo+GNUstepBase.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = "NSProcessInfo+GNUstepBase.h"; path = "../GNUstepBase/NSProcessInfo+GNUstepBase.h"; sourceTree = "<group>"; };
+		18906EFB1610BF3C0003C892 /* NSStream+GNUstepBase.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = "NSStream+GNUstepBase.h"; path = "../GNUstepBase/NSStream+GNUstepBase.h"; sourceTree = "<group>"; };
+		18906EFC1610BF3C0003C892 /* NSString+GNUstepBase.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = "NSString+GNUstepBase.h"; path = "../GNUstepBase/NSString+GNUstepBase.h"; sourceTree = "<group>"; };
+		18906EFD1610BF3C0003C892 /* NSTask+GNUstepBase.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = "NSTask+GNUstepBase.h"; path = "../GNUstepBase/NSTask+GNUstepBase.h"; sourceTree = "<group>"; };
+		18906EFE1610BF3C0003C892 /* NSThread+GNUstepBase.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = "NSThread+GNUstepBase.h"; path = "../GNUstepBase/NSThread+GNUstepBase.h"; sourceTree = "<group>"; };
+		18906EFF1610BF3C0003C892 /* NSURL+GNUstepBase.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = "NSURL+GNUstepBase.h"; path = "../GNUstepBase/NSURL+GNUstepBase.h"; sourceTree = "<group>"; };
+		18906F001610BF3C0003C892 /* Unicode.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Unicode.h; sourceTree = "<group>"; };
+		18906F011610BF3C0003C892 /* config.h.in */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; path = config.h.in; sourceTree = "<group>"; };
+		18906F091610BF3C0003C892 /* .cvsignore */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; path = .cvsignore; sourceTree = "<group>"; };
+		18906F0B1610BF3C0003C892 /* GCArray.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = GCArray.m; sourceTree = "<group>"; };
+		18906F0C1610BF3C0003C892 /* GCDictionary.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = GCDictionary.m; sourceTree = "<group>"; };
+		18906F0D1610BF3C0003C892 /* GCObject.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = GCObject.m; sourceTree = "<group>"; };
+		18906F0E1610BF3C0003C892 /* GNUmakefile */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; path = GNUmakefile; sourceTree = "<group>"; };
+		18906F0F1610BF3C0003C892 /* GSFunctions.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = GSFunctions.m; sourceTree = "<group>"; };
+		18906F101610BF3C0003C892 /* GSInsensitiveDictionary.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = GSInsensitiveDictionary.m; sourceTree = "<group>"; };
+		18906F111610BF3C0003C892 /* GSLock.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = GSLock.m; sourceTree = "<group>"; };
+		18906F121610BF3C0003C892 /* GSMime.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = GSMime.m; sourceTree = "<group>"; };
+		18906F131610BF3C0003C892 /* GSObjCRuntime.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = GSObjCRuntime.m; sourceTree = "<group>"; };
+		18906F141610BF3C0003C892 /* GSXML.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = GSXML.m; sourceTree = "<group>"; };
+		18906F151610BF3C0003C892 /* Makefile.postamble */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; path = Makefile.postamble; sourceTree = "<group>"; };
+		18906F161610BF3C0003C892 /* Makefile.preamble */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; path = Makefile.preamble; sourceTree = "<group>"; };
+		18906F171610BF3C0003C892 /* NSArray+GNUstepBase.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = "NSArray+GNUstepBase.m"; sourceTree = "<group>"; };
+		18906F181610BF3C0003C892 /* NSAttributedString+GNUstepBase.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = "NSAttributedString+GNUstepBase.m"; sourceTree = "<group>"; };
+		18906F191610BF3C0003C892 /* NSBundle+GNUstepBase.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = "NSBundle+GNUstepBase.m"; sourceTree = "<group>"; };
+		18906F1A1610BF3C0003C892 /* NSCalendarDate+GNUstepBase.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = "NSCalendarDate+GNUstepBase.m"; sourceTree = "<group>"; };
+		18906F1B1610BF3C0003C892 /* NSData+GNUstepBase.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = "NSData+GNUstepBase.m"; sourceTree = "<group>"; };
+		18906F1C1610BF3C0003C892 /* NSDebug+GNUstepBase.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = "NSDebug+GNUstepBase.m"; sourceTree = "<group>"; };
+		18906F1D1610BF3C0003C892 /* NSError+GNUstepBase.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = "NSError+GNUstepBase.m"; sourceTree = "<group>"; };
+		18906F1E1610BF3C0003C892 /* NSFileHandle+GNUstepBase.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = "NSFileHandle+GNUstepBase.m"; sourceTree = "<group>"; };
+		18906F1F1610BF3C0003C892 /* NSLock+GNUstepBase.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = "NSLock+GNUstepBase.m"; sourceTree = "<group>"; };
+		18906F201610BF3C0003C892 /* NSMutableString+GNUstepBase.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = "NSMutableString+GNUstepBase.m"; sourceTree = "<group>"; };
+		18906F211610BF3C0003C892 /* NSNumber+GNUstepBase.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = "NSNumber+GNUstepBase.m"; sourceTree = "<group>"; };
+		18906F221610BF3C0003C892 /* NSObject+GNUstepBase.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = "NSObject+GNUstepBase.m"; sourceTree = "<group>"; };
+		18906F231610BF3C0003C892 /* NSProcessInfo+GNUstepBase.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = "NSProcessInfo+GNUstepBase.m"; sourceTree = "<group>"; };
+		18906F241610BF3C0003C892 /* NSPropertyList+GNUstepBase.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = "NSPropertyList+GNUstepBase.m"; sourceTree = "<group>"; };
+		18906F251610BF3C0003C892 /* NSStream+GNUstepBase.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = "NSStream+GNUstepBase.m"; sourceTree = "<group>"; };
+		18906F261610BF3C0003C892 /* NSString+GNUstepBase.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = "NSString+GNUstepBase.m"; sourceTree = "<group>"; };
+		18906F271610BF3C0003C892 /* NSTask+GNUstepBase.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = "NSTask+GNUstepBase.m"; sourceTree = "<group>"; };
+		18906F281610BF3C0003C892 /* NSThread+GNUstepBase.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = "NSThread+GNUstepBase.m"; sourceTree = "<group>"; };
+		18906F291610BF3C0003C892 /* NSURL+GNUstepBase.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = "NSURL+GNUstepBase.m"; sourceTree = "<group>"; };
+		18906F2A1610BF3C0003C892 /* Unicode.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = Unicode.m; sourceTree = "<group>"; };
+		18906F2C1610BF3C0003C892 /* caseconv.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = caseconv.h; sourceTree = "<group>"; };
+		18906F2D1610BF3C0003C892 /* cop.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = cop.h; sourceTree = "<group>"; };
+		18906F2E1610BF3C0003C892 /* cyrillic.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = cyrillic.h; sourceTree = "<group>"; };
+		18906F2F1610BF3C0003C892 /* decomp.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = decomp.h; sourceTree = "<group>"; };
+		18906F301610BF3C0003C892 /* gsm0338.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = gsm0338.h; sourceTree = "<group>"; };
+		18906F311610BF3C0003C892 /* latin2.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = latin2.h; sourceTree = "<group>"; };
+		18906F321610BF3C0003C892 /* latin9.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = latin9.h; sourceTree = "<group>"; };
+		18906F331610BF3C0003C892 /* nextstep.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = nextstep.h; sourceTree = "<group>"; };
+		18906F341610BF3C0003C892 /* thai.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = thai.h; sourceTree = "<group>"; };
+		18906F351610BF3C0003C892 /* CXXException.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = CXXException.m; sourceTree = "<group>"; };
+		18906F361610BF3C0003C892 /* CompatibilityHeaders.make */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; path = CompatibilityHeaders.make; sourceTree = "<group>"; };
+		18906F371610BF3C0003C892 /* DocMakefile */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; path = DocMakefile; sourceTree = "<group>"; };
+		18906F381610BF3C0003C892 /* GNUmakefile */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; path = GNUmakefile; sourceTree = "<group>"; };
+		18906F391610BF3C0003C892 /* GSArray.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = GSArray.m; sourceTree = "<group>"; };
+		18906F3A1610BF3C0003C892 /* GSAttributedString.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = GSAttributedString.m; sourceTree = "<group>"; };
+		18906F3B1610BF3C0003C892 /* GSAvahiClient.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = GSAvahiClient.h; path = Source/GSAvahiClient.h; sourceTree = "<group>"; };
+		18906F3C1610BF3C0003C892 /* GSAvahiClient.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = GSAvahiClient.m; sourceTree = "<group>"; };
+		18906F3D1610BF3C0003C892 /* GSAvahiNetService.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = GSAvahiNetService.m; sourceTree = "<group>"; };
+		18906F3E1610BF3C0003C892 /* GSAvahiNetServiceBrowser.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = GSAvahiNetServiceBrowser.m; sourceTree = "<group>"; };
+		18906F3F1610BF3C0003C892 /* GSAvahiRunLoopIntegration.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = GSAvahiRunLoopIntegration.h; path = Source/GSAvahiRunLoopIntegration.h; sourceTree = "<group>"; };
+		18906F401610BF3C0003C892 /* GSAvahiRunLoopIntegration.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = GSAvahiRunLoopIntegration.m; sourceTree = "<group>"; };
+		18906F411610BF3C0003C892 /* GSBlocks.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = GSBlocks.m; sourceTree = "<group>"; };
+		18906F421610BF3C0003C892 /* GSConcreteValue.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = GSConcreteValue.m; sourceTree = "<group>"; };
+		18906F431610BF3C0003C892 /* GSConcreteValueTemplate.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = GSConcreteValueTemplate.m; sourceTree = "<group>"; };
+		18906F441610BF3C0003C892 /* GSCountedSet.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = GSCountedSet.m; sourceTree = "<group>"; };
+		18906F451610BF3C0003C892 /* GSDictionary.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = GSDictionary.m; sourceTree = "<group>"; };
+		18906F461610BF3C0003C892 /* GSDispatch.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = GSDispatch.h; path = Source/GSDispatch.h; sourceTree = "<group>"; };
+		18906F471610BF3C0003C892 /* GSFFCallInvocation.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = GSFFCallInvocation.m; sourceTree = "<group>"; };
+		18906F481610BF3C0003C892 /* GSFFIInvocation.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = GSFFIInvocation.m; sourceTree = "<group>"; };
+		18906F491610BF3C0003C892 /* GSFTPURLHandle.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = GSFTPURLHandle.m; sourceTree = "<group>"; };
+		18906F4A1610BF3C0003C892 /* GSFastEnumeration.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = GSFastEnumeration.h; path = Source/GSFastEnumeration.h; sourceTree = "<group>"; };
+		18906F4B1610BF3C0003C892 /* GSFileHandle.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = GSFileHandle.h; path = Source/GSFileHandle.h; sourceTree = "<group>"; };
+		18906F4C1610BF3C0003C892 /* GSFileHandle.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = GSFileHandle.m; sourceTree = "<group>"; };
+		18906F4D1610BF3C0003C892 /* GSFormat.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = GSFormat.m; sourceTree = "<group>"; };
+		18906F4E1610BF3C0003C892 /* GSHTTPAuthentication.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = GSHTTPAuthentication.m; sourceTree = "<group>"; };
+		18906F4F1610BF3C0003C892 /* GSHTTPURLHandle.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = GSHTTPURLHandle.m; sourceTree = "<group>"; };
+		18906F501610BF3C0003C892 /* GSICUString.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = GSICUString.h; path = Source/GSICUString.h; sourceTree = "<group>"; };
+		18906F511610BF3C0003C892 /* GSICUString.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = GSICUString.m; sourceTree = "<group>"; };
+		18906F521610BF3C0003C892 /* GSInternal.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = GSInternal.h; path = Source/GSInternal.h; sourceTree = "<group>"; };
+		18906F531610BF3C0003C892 /* GSInvocation.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = GSInvocation.h; path = Source/GSInvocation.h; sourceTree = "<group>"; };
+		18906F541610BF3C0003C892 /* GSLocale.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = GSLocale.m; sourceTree = "<group>"; };
+		18906F551610BF3C0003C892 /* GSMDNSNetServices.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = GSMDNSNetServices.m; sourceTree = "<group>"; };
+		18906F561610BF3C0003C892 /* GSNetServices.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = GSNetServices.h; path = Source/GSNetServices.h; sourceTree = "<group>"; };
+		18906F571610BF3C0003C892 /* GSNetwork.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = GSNetwork.h; path = Source/GSNetwork.h; sourceTree = "<group>"; };
+		18906F581610BF3C0003C892 /* GSNumberTypes.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = GSNumberTypes.h; path = Source/GSNumberTypes.h; sourceTree = "<group>"; };
+		18906F591610BF3C0003C892 /* GSPThread.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = GSPThread.h; path = Source/GSPThread.h; sourceTree = "<group>"; };
+		18906F5A1610BF3C0003C892 /* GSPortPrivate.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = GSPortPrivate.h; path = Source/GSPortPrivate.h; sourceTree = "<group>"; };
+		18906F5B1610BF3C0003C892 /* GSPrivate.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = GSPrivate.h; path = Source/GSPrivate.h; sourceTree = "<group>"; };
+		18906F5C1610BF3C0003C892 /* GSQuickSort.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = GSQuickSort.m; sourceTree = "<group>"; };
+		18906F5D1610BF3C0003C892 /* GSRunLoopCtxt.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = GSRunLoopCtxt.h; path = Source/GSRunLoopCtxt.h; sourceTree = "<group>"; };
+		18906F5E1610BF3C0003C892 /* GSRunLoopWatcher.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = GSRunLoopWatcher.h; path = Source/GSRunLoopWatcher.h; sourceTree = "<group>"; };
+		18906F5F1610BF3C0003C892 /* GSRunLoopWatcher.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = GSRunLoopWatcher.m; sourceTree = "<group>"; };
+		18906F601610BF3C0003C892 /* GSSet.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = GSSet.m; sourceTree = "<group>"; };
+		18906F611610BF3C0003C892 /* GSShellSort.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = GSShellSort.m; sourceTree = "<group>"; };
+		18906F621610BF3C0003C892 /* GSSocketStream.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = GSSocketStream.h; path = Source/GSSocketStream.h; sourceTree = "<group>"; };
+		18906F631610BF3C0003C892 /* GSSocketStream.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = GSSocketStream.m; sourceTree = "<group>"; };
+		18906F641610BF3C0003C892 /* GSSorting.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = GSSorting.h; path = Source/GSSorting.h; sourceTree = "<group>"; };
+		18906F651610BF3C0003C892 /* GSStream.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = GSStream.h; path = Source/GSStream.h; sourceTree = "<group>"; };
+		18906F661610BF3C0003C892 /* GSStream.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = GSStream.m; sourceTree = "<group>"; };
+		18906F671610BF3C0003C892 /* GSString.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = GSString.m; sourceTree = "<group>"; };
+		18906F681610BF3C0003C892 /* GSTLS.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = GSTLS.h; path = Source/GSTLS.h; sourceTree = "<group>"; };
+		18906F691610BF3C0003C892 /* GSTLS.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = GSTLS.m; sourceTree = "<group>"; };
+		18906F6A1610BF3C0003C892 /* GSTimSort.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = GSTimSort.m; sourceTree = "<group>"; };
+		18906F6B1610BF3C0003C892 /* GSURLPrivate.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = GSURLPrivate.h; path = Source/GSURLPrivate.h; sourceTree = "<group>"; };
+		18906F6C1610BF3C0003C892 /* GSValue.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = GSValue.m; sourceTree = "<group>"; };
+		18906F6D1610BF3C0003C892 /* GSeq.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = GSeq.h; path = Source/GSeq.h; sourceTree = "<group>"; };
+		18906F6E1610BF3C0003C892 /* Makefile.postamble */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; path = Makefile.postamble; sourceTree = "<group>"; };
+		18906F6F1610BF3C0003C892 /* Makefile.preamble */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; path = Makefile.preamble; sourceTree = "<group>"; };
+		18906F701610BF3C0003C892 /* NSAffineTransform.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSAffineTransform.m; sourceTree = "<group>"; };
+		18906F711610BF3C0003C892 /* NSArchiver.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSArchiver.m; sourceTree = "<group>"; };
+		18906F721610BF3C0003C892 /* NSArray.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSArray.m; sourceTree = "<group>"; };
+		18906F731610BF3C0003C892 /* NSAssertionHandler.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSAssertionHandler.m; sourceTree = "<group>"; };
+		18906F741610BF3C0003C892 /* NSAttributedString.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSAttributedString.m; sourceTree = "<group>"; };
+		18906F751610BF3C0003C892 /* NSAutoreleasePool.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSAutoreleasePool.m; sourceTree = "<group>"; };
+		18906F761610BF3C0003C892 /* NSBundle.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSBundle.m; sourceTree = "<group>"; };
+		18906F771610BF3C0003C892 /* NSCache.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSCache.m; sourceTree = "<group>"; };
+		18906F781610BF3C0003C892 /* NSCachedURLResponse.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSCachedURLResponse.m; sourceTree = "<group>"; };
+		18906F791610BF3C0003C892 /* NSCalendar.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSCalendar.m; sourceTree = "<group>"; };
+		18906F7A1610BF3C0003C892 /* NSCalendarDate.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSCalendarDate.m; sourceTree = "<group>"; };
+		18906F7B1610BF3C0003C892 /* NSCallBacks.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = NSCallBacks.h; path = Source/NSCallBacks.h; sourceTree = "<group>"; };
+		18906F7C1610BF3C0003C892 /* NSCallBacks.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSCallBacks.m; sourceTree = "<group>"; };
+		18906F7D1610BF3C0003C892 /* NSCharacterSet.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSCharacterSet.m; sourceTree = "<group>"; };
+		18906F7E1610BF3C0003C892 /* NSCharacterSetData.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = NSCharacterSetData.h; path = Source/NSCharacterSetData.h; sourceTree = "<group>"; };
+		18906F7F1610BF3C0003C892 /* NSClassDescription.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSClassDescription.m; sourceTree = "<group>"; };
+		18906F801610BF3C0003C892 /* NSCoder.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSCoder.m; sourceTree = "<group>"; };
+		18906F811610BF3C0003C892 /* NSConcreteHashTable.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSConcreteHashTable.m; sourceTree = "<group>"; };
+		18906F821610BF3C0003C892 /* NSConcreteMapTable.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSConcreteMapTable.m; sourceTree = "<group>"; };
+		18906F831610BF3C0003C892 /* NSConcretePointerFunctions.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = NSConcretePointerFunctions.h; path = Source/NSConcretePointerFunctions.h; sourceTree = "<group>"; };
+		18906F841610BF3C0003C892 /* NSConcretePointerFunctions.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSConcretePointerFunctions.m; sourceTree = "<group>"; };
+		18906F851610BF3C0003C892 /* NSConnection.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSConnection.m; sourceTree = "<group>"; };
+		18906F861610BF3C0003C892 /* NSCopyObject.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSCopyObject.m; sourceTree = "<group>"; };
+		18906F871610BF3C0003C892 /* NSCountedSet.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSCountedSet.m; sourceTree = "<group>"; };
+		18906F881610BF3C0003C892 /* NSData.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSData.m; sourceTree = "<group>"; };
+		18906F891610BF3C0003C892 /* NSDate.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSDate.m; sourceTree = "<group>"; };
+		18906F8A1610BF3C0003C892 /* NSDateFormatter.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSDateFormatter.m; sourceTree = "<group>"; };
+		18906F8B1610BF3C0003C892 /* NSDebug.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSDebug.m; sourceTree = "<group>"; };
+		18906F8C1610BF3C0003C892 /* NSDecimal.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSDecimal.m; sourceTree = "<group>"; };
+		18906F8D1610BF3C0003C892 /* NSDecimalNumber.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSDecimalNumber.m; sourceTree = "<group>"; };
+		18906F8E1610BF3C0003C892 /* NSDictionary.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSDictionary.m; sourceTree = "<group>"; };
+		18906F8F1610BF3C0003C892 /* NSDistantObject.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSDistantObject.m; sourceTree = "<group>"; };
+		18906F901610BF3C0003C892 /* NSDistributedLock.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSDistributedLock.m; sourceTree = "<group>"; };
+		18906F911610BF3C0003C892 /* NSDistributedNotificationCenter.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSDistributedNotificationCenter.m; sourceTree = "<group>"; };
+		18906F921610BF3C0003C892 /* NSEnumerator.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSEnumerator.m; sourceTree = "<group>"; };
+		18906F931610BF3C0003C892 /* NSError.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSError.m; sourceTree = "<group>"; };
+		18906F941610BF3C0003C892 /* NSException.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSException.m; sourceTree = "<group>"; };
+		18906F951610BF3C0003C892 /* NSFileHandle.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSFileHandle.m; sourceTree = "<group>"; };
+		18906F961610BF3C0003C892 /* NSFileManager.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSFileManager.m; sourceTree = "<group>"; };
+		18906F971610BF3C0003C892 /* NSFormatter.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSFormatter.m; sourceTree = "<group>"; };
+		18906F981610BF3C0003C892 /* NSGarbageCollector.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSGarbageCollector.m; sourceTree = "<group>"; };
+		18906F991610BF3C0003C892 /* NSGeometry.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSGeometry.m; sourceTree = "<group>"; };
+		18906F9A1610BF3C0003C892 /* NSHTTPCookie.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSHTTPCookie.m; sourceTree = "<group>"; };
+		18906F9B1610BF3C0003C892 /* NSHTTPCookieStorage.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSHTTPCookieStorage.m; sourceTree = "<group>"; };
+		18906F9C1610BF3C0003C892 /* NSHashTable.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSHashTable.m; sourceTree = "<group>"; };
+		18906F9D1610BF3C0003C892 /* NSHost.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSHost.m; sourceTree = "<group>"; };
+		18906F9E1610BF3C0003C892 /* NSIndexPath.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSIndexPath.m; sourceTree = "<group>"; };
+		18906F9F1610BF3C0003C892 /* NSIndexSet.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSIndexSet.m; sourceTree = "<group>"; };
+		18906FA01610BF3C0003C892 /* NSInvocation.ff.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSInvocation.ff.m; sourceTree = "<group>"; };
+		18906FA11610BF3C0003C892 /* NSJSONSerialization.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSJSONSerialization.m; sourceTree = "<group>"; };
+		18906FA21610BF3C0003C892 /* NSKeyValueCoding.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSKeyValueCoding.m; sourceTree = "<group>"; };
+		18906FA31610BF3C0003C892 /* NSKeyValueMutableArray.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSKeyValueMutableArray.m; sourceTree = "<group>"; };
+		18906FA41610BF3C0003C892 /* NSKeyValueMutableSet.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSKeyValueMutableSet.m; sourceTree = "<group>"; };
+		18906FA61610BF3C0003C892 /* NSKeyedArchiver.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSKeyedArchiver.m; sourceTree = "<group>"; };
+		18906FA71610BF3C0003C892 /* NSKeyedUnarchiver.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSKeyedUnarchiver.m; sourceTree = "<group>"; };
+		18906FA81610BF3C0003C892 /* NSLocale.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSLocale.m; sourceTree = "<group>"; };
+		18906FA91610BF3C0003C892 /* NSLock.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSLock.m; sourceTree = "<group>"; };
+		18906FAA1610BF3C0003C892 /* NSLog.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSLog.m; sourceTree = "<group>"; };
+		18906FAB1610BF3C0003C892 /* NSMapTable.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSMapTable.m; sourceTree = "<group>"; };
+		18906FAC1610BF3C0003C892 /* NSMessagePort.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSMessagePort.m; sourceTree = "<group>"; };
+		18906FAD1610BF3C0003C892 /* NSMessagePortNameServer.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSMessagePortNameServer.m; sourceTree = "<group>"; };
+		18906FAE1610BF3C0003C892 /* NSMethodSignature.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSMethodSignature.m; sourceTree = "<group>"; };
+		18906FAF1610BF3C0003C892 /* NSNetServices.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSNetServices.m; sourceTree = "<group>"; };
+		18906FB01610BF3C0003C892 /* NSNotification.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSNotification.m; sourceTree = "<group>"; };
+		18906FB11610BF3C0003C892 /* NSNotificationCenter.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSNotificationCenter.m; sourceTree = "<group>"; };
+		18906FB21610BF3C0003C892 /* NSNotificationQueue.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSNotificationQueue.m; sourceTree = "<group>"; };
+		18906FB31610BF3C0003C892 /* NSNull.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSNull.m; sourceTree = "<group>"; };
+		18906FB41610BF3C0003C892 /* NSNumber.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSNumber.m; sourceTree = "<group>"; };
+		18906FB51610BF3C0003C892 /* NSNumberFormatter.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSNumberFormatter.m; sourceTree = "<group>"; };
+		18906FB61610BF3C0003C892 /* NSNumberMethods.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = NSNumberMethods.h; path = Source/NSNumberMethods.h; sourceTree = "<group>"; };
+		18906FB71610BF3C0003C892 /* NSObjCRuntime.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSObjCRuntime.m; sourceTree = "<group>"; };
+		18906FB81610BF3C0003C892 /* NSObject+NSComparisonMethods.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = "NSObject+NSComparisonMethods.m"; sourceTree = "<group>"; };
+		18906FB91610BF3C0003C892 /* NSObject.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSObject.m; sourceTree = "<group>"; };
+		18906FBA1610BF3C0003C892 /* NSOperation.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSOperation.m; sourceTree = "<group>"; };
+		18906FBB1610BF3C0003C892 /* NSPage.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSPage.m; sourceTree = "<group>"; };
+		18906FBC1610BF3C0003C892 /* NSPathUtilities.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSPathUtilities.m; sourceTree = "<group>"; };
+		18906FBD1610BF3C0003C892 /* NSPipe.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSPipe.m; sourceTree = "<group>"; };
+		18906FBE1610BF3C0003C892 /* NSPointerArray.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSPointerArray.m; sourceTree = "<group>"; };
+		18906FBF1610BF3C0003C892 /* NSPointerFunctions.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSPointerFunctions.m; sourceTree = "<group>"; };
+		18906FC01610BF3C0003C892 /* NSPort.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSPort.m; sourceTree = "<group>"; };
+		18906FC11610BF3C0003C892 /* NSPortCoder.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSPortCoder.m; sourceTree = "<group>"; };
+		18906FC21610BF3C0003C892 /* NSPortMessage.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSPortMessage.m; sourceTree = "<group>"; };
+		18906FC31610BF3C0003C892 /* NSPortNameServer.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSPortNameServer.m; sourceTree = "<group>"; };
+		18906FC41610BF3C0003C892 /* NSPredicate.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSPredicate.m; sourceTree = "<group>"; };
+		18906FC51610BF3C0003C892 /* NSProcessInfo.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSProcessInfo.m; sourceTree = "<group>"; };
+		18906FC61610BF3C0003C892 /* NSPropertyList.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSPropertyList.m; sourceTree = "<group>"; };
+		18906FC71610BF3C0003C892 /* NSProtocolChecker.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSProtocolChecker.m; sourceTree = "<group>"; };
+		18906FC81610BF3C0003C892 /* NSProxy.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSProxy.m; sourceTree = "<group>"; };
+		18906FC91610BF3C0003C892 /* NSRange.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSRange.m; sourceTree = "<group>"; };
+		18906FCA1610BF3C0003C892 /* NSRegularExpression.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSRegularExpression.m; sourceTree = "<group>"; };
+		18906FCB1610BF3C0003C892 /* NSRunLoop.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSRunLoop.m; sourceTree = "<group>"; };
+		18906FCC1610BF3C0003C892 /* NSScanner.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSScanner.m; sourceTree = "<group>"; };
+		18906FCD1610BF3C0003C892 /* NSSerializer.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSSerializer.m; sourceTree = "<group>"; };
+		18906FCE1610BF3C0003C892 /* NSSet.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSSet.m; sourceTree = "<group>"; };
+		18906FCF1610BF3C0003C892 /* NSSocketPort.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSSocketPort.m; sourceTree = "<group>"; };
+		18906FD01610BF3C0003C892 /* NSSocketPortNameServer.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSSocketPortNameServer.m; sourceTree = "<group>"; };
+		18906FD11610BF3C0003C892 /* NSSortDescriptor.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSSortDescriptor.m; sourceTree = "<group>"; };
+		18906FD21610BF3C0003C892 /* NSSpellServer.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSSpellServer.m; sourceTree = "<group>"; };
+		18906FD31610BF3C0003C892 /* NSString.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSString.m; sourceTree = "<group>"; };
+		18906FD41610BF3C0003C892 /* NSTask.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSTask.m; sourceTree = "<group>"; };
+		18906FD51610BF3C0003C892 /* NSTextCheckingResult.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSTextCheckingResult.m; sourceTree = "<group>"; };
+		18906FD61610BF3C0003C892 /* NSThread.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSThread.m; sourceTree = "<group>"; };
+		18906FD71610BF3C0003C892 /* NSTimeZone.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSTimeZone.m; sourceTree = "<group>"; };
+		18906FD81610BF3C0003C892 /* NSTimer.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSTimer.m; sourceTree = "<group>"; };
+		18906FD91610BF3C0003C892 /* NSURL.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSURL.m; sourceTree = "<group>"; };
+		18906FDA1610BF3C0003C892 /* NSURLAuthenticationChallenge.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSURLAuthenticationChallenge.m; sourceTree = "<group>"; };
+		18906FDB1610BF3C0003C892 /* NSURLCache.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSURLCache.m; sourceTree = "<group>"; };
+		18906FDC1610BF3C0003C892 /* NSURLConnection.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSURLConnection.m; sourceTree = "<group>"; };
+		18906FDD1610BF3C0003C892 /* NSURLCredential.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSURLCredential.m; sourceTree = "<group>"; };
+		18906FDE1610BF3C0003C892 /* NSURLCredentialStorage.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSURLCredentialStorage.m; sourceTree = "<group>"; };
+		18906FDF1610BF3C0003C892 /* NSURLDownload.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSURLDownload.m; sourceTree = "<group>"; };
+		18906FE01610BF3C0003C892 /* NSURLHandle.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSURLHandle.m; sourceTree = "<group>"; };
+		18906FE11610BF3C0003C892 /* NSURLProtectionSpace.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSURLProtectionSpace.m; sourceTree = "<group>"; };
+		18906FE21610BF3C0003C892 /* NSURLProtocol.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSURLProtocol.m; sourceTree = "<group>"; };
+		18906FE31610BF3C0003C892 /* NSURLRequest.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSURLRequest.m; sourceTree = "<group>"; };
+		18906FE41610BF3C0003C892 /* NSURLResponse.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSURLResponse.m; sourceTree = "<group>"; };
+		18906FE51610BF3C0003C892 /* NSUnarchiver.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSUnarchiver.m; sourceTree = "<group>"; };
+		18906FE61610BF3C0003C892 /* NSUndoManager.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSUndoManager.m; sourceTree = "<group>"; };
+		18906FE71610BF3C0003C892 /* NSUserDefaults.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSUserDefaults.m; sourceTree = "<group>"; };
+		18906FE81610BF3C0003C892 /* NSValue.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSValue.m; sourceTree = "<group>"; };
+		18906FE91610BF3C0003C892 /* NSValueTransformer.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSValueTransformer.m; sourceTree = "<group>"; };
+		18906FEA1610BF3C0003C892 /* NSXMLDTD.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSXMLDTD.m; sourceTree = "<group>"; };
+		18906FEB1610BF3C0003C892 /* NSXMLDTDNode.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSXMLDTDNode.m; sourceTree = "<group>"; };
+		18906FEC1610BF3C0003C892 /* NSXMLDocument.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSXMLDocument.m; sourceTree = "<group>"; };
+		18906FED1610BF3C0003C892 /* NSXMLElement.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSXMLElement.m; sourceTree = "<group>"; };
+		18906FEE1610BF3C0003C892 /* NSXMLNode.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSXMLNode.m; sourceTree = "<group>"; };
+		18906FEF1610BF3C0003C892 /* NSXMLParser.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSXMLParser.m; sourceTree = "<group>"; };
+		18906FF01610BF3C0003C892 /* NSXMLPrivate.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = NSXMLPrivate.h; path = Source/NSXMLPrivate.h; sourceTree = "<group>"; };
+		18906FF11610BF3C0003C892 /* NSZone.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSZone.m; sourceTree = "<group>"; };
+		18906FFD1610BF3C0003C892 /* callframe.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = callframe.h; sourceTree = "<group>"; };
+		18906FFE1610BF3C0003C892 /* callframe.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = callframe.m; sourceTree = "<group>"; };
+		18906FFF1610BF3C0003C892 /* cifframe.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = cifframe.h; sourceTree = "<group>"; };
+		189070001610BF3C0003C892 /* cifframe.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = cifframe.m; sourceTree = "<group>"; };
+		189070011610BF3C0003C892 /* common.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = common.h; sourceTree = "<group>"; };
+		189070021610BF3C0003C892 /* dld-load.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = "dld-load.h"; sourceTree = "<group>"; };
+		189070031610BF3C0003C892 /* externs.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = externs.m; sourceTree = "<group>"; };
+		189070041610BF3C0003C892 /* hpux-load.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = "hpux-load.h"; sourceTree = "<group>"; };
+		189070051610BF3C0003C892 /* inet_ntop.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = inet_ntop.m; sourceTree = "<group>"; };
+		189070061610BF3C0003C892 /* inet_pton.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = inet_pton.m; sourceTree = "<group>"; };
+		189070071610BF3C0003C892 /* libgnustep-base-entry.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = "libgnustep-base-entry.m"; sourceTree = "<group>"; };
+		189070081610BF3C0003C892 /* nstzfile.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = nstzfile.h; sourceTree = "<group>"; };
+		189070091610BF3C0003C892 /* null-load.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = "null-load.h"; sourceTree = "<group>"; };
+		1890700A1610BF3C0003C892 /* objc-load.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = "objc-load.h"; sourceTree = "<group>"; };
+		1890700B1610BF3C0003C892 /* objc-load.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = "objc-load.m"; sourceTree = "<group>"; };
+		1890700C1610BF3C0003C892 /* preface.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = preface.m; sourceTree = "<group>"; };
+		1890700D1610BF3C0003C892 /* simple-load.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = "simple-load.h"; sourceTree = "<group>"; };
+		1890700F1610BF3C0003C892 /* GNUmakefile */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; path = GNUmakefile; sourceTree = "<group>"; };
+		189070101610BF3C0003C892 /* GSRunLoopCtxt.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = GSRunLoopCtxt.m; sourceTree = "<group>"; };
+		189070111610BF3C0003C892 /* Makefile.preamble */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; path = Makefile.preamble; sourceTree = "<group>"; };
+		189070121610BF3C0003C892 /* NSStream.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSStream.m; sourceTree = "<group>"; };
+		189070141610BF3C0003C892 /* GNUmakefile */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; path = GNUmakefile; sourceTree = "<group>"; };
+		189070151610BF3C0003C892 /* GSFileHandle.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = GSFileHandle.m; sourceTree = "<group>"; };
+		189070161610BF3C0003C892 /* GSRunLoopCtxt.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = GSRunLoopCtxt.m; sourceTree = "<group>"; };
+		189070171610BF3C0003C892 /* Makefile.preamble */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; path = Makefile.preamble; sourceTree = "<group>"; };
+		189070181610BF3C0003C892 /* NSMessagePort.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSMessagePort.m; sourceTree = "<group>"; };
+		189070191610BF3C0003C892 /* NSMessagePortNameServer.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSMessagePortNameServer.m; sourceTree = "<group>"; };
+		1890701A1610BF3C0003C892 /* NSStream.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSStream.m; sourceTree = "<group>"; };
+		1890701B1610BF3C0003C892 /* NSUserDefaults.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSUserDefaults.m; sourceTree = "<group>"; };
+		1890701C1610BF3C0003C892 /* win32-def.top */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; path = "win32-def.top"; sourceTree = "<group>"; };
+		1890701D1610BF3C0003C892 /* win32-load.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = "win32-load.h"; sourceTree = "<group>"; };
+		1890B34016F3BC3300187826 /* GSPrivateHash.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = GSPrivateHash.m; sourceTree = "<group>"; };
+		18D882491729B64E0067E486 /* ChangeStack.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist; path = ChangeStack.plist; sourceTree = "<group>"; };
+		18D8824A1729B64E0067E486 /* ComplexDependency.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist; path = ComplexDependency.plist; sourceTree = "<group>"; };
+		18D8824B1729B64E0067E486 /* DependencyObservance.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist; path = DependencyObservance.plist; sourceTree = "<group>"; };
+		18D8824C1729B64E0067E486 /* DependentNestedProperty.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist; path = DependentNestedProperty.plist; sourceTree = "<group>"; };
+		18D8824D1729B64E0067E486 /* NestedProperty.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist; path = NestedProperty.plist; sourceTree = "<group>"; };
+		18D8824E1729B64E0067E486 /* NestedPropertyDependency.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist; path = NestedPropertyDependency.plist; sourceTree = "<group>"; };
+		18D8824F1729B64E0067E486 /* NestedPropertyLevels.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist; path = NestedPropertyLevels.plist; sourceTree = "<group>"; };
+		18D882501729B64E0067E486 /* Observance.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist; path = Observance.plist; sourceTree = "<group>"; };
+		18D882511729B64E0067E486 /* ObservanceStack.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist; path = ObservanceStack.plist; sourceTree = "<group>"; };
+		18D882521729B64E0067E486 /* StackCorruption.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist; path = StackCorruption.plist; sourceTree = "<group>"; };
+		18D882531729B64E0067E486 /* test01.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = test01.m; sourceTree = "<group>"; };
+		18D8BEA2164B5FF700942A5D /* NSInvocation.x86_64.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSInvocation.x86_64.m; sourceTree = "<group>"; };
+		18EA675F172EC6170026AC34 /* GSTypeEncoding.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = GSTypeEncoding.c; sourceTree = "<group>"; };
+		18EA6763172EC7F70026AC34 /* GSTypeEncoding.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = GSTypeEncoding.h; sourceTree = "<group>"; };
+		18EFCC00172AF0F0003304CA /* ItemInsertion.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist; path = ItemInsertion.plist; sourceTree = "<group>"; };
+		18EFCC01172AF0F0003304CA /* ItemRemoval.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist; path = ItemRemoval.plist; sourceTree = "<group>"; };
+		18EFCC02172AF0F0003304CA /* ItemReplacement.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist; path = ItemReplacement.plist; sourceTree = "<group>"; };
+		18EFCC03172AF0F0003304CA /* NilValue.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist; path = NilValue.plist; sourceTree = "<group>"; };
+		18EFCC04172AF0F0003304CA /* SetComplementation.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist; path = SetComplementation.plist; sourceTree = "<group>"; };
+		18EFCC05172AF0F0003304CA /* SetIntersection.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist; path = SetIntersection.plist; sourceTree = "<group>"; };
+		18EFCC07172AF0F0003304CA /* SetUnion.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist; path = SetUnion.plist; sourceTree = "<group>"; };
+		18EFCC08172AF0F0003304CA /* test02.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = test02.m; sourceTree = "<group>"; };
+		18EFCC11172B01B9003304CA /* SetSettingEmpty.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist; path = SetSettingEmpty.plist; sourceTree = "<group>"; };
+		18EFCC12172B01B9003304CA /* SetSettingNil.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist; path = SetSettingNil.plist; sourceTree = "<group>"; };
+		18EFCC13172B01B9003304CA /* SetSettingNotEmpty.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist; path = SetSettingNotEmpty.plist; sourceTree = "<group>"; };
+		18F8D04C17244FE900420DA5 /* TestInfo */ = {isa = PBXFileReference; lastKnownFileType = text; path = TestInfo; sourceTree = "<group>"; };
+		18F8D04D17244FE900420DA5 /* test00.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = test00.m; sourceTree = "<group>"; };
+		18F8D0501724534E00420DA5 /* NSKeyValueNestedProperty.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSKeyValueNestedProperty.h; sourceTree = "<group>"; };
+		18F8D0511724534E00420DA5 /* NSKeyValueNestedProperty.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSKeyValueNestedProperty.m; sourceTree = "<group>"; };
+		18F8D0521724534E00420DA5 /* NSKeyValueObservance.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSKeyValueObservance.h; sourceTree = "<group>"; };
+		18F8D0531724534E00420DA5 /* NSKeyValueObservance.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSKeyValueObservance.m; sourceTree = "<group>"; };
+		18F8D0541724534E00420DA5 /* NSKeyValueObservationInfo.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSKeyValueObservationInfo.h; sourceTree = "<group>"; };
+		18F8D0551724534E00420DA5 /* NSKeyValueObservationInfo.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSKeyValueObservationInfo.m; sourceTree = "<group>"; };
+		18F8D0561724534E00420DA5 /* NSKeyValueObservingPrivate.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSKeyValueObservingPrivate.h; sourceTree = "<group>"; };
+		18F8D0571724534E00420DA5 /* NSKeyValueObservingPrivate.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSKeyValueObservingPrivate.m; sourceTree = "<group>"; };
+		18F8D0581724534E00420DA5 /* NSKeyValueProperty.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSKeyValueProperty.h; sourceTree = "<group>"; };
+		18F8D0591724534E00420DA5 /* NSKeyValueProperty.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSKeyValueProperty.m; sourceTree = "<group>"; };
+		18F8D05A1724534E00420DA5 /* NSKeyValueUnnestedProperty.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSKeyValueUnnestedProperty.h; sourceTree = "<group>"; };
+		18F8D05B1724534E00420DA5 /* NSKeyValueUnnestedProperty.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSKeyValueUnnestedProperty.m; sourceTree = "<group>"; };
+		18F8D05C1724534E00420DA5 /* NSObject+KVO.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = "NSObject+KVO.m"; sourceTree = "<group>"; };
+		18F8D06A1725919700420DA5 /* NSKVONotifying.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSKVONotifying.h; sourceTree = "<group>"; };
+		18F8D06B1725919800420DA5 /* NSKVONotifying.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = NSKVONotifying.m; sourceTree = "<group>"; };
+		18FE1E12162716A200389A13 /* ChangeLog */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; path = ChangeLog; sourceTree = SOURCE_ROOT; };
+		18FE1E13162716A200389A13 /* ChangeLog.1 */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.man; path = ChangeLog.1; sourceTree = SOURCE_ROOT; };
+		18FE1E14162716A200389A13 /* ChangeLog.2 */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; path = ChangeLog.2; sourceTree = SOURCE_ROOT; };
+		18FE1E281628550000389A13 /* GNUmakefile */ = {isa = PBXFileReference; lastKnownFileType = text; path = GNUmakefile; sourceTree = "<group>"; };
+		18FE1E2B1628550000389A13 /* NSGeometry1.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSGeometry1.m; sourceTree = "<group>"; };
+		18FE1E2C1628550000389A13 /* NSPathUtilities.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSPathUtilities.m; sourceTree = "<group>"; };
+		18FE1E2D1628550000389A13 /* NSZone.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSZone.m; sourceTree = "<group>"; };
+		18FE1E2E1628550000389A13 /* TestInfo */ = {isa = PBXFileReference; lastKnownFileType = text; path = TestInfo; sourceTree = "<group>"; };
+		18FE1E2F1628550000389A13 /* class_hierarchy.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = class_hierarchy.m; sourceTree = "<group>"; };
+		18FE1E301628550000389A13 /* clsCreate.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = clsCreate.m; sourceTree = "<group>"; };
+		18FE1E311628550000389A13 /* properties.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = properties.m; sourceTree = "<group>"; };
+		18FE1E321628550000389A13 /* propertyAttrs.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = propertyAttrs.m; sourceTree = "<group>"; };
+		18FE1E331628550000389A13 /* runtime.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = runtime.m; sourceTree = "<group>"; };
+		18FE1E341628550000389A13 /* GNUmakefile.postamble */ = {isa = PBXFileReference; lastKnownFileType = text; path = GNUmakefile.postamble; sourceTree = "<group>"; };
+		18FE1E351628550000389A13 /* GNUmakefile.super */ = {isa = PBXFileReference; lastKnownFileType = text; path = GNUmakefile.super; sourceTree = "<group>"; };
+		18FE1E371628550000389A13 /* HTTP1.dat */ = {isa = PBXFileReference; lastKnownFileType = text; path = HTTP1.dat; sourceTree = "<group>"; };
+		18FE1E381628550000389A13 /* HTTP2.dat */ = {isa = PBXFileReference; lastKnownFileType = text; path = HTTP2.dat; sourceTree = "<group>"; };
+		18FE1E391628550000389A13 /* TestInfo */ = {isa = PBXFileReference; lastKnownFileType = text; path = TestInfo; sourceTree = "<group>"; };
+		18FE1E3A1628550000389A13 /* build.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = build.m; sourceTree = "<group>"; };
+		18FE1E3B1628550000389A13 /* general.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = general.m; sourceTree = "<group>"; };
+		18FE1E3C1628550000389A13 /* mime1.dat */ = {isa = PBXFileReference; lastKnownFileType = text; path = mime1.dat; sourceTree = "<group>"; };
+		18FE1E3D1628550000389A13 /* mime10.dat */ = {isa = PBXFileReference; lastKnownFileType = text; path = mime10.dat; sourceTree = "<group>"; };
+		18FE1E3E1628550000389A13 /* mime2.dat */ = {isa = PBXFileReference; lastKnownFileType = text; path = mime2.dat; sourceTree = "<group>"; };
+		18FE1E3F1628550000389A13 /* mime3.dat */ = {isa = PBXFileReference; lastKnownFileType = text; path = mime3.dat; sourceTree = "<group>"; };
+		18FE1E401628550000389A13 /* mime4.dat */ = {isa = PBXFileReference; lastKnownFileType = text; path = mime4.dat; sourceTree = "<group>"; };
+		18FE1E411628550000389A13 /* mime5.dat */ = {isa = PBXFileReference; lastKnownFileType = text; path = mime5.dat; sourceTree = "<group>"; };
+		18FE1E421628550000389A13 /* mime6.dat */ = {isa = PBXFileReference; lastKnownFileType = text; path = mime6.dat; sourceTree = "<group>"; };
+		18FE1E431628550000389A13 /* mime7.dat */ = {isa = PBXFileReference; lastKnownFileType = file; path = mime7.dat; sourceTree = "<group>"; };
+		18FE1E441628550000389A13 /* mime8.dat */ = {isa = PBXFileReference; lastKnownFileType = text; path = mime8.dat; sourceTree = "<group>"; };
+		18FE1E451628550000389A13 /* mime9.dat */ = {isa = PBXFileReference; lastKnownFileType = text; path = mime9.dat; sourceTree = "<group>"; };
+		18FE1E461628550000389A13 /* test01.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = test01.m; sourceTree = "<group>"; };
+		18FE1E471628550000389A13 /* test02.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = test02.m; sourceTree = "<group>"; };
+		18FE1E491628550000389A13 /* TestInfo */ = {isa = PBXFileReference; lastKnownFileType = text; path = TestInfo; sourceTree = "<group>"; };
+		18FE1E4A1628550000389A13 /* basic.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = basic.m; sourceTree = "<group>"; };
+		18FE1E4C1628550000389A13 /* TestInfo */ = {isa = PBXFileReference; lastKnownFileType = text; path = TestInfo; sourceTree = "<group>"; };
+		18FE1E4D1628550000389A13 /* general.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = general.m; sourceTree = "<group>"; };
+		18FE1E4E1628550000389A13 /* notifications.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = notifications.m; sourceTree = "<group>"; };
+		18FE1E501628550000389A13 /* GNUmakefile */ = {isa = PBXFileReference; lastKnownFileType = text; path = GNUmakefile; sourceTree = "<group>"; };
+		18FE1E511628550000389A13 /* generic.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = generic.h; sourceTree = "<group>"; };
+		18FE1E521628550000389A13 /* generic.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = generic.m; sourceTree = "<group>"; };
+		18FE1E541628550000389A13 /* TestInfo */ = {isa = PBXFileReference; lastKnownFileType = text; path = TestInfo; sourceTree = "<group>"; };
+		18FE1E551628550000389A13 /* array.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = array.m; sourceTree = "<group>"; };
+		18FE1E561628550000389A13 /* basic.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = basic.m; sourceTree = "<group>"; };
+		18FE1E571628550000389A13 /* mutable.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = mutable.m; sourceTree = "<group>"; };
+		18FE1E581628550000389A13 /* nil.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = nil.m; sourceTree = "<group>"; };
+		18FE1E591628550000389A13 /* path.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = path.m; sourceTree = "<group>"; };
+		18FE1E5B1628550000389A13 /* TestInfo */ = {isa = PBXFileReference; lastKnownFileType = text; path = TestInfo; sourceTree = "<group>"; };
+		18FE1E5C1628550000389A13 /* basic.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = basic.m; sourceTree = "<group>"; };
+		18FE1E5E1628550000389A13 /* TestInfo */ = {isa = PBXFileReference; lastKnownFileType = text; path = TestInfo; sourceTree = "<group>"; };
+		18FE1E5F1628550000389A13 /* basic.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = basic.m; sourceTree = "<group>"; };
+		18FE1E601628550000389A13 /* create.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = create.m; sourceTree = "<group>"; };
+		18FE1E611628550000389A13 /* general.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = general.m; sourceTree = "<group>"; };
+		18FE1E631628550000389A13 /* TestInfo */ = {isa = PBXFileReference; lastKnownFileType = text; path = TestInfo; sourceTree = "<group>"; };
+		18FE1E641628550000389A13 /* basic.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = basic.m; sourceTree = "<group>"; };
+		18FE1E651628550000389A13 /* blocks.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = blocks.m; sourceTree = "<group>"; };
+		18FE1E661628550000389A13 /* create.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = create.m; sourceTree = "<group>"; };
+		18FE1E671628550000389A13 /* general.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = general.m; sourceTree = "<group>"; };
+		18FE1E681628550000389A13 /* random.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist; path = random.plist; sourceTree = "<group>"; };
+		18FE1E691628550000389A13 /* sorted.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist; path = sorted.plist; sourceTree = "<group>"; };
+		18FE1E6A1628550000389A13 /* test.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist; path = test.plist; sourceTree = "<group>"; };
+		18FE1E6C1628550000389A13 /* TestInfo */ = {isa = PBXFileReference; lastKnownFileType = text; path = TestInfo; sourceTree = "<group>"; };
+		18FE1E6D1628550000389A13 /* basic.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = basic.m; sourceTree = "<group>"; };
+		18FE1E6E1628550000389A13 /* test00.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = test00.m; sourceTree = "<group>"; };
+		18FE1E701628550000389A13 /* TestInfo */ = {isa = PBXFileReference; lastKnownFileType = text; path = TestInfo; sourceTree = "<group>"; };
+		18FE1E711628550000389A13 /* autorelease_eh.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = autorelease_eh.m; sourceTree = "<group>"; };
+		18FE1E721628550000389A13 /* basic.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = basic.m; sourceTree = "<group>"; };
+		18FE1E741628550000389A13 /* blockassign.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = blockassign.m; sourceTree = "<group>"; };
+		18FE1E761628550000389A13 /* GNUmakefile.preamble */ = {isa = PBXFileReference; lastKnownFileType = text; path = GNUmakefile.preamble; sourceTree = "<group>"; };
+		18FE1E791628550000389A13 /* English */ = {isa = PBXFileReference; lastKnownFileType = text; name = English; path = English.lproj/TextRes.txt; sourceTree = "<group>"; };
+		18FE1E7A1628550000389A13 /* French */ = {isa = PBXFileReference; lastKnownFileType = text; name = French; path = French.lproj/TextRes.txt; sourceTree = "<group>"; };
+		18FE1E7B1628550000389A13 /* GNUmakefile */ = {isa = PBXFileReference; lastKnownFileType = text; path = GNUmakefile; sourceTree = "<group>"; };
+		18FE1E7C1628550000389A13 /* NonLocalRes.txt */ = {isa = PBXFileReference; lastKnownFileType = text; path = NonLocalRes.txt; sourceTree = "<group>"; };
+		18FE1E7D1628550000389A13 /* TestBundle.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = TestBundle.m; sourceTree = "<group>"; };
+		18FE1E7E1628550000389A13 /* TestBundleInfo.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist; path = TestBundleInfo.plist; sourceTree = "<group>"; };
+		18FE1E7F1628550000389A13 /* de */ = {isa = PBXFileReference; lastKnownFileType = text; name = de; path = de.lproj/TextRes.txt; sourceTree = "<group>"; };
+		18FE1E801628550000389A13 /* TestInfo */ = {isa = PBXFileReference; lastKnownFileType = text; path = TestInfo; sourceTree = "<group>"; };
+		18FE1E811628550000389A13 /* basic.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = basic.m; sourceTree = "<group>"; };
+		18FE1E821628550000389A13 /* create.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = create.m; sourceTree = "<group>"; };
+		18FE1E831628550000389A13 /* general.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = general.m; sourceTree = "<group>"; };
+		18FE1E851628550000389A13 /* GNUmakefile.preamble */ = {isa = PBXFileReference; lastKnownFileType = text; path = GNUmakefile.preamble; sourceTree = "<group>"; };
+		18FE1E861628550000389A13 /* load.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = load.m; sourceTree = "<group>"; };
+		18FE1E871628550000389A13 /* resources.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = resources.m; sourceTree = "<group>"; };
+		18FE1E881628550000389A13 /* resources2.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = resources2.m; sourceTree = "<group>"; };
+		18FE1E8A1628550000389A13 /* TestInfo */ = {isa = PBXFileReference; lastKnownFileType = text; path = TestInfo; sourceTree = "<group>"; };
+		18FE1E8B1628550000389A13 /* basic.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = basic.m; sourceTree = "<group>"; };
+		18FE1E8C1628550000389A13 /* create.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = create.m; sourceTree = "<group>"; };
+		18FE1E8E1628550000389A13 /* TestInfo */ = {isa = PBXFileReference; lastKnownFileType = text; path = TestInfo; sourceTree = "<group>"; };
+		18FE1E8F1628550000389A13 /* basic.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = basic.m; sourceTree = "<group>"; };
+		18FE1E901628550000389A13 /* test00.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = test00.m; sourceTree = "<group>"; };
+		18FE1E911628550000389A13 /* test01.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = test01.m; sourceTree = "<group>"; };
+		18FE1E921628550000389A13 /* test02.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = test02.m; sourceTree = "<group>"; };
+		18FE1E931628550000389A13 /* western.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = western.h; sourceTree = "<group>"; };
+		18FE1E951628550000389A13 /* TestInfo */ = {isa = PBXFileReference; lastKnownFileType = text; path = TestInfo; sourceTree = "<group>"; };
+		18FE1E961628550000389A13 /* basic.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = basic.m; sourceTree = "<group>"; };
+		18FE1E971628550000389A13 /* class.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = class.m; sourceTree = "<group>"; };
+		18FE1E981628550000389A13 /* general.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = general.m; sourceTree = "<group>"; };
+		18FE1E991628550000389A13 /* illegalCharacterSet.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = illegalCharacterSet.m; sourceTree = "<group>"; };
+		18FE1E9B1628550000389A13 /* GNUmakefile.preamble */ = {isa = PBXFileReference; lastKnownFileType = text; path = GNUmakefile.preamble; sourceTree = "<group>"; };
+		18FE1E9D1628550000389A13 /* Connection.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = Connection.m; sourceTree = "<group>"; };
+		18FE1E9E1628550000389A13 /* GNUmakefile */ = {isa = PBXFileReference; lastKnownFileType = text; path = GNUmakefile; sourceTree = "<group>"; };
+		18FE1E9F1628550000389A13 /* TestInfo */ = {isa = PBXFileReference; lastKnownFileType = text; path = TestInfo; sourceTree = "<group>"; };
+		18FE1EA01628550000389A13 /* basic.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = basic.m; sourceTree = "<group>"; };
+		18FE1EA11628550000389A13 /* connection.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = connection.m; sourceTree = "<group>"; };
+		18FE1EA31628550000389A13 /* TestInfo */ = {isa = PBXFileReference; lastKnownFileType = text; path = TestInfo; sourceTree = "<group>"; };
+		18FE1EA41628550000389A13 /* basic.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = basic.m; sourceTree = "<group>"; };
+		18FE1EA61628550000389A13 /* TestInfo */ = {isa = PBXFileReference; lastKnownFileType = text; path = TestInfo; sourceTree = "<group>"; };
+		18FE1EA71628550000389A13 /* basic.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = basic.m; sourceTree = "<group>"; };
+		18FE1EA81628550000389A13 /* general.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = general.m; sourceTree = "<group>"; };
+		18FE1EAA1628550000389A13 /* TestInfo */ = {isa = PBXFileReference; lastKnownFileType = text; path = TestInfo; sourceTree = "<group>"; };
+		18FE1EAB1628550000389A13 /* basic.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = basic.m; sourceTree = "<group>"; };
+		18FE1EAC1628550000389A13 /* create.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = create.m; sourceTree = "<group>"; };
+		18FE1EAD1628550000389A13 /* general.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = general.m; sourceTree = "<group>"; };
+		18FE1EAF1628550000389A13 /* TestInfo */ = {isa = PBXFileReference; lastKnownFileType = text; path = TestInfo; sourceTree = "<group>"; };
+		18FE1EB01628550000389A13 /* general.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = general.m; sourceTree = "<group>"; };
+		18FE1EB21628550100389A13 /* TestInfo */ = {isa = PBXFileReference; lastKnownFileType = text; path = TestInfo; sourceTree = "<group>"; };
+		18FE1EB31628550100389A13 /* basic.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = basic.m; sourceTree = "<group>"; };
+		18FE1EB41628550100389A13 /* blocks.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = blocks.m; sourceTree = "<group>"; };
+		18FE1EB51628550100389A13 /* create.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = create.m; sourceTree = "<group>"; };
+		18FE1EB61628550100389A13 /* general.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = general.m; sourceTree = "<group>"; };
+		18FE1EB81628550100389A13 /* TestInfo */ = {isa = PBXFileReference; lastKnownFileType = text; path = TestInfo; sourceTree = "<group>"; };
+		18FE1EB91628550100389A13 /* basic.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = basic.m; sourceTree = "<group>"; };
+		18FE1EBA1628550100389A13 /* basic.m.abort */ = {isa = PBXFileReference; lastKnownFileType = text; path = basic.m.abort; sourceTree = "<group>"; };
+		18FE1EBB1628550100389A13 /* mixedException.mm */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.cpp.objcpp; path = mixedException.mm; sourceTree = "<group>"; };
+		18FE1EBC1628550100389A13 /* sillySemantics.mm */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.cpp.objcpp; path = sillySemantics.mm; sourceTree = "<group>"; };
+		18FE1EBD1628550100389A13 /* skipCatchall.mm */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.cpp.objcpp; path = skipCatchall.mm; sourceTree = "<group>"; };
+		18FE1EBE1628550100389A13 /* throwstr.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = throwstr.m; sourceTree = "<group>"; };
+		18FE1EC01628550100389A13 /* TestInfo */ = {isa = PBXFileReference; lastKnownFileType = text; path = TestInfo; sourceTree = "<group>"; };
+		18FE1EC11628550100389A13 /* basic.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = basic.m; sourceTree = "<group>"; };
+		18FE1EC21628550100389A13 /* general.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = general.m; sourceTree = "<group>"; };
+		18FE1EC31628550100389A13 /* socket.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = socket.m; sourceTree = "<group>"; };
+		18FE1EC61628550100389A13 /* TestInfo */ = {isa = PBXFileReference; lastKnownFileType = text; path = TestInfo; sourceTree = "<group>"; };
+		18FE1EC71628550100389A13 /* basic.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = basic.m; sourceTree = "<group>"; };
+		18FE1EC81628550100389A13 /* general.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = general.m; sourceTree = "<group>"; };
+		18FE1EC91628550100389A13 /* unrepresentable_filenames.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = unrepresentable_filenames.m; sourceTree = "<group>"; };
+		18FE1ECB1628550100389A13 /* TestInfo */ = {isa = PBXFileReference; lastKnownFileType = text; path = TestInfo; sourceTree = "<group>"; };
+		18FE1ECC1628550100389A13 /* basic.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = basic.m; sourceTree = "<group>"; };
+		18FE1ECE1628550100389A13 /* TestInfo */ = {isa = PBXFileReference; lastKnownFileType = text; path = TestInfo; sourceTree = "<group>"; };
+		18FE1ECF1628550100389A13 /* basic.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = basic.m; sourceTree = "<group>"; };
+		18FE1ED01628550100389A13 /* create.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = create.m; sourceTree = "<group>"; };
+		18FE1ED11628550100389A13 /* general.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = general.m; sourceTree = "<group>"; };
+		18FE1ED31628550100389A13 /* TestInfo */ = {isa = PBXFileReference; lastKnownFileType = text; path = TestInfo; sourceTree = "<group>"; };
+		18FE1ED41628550100389A13 /* basic.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = basic.m; sourceTree = "<group>"; };
+		18FE1ED51628550100389A13 /* create.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = create.m; sourceTree = "<group>"; };
+		18FE1ED71628550100389A13 /* TestInfo */ = {isa = PBXFileReference; lastKnownFileType = text; path = TestInfo; sourceTree = "<group>"; };
+		18FE1ED81628550100389A13 /* general.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = general.m; sourceTree = "<group>"; };
+		18FE1EDA1628550100389A13 /* GNUmakefile.preamble */ = {isa = PBXFileReference; lastKnownFileType = text; path = GNUmakefile.preamble; sourceTree = "<group>"; };
+		18FE1EDB1628550100389A13 /* InvokeProxyProtocol.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = InvokeProxyProtocol.h; sourceTree = "<group>"; };
+		18FE1EDD1628550100389A13 /* GNUmakefile */ = {isa = PBXFileReference; lastKnownFileType = text; path = GNUmakefile; sourceTree = "<group>"; };
+		18FE1EDE1628550100389A13 /* InvokeProxy.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = InvokeProxy.h; sourceTree = "<group>"; };
+		18FE1EDF1628550100389A13 /* InvokeProxy.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = InvokeProxy.m; sourceTree = "<group>"; };
+		18FE1EE01628550100389A13 /* TestInfo */ = {isa = PBXFileReference; lastKnownFileType = text; path = TestInfo; sourceTree = "<group>"; };
+		18FE1EE11628550100389A13 /* basic.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = basic.m; sourceTree = "<group>"; };
+		18FE1EE21628550100389A13 /* general.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = general.m; sourceTree = "<group>"; };
+		18FE1EE31628550100389A13 /* test01.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = test01.m; sourceTree = "<group>"; };
+		18FE1EE51628550100389A13 /* TestInfo */ = {isa = PBXFileReference; lastKnownFileType = text; path = TestInfo; sourceTree = "<group>"; };
+		18FE1EE61628550100389A13 /* json.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = json.m; sourceTree = "<group>"; };
+		18FE1EE81628550100389A13 /* TestInfo */ = {isa = PBXFileReference; lastKnownFileType = text; path = TestInfo; sourceTree = "<group>"; };
+		18FE1EE91628550100389A13 /* basic.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = basic.m; sourceTree = "<group>"; };
+		18FE1EEA1628550100389A13 /* create.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = create.m; sourceTree = "<group>"; };
+		18FE1EEB1628550100389A13 /* general.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = general.m; sourceTree = "<group>"; };
+		18FE1EED1628550100389A13 /* TestInfo */ = {isa = PBXFileReference; lastKnownFileType = text; path = TestInfo; sourceTree = "<group>"; };
+		18FE1EEE1628550100389A13 /* basic.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = basic.m; sourceTree = "<group>"; };
+		18FE1EEF1628550100389A13 /* create.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = create.m; sourceTree = "<group>"; };
+		18FE1EF01628550100389A13 /* general.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = general.m; sourceTree = "<group>"; };
+		18FE1EF21628550100389A13 /* GNUmakefile.preamble */ = {isa = PBXFileReference; lastKnownFileType = text; path = GNUmakefile.preamble; sourceTree = "<group>"; };
+		18FE1EF41628550100389A13 /* GNUmakefile */ = {isa = PBXFileReference; lastKnownFileType = text; path = GNUmakefile; sourceTree = "<group>"; };
+		18FE1EF51628550100389A13 /* doubleNSConditionLock.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = doubleNSConditionLock.m; sourceTree = "<group>"; };
+		18FE1EF61628550100389A13 /* doubleNSLock.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = doubleNSLock.m; sourceTree = "<group>"; };
+		18FE1EF71628550100389A13 /* RecursiveLock.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = RecursiveLock.m; sourceTree = "<group>"; };
+		18FE1EF81628550100389A13 /* TestInfo */ = {isa = PBXFileReference; lastKnownFileType = text; path = TestInfo; sourceTree = "<group>"; };
+		18FE1EF91628550100389A13 /* condlock.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = condlock.m; sourceTree = "<group>"; };
+		18FE1EFA1628550100389A13 /* doubleLocking.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = doubleLocking.m; sourceTree = "<group>"; };
+		18FE1EFB1628550100389A13 /* tryLock.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = tryLock.m; sourceTree = "<group>"; };
+		18FE1EFD1628550100389A13 /* TestInfo */ = {isa = PBXFileReference; lastKnownFileType = text; path = TestInfo; sourceTree = "<group>"; };
+		18FE1EFE1628550100389A13 /* basic.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = basic.m; sourceTree = "<group>"; };
+		18FE1EFF1628550100389A13 /* create.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = create.m; sourceTree = "<group>"; };
+		18FE1F001628550100389A13 /* general.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = general.m; sourceTree = "<group>"; };
+		18FE1F021628550100389A13 /* TestInfo */ = {isa = PBXFileReference; lastKnownFileType = text; path = TestInfo; sourceTree = "<group>"; };
+		18FE1F031628550100389A13 /* general.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = general.m; sourceTree = "<group>"; };
+		18FE1F051628550100389A13 /* TestInfo */ = {isa = PBXFileReference; lastKnownFileType = text; path = TestInfo; sourceTree = "<group>"; };
+		18FE1F061628550100389A13 /* basic.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = basic.m; sourceTree = "<group>"; };
+		18FE1F071628550100389A13 /* create.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = create.m; sourceTree = "<group>"; };
+		18FE1F081628550100389A13 /* general.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = general.m; sourceTree = "<group>"; };
+		18FE1F0A1628550100389A13 /* TestInfo */ = {isa = PBXFileReference; lastKnownFileType = text; path = TestInfo; sourceTree = "<group>"; };
+		18FE1F0B1628550100389A13 /* basic.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = basic.m; sourceTree = "<group>"; };
+		18FE1F0C1628550100389A13 /* test00.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = test00.m; sourceTree = "<group>"; };
+		18FE1F0D1628550100389A13 /* test01.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = test01.m; sourceTree = "<group>"; };
+		18FE1F0F1628550100389A13 /* TestInfo */ = {isa = PBXFileReference; lastKnownFileType = text; path = TestInfo; sourceTree = "<group>"; };
+		18FE1F101628550100389A13 /* basic.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = basic.m; sourceTree = "<group>"; };
+		18FE1F111628550100389A13 /* test00.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = test00.m; sourceTree = "<group>"; };
+		18FE1F131628550100389A13 /* TestInfo */ = {isa = PBXFileReference; lastKnownFileType = text; path = TestInfo; sourceTree = "<group>"; };
+		18FE1F141628550100389A13 /* basic.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = basic.m; sourceTree = "<group>"; };
+		18FE1F151628550100389A13 /* general.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = general.m; sourceTree = "<group>"; };
+		18FE1F171628550100389A13 /* TestInfo */ = {isa = PBXFileReference; lastKnownFileType = text; path = TestInfo; sourceTree = "<group>"; };
+		18FE1F181628550100389A13 /* basic.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = basic.m; sourceTree = "<group>"; };
+		18FE1F191628550100389A13 /* general.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = general.m; sourceTree = "<group>"; };
+		18FE1F1B1628550100389A13 /* TestInfo */ = {isa = PBXFileReference; lastKnownFileType = text; path = TestInfo; sourceTree = "<group>"; };
+		18FE1F1C1628550100389A13 /* blocks.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = blocks.m; sourceTree = "<group>"; };
+		18FE1F1D1628550100389A13 /* test0.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = test0.m; sourceTree = "<group>"; };
+		18FE1F1E1628550100389A13 /* test1.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = test1.m; sourceTree = "<group>"; };
+		18FE1F201628550100389A13 /* TestInfo */ = {isa = PBXFileReference; lastKnownFileType = text; path = TestInfo; sourceTree = "<group>"; };
+		18FE1F211628550100389A13 /* basic.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = basic.m; sourceTree = "<group>"; };
+		18FE1F231628550100389A13 /* GNUmakefile.preamble */ = {isa = PBXFileReference; lastKnownFileType = text; path = GNUmakefile.preamble; sourceTree = "<group>"; };
+		18FE1F241628550100389A13 /* NSMutableString_string.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSMutableString_string.m; sourceTree = "<group>"; };
+		18FE1F251628550100389A13 /* TestInfo */ = {isa = PBXFileReference; lastKnownFileType = text; path = TestInfo; sourceTree = "<group>"; };
+		18FE1F261628550100389A13 /* basic.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = basic.m; sourceTree = "<group>"; };
+		18FE1F281628550100389A13 /* TestInfo */ = {isa = PBXFileReference; lastKnownFileType = text; path = TestInfo; sourceTree = "<group>"; };
+		18FE1F291628550100389A13 /* basic.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = basic.m; sourceTree = "<group>"; };
+		18FE1F2A1628550100389A13 /* test00.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = test00.m; sourceTree = "<group>"; };
+		18FE1F2B1628550100389A13 /* test01.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = test01.m; sourceTree = "<group>"; };
+		18FE1F2D1628550100389A13 /* TestInfo */ = {isa = PBXFileReference; lastKnownFileType = text; path = TestInfo; sourceTree = "<group>"; };
+		18FE1F2E1628550100389A13 /* basic.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = basic.m; sourceTree = "<group>"; };
+		18FE1F2F1628550100389A13 /* basic10_4.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = basic10_4.m; sourceTree = "<group>"; };
+		18FE1F311628550100389A13 /* TestInfo */ = {isa = PBXFileReference; lastKnownFileType = text; path = TestInfo; sourceTree = "<group>"; };
+		18FE1F321628550100389A13 /* basic.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = basic.m; sourceTree = "<group>"; };
+		18FE1F331628550100389A13 /* initialize.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = initialize.m; sourceTree = "<group>"; };
+		18FE1F341628550100389A13 /* objc++.mm */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.cpp.objcpp; path = "objc++.mm"; sourceTree = "<group>"; };
+		18FE1F351628550100389A13 /* test00.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = test00.m; sourceTree = "<group>"; };
+		18FE1F361628550100389A13 /* test01.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = test01.m; sourceTree = "<group>"; };
+		18FE1F371628550100389A13 /* test02.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = test02.m; sourceTree = "<group>"; };
+		18FE1F391628550100389A13 /* TestInfo */ = {isa = PBXFileReference; lastKnownFileType = text; path = TestInfo; sourceTree = "<group>"; };
+		18FE1F3A1628550100389A13 /* basic.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = basic.m; sourceTree = "<group>"; };
+		18FE1F3B1628550100389A13 /* concurrent.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = concurrent.m; sourceTree = "<group>"; };
+		18FE1F3C1628550100389A13 /* threads.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = threads.m; sourceTree = "<group>"; };
+		18FE1F3E1628550100389A13 /* TestInfo */ = {isa = PBXFileReference; lastKnownFileType = text; path = TestInfo; sourceTree = "<group>"; };
+		18FE1F3F1628550100389A13 /* basic.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = basic.m; sourceTree = "<group>"; };
+		18FE1F411628550100389A13 /* TestInfo */ = {isa = PBXFileReference; lastKnownFileType = text; path = TestInfo; sourceTree = "<group>"; };
+		18FE1F421628550100389A13 /* basic.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = basic.m; sourceTree = "<group>"; };
+		18FE1F431628550100389A13 /* create.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = create.m; sourceTree = "<group>"; };
+		18FE1F441628550100389A13 /* general.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = general.m; sourceTree = "<group>"; };
+		18FE1F461628550100389A13 /* TestInfo */ = {isa = PBXFileReference; lastKnownFileType = text; path = TestInfo; sourceTree = "<group>"; };
+		18FE1F471628550100389A13 /* basic.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = basic.m; sourceTree = "<group>"; };
+		18FE1F491628550100389A13 /* TestInfo */ = {isa = PBXFileReference; lastKnownFileType = text; path = TestInfo; sourceTree = "<group>"; };
+		18FE1F4A1628550100389A13 /* basic.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = basic.m; sourceTree = "<group>"; };
+		18FE1F4B1628550100389A13 /* general.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = general.m; sourceTree = "<group>"; };
+		18FE1F4D1628550100389A13 /* TestInfo */ = {isa = PBXFileReference; lastKnownFileType = text; path = TestInfo; sourceTree = "<group>"; };
+		18FE1F4E1628550100389A13 /* basic.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = basic.m; sourceTree = "<group>"; };
+		18FE1F4F1628550100389A13 /* test00.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = test00.m; sourceTree = "<group>"; };
+		18FE1F501628550100389A13 /* test01.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = test01.m; sourceTree = "<group>"; };
+		18FE1F521628550100389A13 /* TestInfo */ = {isa = PBXFileReference; lastKnownFileType = text; path = TestInfo; sourceTree = "<group>"; };
+		18FE1F531628550100389A13 /* basic.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = basic.m; sourceTree = "<group>"; };
+		18FE1F541628550100389A13 /* general.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = general.m; sourceTree = "<group>"; };
+		18FE1F551628550100389A13 /* performers.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = performers.m; sourceTree = "<group>"; };
+		18FE1F561628550100389A13 /* thread.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = thread.m; sourceTree = "<group>"; };
+		18FE1F581628550100389A13 /* TestInfo */ = {isa = PBXFileReference; lastKnownFileType = text; path = TestInfo; sourceTree = "<group>"; };
+		18FE1F591628550100389A13 /* test00.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = test00.m; sourceTree = "<group>"; };
+		18FE1F5A1628550100389A13 /* test01.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = test01.m; sourceTree = "<group>"; };
+		18FE1F5C1628550100389A13 /* TestInfo */ = {isa = PBXFileReference; lastKnownFileType = text; path = TestInfo; sourceTree = "<group>"; };
+		18FE1F5D1628550100389A13 /* basic.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = basic.m; sourceTree = "<group>"; };
+		18FE1F5F1628550100389A13 /* TestInfo */ = {isa = PBXFileReference; lastKnownFileType = text; path = TestInfo; sourceTree = "<group>"; };
+		18FE1F601628550100389A13 /* basic.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = basic.m; sourceTree = "<group>"; };
+		18FE1F621628550100389A13 /* TestInfo */ = {isa = PBXFileReference; lastKnownFileType = text; path = TestInfo; sourceTree = "<group>"; };
+		18FE1F631628550100389A13 /* basic.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = basic.m; sourceTree = "<group>"; };
+		18FE1F641628550100389A13 /* memandfile.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = memandfile.m; sourceTree = "<group>"; };
+		18FE1F651628550100389A13 /* memandfile_2.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = memandfile_2.m; sourceTree = "<group>"; };
+		18FE1F661628550100389A13 /* pipe.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = pipe.m; sourceTree = "<group>"; };
+		18FE1F671628550100389A13 /* socket.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = socket.m; sourceTree = "<group>"; };
+		18FE1F681628550100389A13 /* socket_cs.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = socket_cs.m; sourceTree = "<group>"; };
+		18FE1F6A1628550100389A13 /* NSString_base.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSString_base.m; sourceTree = "<group>"; };
+		18FE1F6B1628550100389A13 /* NSString_custom.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSString_custom.m; sourceTree = "<group>"; };
+		18FE1F6C1628550100389A13 /* NSString_tests.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = NSString_tests.h; sourceTree = "<group>"; };
+		18FE1F6D1628550100389A13 /* NSString_zero_hash.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSString_zero_hash.m; sourceTree = "<group>"; };
+		18FE1F6E1628550100389A13 /* TestInfo */ = {isa = PBXFileReference; lastKnownFileType = text; path = TestInfo; sourceTree = "<group>"; };
+		18FE1F6F1628550100389A13 /* basic.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = basic.m; sourceTree = "<group>"; };
+		18FE1F701628550100389A13 /* bom.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = bom.m; sourceTree = "<group>"; };
+		18FE1F711628550100389A13 /* boolValue.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = boolValue.m; sourceTree = "<group>"; };
+		18FE1F721628550100389A13 /* locale.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = locale.m; sourceTree = "<group>"; };
+		18FE1F731628550100389A13 /* nuls_in_strings.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = nuls_in_strings.m; sourceTree = "<group>"; };
+		18FE1F741628550100389A13 /* order.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = order.m; sourceTree = "<group>"; };
+		18FE1F751628550100389A13 /* regex.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = regex.m; sourceTree = "<group>"; };
+		18FE1F761628550100389A13 /* test00.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = test00.m; sourceTree = "<group>"; };
+		18FE1F771628550100389A13 /* test01.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = test01.m; sourceTree = "<group>"; };
+		18FE1F781628550100389A13 /* test02.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = test02.m; sourceTree = "<group>"; };
+		18FE1F791628550100389A13 /* test03.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = test03.m; sourceTree = "<group>"; };
+		18FE1F7A1628550100389A13 /* test04.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = test04.m; sourceTree = "<group>"; };
+		18FE1F7B1628550100389A13 /* test05.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = test05.m; sourceTree = "<group>"; };
+		18FE1F7C1628550100389A13 /* test06.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = test06.m; sourceTree = "<group>"; };
+		18FE1F7D1628550100389A13 /* test07.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = test07.m; sourceTree = "<group>"; };
+		18FE1F7E1628550100389A13 /* utf8bom.txt */ = {isa = PBXFileReference; lastKnownFileType = text; path = utf8bom.txt; sourceTree = "<group>"; };
+		18FE1F801628550100389A13 /* GNUmakefile.preamble */ = {isa = PBXFileReference; lastKnownFileType = text; path = GNUmakefile.preamble; sourceTree = "<group>"; };
+		18FE1F821628550100389A13 /* GNUmakefile */ = {isa = PBXFileReference; lastKnownFileType = text; path = GNUmakefile; sourceTree = "<group>"; };
+		18FE1F831628550100389A13 /* NSZombie.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSZombie.m; sourceTree = "<group>"; };
+		18FE1F841628550100389A13 /* processgroup.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = processgroup.m; sourceTree = "<group>"; };
+		18FE1F851628550100389A13 /* testcat.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = testcat.m; sourceTree = "<group>"; };
+		18FE1F861628550100389A13 /* testecho.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = testecho.m; sourceTree = "<group>"; };
+		18FE1F871628550100389A13 /* TestInfo */ = {isa = PBXFileReference; lastKnownFileType = text; path = TestInfo; sourceTree = "<group>"; };
+		18FE1F881628550100389A13 /* basic.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = basic.m; sourceTree = "<group>"; };
+		18FE1F891628550100389A13 /* general.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = general.m; sourceTree = "<group>"; };
+		18FE1F8A1628550100389A13 /* launch.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = launch.m; sourceTree = "<group>"; };
+		18FE1F8B1628550100389A13 /* zombie.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = zombie.m; sourceTree = "<group>"; };
+		18FE1F8D1628550100389A13 /* lazy_thread.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = lazy_thread.m; sourceTree = "<group>"; };
+		18FE1F8F1628550100389A13 /* TestInfo */ = {isa = PBXFileReference; lastKnownFileType = text; path = TestInfo; sourceTree = "<group>"; };
+		18FE1F901628550100389A13 /* basic.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = basic.m; sourceTree = "<group>"; };
+		18FE1F911628550100389A13 /* create.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = create.m; sourceTree = "<group>"; };
+		18FE1F921628550100389A13 /* use.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = use.m; sourceTree = "<group>"; };
+		18FE1F941628550100389A13 /* Chunked.dat */ = {isa = PBXFileReference; lastKnownFileType = text; path = Chunked.dat; sourceTree = "<group>"; };
+		18FE1F951628550100389A13 /* GNUmakefile.preamble */ = {isa = PBXFileReference; lastKnownFileType = text; path = GNUmakefile.preamble; sourceTree = "<group>"; };
+		18FE1F971628550100389A13 /* GNUmakefile */ = {isa = PBXFileReference; lastKnownFileType = text; path = GNUmakefile; sourceTree = "<group>"; };
+		18FE1F981628550100389A13 /* capture.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = capture.m; sourceTree = "<group>"; };
+		18FE1F991628550100389A13 /* keepalive.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = keepalive.m; sourceTree = "<group>"; };
+		18FE1F9A1628550100389A13 /* respond.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = respond.m; sourceTree = "<group>"; };
+		18FE1F9B1628550100389A13 /* TestInfo */ = {isa = PBXFileReference; lastKnownFileType = text; path = TestInfo; sourceTree = "<group>"; };
+		18FE1F9C1628550100389A13 /* basic.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = basic.m; sourceTree = "<group>"; };
+		18FE1F9D1628550100389A13 /* test00.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = test00.m; sourceTree = "<group>"; };
+		18FE1F9E1628550100389A13 /* test01.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = test01.m; sourceTree = "<group>"; };
+		18FE1FA01628550100389A13 /* TestInfo */ = {isa = PBXFileReference; lastKnownFileType = text; path = TestInfo; sourceTree = "<group>"; };
+		18FE1FA11628550100389A13 /* basic.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = basic.m; sourceTree = "<group>"; };
+		18FE1FA31628550100389A13 /* GNUmakefile.preamble */ = {isa = PBXFileReference; lastKnownFileType = text; path = GNUmakefile.preamble; sourceTree = "<group>"; };
+		18FE1FA51628550100389A13 /* GNUmakefile */ = {isa = PBXFileReference; lastKnownFileType = text; path = GNUmakefile; sourceTree = "<group>"; };
+		18FE1FA61628550100389A13 /* StatusServer.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = StatusServer.m; sourceTree = "<group>"; };
+		18FE1FA71628550100389A13 /* TestInfo */ = {isa = PBXFileReference; lastKnownFileType = text; path = TestInfo; sourceTree = "<group>"; };
+		18FE1FA81628550100389A13 /* basic.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = basic.m; sourceTree = "<group>"; };
+		18FE1FA91628550100389A13 /* test00.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = test00.m; sourceTree = "<group>"; };
+		18FE1FAA1628550100389A13 /* test01.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = test01.m; sourceTree = "<group>"; };
+		18FE1FAC1628550100389A13 /* TestInfo */ = {isa = PBXFileReference; lastKnownFileType = text; path = TestInfo; sourceTree = "<group>"; };
+		18FE1FAD1628550100389A13 /* basic.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = basic.m; sourceTree = "<group>"; };
+		18FE1FAF1628550100389A13 /* TestInfo */ = {isa = PBXFileReference; lastKnownFileType = text; path = TestInfo; sourceTree = "<group>"; };
+		18FE1FB01628550100389A13 /* basic.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = basic.m; sourceTree = "<group>"; };
+		18FE1FB21628550100389A13 /* NSUndoManager_basic.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSUndoManager_basic.m; sourceTree = "<group>"; };
+		18FE1FB31628550100389A13 /* NSUndoManager_notifications.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSUndoManager_notifications.m; sourceTree = "<group>"; };
+		18FE1FB41628550100389A13 /* TestInfo */ = {isa = PBXFileReference; lastKnownFileType = text; path = TestInfo; sourceTree = "<group>"; };
+		18FE1FB61628550100389A13 /* TestInfo */ = {isa = PBXFileReference; lastKnownFileType = text; path = TestInfo; sourceTree = "<group>"; };
+		18FE1FB71628550100389A13 /* basic.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = basic.m; sourceTree = "<group>"; };
+		18FE1FB81628550100389A13 /* general.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = general.m; sourceTree = "<group>"; };
+		18FE1FBA1628550100389A13 /* TestInfo */ = {isa = PBXFileReference; lastKnownFileType = text; path = TestInfo; sourceTree = "<group>"; };
+		18FE1FBB1628550100389A13 /* basic.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = basic.m; sourceTree = "<group>"; };
+		18FE1FBC1628550100389A13 /* cdata.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = cdata.m; sourceTree = "<group>"; };
+		18FE1FBE1628550100389A13 /* TestInfo */ = {isa = PBXFileReference; lastKnownFileType = text; path = TestInfo; sourceTree = "<group>"; };
+		18FE1FBF1628550100389A13 /* attributes.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = attributes.m; sourceTree = "<group>"; };
+		18FE1FC01628550100389A13 /* basic.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = basic.m; sourceTree = "<group>"; };
+		18FE1FC11628550100389A13 /* children.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = children.m; sourceTree = "<group>"; };
+		18FE1FC21628550100389A13 /* transfer.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = transfer.m; sourceTree = "<group>"; };
+		18FE1FC41628550100389A13 /* TestInfo */ = {isa = PBXFileReference; lastKnownFileType = text; path = TestInfo; sourceTree = "<group>"; };
+		18FE1FC51628550100389A13 /* basic.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = basic.m; sourceTree = "<group>"; };
+		18FE1FC61628550100389A13 /* children.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = children.m; sourceTree = "<group>"; };
+		18FE1FC71628550100389A13 /* description.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = description.m; sourceTree = "<group>"; };
+		18FE1FC81628550100389A13 /* kinds.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = kinds.m; sourceTree = "<group>"; };
+		18FE1FC91628550100389A13 /* namespaces.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = namespaces.m; sourceTree = "<group>"; };
+		18FE1FCC1628550100389A13 /* internal-document.result */ = {isa = PBXFileReference; lastKnownFileType = text; path = "internal-document.result"; sourceTree = "<group>"; };
+		18FE1FCD1628550100389A13 /* internal-document.xml */ = {isa = PBXFileReference; lastKnownFileType = text.xml; path = "internal-document.xml"; sourceTree = "<group>"; };
+		18FE1FCE1628550100389A13 /* TestInfo */ = {isa = PBXFileReference; lastKnownFileType = text; path = TestInfo; sourceTree = "<group>"; };
+		18FE1FCF1628550100389A13 /* basic.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = basic.m; sourceTree = "<group>"; };
+		18FE1FD01628550100389A13 /* parse.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = parse.m; sourceTree = "<group>"; };
+		18FE1FD21628550100389A13 /* TestInfo */ = {isa = PBXFileReference; lastKnownFileType = text; path = TestInfo; sourceTree = "<group>"; };
+		18FE1FD31628550100389A13 /* non_ascii.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = non_ascii.m; sourceTree = "<group>"; };
+		18FE1FD41628550100389A13 /* non_ascii_utf16.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist; path = non_ascii_utf16.plist; sourceTree = "<group>"; };
+		18FE1FD51628550100389A13 /* non_ascii_utf16.strings */ = {isa = PBXFileReference; lastKnownFileType = text.plist.strings; path = non_ascii_utf16.strings; sourceTree = "<group>"; };
+		18FE1FD61628550100389A13 /* non_ascii_utf8.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist; path = non_ascii_utf8.plist; sourceTree = "<group>"; };
+		18FE1FD71628550100389A13 /* non_ascii_utf8.strings */ = {isa = PBXFileReference; lastKnownFileType = text.plist.strings; path = non_ascii_utf8.strings; sourceTree = "<group>"; };
+		18FE1FD81628550100389A13 /* test00.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = test00.m; sourceTree = "<group>"; };
+		18FE1FD91628550100389A13 /* test01.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = test01.m; sourceTree = "<group>"; };
+		18FE1FDA1628550100389A13 /* xml.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = xml.m; sourceTree = "<group>"; };
+		18FE1FDB1628550100389A13 /* TestInfo */ = {isa = PBXFileReference; lastKnownFileType = text; path = TestInfo; sourceTree = "<group>"; };
+		18FE1FDD1628550100389A13 /* TestInfo */ = {isa = PBXFileReference; lastKnownFileType = text; path = TestInfo; sourceTree = "<group>"; };
+		18FE1FDE1628550100389A13 /* test00.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = test00.m; sourceTree = "<group>"; };
+		18FE1FF21628550100389A13 /* TestInfo */ = {isa = PBXFileReference; lastKnownFileType = text; path = TestInfo; sourceTree = "<group>"; };
+		18FE1FF31628550100389A13 /* basictypes.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = basictypes.m; sourceTree = "<group>"; };
+		18FE1FF41628550100389A13 /* decoding.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = decoding.m; sourceTree = "<group>"; };
+		18FE1FF51628550100389A13 /* double-8.type */ = {isa = PBXFileReference; lastKnownFileType = file; path = "double-8.type"; sourceTree = "<group>"; };
+		18FE1FF61628550100389A13 /* float-4.type */ = {isa = PBXFileReference; lastKnownFileType = file; path = "float-4.type"; sourceTree = "<group>"; };
+		18FE1FF71628550100389A13 /* int-4.type */ = {isa = PBXFileReference; lastKnownFileType = file; path = "int-4.type"; sourceTree = "<group>"; };
+		18FE1FF81628550100389A13 /* llong-8.type */ = {isa = PBXFileReference; lastKnownFileType = file; path = "llong-8.type"; sourceTree = "<group>"; };
+		18FE1FF91628550100389A13 /* long-4.type */ = {isa = PBXFileReference; lastKnownFileType = file; path = "long-4.type"; sourceTree = "<group>"; };
+		18FE1FFA1628550100389A13 /* schar-1.type */ = {isa = PBXFileReference; lastKnownFileType = file; path = "schar-1.type"; sourceTree = "<group>"; };
+		18FE1FFB1628550100389A13 /* short-2.type */ = {isa = PBXFileReference; lastKnownFileType = file; path = "short-2.type"; sourceTree = "<group>"; };
+		18FE1FFC1628550100389A13 /* uchar-1.type */ = {isa = PBXFileReference; lastKnownFileType = file; path = "uchar-1.type"; sourceTree = "<group>"; };
+		18FE1FFD1628550100389A13 /* uint-4.type */ = {isa = PBXFileReference; lastKnownFileType = file; path = "uint-4.type"; sourceTree = "<group>"; };
+		18FE1FFE1628550100389A13 /* ullong-8.type */ = {isa = PBXFileReference; lastKnownFileType = file; path = "ullong-8.type"; sourceTree = "<group>"; };
+		18FE1FFF1628550100389A13 /* ulong-4.type */ = {isa = PBXFileReference; lastKnownFileType = file; path = "ulong-4.type"; sourceTree = "<group>"; };
+		18FE20001628550100389A13 /* ushort-2.type */ = {isa = PBXFileReference; lastKnownFileType = file; path = "ushort-2.type"; sourceTree = "<group>"; };
+		18FE20021628550100389A13 /* GSLock.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = GSLock.m; sourceTree = "<group>"; };
+		18FE20031628550100389A13 /* GSMime.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = GSMime.m; sourceTree = "<group>"; };
+		18FE20041628550100389A13 /* GSObjCRuntime.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = GSObjCRuntime.m; sourceTree = "<group>"; };
+		18FE20051628550100389A13 /* GSXML.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = GSXML.m; sourceTree = "<group>"; };
+		18FE20061628550100389A13 /* NSArchiver.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSArchiver.m; sourceTree = "<group>"; };
+		18FE20071628550100389A13 /* NSArray.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSArray.m; sourceTree = "<group>"; };
+		18FE20081628550100389A13 /* NSAttributedString.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSAttributedString.m; sourceTree = "<group>"; };
+		18FE20091628550100389A13 /* NSAutoreleasePool.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSAutoreleasePool.m; sourceTree = "<group>"; };
+		18FE200A1628550100389A13 /* NSBundle.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSBundle.m; sourceTree = "<group>"; };
+		18FE200B1628550100389A13 /* NSByteOrder.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSByteOrder.m; sourceTree = "<group>"; };
+		18FE200C1628550100389A13 /* NSCalendarDate.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSCalendarDate.m; sourceTree = "<group>"; };
+		18FE200D1628550100389A13 /* NSCharacterSet.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSCharacterSet.m; sourceTree = "<group>"; };
+		18FE200E1628550100389A13 /* NSClassDescription.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSClassDescription.m; sourceTree = "<group>"; };
+		18FE200F1628550100389A13 /* NSCoder.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSCoder.m; sourceTree = "<group>"; };
+		18FE20101628550100389A13 /* NSComparisonPredicate.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSComparisonPredicate.m; sourceTree = "<group>"; };
+		18FE20111628550100389A13 /* NSCompoundPredicate.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSCompoundPredicate.m; sourceTree = "<group>"; };
+		18FE20121628550100389A13 /* NSConnection.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSConnection.m; sourceTree = "<group>"; };
+		18FE20131628550100389A13 /* NSData.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSData.m; sourceTree = "<group>"; };
+		18FE20141628550100389A13 /* NSDate.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSDate.m; sourceTree = "<group>"; };
+		18FE20151628550100389A13 /* NSDateFormatter.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSDateFormatter.m; sourceTree = "<group>"; };
+		18FE20161628550100389A13 /* NSDebug.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSDebug.m; sourceTree = "<group>"; };
+		18FE20171628550100389A13 /* NSDecimal.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSDecimal.m; sourceTree = "<group>"; };
+		18FE20181628550100389A13 /* NSDecimalNumber.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSDecimalNumber.m; sourceTree = "<group>"; };
+		18FE20191628550100389A13 /* NSDictionary.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSDictionary.m; sourceTree = "<group>"; };
+		18FE201A1628550100389A13 /* NSDistantObject.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSDistantObject.m; sourceTree = "<group>"; };
+		18FE201B1628550100389A13 /* NSDistributedLock.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSDistributedLock.m; sourceTree = "<group>"; };
+		18FE201C1628550100389A13 /* NSDistributedNotificationCenter.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSDistributedNotificationCenter.m; sourceTree = "<group>"; };
+		18FE201D1628550100389A13 /* NSEnumerator.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSEnumerator.m; sourceTree = "<group>"; };
+		18FE201E1628550100389A13 /* NSError.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSError.m; sourceTree = "<group>"; };
+		18FE201F1628550100389A13 /* NSException.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSException.m; sourceTree = "<group>"; };
+		18FE20201628550100389A13 /* NSExpression.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSExpression.m; sourceTree = "<group>"; };
+		18FE20211628550100389A13 /* NSFileHandle.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSFileHandle.m; sourceTree = "<group>"; };
+		18FE20221628550100389A13 /* NSFileManager.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSFileManager.m; sourceTree = "<group>"; };
+		18FE20231628550100389A13 /* NSFormatter.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSFormatter.m; sourceTree = "<group>"; };
+		18FE20241628550100389A13 /* NSGeometry.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSGeometry.m; sourceTree = "<group>"; };
+		18FE20251628550100389A13 /* NSHTTPCookie.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSHTTPCookie.m; sourceTree = "<group>"; };
+		18FE20261628550100389A13 /* NSHTTPCookieStorage.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSHTTPCookieStorage.m; sourceTree = "<group>"; };
+		18FE20271628550100389A13 /* NSHashTable.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSHashTable.m; sourceTree = "<group>"; };
+		18FE20281628550100389A13 /* NSHost.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSHost.m; sourceTree = "<group>"; };
+		18FE20291628550100389A13 /* NSIndexPath.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSIndexPath.m; sourceTree = "<group>"; };
+		18FE202A1628550100389A13 /* NSIndexSet.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSIndexSet.m; sourceTree = "<group>"; };
+		18FE202B1628550100389A13 /* NSInvocation.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSInvocation.m; sourceTree = "<group>"; };
+		18FE202C1628550100389A13 /* NSKeyValueCoding.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSKeyValueCoding.m; sourceTree = "<group>"; };
+		18FE202D1628550100389A13 /* NSKeyValueObserving.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSKeyValueObserving.m; sourceTree = "<group>"; };
+		18FE202E1628550100389A13 /* NSKeyedArchiver.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSKeyedArchiver.m; sourceTree = "<group>"; };
+		18FE202F1628550100389A13 /* NSLock.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSLock.m; sourceTree = "<group>"; };
+		18FE20301628550100389A13 /* NSMapTable.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSMapTable.m; sourceTree = "<group>"; };
+		18FE20311628550100389A13 /* NSMethodSignature.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSMethodSignature.m; sourceTree = "<group>"; };
+		18FE20321628550100389A13 /* NSNotification.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSNotification.m; sourceTree = "<group>"; };
+		18FE20331628550100389A13 /* NSNotificationQueue.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSNotificationQueue.m; sourceTree = "<group>"; };
+		18FE20341628550100389A13 /* NSNull.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSNull.m; sourceTree = "<group>"; };
+		18FE20351628550100389A13 /* NSNumberFormatter.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSNumberFormatter.m; sourceTree = "<group>"; };
+		18FE20361628550100389A13 /* NSObjCRuntime.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSObjCRuntime.m; sourceTree = "<group>"; };
+		18FE20371628550100389A13 /* NSObject.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSObject.m; sourceTree = "<group>"; };
+		18FE20381628550100389A13 /* NSPathUtilities.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSPathUtilities.m; sourceTree = "<group>"; };
+		18FE20391628550100389A13 /* NSPort.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSPort.m; sourceTree = "<group>"; };
+		18FE203A1628550100389A13 /* NSPortCoder.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSPortCoder.m; sourceTree = "<group>"; };
+		18FE203B1628550100389A13 /* NSPortMessage.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSPortMessage.m; sourceTree = "<group>"; };
+		18FE203C1628550100389A13 /* NSPortNameServer.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSPortNameServer.m; sourceTree = "<group>"; };
+		18FE203D1628550100389A13 /* NSPredicate.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSPredicate.m; sourceTree = "<group>"; };
+		18FE203E1628550100389A13 /* NSProcessInfo.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSProcessInfo.m; sourceTree = "<group>"; };
+		18FE203F1628550100389A13 /* NSPropertyList.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSPropertyList.m; sourceTree = "<group>"; };
+		18FE20401628550100389A13 /* NSProtocolChecker.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSProtocolChecker.m; sourceTree = "<group>"; };
+		18FE20411628550100389A13 /* NSProxy.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSProxy.m; sourceTree = "<group>"; };
+		18FE20421628550100389A13 /* NSRange.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSRange.m; sourceTree = "<group>"; };
+		18FE20431628550100389A13 /* NSRunLoop.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSRunLoop.m; sourceTree = "<group>"; };
+		18FE20441628550100389A13 /* NSScanner.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSScanner.m; sourceTree = "<group>"; };
+		18FE20451628550100389A13 /* NSSerialization.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSSerialization.m; sourceTree = "<group>"; };
+		18FE20461628550100389A13 /* NSSet.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSSet.m; sourceTree = "<group>"; };
+		18FE20471628550100389A13 /* NSSortDescriptor.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSSortDescriptor.m; sourceTree = "<group>"; };
+		18FE20481628550100389A13 /* NSStream.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSStream.m; sourceTree = "<group>"; };
+		18FE20491628550100389A13 /* NSString.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSString.m; sourceTree = "<group>"; };
+		18FE204A1628550100389A13 /* NSTask.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSTask.m; sourceTree = "<group>"; };
+		18FE204B1628550100389A13 /* NSThread.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSThread.m; sourceTree = "<group>"; };
+		18FE204C1628550100389A13 /* NSTimeZone.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSTimeZone.m; sourceTree = "<group>"; };
+		18FE204D1628550100389A13 /* NSTimer.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSTimer.m; sourceTree = "<group>"; };
+		18FE204E1628550100389A13 /* NSURL.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSURL.m; sourceTree = "<group>"; };
+		18FE204F1628550100389A13 /* NSURLAuthenticationChallenge.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSURLAuthenticationChallenge.m; sourceTree = "<group>"; };
+		18FE20501628550100389A13 /* NSURLCache.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSURLCache.m; sourceTree = "<group>"; };
+		18FE20511628550100389A13 /* NSURLConnection.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSURLConnection.m; sourceTree = "<group>"; };
+		18FE20521628550100389A13 /* NSURLCredential.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSURLCredential.m; sourceTree = "<group>"; };
+		18FE20531628550100389A13 /* NSURLCredentialStorage.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSURLCredentialStorage.m; sourceTree = "<group>"; };
+		18FE20541628550100389A13 /* NSURLDownload.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSURLDownload.m; sourceTree = "<group>"; };
+		18FE20551628550100389A13 /* NSURLError.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSURLError.m; sourceTree = "<group>"; };
+		18FE20561628550100389A13 /* NSURLHandle.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSURLHandle.m; sourceTree = "<group>"; };
+		18FE20571628550100389A13 /* NSURLProtectionSpace.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSURLProtectionSpace.m; sourceTree = "<group>"; };
+		18FE20581628550100389A13 /* NSURLProtocol.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSURLProtocol.m; sourceTree = "<group>"; };
+		18FE20591628550100389A13 /* NSURLRequest.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSURLRequest.m; sourceTree = "<group>"; };
+		18FE205A1628550100389A13 /* NSURLResponse.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSURLResponse.m; sourceTree = "<group>"; };
+		18FE205B1628550100389A13 /* NSUndoManager.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSUndoManager.m; sourceTree = "<group>"; };
+		18FE205C1628550100389A13 /* NSUserDefaults.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSUserDefaults.m; sourceTree = "<group>"; };
+		18FE205D1628550100389A13 /* NSValue.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSValue.m; sourceTree = "<group>"; };
+		18FE205E1628550100389A13 /* NSXMLParser.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSXMLParser.m; sourceTree = "<group>"; };
+		18FE205F1628550100389A13 /* NSZone.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSZone.m; sourceTree = "<group>"; };
+		18FE20601628550100389A13 /* ObjCXX.mm */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.cpp.objcpp; path = ObjCXX.mm; sourceTree = "<group>"; };
+		18FE20611628550100389A13 /* TestInfo */ = {isa = PBXFileReference; lastKnownFileType = text; path = TestInfo; sourceTree = "<group>"; };
+		18FE20621628550100389A13 /* Unicode.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = Unicode.m; sourceTree = "<group>"; };
+/* End PBXFileReference section */
+
+/* Begin PBXFrameworksBuildPhase section */
+		1837DA121652D18400197E53 /* Frameworks */ = {
+			isa = PBXFrameworksBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				1837DA141652D18400197E53 /* Foundation.framework in Frameworks */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+		18394B181610D8E300335E85 /* Frameworks */ = {
+			isa = PBXFrameworksBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				184915A5163056E800B0ED83 /* libffi.dylib in Frameworks */,
+				1852899F16139A1B0016729B /* libiconv.dylib in Frameworks */,
+				1852899D161399FB0016729B /* libxslt.dylib in Frameworks */,
+				1852899B161399D70016729B /* libz.dylib in Frameworks */,
+				18528999161399720016729B /* libxml2.dylib in Frameworks */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+/* End PBXFrameworksBuildPhase section */
+
+/* Begin PBXGroup section */
+		1837D9C51652D0FF00197E53 /* Tools */ = {
+			isa = PBXGroup;
+			children = (
+				1837D9C61652D0FF00197E53 /* .cvsignore */,
+				1837D9C71652D0FF00197E53 /* AGSHtml.h */,
+				1837D9C81652D0FF00197E53 /* AGSHtml.m */,
+				1837D9C91652D0FF00197E53 /* AGSIndex.h */,
+				1837D9CA1652D0FF00197E53 /* AGSIndex.m */,
+				1837D9CB1652D0FF00197E53 /* AGSOutput.h */,
+				1837D9CC1652D0FF00197E53 /* AGSOutput.m */,
+				1837D9CD1652D0FF00197E53 /* AGSParser.h */,
+				1837D9CE1652D0FF00197E53 /* AGSParser.m */,
+				1837D9CF1652D0FF00197E53 /* BaseTools.gsdoc */,
+				1837D9D01652D0FF00197E53 /* DocMakefile */,
+				1837D9D11652D0FF00197E53 /* GNUmakefile */,
+				1837D9D21652D0FF00197E53 /* HTMLLinker.gsdoc */,
+				1837D9D31652D0FF00197E53 /* HTMLLinker.m */,
+				1837D9D41652D0FF00197E53 /* Makefile.postamble */,
+				1837D9D51652D0FF00197E53 /* Makefile.preamble */,
+				1837D9D61652D0FF00197E53 /* autogsdoc.1 */,
+				1837D9D71652D0FF00197E53 /* autogsdoc.m */,
+				1837D9D81652D0FF00197E53 /* cvtenc.1 */,
+				1837D9D91652D0FF00197E53 /* cvtenc.m */,
+				1837D9DA1652D0FF00197E53 /* defaults.1 */,
+				1837D9DB1652D0FF00197E53 /* defaults.m */,
+				1837D9DC1652D0FF00197E53 /* gdnc.1 */,
+				1837D9DD1652D0FF00197E53 /* gdnc.h */,
+				1837D9DE1652D0FF00197E53 /* gdnc.m */,
+				1837D9DF1652D0FF00197E53 /* gdomap.8 */,
+				1837D9E01652D0FF00197E53 /* gdomap.c */,
+				1837D9E11652D0FF00197E53 /* gdomap.gsdoc */,
+				1837D9E21652D0FF00197E53 /* gdomap.h */,
+				1837D9E31652D0FF00197E53 /* gsdoc-0_6_5.dtd */,
+				1837D9E41652D0FF00197E53 /* gsdoc-0_6_6.dtd */,
+				1837D9E51652D0FF00197E53 /* gsdoc-0_6_7.dtd */,
+				1837D9E61652D0FF00197E53 /* gsdoc-1_0_0.dtd */,
+				1837D9E71652D0FF00197E53 /* gsdoc-1_0_1.dtd */,
+				1837D9E81652D0FF00197E53 /* gsdoc-1_0_1.rnc */,
+				1837D9E91652D0FF00197E53 /* gsdoc-1_0_2.dtd */,
+				1837D9EA1652D0FF00197E53 /* gsdoc-1_0_3.dtd */,
+				1837D9EB1652D0FF00197E53 /* gsdoc.7 */,
+				1837D9EC1652D0FF00197E53 /* gsdoc.gsdoc */,
+				1837D9ED1652D0FF00197E53 /* gspath.1 */,
+				1837D9EE1652D0FF00197E53 /* gspath.m */,
+				1837D9EF1652D0FF00197E53 /* locale_alias.m */,
+				1837D9F01652D0FF00197E53 /* make_strings */,
+				1837D9FF1652D0FF00197E53 /* mkchlog.sh */,
+				1837DA001652D0FF00197E53 /* pl.m */,
+				1837DA011652D0FF00197E53 /* pl2link.m */,
+				1837DA021652D0FF00197E53 /* pldes.1 */,
+				1837DA031652D0FF00197E53 /* pldes.m */,
+				1837DA041652D0FF00197E53 /* plget.m */,
+				1837DA051652D0FF00197E53 /* plist-0_9.dtd */,
+				1837DA061652D0FF00197E53 /* plmerge.m */,
+				1837DA071652D0FF00197E53 /* plparse.m */,
+				1837DA081652D0FF00197E53 /* plser.m */,
+				1837DA091652D0FF00197E53 /* sfparse.1 */,
+				1837DA0A1652D0FF00197E53 /* sfparse.m */,
+				1837DA0B1652D0FF00197E53 /* xmlparse.1 */,
+				1837DA0C1652D0FF00197E53 /* xmlparse.m */,
+			);
+			path = Tools;
+			sourceTree = "<group>";
+		};
+		1837D9F01652D0FF00197E53 /* make_strings */ = {
+			isa = PBXGroup;
+			children = (
+				1837D9F11652D0FF00197E53 /* .cvsignore */,
+				1837D9F21652D0FF00197E53 /* GNUmakefile */,
+				1837D9F31652D0FF00197E53 /* GNUmakefile.preamble */,
+				1837D9F41652D0FF00197E53 /* README */,
+				1837D9F51652D0FF00197E53 /* SourceEntry.h */,
+				1837D9F61652D0FF00197E53 /* SourceEntry.m */,
+				1837D9F71652D0FF00197E53 /* StringsEntry.h */,
+				1837D9F81652D0FF00197E53 /* StringsEntry.m */,
+				1837D9F91652D0FF00197E53 /* StringsFile.h */,
+				1837D9FA1652D0FF00197E53 /* StringsFile.m */,
+				1837D9FB1652D0FF00197E53 /* Using.txt */,
+				1837D9FC1652D0FF00197E53 /* make_strings.h */,
+				1837D9FD1652D0FF00197E53 /* make_strings.m */,
+				1837D9FE1652D0FF00197E53 /* test1.m */,
+			);
+			path = make_strings;
+			sourceTree = "<group>";
+		};
+		18394B031610D85D00335E85 /* Additions */ = {
+			isa = PBXGroup;
+			children = (
+				18906EEE1610BF3C0003C892 /* NSArray+GNUstepBase.h */,
+				18906EEF1610BF3C0003C892 /* NSAttributedString+GNUstepBase.h */,
+				18906EF01610BF3C0003C892 /* NSBundle+GNUstepBase.h */,
+				18906EF11610BF3C0003C892 /* NSCalendarDate+GNUstepBase.h */,
+				18906EF21610BF3C0003C892 /* NSData+GNUstepBase.h */,
+				18906EF31610BF3C0003C892 /* NSDebug+GNUstepBase.h */,
+				18906EF41610BF3C0003C892 /* NSFileHandle+GNUstepBase.h */,
+				18906EF51610BF3C0003C892 /* NSLock+GNUstepBase.h */,
+				18906EF61610BF3C0003C892 /* NSMutableString+GNUstepBase.h */,
+				18906EF71610BF3C0003C892 /* NSNetServices+GNUstepBase.h */,
+				18906EF81610BF3C0003C892 /* NSNumber+GNUstepBase.h */,
+				18906EF91610BF3C0003C892 /* NSObject+GNUstepBase.h */,
+				18906EFA1610BF3C0003C892 /* NSProcessInfo+GNUstepBase.h */,
+				18906EFB1610BF3C0003C892 /* NSStream+GNUstepBase.h */,
+				18906EFC1610BF3C0003C892 /* NSString+GNUstepBase.h */,
+				18906EFD1610BF3C0003C892 /* NSTask+GNUstepBase.h */,
+				18906EFE1610BF3C0003C892 /* NSThread+GNUstepBase.h */,
+				18906EFF1610BF3C0003C892 /* NSURL+GNUstepBase.h */,
+			);
+			name = Additions;
+			sourceTree = "<group>";
+		};
+		18394B301610D93700335E85 /* Foundation */ = {
+			isa = PBXGroup;
+			children = (
+				18394B311610D95600335E85 /* Foundation-Info.plist */,
+				18394B321610D95600335E85 /* Foundation-Prefix.pch */,
+			);
+			name = Foundation;
+			sourceTree = "<group>";
+		};
+		18394BF21610DC0B00335E85 /* GNUstepBase */ = {
+			isa = PBXGroup;
+			children = (
+				18641D0D1678AD04003C6E11 /* GSSocksParser */,
+				18906F391610BF3C0003C892 /* GSArray.m */,
+				18906F3A1610BF3C0003C892 /* GSAttributedString.m */,
+				18906F351610BF3C0003C892 /* CXXException.m */,
+				18906F3C1610BF3C0003C892 /* GSAvahiClient.m */,
+				18906F3D1610BF3C0003C892 /* GSAvahiNetService.m */,
+				18906F3E1610BF3C0003C892 /* GSAvahiNetServiceBrowser.m */,
+				18906F401610BF3C0003C892 /* GSAvahiRunLoopIntegration.m */,
+				18906F411610BF3C0003C892 /* GSBlocks.m */,
+				18906F421610BF3C0003C892 /* GSConcreteValue.m */,
+				18906F431610BF3C0003C892 /* GSConcreteValueTemplate.m */,
+				18906F441610BF3C0003C892 /* GSCountedSet.m */,
+				18906F451610BF3C0003C892 /* GSDictionary.m */,
+				18906F471610BF3C0003C892 /* GSFFCallInvocation.m */,
+				18906F481610BF3C0003C892 /* GSFFIInvocation.m */,
+				18906F491610BF3C0003C892 /* GSFTPURLHandle.m */,
+				18906F4C1610BF3C0003C892 /* GSFileHandle.m */,
+				18906F4D1610BF3C0003C892 /* GSFormat.m */,
+				18906F4E1610BF3C0003C892 /* GSHTTPAuthentication.m */,
+				18906F4F1610BF3C0003C892 /* GSHTTPURLHandle.m */,
+				18906F511610BF3C0003C892 /* GSICUString.m */,
+				18906F541610BF3C0003C892 /* GSLocale.m */,
+				18906F551610BF3C0003C892 /* GSMDNSNetServices.m */,
+				18906F5C1610BF3C0003C892 /* GSQuickSort.m */,
+				18906F5F1610BF3C0003C892 /* GSRunLoopWatcher.m */,
+				1890B34016F3BC3300187826 /* GSPrivateHash.m */,
+				18906F601610BF3C0003C892 /* GSSet.m */,
+				18906F611610BF3C0003C892 /* GSShellSort.m */,
+				18906F631610BF3C0003C892 /* GSSocketStream.m */,
+				18906F661610BF3C0003C892 /* GSStream.m */,
+				18906F671610BF3C0003C892 /* GSString.m */,
+				18906F691610BF3C0003C892 /* GSTLS.m */,
+				18906F6A1610BF3C0003C892 /* GSTimSort.m */,
+				18906F6C1610BF3C0003C892 /* GSValue.m */,
+			);
+			name = GNUstepBase;
+			sourceTree = "<group>";
+		};
+		18394BF31610DC4B00335E85 /* Private Headers */ = {
+			isa = PBXGroup;
+			children = (
+				18394C001610EB3F00335E85 /* Foundation */,
+				18394BF41610DC6A00335E85 /* GNUstepBase */,
+			);
+			name = "Private Headers";
+			sourceTree = "<group>";
+		};
+		18394BF41610DC6A00335E85 /* GNUstepBase */ = {
+			isa = PBXGroup;
+			children = (
+				18906F3B1610BF3C0003C892 /* GSAvahiClient.h */,
+				18906F3F1610BF3C0003C892 /* GSAvahiRunLoopIntegration.h */,
+				18906F461610BF3C0003C892 /* GSDispatch.h */,
+				18906F4A1610BF3C0003C892 /* GSFastEnumeration.h */,
+				18906F4B1610BF3C0003C892 /* GSFileHandle.h */,
+				18906F501610BF3C0003C892 /* GSICUString.h */,
+				18906F521610BF3C0003C892 /* GSInternal.h */,
+				18906F531610BF3C0003C892 /* GSInvocation.h */,
+				18906F561610BF3C0003C892 /* GSNetServices.h */,
+				18906F571610BF3C0003C892 /* GSNetwork.h */,
+				18906F581610BF3C0003C892 /* GSNumberTypes.h */,
+				18906F591610BF3C0003C892 /* GSPThread.h */,
+				18906F5A1610BF3C0003C892 /* GSPortPrivate.h */,
+				18906F5B1610BF3C0003C892 /* GSPrivate.h */,
+				18906F5D1610BF3C0003C892 /* GSRunLoopCtxt.h */,
+				18906F5E1610BF3C0003C892 /* GSRunLoopWatcher.h */,
+				18906F621610BF3C0003C892 /* GSSocketStream.h */,
+				18906F641610BF3C0003C892 /* GSSorting.h */,
+				18906F651610BF3C0003C892 /* GSStream.h */,
+				18906F681610BF3C0003C892 /* GSTLS.h */,
+				18906F6B1610BF3C0003C892 /* GSURLPrivate.h */,
+				18906F6D1610BF3C0003C892 /* GSeq.h */,
+			);
+			name = GNUstepBase;
+			sourceTree = "<group>";
+		};
+		18394BFF1610E9D600335E85 /* Foundation */ = {
+			isa = PBXGroup;
+			children = (
+				18F8D04F1724534E00420DA5 /* KVO */,
+				18906F701610BF3C0003C892 /* NSAffineTransform.m */,
+				18906F711610BF3C0003C892 /* NSArchiver.m */,
+				18906F721610BF3C0003C892 /* NSArray.m */,
+				18906F731610BF3C0003C892 /* NSAssertionHandler.m */,
+				18906F741610BF3C0003C892 /* NSAttributedString.m */,
+				18906F751610BF3C0003C892 /* NSAutoreleasePool.m */,
+				18906F761610BF3C0003C892 /* NSBundle.m */,
+				18906F771610BF3C0003C892 /* NSCache.m */,
+				18906F781610BF3C0003C892 /* NSCachedURLResponse.m */,
+				18906F791610BF3C0003C892 /* NSCalendar.m */,
+				18906F7A1610BF3C0003C892 /* NSCalendarDate.m */,
+				18906F7C1610BF3C0003C892 /* NSCallBacks.m */,
+				18906F7D1610BF3C0003C892 /* NSCharacterSet.m */,
+				18906F7F1610BF3C0003C892 /* NSClassDescription.m */,
+				18906F801610BF3C0003C892 /* NSCoder.m */,
+				18906F811610BF3C0003C892 /* NSConcreteHashTable.m */,
+				18906F821610BF3C0003C892 /* NSConcreteMapTable.m */,
+				18906F841610BF3C0003C892 /* NSConcretePointerFunctions.m */,
+				18906F851610BF3C0003C892 /* NSConnection.m */,
+				18906F861610BF3C0003C892 /* NSCopyObject.m */,
+				18906F871610BF3C0003C892 /* NSCountedSet.m */,
+				18906F881610BF3C0003C892 /* NSData.m */,
+				18906F891610BF3C0003C892 /* NSDate.m */,
+				18906F8A1610BF3C0003C892 /* NSDateFormatter.m */,
+				18906F8B1610BF3C0003C892 /* NSDebug.m */,
+				18906F8C1610BF3C0003C892 /* NSDecimal.m */,
+				18906F8D1610BF3C0003C892 /* NSDecimalNumber.m */,
+				18906F8E1610BF3C0003C892 /* NSDictionary.m */,
+				18906F8F1610BF3C0003C892 /* NSDistantObject.m */,
+				18906F901610BF3C0003C892 /* NSDistributedLock.m */,
+				18906F911610BF3C0003C892 /* NSDistributedNotificationCenter.m */,
+				18906F921610BF3C0003C892 /* NSEnumerator.m */,
+				18906F931610BF3C0003C892 /* NSError.m */,
+				18906F941610BF3C0003C892 /* NSException.m */,
+				18906F951610BF3C0003C892 /* NSFileHandle.m */,
+				18906F961610BF3C0003C892 /* NSFileManager.m */,
+				18906F971610BF3C0003C892 /* NSFormatter.m */,
+				18906F981610BF3C0003C892 /* NSGarbageCollector.m */,
+				18906F991610BF3C0003C892 /* NSGeometry.m */,
+				18906F9A1610BF3C0003C892 /* NSHTTPCookie.m */,
+				18906F9B1610BF3C0003C892 /* NSHTTPCookieStorage.m */,
+				18906F9C1610BF3C0003C892 /* NSHashTable.m */,
+				18906F9D1610BF3C0003C892 /* NSHost.m */,
+				18906F9E1610BF3C0003C892 /* NSIndexPath.m */,
+				18906F9F1610BF3C0003C892 /* NSIndexSet.m */,
+				18906FA01610BF3C0003C892 /* NSInvocation.ff.m */,
+				18D8BEA2164B5FF700942A5D /* NSInvocation.x86_64.m */,
+				180DFAE9165BF94E00573635 /* NSInvocation.x86_64.S */,
+				18906FA11610BF3C0003C892 /* NSJSONSerialization.m */,
+				18906FA21610BF3C0003C892 /* NSKeyValueCoding.m */,
+				18906FA31610BF3C0003C892 /* NSKeyValueMutableArray.m */,
+				18906FA41610BF3C0003C892 /* NSKeyValueMutableSet.m */,
+				18906FA61610BF3C0003C892 /* NSKeyedArchiver.m */,
+				18906FA71610BF3C0003C892 /* NSKeyedUnarchiver.m */,
+				18906FA81610BF3C0003C892 /* NSLocale.m */,
+				18906FA91610BF3C0003C892 /* NSLock.m */,
+				18906FAA1610BF3C0003C892 /* NSLog.m */,
+				18906FAB1610BF3C0003C892 /* NSMapTable.m */,
+				18906FAC1610BF3C0003C892 /* NSMessagePort.m */,
+				18906FAD1610BF3C0003C892 /* NSMessagePortNameServer.m */,
+				18906FAE1610BF3C0003C892 /* NSMethodSignature.m */,
+				18906FAF1610BF3C0003C892 /* NSNetServices.m */,
+				18906FB01610BF3C0003C892 /* NSNotification.m */,
+				18906FB11610BF3C0003C892 /* NSNotificationCenter.m */,
+				18906FB21610BF3C0003C892 /* NSNotificationQueue.m */,
+				18906FB31610BF3C0003C892 /* NSNull.m */,
+				18906FB41610BF3C0003C892 /* NSNumber.m */,
+				18906FB51610BF3C0003C892 /* NSNumberFormatter.m */,
+				18906FB71610BF3C0003C892 /* NSObjCRuntime.m */,
+				18906FB91610BF3C0003C892 /* NSObject.m */,
+				18906FBA1610BF3C0003C892 /* NSOperation.m */,
+				18906FBB1610BF3C0003C892 /* NSPage.m */,
+				18906FBC1610BF3C0003C892 /* NSPathUtilities.m */,
+				18906FBD1610BF3C0003C892 /* NSPipe.m */,
+				18906FBE1610BF3C0003C892 /* NSPointerArray.m */,
+				18906FBF1610BF3C0003C892 /* NSPointerFunctions.m */,
+				18906FC01610BF3C0003C892 /* NSPort.m */,
+				18906FC11610BF3C0003C892 /* NSPortCoder.m */,
+				18906FC21610BF3C0003C892 /* NSPortMessage.m */,
+				18906FC31610BF3C0003C892 /* NSPortNameServer.m */,
+				18906FC41610BF3C0003C892 /* NSPredicate.m */,
+				18906FC51610BF3C0003C892 /* NSProcessInfo.m */,
+				18906FC61610BF3C0003C892 /* NSPropertyList.m */,
+				18906FC71610BF3C0003C892 /* NSProtocolChecker.m */,
+				18906FC81610BF3C0003C892 /* NSProxy.m */,
+				18906FC91610BF3C0003C892 /* NSRange.m */,
+				18906FCA1610BF3C0003C892 /* NSRegularExpression.m */,
+				18906FCB1610BF3C0003C892 /* NSRunLoop.m */,
+				18906FCC1610BF3C0003C892 /* NSScanner.m */,
+				18906FCD1610BF3C0003C892 /* NSSerializer.m */,
+				18906FCE1610BF3C0003C892 /* NSSet.m */,
+				18906FCF1610BF3C0003C892 /* NSSocketPort.m */,
+				18906FD01610BF3C0003C892 /* NSSocketPortNameServer.m */,
+				18906FD11610BF3C0003C892 /* NSSortDescriptor.m */,
+				18906FD21610BF3C0003C892 /* NSSpellServer.m */,
+				18906FD31610BF3C0003C892 /* NSString.m */,
+				18906FD41610BF3C0003C892 /* NSTask.m */,
+				18906FD51610BF3C0003C892 /* NSTextCheckingResult.m */,
+				18906FD61610BF3C0003C892 /* NSThread.m */,
+				18906FD71610BF3C0003C892 /* NSTimeZone.m */,
+				18906FD81610BF3C0003C892 /* NSTimer.m */,
+				18906FD91610BF3C0003C892 /* NSURL.m */,
+				18906FDA1610BF3C0003C892 /* NSURLAuthenticationChallenge.m */,
+				18906FDB1610BF3C0003C892 /* NSURLCache.m */,
+				18906FDC1610BF3C0003C892 /* NSURLConnection.m */,
+				18906FDD1610BF3C0003C892 /* NSURLCredential.m */,
+				18906FDE1610BF3C0003C892 /* NSURLCredentialStorage.m */,
+				18906FDF1610BF3C0003C892 /* NSURLDownload.m */,
+				18906FE01610BF3C0003C892 /* NSURLHandle.m */,
+				18906FE11610BF3C0003C892 /* NSURLProtectionSpace.m */,
+				18906FE21610BF3C0003C892 /* NSURLProtocol.m */,
+				18906FE31610BF3C0003C892 /* NSURLRequest.m */,
+				18906FE41610BF3C0003C892 /* NSURLResponse.m */,
+				18906FE51610BF3C0003C892 /* NSUnarchiver.m */,
+				18906FE61610BF3C0003C892 /* NSUndoManager.m */,
+				18906FE71610BF3C0003C892 /* NSUserDefaults.m */,
+				18906FE81610BF3C0003C892 /* NSValue.m */,
+				18906FE91610BF3C0003C892 /* NSValueTransformer.m */,
+				18906FEA1610BF3C0003C892 /* NSXMLDTD.m */,
+				18906FEB1610BF3C0003C892 /* NSXMLDTDNode.m */,
+				18906FEC1610BF3C0003C892 /* NSXMLDocument.m */,
+				18906FED1610BF3C0003C892 /* NSXMLElement.m */,
+				18906FEE1610BF3C0003C892 /* NSXMLNode.m */,
+				18906FEF1610BF3C0003C892 /* NSXMLParser.m */,
+				18906FF11610BF3C0003C892 /* NSZone.m */,
+			);
+			name = Foundation;
+			sourceTree = "<group>";
+		};
+		18394C001610EB3F00335E85 /* Foundation */ = {
+			isa = PBXGroup;
+			children = (
+				18906F7B1610BF3C0003C892 /* NSCallBacks.h */,
+				18906F7E1610BF3C0003C892 /* NSCharacterSetData.h */,
+				18906F831610BF3C0003C892 /* NSConcretePointerFunctions.h */,
+				18906FB61610BF3C0003C892 /* NSNumberMethods.h */,
+				18906FF01610BF3C0003C892 /* NSXMLPrivate.h */,
+			);
+			name = Foundation;
+			sourceTree = "<group>";
+		};
+		185289AD1613A1060016729B /* config */ = {
+			isa = PBXGroup;
+			children = (
+				185289AE1613A1060016729B /* addlibrarypath.m4 */,
+				185289AF1613A1060016729B /* codeset.m4 */,
+				185289B01613A1060016729B /* config.align.c */,
+				185289B11613A1060016729B /* config.builtin_apply.c */,
+				185289B21613A1060016729B /* config.constant-string-class.m */,
+				185289B31613A1060016729B /* config.constant-string-encoding.c */,
+				185289B41613A1060016729B /* config.ffi.c */,
+				185289B51613A1060016729B /* config.forward.m */,
+				185289B61613A1060016729B /* config.forward2.m */,
+				185289B71613A1060016729B /* config.initialize.m */,
+				185289B81613A1060016729B /* config.joinable.m */,
+				185289B91613A1060016729B /* config.kvmopen.c */,
+				185289BA1613A1060016729B /* config.loadtest.m */,
+				185289BB1613A1060016729B /* config.nested.c */,
+				185289BC1613A1060016729B /* config.nextcc.h */,
+				185289BD1613A1060016729B /* config.nextrt.m */,
+				185289BE1613A1060016729B /* config.non-fragile-ivars.m */,
+				185289BF1613A1060016729B /* config.objc.m */,
+				185289C01613A1060016729B /* config.poll-dev.c */,
+				185289C11613A1060016729B /* config.poll.c */,
+				185289C21613A1060016729B /* config.printf.c */,
+				185289C31613A1060016729B /* config.proccmd.c */,
+				185289C41613A1060016729B /* config.psinfo.c */,
+				185289C51613A1060016729B /* config.retframe.c */,
+				185289C61613A1060016729B /* config.reuseaddr.c */,
+				185289C71613A1060016729B /* config.setUncaughtExceptionHandler.m */,
+				185289C81613A1060016729B /* config.set_unexpected.m */,
+				185289C91613A1060016729B /* config.trampoline.c */,
+				185289CA1613A1060016729B /* config.unexpected.m */,
+				185289CB1613A1060016729B /* config.vasprintf.c */,
+				185289CC1613A1060016729B /* config.vsprintf.c */,
+				185289CD1613A1060016729B /* config.wprintf.c */,
+				185289CE1613A1060016729B /* icu.m4 */,
+				185289CF1613A1060016729B /* objc-common.g */,
+				185289D01613A1060016729B /* objc-con-autoload.m4 */,
+				185289D11613A1060016729B /* objc-sys-dynamic.m4 */,
+				185289D21613A1060016729B /* pathtls.m4 */,
+				185289D31613A1060016729B /* pathxml.m4 */,
+				185289D41613A1060016729B /* procfs-exe-link.m4 */,
+				185289D51613A1060016729B /* procfs.m4 */,
+			);
+			path = config;
+			sourceTree = SOURCE_ROOT;
+		};
+		1857833D17551CC200CB7160 /* NSNotification */ = {
+			isa = PBXGroup;
+			children = (
+				1857833F17551CC200CB7160 /* TestInfo */,
+				1857834017551CC200CB7160 /* basic.m */,
+				1857834117551CC200CB7160 /* general.m */,
+			);
+			path = NSNotification;
+			sourceTree = "<group>";
+		};
+		18641D0D1678AD04003C6E11 /* GSSocksParser */ = {
+			isa = PBXGroup;
+			children = (
+				18641D0E1678AD04003C6E11 /* GSSocks4Parser.h */,
+				18641D0F1678AD04003C6E11 /* GSSocks4Parser.m */,
+				18641D101678AD04003C6E11 /* GSSocks5Parser.h */,
+				18641D111678AD04003C6E11 /* GSSocks5Parser.m */,
+				18641D121678AD04003C6E11 /* GSSocksParser.h */,
+				18641D131678AD04003C6E11 /* GSSocksParser.m */,
+				18641D141678AD04003C6E11 /* GSSocksParserPrivate.h */,
+				18641D151678AD04003C6E11 /* GSSocksParserPrivate.m */,
+			);
+			path = GSSocksParser;
+			sourceTree = "<group>";
+		};
+		18906E351610BC4C0003C892 = {
+			isa = PBXGroup;
+			children = (
+				18906E661610BF3C0003C892 /* Headers */,
+				18394BF31610DC4B00335E85 /* Private Headers */,
+				18906F081610BF3C0003C892 /* Source */,
+				18906E4B1610BC4C0003C892 /* Supporting Files */,
+				18FE1E271628550000389A13 /* Tests */,
+				1837D9C51652D0FF00197E53 /* Tools */,
+				18906E421610BC4C0003C892 /* Products */,
+				18906E431610BC4C0003C892 /* Libraries */,
+			);
+			sourceTree = "<group>";
+		};
+		18906E421610BC4C0003C892 /* Products */ = {
+			isa = PBXGroup;
+			children = (
+				18394B1C1610D8E300335E85 /* Foundation.framework */,
+				1837DA191652D18400197E53 /* gdnc */,
+			);
+			name = Products;
+			sourceTree = "<group>";
+		};
+		18906E431610BC4C0003C892 /* Libraries */ = {
+			isa = PBXGroup;
+			children = (
+				184915A4163056E800B0ED83 /* libffi.dylib */,
+				185289A016139A470016729B /* libgcrypt.11.dylib */,
+				1852899E16139A180016729B /* libiconv.dylib */,
+				1852899C161399F80016729B /* libxslt.dylib */,
+				1852899A161399D40016729B /* libz.dylib */,
+				185289981613996F0016729B /* libxml2.dylib */,
+				18528980161397F40016729B /* libgnutls.26.dylib */,
+				18394BFD1610E97A00335E85 /* libicuuc.48.1.dylib */,
+				18394BFB1610E8FB00335E85 /* libicui18n.48.1.dylib */,
+				18394BF91610E85A00335E85 /* libicucore.dylib */,
+				18394BF71610E84A00335E85 /* libicudata.48.1.dylib */,
+				18394BF51610E73300335E85 /* libobjc.dylib */,
+			);
+			name = Libraries;
+			sourceTree = "<group>";
+		};
+		18906E4B1610BC4C0003C892 /* Supporting Files */ = {
+			isa = PBXGroup;
+			children = (
+				18394B301610D93700335E85 /* Foundation */,
+				185289AD1613A1060016729B /* config */,
+				185289AB1613A06F0016729B /* configure.ac */,
+				18394A9C1610C04600335E85 /* configure */,
+				18906E621610BEC80003C892 /* README */,
+				18FE1E12162716A200389A13 /* ChangeLog */,
+				18FE1E13162716A200389A13 /* ChangeLog.1 */,
+				18FE1E14162716A200389A13 /* ChangeLog.2 */,
+			);
+			name = "Supporting Files";
+			path = base;
+			sourceTree = "<group>";
+		};
+		18906E661610BF3C0003C892 /* Headers */ = {
+			isa = PBXGroup;
+			children = (
+				18906E671610BF3C0003C892 /* Foundation */,
+				18906EDB1610BF3C0003C892 /* GNUstepBase */,
+			);
+			path = Headers;
+			sourceTree = "<group>";
+		};
+		18906E671610BF3C0003C892 /* Foundation */ = {
+			isa = PBXGroup;
+			children = (
+				18394B031610D85D00335E85 /* Additions */,
+				18906E681610BF3C0003C892 /* Foundation.h */,
+				18906E691610BF3C0003C892 /* FoundationErrors.h */,
+				18906E6A1610BF3C0003C892 /* NSAffineTransform.h */,
+				18906E6B1610BF3C0003C892 /* NSArchiver.h */,
+				18906E6C1610BF3C0003C892 /* NSArray.h */,
+				18906E6D1610BF3C0003C892 /* NSAttributedString.h */,
+				18906E6E1610BF3C0003C892 /* NSAutoreleasePool.h */,
+				18906E6F1610BF3C0003C892 /* NSBundle.h */,
+				18906E701610BF3C0003C892 /* NSByteOrder.h */,
+				18906E711610BF3C0003C892 /* NSCache.h */,
+				18906E721610BF3C0003C892 /* NSCalendar.h */,
+				18906E731610BF3C0003C892 /* NSCalendarDate.h */,
+				18906E741610BF3C0003C892 /* NSCharacterSet.h */,
+				18906E751610BF3C0003C892 /* NSClassDescription.h */,
+				18906E761610BF3C0003C892 /* NSCoder.h */,
+				18906E771610BF3C0003C892 /* NSComparisonPredicate.h */,
+				18906E781610BF3C0003C892 /* NSCompoundPredicate.h */,
+				18906E791610BF3C0003C892 /* NSConnection.h */,
+				18906E7A1610BF3C0003C892 /* NSData.h */,
+				18906E7B1610BF3C0003C892 /* NSDate.h */,
+				18906E7C1610BF3C0003C892 /* NSDateFormatter.h */,
+				18906E7D1610BF3C0003C892 /* NSDebug.h */,
+				18906E7E1610BF3C0003C892 /* NSDecimal.h */,
+				18906E7F1610BF3C0003C892 /* NSDecimalNumber.h */,
+				18906E801610BF3C0003C892 /* NSDictionary.h */,
+				18906E811610BF3C0003C892 /* NSDistantObject.h */,
+				18906E821610BF3C0003C892 /* NSDistributedLock.h */,
+				18906E831610BF3C0003C892 /* NSDistributedNotificationCenter.h */,
+				18906E841610BF3C0003C892 /* NSEnumerator.h */,
+				18906E851610BF3C0003C892 /* NSError.h */,
+				18906E861610BF3C0003C892 /* NSErrorRecoveryAttempting.h */,
+				18906E871610BF3C0003C892 /* NSException.h */,
+				18906E881610BF3C0003C892 /* NSExpression.h */,
+				18906E891610BF3C0003C892 /* NSFileHandle.h */,
+				18906E8A1610BF3C0003C892 /* NSFileManager.h */,
+				18906E8B1610BF3C0003C892 /* NSFormatter.h */,
+				18906E8C1610BF3C0003C892 /* NSGarbageCollector.h */,
+				18906E8D1610BF3C0003C892 /* NSGeometry.h */,
+				18906E8E1610BF3C0003C892 /* NSHTTPCookie.h */,
+				18906E8F1610BF3C0003C892 /* NSHTTPCookieStorage.h */,
+				18906E901610BF3C0003C892 /* NSHashTable.h */,
+				18906E911610BF3C0003C892 /* NSHost.h */,
+				18906E921610BF3C0003C892 /* NSIndexPath.h */,
+				18906E931610BF3C0003C892 /* NSIndexSet.h */,
+				18906E941610BF3C0003C892 /* NSInvocation.h */,
+				18906E951610BF3C0003C892 /* NSJSONSerialization.h */,
+				18906E961610BF3C0003C892 /* NSKeyValueCoding.h */,
+				18906E971610BF3C0003C892 /* NSKeyValueObserving.h */,
+				18906E981610BF3C0003C892 /* NSKeyedArchiver.h */,
+				18906E991610BF3C0003C892 /* NSLocale.h */,
+				18906E9A1610BF3C0003C892 /* NSLock.h */,
+				18906E9B1610BF3C0003C892 /* NSMapTable.h */,
+				18906E9C1610BF3C0003C892 /* NSMethodSignature.h */,
+				18906E9D1610BF3C0003C892 /* NSNetServices.h */,
+				18906E9E1610BF3C0003C892 /* NSNotification.h */,
+				18906E9F1610BF3C0003C892 /* NSNotificationQueue.h */,
+				18906EA01610BF3C0003C892 /* NSNull.h */,
+				18906EA11610BF3C0003C892 /* NSNumberFormatter.h */,
+				18906EA21610BF3C0003C892 /* NSObjCRuntime.h */,
+				18906EA31610BF3C0003C892 /* NSObject.h */,
+				18906EA41610BF3C0003C892 /* NSOperation.h */,
+				18906EA51610BF3C0003C892 /* NSPathUtilities.h */,
+				18906EA61610BF3C0003C892 /* NSPointerArray.h */,
+				18906EA71610BF3C0003C892 /* NSPointerFunctions.h */,
+				18906EA81610BF3C0003C892 /* NSPort.h */,
+				18906EA91610BF3C0003C892 /* NSPortCoder.h */,
+				18906EAA1610BF3C0003C892 /* NSPortMessage.h */,
+				18906EAB1610BF3C0003C892 /* NSPortNameServer.h */,
+				18906EAC1610BF3C0003C892 /* NSPredicate.h */,
+				18906EAD1610BF3C0003C892 /* NSProcessInfo.h */,
+				18906EAE1610BF3C0003C892 /* NSPropertyList.h */,
+				18906EAF1610BF3C0003C892 /* NSProtocolChecker.h */,
+				18906EB01610BF3C0003C892 /* NSProxy.h */,
+				18906EB11610BF3C0003C892 /* NSRange.h */,
+				18906EB21610BF3C0003C892 /* NSRegularExpression.h */,
+				18906EB31610BF3C0003C892 /* NSRunLoop.h */,
+				18906EB41610BF3C0003C892 /* NSScanner.h */,
+				18906EB51610BF3C0003C892 /* NSScriptWhoseTests.h */,
+				18906EB61610BF3C0003C892 /* NSSerialization.h */,
+				18906EB71610BF3C0003C892 /* NSSet.h */,
+				18906EB81610BF3C0003C892 /* NSSortDescriptor.h */,
+				18906EB91610BF3C0003C892 /* NSSpellServer.h */,
+				18906EBA1610BF3C0003C892 /* NSStream.h */,
+				18906EBB1610BF3C0003C892 /* NSString.h */,
+				18906EBC1610BF3C0003C892 /* NSTask.h */,
+				18906EBD1610BF3C0003C892 /* NSTextCheckingResult.h */,
+				18906EBE1610BF3C0003C892 /* NSThread.h */,
+				18906EBF1610BF3C0003C892 /* NSTimeZone.h */,
+				18906EC01610BF3C0003C892 /* NSTimer.h */,
+				18906EC11610BF3C0003C892 /* NSURL.h */,
+				18906EC21610BF3C0003C892 /* NSURLAuthenticationChallenge.h */,
+				18906EC31610BF3C0003C892 /* NSURLCache.h */,
+				18906EC41610BF3C0003C892 /* NSURLConnection.h */,
+				18906EC51610BF3C0003C892 /* NSURLCredential.h */,
+				18906EC61610BF3C0003C892 /* NSURLCredentialStorage.h */,
+				18906EC71610BF3C0003C892 /* NSURLDownload.h */,
+				18906EC81610BF3C0003C892 /* NSURLError.h */,
+				18906EC91610BF3C0003C892 /* NSURLHandle.h */,
+				18906ECA1610BF3C0003C892 /* NSURLProtectionSpace.h */,
+				18906ECB1610BF3C0003C892 /* NSURLProtocol.h */,
+				18906ECC1610BF3C0003C892 /* NSURLRequest.h */,
+				18906ECD1610BF3C0003C892 /* NSURLResponse.h */,
+				18906ECE1610BF3C0003C892 /* NSUndoManager.h */,
+				18906ECF1610BF3C0003C892 /* NSUserDefaults.h */,
+				18906ED01610BF3C0003C892 /* NSUtilities.h */,
+				18906ED11610BF3C0003C892 /* NSValue.h */,
+				18906ED21610BF3C0003C892 /* NSValueTransformer.h */,
+				18906ED31610BF3C0003C892 /* NSXMLDTD.h */,
+				18906ED41610BF3C0003C892 /* NSXMLDTDNode.h */,
+				18906ED51610BF3C0003C892 /* NSXMLDocument.h */,
+				18906ED61610BF3C0003C892 /* NSXMLElement.h */,
+				18906ED71610BF3C0003C892 /* NSXMLNode.h */,
+				18906ED81610BF3C0003C892 /* NSXMLNodeOptions.h */,
+				18906ED91610BF3C0003C892 /* NSXMLParser.h */,
+				18906EDA1610BF3C0003C892 /* NSZone.h */,
+			);
+			path = Foundation;
+			sourceTree = "<group>";
+		};
+		18906EDB1610BF3C0003C892 /* GNUstepBase */ = {
+			isa = PBXGroup;
+			children = (
+				18394AA31610CC4E00335E85 /* config.h */,
+				18394AA41610CC4E00335E85 /* GSConfig.h */,
+				18906EDC1610BF3C0003C892 /* .cvsignore */,
+				18906EDD1610BF3C0003C892 /* Additions.h */,
+				18906EDE1610BF3C0003C892 /* CXXException.h */,
+				18906EDF1610BF3C0003C892 /* DistributedObjects.h */,
+				18906EE01610BF3C0003C892 /* GCObject.h */,
+				18906EE11610BF3C0003C892 /* GNUstep.h */,
+				18906EE21610BF3C0003C892 /* GSBlocks.h */,
+				18906EE31610BF3C0003C892 /* GSConfig.h.in */,
+				18906EE41610BF3C0003C892 /* GSFunctions.h */,
+				18906EE51610BF3C0003C892 /* GSIArray.h */,
+				18906EE61610BF3C0003C892 /* GSIMap.h */,
+				18906EE71610BF3C0003C892 /* GSLocale.h */,
+				18906EE81610BF3C0003C892 /* GSLock.h */,
+				18906EE91610BF3C0003C892 /* GSMime.h */,
+				18906EEA1610BF3C0003C892 /* GSObjCRuntime.h */,
+				18EA6763172EC7F70026AC34 /* GSTypeEncoding.h */,
+				18906EEB1610BF3C0003C892 /* GSUnion.h */,
+				18906EEC1610BF3C0003C892 /* GSVersionMacros.h */,
+				18906EED1610BF3C0003C892 /* GSXML.h */,
+				18906F001610BF3C0003C892 /* Unicode.h */,
+				18906F011610BF3C0003C892 /* config.h.in */,
+			);
+			path = GNUstepBase;
+			sourceTree = "<group>";
+		};
+		18906F081610BF3C0003C892 /* Source */ = {
+			isa = PBXGroup;
+			children = (
+				18394BFF1610E9D600335E85 /* Foundation */,
+				18394BF21610DC0B00335E85 /* GNUstepBase */,
+				18906F091610BF3C0003C892 /* .cvsignore */,
+				18906F0A1610BF3C0003C892 /* Additions */,
+				18906F361610BF3C0003C892 /* CompatibilityHeaders.make */,
+				18906F371610BF3C0003C892 /* DocMakefile */,
+				18906F381610BF3C0003C892 /* GNUmakefile */,
+				18906F6E1610BF3C0003C892 /* Makefile.postamble */,
+				18906F6F1610BF3C0003C892 /* Makefile.preamble */,
+				18906FFD1610BF3C0003C892 /* callframe.h */,
+				18906FFE1610BF3C0003C892 /* callframe.m */,
+				18906FFF1610BF3C0003C892 /* cifframe.h */,
+				189070001610BF3C0003C892 /* cifframe.m */,
+				189070011610BF3C0003C892 /* common.h */,
+				189070021610BF3C0003C892 /* dld-load.h */,
+				189070031610BF3C0003C892 /* externs.m */,
+				189070041610BF3C0003C892 /* hpux-load.h */,
+				189070051610BF3C0003C892 /* inet_ntop.m */,
+				189070061610BF3C0003C892 /* inet_pton.m */,
+				189070071610BF3C0003C892 /* libgnustep-base-entry.m */,
+				189070081610BF3C0003C892 /* nstzfile.h */,
+				189070091610BF3C0003C892 /* null-load.h */,
+				1890700A1610BF3C0003C892 /* objc-load.h */,
+				1890700B1610BF3C0003C892 /* objc-load.m */,
+				1890700C1610BF3C0003C892 /* preface.m */,
+				1890700D1610BF3C0003C892 /* simple-load.h */,
+				18906FB81610BF3C0003C892 /* NSObject+NSComparisonMethods.m */,
+				1890700E1610BF3C0003C892 /* unix */,
+				189070131610BF3C0003C892 /* win32 */,
+				1890701C1610BF3C0003C892 /* win32-def.top */,
+				1890701D1610BF3C0003C892 /* win32-load.h */,
+			);
+			path = Source;
+			sourceTree = "<group>";
+		};
+		18906F0A1610BF3C0003C892 /* Additions */ = {
+			isa = PBXGroup;
+			children = (
+				18906F0B1610BF3C0003C892 /* GCArray.m */,
+				18906F0C1610BF3C0003C892 /* GCDictionary.m */,
+				18906F0D1610BF3C0003C892 /* GCObject.m */,
+				18906F0E1610BF3C0003C892 /* GNUmakefile */,
+				18906F0F1610BF3C0003C892 /* GSFunctions.m */,
+				18906F101610BF3C0003C892 /* GSInsensitiveDictionary.m */,
+				18906F111610BF3C0003C892 /* GSLock.m */,
+				18906F121610BF3C0003C892 /* GSMime.m */,
+				18906F131610BF3C0003C892 /* GSObjCRuntime.m */,
+				18EA675F172EC6170026AC34 /* GSTypeEncoding.c */,
+				18906F141610BF3C0003C892 /* GSXML.m */,
+				18906F151610BF3C0003C892 /* Makefile.postamble */,
+				18906F161610BF3C0003C892 /* Makefile.preamble */,
+				18906F171610BF3C0003C892 /* NSArray+GNUstepBase.m */,
+				18906F181610BF3C0003C892 /* NSAttributedString+GNUstepBase.m */,
+				18906F191610BF3C0003C892 /* NSBundle+GNUstepBase.m */,
+				18906F1A1610BF3C0003C892 /* NSCalendarDate+GNUstepBase.m */,
+				18906F1B1610BF3C0003C892 /* NSData+GNUstepBase.m */,
+				18906F1C1610BF3C0003C892 /* NSDebug+GNUstepBase.m */,
+				18906F1D1610BF3C0003C892 /* NSError+GNUstepBase.m */,
+				18906F1E1610BF3C0003C892 /* NSFileHandle+GNUstepBase.m */,
+				18906F1F1610BF3C0003C892 /* NSLock+GNUstepBase.m */,
+				18906F201610BF3C0003C892 /* NSMutableString+GNUstepBase.m */,
+				18906F211610BF3C0003C892 /* NSNumber+GNUstepBase.m */,
+				18906F221610BF3C0003C892 /* NSObject+GNUstepBase.m */,
+				18906F231610BF3C0003C892 /* NSProcessInfo+GNUstepBase.m */,
+				18906F241610BF3C0003C892 /* NSPropertyList+GNUstepBase.m */,
+				18906F251610BF3C0003C892 /* NSStream+GNUstepBase.m */,
+				18906F261610BF3C0003C892 /* NSString+GNUstepBase.m */,
+				18906F271610BF3C0003C892 /* NSTask+GNUstepBase.m */,
+				18906F281610BF3C0003C892 /* NSThread+GNUstepBase.m */,
+				18906F291610BF3C0003C892 /* NSURL+GNUstepBase.m */,
+				18906F2A1610BF3C0003C892 /* Unicode.m */,
+				18906F2B1610BF3C0003C892 /* unicode */,
+			);
+			path = Additions;
+			sourceTree = "<group>";
+		};
+		18906F2B1610BF3C0003C892 /* unicode */ = {
+			isa = PBXGroup;
+			children = (
+				18906F2C1610BF3C0003C892 /* caseconv.h */,
+				18906F2D1610BF3C0003C892 /* cop.h */,
+				18906F2E1610BF3C0003C892 /* cyrillic.h */,
+				18906F2F1610BF3C0003C892 /* decomp.h */,
+				18906F301610BF3C0003C892 /* gsm0338.h */,
+				18906F311610BF3C0003C892 /* latin2.h */,
+				18906F321610BF3C0003C892 /* latin9.h */,
+				18906F331610BF3C0003C892 /* nextstep.h */,
+				18906F341610BF3C0003C892 /* thai.h */,
+			);
+			path = unicode;
+			sourceTree = "<group>";
+		};
+		1890700E1610BF3C0003C892 /* unix */ = {
+			isa = PBXGroup;
+			children = (
+				1890700F1610BF3C0003C892 /* GNUmakefile */,
+				189070101610BF3C0003C892 /* GSRunLoopCtxt.m */,
+				189070111610BF3C0003C892 /* Makefile.preamble */,
+				189070121610BF3C0003C892 /* NSStream.m */,
+			);
+			path = unix;
+			sourceTree = "<group>";
+		};
+		189070131610BF3C0003C892 /* win32 */ = {
+			isa = PBXGroup;
+			children = (
+				189070141610BF3C0003C892 /* GNUmakefile */,
+				189070151610BF3C0003C892 /* GSFileHandle.m */,
+				189070161610BF3C0003C892 /* GSRunLoopCtxt.m */,
+				189070171610BF3C0003C892 /* Makefile.preamble */,
+				189070181610BF3C0003C892 /* NSMessagePort.m */,
+				189070191610BF3C0003C892 /* NSMessagePortNameServer.m */,
+				1890701A1610BF3C0003C892 /* NSStream.m */,
+				1890701B1610BF3C0003C892 /* NSUserDefaults.m */,
+			);
+			path = win32;
+			sourceTree = "<group>";
+		};
+		18D882481729B64E0067E486 /* test00 */ = {
+			isa = PBXGroup;
+			children = (
+				18D882491729B64E0067E486 /* ChangeStack.plist */,
+				18D8824A1729B64E0067E486 /* ComplexDependency.plist */,
+				18D8824B1729B64E0067E486 /* DependencyObservance.plist */,
+				18D8824C1729B64E0067E486 /* DependentNestedProperty.plist */,
+				18D8824D1729B64E0067E486 /* NestedProperty.plist */,
+				18D8824E1729B64E0067E486 /* NestedPropertyDependency.plist */,
+				18D8824F1729B64E0067E486 /* NestedPropertyLevels.plist */,
+				18D882501729B64E0067E486 /* Observance.plist */,
+				18D882511729B64E0067E486 /* ObservanceStack.plist */,
+				18D882521729B64E0067E486 /* StackCorruption.plist */,
+			);
+			path = test00;
+			sourceTree = "<group>";
+		};
+		18EFCBFF172AF0F0003304CA /* test02 */ = {
+			isa = PBXGroup;
+			children = (
+				18EFCC00172AF0F0003304CA /* ItemInsertion.plist */,
+				18EFCC01172AF0F0003304CA /* ItemRemoval.plist */,
+				18EFCC02172AF0F0003304CA /* ItemReplacement.plist */,
+				18EFCC03172AF0F0003304CA /* NilValue.plist */,
+				18EFCC04172AF0F0003304CA /* SetComplementation.plist */,
+				18EFCC05172AF0F0003304CA /* SetIntersection.plist */,
+				18EFCC11172B01B9003304CA /* SetSettingEmpty.plist */,
+				18EFCC12172B01B9003304CA /* SetSettingNil.plist */,
+				18EFCC13172B01B9003304CA /* SetSettingNotEmpty.plist */,
+				18EFCC07172AF0F0003304CA /* SetUnion.plist */,
+			);
+			path = test02;
+			sourceTree = "<group>";
+		};
+		18F8D04117244FE900420DA5 /* KVO */ = {
+			isa = PBXGroup;
+			children = (
+				18D882481729B64E0067E486 /* test00 */,
+				18EFCBFF172AF0F0003304CA /* test02 */,
+				18F8D04C17244FE900420DA5 /* TestInfo */,
+				18F8D04D17244FE900420DA5 /* test00.m */,
+				18D882531729B64E0067E486 /* test01.m */,
+				18EFCC08172AF0F0003304CA /* test02.m */,
+			);
+			path = KVO;
+			sourceTree = "<group>";
+		};
+		18F8D04F1724534E00420DA5 /* KVO */ = {
+			isa = PBXGroup;
+			children = (
+				18408FF417271EAD00CFD080 /* NSArray+KVO.m */,
+				18F8D0501724534E00420DA5 /* NSKeyValueNestedProperty.h */,
+				18F8D0511724534E00420DA5 /* NSKeyValueNestedProperty.m */,
+				18F8D0521724534E00420DA5 /* NSKeyValueObservance.h */,
+				18F8D0531724534E00420DA5 /* NSKeyValueObservance.m */,
+				18F8D0541724534E00420DA5 /* NSKeyValueObservationInfo.h */,
+				18F8D0551724534E00420DA5 /* NSKeyValueObservationInfo.m */,
+				18408FF017271D3D00CFD080 /* NSKeyValueObserving.m */,
+				18F8D0561724534E00420DA5 /* NSKeyValueObservingPrivate.h */,
+				18F8D0571724534E00420DA5 /* NSKeyValueObservingPrivate.m */,
+				18F8D0581724534E00420DA5 /* NSKeyValueProperty.h */,
+				18F8D0591724534E00420DA5 /* NSKeyValueProperty.m */,
+				18F8D05A1724534E00420DA5 /* NSKeyValueUnnestedProperty.h */,
+				18F8D05B1724534E00420DA5 /* NSKeyValueUnnestedProperty.m */,
+				18F8D06A1725919700420DA5 /* NSKVONotifying.h */,
+				18F8D06B1725919800420DA5 /* NSKVONotifying.m */,
+				18F8D05C1724534E00420DA5 /* NSObject+KVO.m */,
+				18408FF81727200100CFD080 /* NSSet+KVO.m */,
+			);
+			path = KVO;
+			sourceTree = "<group>";
+		};
+		18FE1E271628550000389A13 /* Tests */ = {
+			isa = PBXGroup;
+			children = (
+				18FE1E281628550000389A13 /* GNUmakefile */,
+				18FE1E291628550000389A13 /* base */,
+			);
+			path = Tests;
+			sourceTree = "<group>";
+		};
+		18FE1E291628550000389A13 /* base */ = {
+			isa = PBXGroup;
+			children = (
+				18FE1E2A1628550000389A13 /* Functions */,
+				18FE1E341628550000389A13 /* GNUmakefile.postamble */,
+				18FE1E351628550000389A13 /* GNUmakefile.super */,
+				18FE1E361628550000389A13 /* GSMime */,
+				18FE1E481628550000389A13 /* GSXML */,
+				18FE1E4B1628550000389A13 /* GarbageCollection */,
+				18FE1E4F1628550000389A13 /* GenericTests */,
+				18FE1E531628550000389A13 /* KVC */,
+				18F8D04117244FE900420DA5 /* KVO */,
+				18FE1E5A1628550000389A13 /* NSAffineTransform */,
+				18FE1E5D1628550000389A13 /* NSArchiver */,
+				18FE1E621628550000389A13 /* NSArray */,
+				18FE1E6B1628550000389A13 /* NSAttributedString */,
+				18FE1E6F1628550000389A13 /* NSAutoreleasePool */,
+				18FE1E731628550000389A13 /* NSBlock */,
+				18FE1E751628550000389A13 /* NSBundle */,
+				18FE1E891628550000389A13 /* NSCalendar */,
+				18FE1E8D1628550000389A13 /* NSCalendarDate */,
+				18FE1E941628550000389A13 /* NSCharacterSet */,
+				18FE1E9A1628550000389A13 /* NSConnection */,
+				18FE1EA21628550000389A13 /* NSCountedSet */,
+				18FE1EA51628550000389A13 /* NSData */,
+				18FE1EA91628550000389A13 /* NSDate */,
+				18FE1EAE1628550000389A13 /* NSDateFormatter */,
+				18FE1EB11628550000389A13 /* NSDictionary */,
+				18FE1EB71628550100389A13 /* NSException */,
+				18FE1EBF1628550100389A13 /* NSFileHandle */,
+				18FE1EC41628550100389A13 /* NSFileManager */,
+				18FE1ECA1628550100389A13 /* NSHTTPCookie */,
+				18FE1ECD1628550100389A13 /* NSHashTable */,
+				18FE1ED21628550100389A13 /* NSHost */,
+				18FE1ED61628550100389A13 /* NSIndexPath */,
+				18FE1ED91628550100389A13 /* NSInvocation */,
+				18FE1EE41628550100389A13 /* NSJSONSerialization */,
+				18FE1EE71628550100389A13 /* NSKeyedArchiver */,
+				18FE1EEC1628550100389A13 /* NSLocale */,
+				18FE1EF11628550100389A13 /* NSLock */,
+				18FE1EFC1628550100389A13 /* NSMapTable */,
+				18FE1F011628550100389A13 /* NSMethodSignature */,
+				18FE1F041628550100389A13 /* NSMutableArray */,
+				18FE1F091628550100389A13 /* NSMutableAttributedString */,
+				18FE1F0E1628550100389A13 /* NSMutableCharacterSet */,
+				18FE1F121628550100389A13 /* NSMutableData */,
+				18FE1F161628550100389A13 /* NSMutableDictionary */,
+				18FE1F1A1628550100389A13 /* NSMutableIndexSet */,
+				18FE1F1F1628550100389A13 /* NSMutableSet */,
+				18FE1F221628550100389A13 /* NSMutableString */,
+				1857833D17551CC200CB7160 /* NSNotification */,
+				18FE1F271628550100389A13 /* NSNumber */,
+				18FE1F2C1628550100389A13 /* NSNumberFormatter */,
+				18FE1F301628550100389A13 /* NSObject */,
+				18FE1F381628550100389A13 /* NSOperation */,
+				18FE1F3D1628550100389A13 /* NSOrderedSet */,
+				18FE1F401628550100389A13 /* NSPointerArray */,
+				18FE1F451628550100389A13 /* NSPredicate */,
+				18FE1F481628550100389A13 /* NSProcessInfo */,
+				18FE1F4C1628550100389A13 /* NSProxy */,
+				18FE1F511628550100389A13 /* NSRunLoop */,
+				18FE1F571628550100389A13 /* NSScanner */,
+				18FE1F5B1628550100389A13 /* NSSet */,
+				18FE1F5E1628550100389A13 /* NSSortDescriptor */,
+				18FE1F611628550100389A13 /* NSStream */,
+				18FE1F691628550100389A13 /* NSString */,
+				18FE1F7F1628550100389A13 /* NSTask */,
+				18FE1F8C1628550100389A13 /* NSThread */,
+				18FE1F8E1628550100389A13 /* NSTimeZone */,
+				18FE1F931628550100389A13 /* NSURL */,
+				18FE1F9F1628550100389A13 /* NSURLConnection */,
+				18FE1FA21628550100389A13 /* NSURLHandle */,
+				18FE1FAB1628550100389A13 /* NSURLProtocol */,
+				18FE1FAE1628550100389A13 /* NSURLRequest */,
+				18FE1FB11628550100389A13 /* NSUndoManager */,
+				18FE1FB51628550100389A13 /* NSUserDefaults */,
+				18FE1FB91628550100389A13 /* NSXMLDocument */,
+				18FE1FBD1628550100389A13 /* NSXMLElement */,
+				18FE1FC31628550100389A13 /* NSXMLNode */,
+				18FE1FCA1628550100389A13 /* NSXMLParser */,
+				18FE1FD11628550100389A13 /* PropertyLists */,
+				18FE1FDB1628550100389A13 /* TestInfo */,
+				18FE1FDC1628550100389A13 /* Unicode */,
+				18FE1FDF1628550100389A13 /* coding */,
+				18FE20011628550100389A13 /* headers */,
+			);
+			path = base;
+			sourceTree = "<group>";
+		};
+		18FE1E2A1628550000389A13 /* Functions */ = {
+			isa = PBXGroup;
+			children = (
+				18FE1E2B1628550000389A13 /* NSGeometry1.m */,
+				18FE1E2C1628550000389A13 /* NSPathUtilities.m */,
+				18FE1E2D1628550000389A13 /* NSZone.m */,
+				18FE1E2E1628550000389A13 /* TestInfo */,
+				18FE1E2F1628550000389A13 /* class_hierarchy.m */,
+				18FE1E301628550000389A13 /* clsCreate.m */,
+				18FE1E311628550000389A13 /* properties.m */,
+				18FE1E321628550000389A13 /* propertyAttrs.m */,
+				18FE1E331628550000389A13 /* runtime.m */,
+			);
+			path = Functions;
+			sourceTree = "<group>";
+		};
+		18FE1E361628550000389A13 /* GSMime */ = {
+			isa = PBXGroup;
+			children = (
+				18FE1E371628550000389A13 /* HTTP1.dat */,
+				18FE1E381628550000389A13 /* HTTP2.dat */,
+				18FE1E391628550000389A13 /* TestInfo */,
+				18FE1E3A1628550000389A13 /* build.m */,
+				18FE1E3B1628550000389A13 /* general.m */,
+				18FE1E3C1628550000389A13 /* mime1.dat */,
+				18FE1E3D1628550000389A13 /* mime10.dat */,
+				18FE1E3E1628550000389A13 /* mime2.dat */,
+				18FE1E3F1628550000389A13 /* mime3.dat */,
+				18FE1E401628550000389A13 /* mime4.dat */,
+				18FE1E411628550000389A13 /* mime5.dat */,
+				18FE1E421628550000389A13 /* mime6.dat */,
+				18FE1E431628550000389A13 /* mime7.dat */,
+				18FE1E441628550000389A13 /* mime8.dat */,
+				18FE1E451628550000389A13 /* mime9.dat */,
+				18FE1E461628550000389A13 /* test01.m */,
+				18FE1E471628550000389A13 /* test02.m */,
+			);
+			path = GSMime;
+			sourceTree = "<group>";
+		};
+		18FE1E481628550000389A13 /* GSXML */ = {
+			isa = PBXGroup;
+			children = (
+				18FE1E491628550000389A13 /* TestInfo */,
+				18FE1E4A1628550000389A13 /* basic.m */,
+			);
+			path = GSXML;
+			sourceTree = "<group>";
+		};
+		18FE1E4B1628550000389A13 /* GarbageCollection */ = {
+			isa = PBXGroup;
+			children = (
+				18FE1E4C1628550000389A13 /* TestInfo */,
+				18FE1E4D1628550000389A13 /* general.m */,
+				18FE1E4E1628550000389A13 /* notifications.m */,
+			);
+			path = GarbageCollection;
+			sourceTree = "<group>";
+		};
+		18FE1E4F1628550000389A13 /* GenericTests */ = {
+			isa = PBXGroup;
+			children = (
+				18FE1E501628550000389A13 /* GNUmakefile */,
+				18FE1E511628550000389A13 /* generic.h */,
+				18FE1E521628550000389A13 /* generic.m */,
+			);
+			path = GenericTests;
+			sourceTree = "<group>";
+		};
+		18FE1E531628550000389A13 /* KVC */ = {
+			isa = PBXGroup;
+			children = (
+				18FE1E541628550000389A13 /* TestInfo */,
+				18FE1E551628550000389A13 /* array.m */,
+				18FE1E561628550000389A13 /* basic.m */,
+				18FE1E571628550000389A13 /* mutable.m */,
+				18FE1E581628550000389A13 /* nil.m */,
+				18FE1E591628550000389A13 /* path.m */,
+			);
+			path = KVC;
+			sourceTree = "<group>";
+		};
+		18FE1E5A1628550000389A13 /* NSAffineTransform */ = {
+			isa = PBXGroup;
+			children = (
+				18FE1E5B1628550000389A13 /* TestInfo */,
+				18FE1E5C1628550000389A13 /* basic.m */,
+			);
+			path = NSAffineTransform;
+			sourceTree = "<group>";
+		};
+		18FE1E5D1628550000389A13 /* NSArchiver */ = {
+			isa = PBXGroup;
+			children = (
+				18FE1E5E1628550000389A13 /* TestInfo */,
+				18FE1E5F1628550000389A13 /* basic.m */,
+				18FE1E601628550000389A13 /* create.m */,
+				18FE1E611628550000389A13 /* general.m */,
+			);
+			path = NSArchiver;
+			sourceTree = "<group>";
+		};
+		18FE1E621628550000389A13 /* NSArray */ = {
+			isa = PBXGroup;
+			children = (
+				18FE1E631628550000389A13 /* TestInfo */,
+				18FE1E641628550000389A13 /* basic.m */,
+				18FE1E651628550000389A13 /* blocks.m */,
+				18FE1E661628550000389A13 /* create.m */,
+				18FE1E671628550000389A13 /* general.m */,
+				18FE1E681628550000389A13 /* random.plist */,
+				18FE1E691628550000389A13 /* sorted.plist */,
+				18FE1E6A1628550000389A13 /* test.plist */,
+			);
+			path = NSArray;
+			sourceTree = "<group>";
+		};
+		18FE1E6B1628550000389A13 /* NSAttributedString */ = {
+			isa = PBXGroup;
+			children = (
+				18FE1E6C1628550000389A13 /* TestInfo */,
+				18FE1E6D1628550000389A13 /* basic.m */,
+				18FE1E6E1628550000389A13 /* test00.m */,
+			);
+			path = NSAttributedString;
+			sourceTree = "<group>";
+		};
+		18FE1E6F1628550000389A13 /* NSAutoreleasePool */ = {
+			isa = PBXGroup;
+			children = (
+				18FE1E701628550000389A13 /* TestInfo */,
+				18FE1E711628550000389A13 /* autorelease_eh.m */,
+				18FE1E721628550000389A13 /* basic.m */,
+			);
+			path = NSAutoreleasePool;
+			sourceTree = "<group>";
+		};
+		18FE1E731628550000389A13 /* NSBlock */ = {
+			isa = PBXGroup;
+			children = (
+				18FE1E741628550000389A13 /* blockassign.m */,
+			);
+			path = NSBlock;
+			sourceTree = "<group>";
+		};
+		18FE1E751628550000389A13 /* NSBundle */ = {
+			isa = PBXGroup;
+			children = (
+				18FE1E761628550000389A13 /* GNUmakefile.preamble */,
+				18FE1E771628550000389A13 /* Resources */,
+				18FE1E801628550000389A13 /* TestInfo */,
+				18FE1E811628550000389A13 /* basic.m */,
+				18FE1E821628550000389A13 /* create.m */,
+				18FE1E831628550000389A13 /* general.m */,
+				18FE1E841628550000389A13 /* load */,
+				18FE1E871628550000389A13 /* resources.m */,
+				18FE1E881628550000389A13 /* resources2.m */,
+			);
+			path = NSBundle;
+			sourceTree = "<group>";
+		};
+		18FE1E771628550000389A13 /* Resources */ = {
+			isa = PBXGroup;
+			children = (
+				18FE1E781628550000389A13 /* TextRes.txt */,
+				18FE1E7B1628550000389A13 /* GNUmakefile */,
+				18FE1E7C1628550000389A13 /* NonLocalRes.txt */,
+				18FE1E7D1628550000389A13 /* TestBundle.m */,
+				18FE1E7E1628550000389A13 /* TestBundleInfo.plist */,
+			);
+			path = Resources;
+			sourceTree = "<group>";
+		};
+		18FE1E841628550000389A13 /* load */ = {
+			isa = PBXGroup;
+			children = (
+				18FE1E851628550000389A13 /* GNUmakefile.preamble */,
+				18FE1E861628550000389A13 /* load.m */,
+			);
+			path = load;
+			sourceTree = "<group>";
+		};
+		18FE1E891628550000389A13 /* NSCalendar */ = {
+			isa = PBXGroup;
+			children = (
+				18FE1E8A1628550000389A13 /* TestInfo */,
+				18FE1E8B1628550000389A13 /* basic.m */,
+				18FE1E8C1628550000389A13 /* create.m */,
+			);
+			path = NSCalendar;
+			sourceTree = "<group>";
+		};
+		18FE1E8D1628550000389A13 /* NSCalendarDate */ = {
+			isa = PBXGroup;
+			children = (
+				18FE1E8E1628550000389A13 /* TestInfo */,
+				18FE1E8F1628550000389A13 /* basic.m */,
+				18FE1E901628550000389A13 /* test00.m */,
+				18FE1E911628550000389A13 /* test01.m */,
+				18FE1E921628550000389A13 /* test02.m */,
+				18FE1E931628550000389A13 /* western.h */,
+			);
+			path = NSCalendarDate;
+			sourceTree = "<group>";
+		};
+		18FE1E941628550000389A13 /* NSCharacterSet */ = {
+			isa = PBXGroup;
+			children = (
+				18FE1E951628550000389A13 /* TestInfo */,
+				18FE1E961628550000389A13 /* basic.m */,
+				18FE1E971628550000389A13 /* class.m */,
+				18FE1E981628550000389A13 /* general.m */,
+				18FE1E991628550000389A13 /* illegalCharacterSet.m */,
+			);
+			path = NSCharacterSet;
+			sourceTree = "<group>";
+		};
+		18FE1E9A1628550000389A13 /* NSConnection */ = {
+			isa = PBXGroup;
+			children = (
+				18FE1E9B1628550000389A13 /* GNUmakefile.preamble */,
+				18FE1E9C1628550000389A13 /* Resources */,
+				18FE1E9F1628550000389A13 /* TestInfo */,
+				18FE1EA01628550000389A13 /* basic.m */,
+				18FE1EA11628550000389A13 /* connection.m */,
+			);
+			path = NSConnection;
+			sourceTree = "<group>";
+		};
+		18FE1E9C1628550000389A13 /* Resources */ = {
+			isa = PBXGroup;
+			children = (
+				18FE1E9D1628550000389A13 /* Connection.m */,
+				18FE1E9E1628550000389A13 /* GNUmakefile */,
+			);
+			path = Resources;
+			sourceTree = "<group>";
+		};
+		18FE1EA21628550000389A13 /* NSCountedSet */ = {
+			isa = PBXGroup;
+			children = (
+				18FE1EA31628550000389A13 /* TestInfo */,
+				18FE1EA41628550000389A13 /* basic.m */,
+			);
+			path = NSCountedSet;
+			sourceTree = "<group>";
+		};
+		18FE1EA51628550000389A13 /* NSData */ = {
+			isa = PBXGroup;
+			children = (
+				18FE1EA61628550000389A13 /* TestInfo */,
+				18FE1EA71628550000389A13 /* basic.m */,
+				18FE1EA81628550000389A13 /* general.m */,
+			);
+			path = NSData;
+			sourceTree = "<group>";
+		};
+		18FE1EA91628550000389A13 /* NSDate */ = {
+			isa = PBXGroup;
+			children = (
+				18FE1EAA1628550000389A13 /* TestInfo */,
+				18FE1EAB1628550000389A13 /* basic.m */,
+				18FE1EAC1628550000389A13 /* create.m */,
+				18FE1EAD1628550000389A13 /* general.m */,
+			);
+			path = NSDate;
+			sourceTree = "<group>";
+		};
+		18FE1EAE1628550000389A13 /* NSDateFormatter */ = {
+			isa = PBXGroup;
+			children = (
+				18FE1EAF1628550000389A13 /* TestInfo */,
+				18FE1EB01628550000389A13 /* general.m */,
+			);
+			path = NSDateFormatter;
+			sourceTree = "<group>";
+		};
+		18FE1EB11628550000389A13 /* NSDictionary */ = {
+			isa = PBXGroup;
+			children = (
+				18FE1EB21628550100389A13 /* TestInfo */,
+				18FE1EB31628550100389A13 /* basic.m */,
+				18FE1EB41628550100389A13 /* blocks.m */,
+				18FE1EB51628550100389A13 /* create.m */,
+				18FE1EB61628550100389A13 /* general.m */,
+			);
+			path = NSDictionary;
+			sourceTree = "<group>";
+		};
+		18FE1EB71628550100389A13 /* NSException */ = {
+			isa = PBXGroup;
+			children = (
+				18FE1EB81628550100389A13 /* TestInfo */,
+				18FE1EB91628550100389A13 /* basic.m */,
+				18FE1EBA1628550100389A13 /* basic.m.abort */,
+				18FE1EBB1628550100389A13 /* mixedException.mm */,
+				18FE1EBC1628550100389A13 /* sillySemantics.mm */,
+				18FE1EBD1628550100389A13 /* skipCatchall.mm */,
+				18FE1EBE1628550100389A13 /* throwstr.m */,
+			);
+			path = NSException;
+			sourceTree = "<group>";
+		};
+		18FE1EBF1628550100389A13 /* NSFileHandle */ = {
+			isa = PBXGroup;
+			children = (
+				18FE1EC01628550100389A13 /* TestInfo */,
+				18FE1EC11628550100389A13 /* basic.m */,
+				18FE1EC21628550100389A13 /* general.m */,
+				18FE1EC31628550100389A13 /* socket.m */,
+			);
+			path = NSFileHandle;
+			sourceTree = "<group>";
+		};
+		18FE1EC41628550100389A13 /* NSFileManager */ = {
+			isa = PBXGroup;
+			children = (
+				18FE1EC51628550100389A13 /* NSFileManagerTestDir */,
+				18FE1EC61628550100389A13 /* TestInfo */,
+				18FE1EC71628550100389A13 /* basic.m */,
+				18FE1EC81628550100389A13 /* general.m */,
+				18FE1EC91628550100389A13 /* unrepresentable_filenames.m */,
+			);
+			path = NSFileManager;
+			sourceTree = "<group>";
+		};
+		18FE1EC51628550100389A13 /* NSFileManagerTestDir */ = {
+			isa = PBXGroup;
+			children = (
+			);
+			path = NSFileManagerTestDir;
+			sourceTree = "<group>";
+		};
+		18FE1ECA1628550100389A13 /* NSHTTPCookie */ = {
+			isa = PBXGroup;
+			children = (
+				18FE1ECB1628550100389A13 /* TestInfo */,
+				18FE1ECC1628550100389A13 /* basic.m */,
+			);
+			path = NSHTTPCookie;
+			sourceTree = "<group>";
+		};
+		18FE1ECD1628550100389A13 /* NSHashTable */ = {
+			isa = PBXGroup;
+			children = (
+				18FE1ECE1628550100389A13 /* TestInfo */,
+				18FE1ECF1628550100389A13 /* basic.m */,
+				18FE1ED01628550100389A13 /* create.m */,
+				18FE1ED11628550100389A13 /* general.m */,
+			);
+			path = NSHashTable;
+			sourceTree = "<group>";
+		};
+		18FE1ED21628550100389A13 /* NSHost */ = {
+			isa = PBXGroup;
+			children = (
+				18FE1ED31628550100389A13 /* TestInfo */,
+				18FE1ED41628550100389A13 /* basic.m */,
+				18FE1ED51628550100389A13 /* create.m */,
+			);
+			path = NSHost;
+			sourceTree = "<group>";
+		};
+		18FE1ED61628550100389A13 /* NSIndexPath */ = {
+			isa = PBXGroup;
+			children = (
+				18FE1ED71628550100389A13 /* TestInfo */,
+				18FE1ED81628550100389A13 /* general.m */,
+			);
+			path = NSIndexPath;
+			sourceTree = "<group>";
+		};
+		18FE1ED91628550100389A13 /* NSInvocation */ = {
+			isa = PBXGroup;
+			children = (
+				18FE1EDA1628550100389A13 /* GNUmakefile.preamble */,
+				18FE1EDB1628550100389A13 /* InvokeProxyProtocol.h */,
+				18FE1EDC1628550100389A13 /* Resources */,
+				18FE1EE01628550100389A13 /* TestInfo */,
+				18FE1EE11628550100389A13 /* basic.m */,
+				18FE1EE21628550100389A13 /* general.m */,
+				18FE1EE31628550100389A13 /* test01.m */,
+			);
+			path = NSInvocation;
+			sourceTree = "<group>";
+		};
+		18FE1EDC1628550100389A13 /* Resources */ = {
+			isa = PBXGroup;
+			children = (
+				18FE1EDD1628550100389A13 /* GNUmakefile */,
+				18FE1EDE1628550100389A13 /* InvokeProxy.h */,
+				18FE1EDF1628550100389A13 /* InvokeProxy.m */,
+			);
+			path = Resources;
+			sourceTree = "<group>";
+		};
+		18FE1EE41628550100389A13 /* NSJSONSerialization */ = {
+			isa = PBXGroup;
+			children = (
+				18FE1EE51628550100389A13 /* TestInfo */,
+				18FE1EE61628550100389A13 /* json.m */,
+			);
+			path = NSJSONSerialization;
+			sourceTree = "<group>";
+		};
+		18FE1EE71628550100389A13 /* NSKeyedArchiver */ = {
+			isa = PBXGroup;
+			children = (
+				18FE1EE81628550100389A13 /* TestInfo */,
+				18FE1EE91628550100389A13 /* basic.m */,
+				18FE1EEA1628550100389A13 /* create.m */,
+				18FE1EEB1628550100389A13 /* general.m */,
+			);
+			path = NSKeyedArchiver;
+			sourceTree = "<group>";
+		};
+		18FE1EEC1628550100389A13 /* NSLocale */ = {
+			isa = PBXGroup;
+			children = (
+				18FE1EED1628550100389A13 /* TestInfo */,
+				18FE1EEE1628550100389A13 /* basic.m */,
+				18FE1EEF1628550100389A13 /* create.m */,
+				18FE1EF01628550100389A13 /* general.m */,
+			);
+			path = NSLocale;
+			sourceTree = "<group>";
+		};
+		18FE1EF11628550100389A13 /* NSLock */ = {
+			isa = PBXGroup;
+			children = (
+				18FE1EF21628550100389A13 /* GNUmakefile.preamble */,
+				18FE1EF31628550100389A13 /* Helpers */,
+				18FE1EF71628550100389A13 /* RecursiveLock.m */,
+				18FE1EF81628550100389A13 /* TestInfo */,
+				18FE1EF91628550100389A13 /* condlock.m */,
+				18FE1EFA1628550100389A13 /* doubleLocking.m */,
+				18FE1EFB1628550100389A13 /* tryLock.m */,
+			);
+			path = NSLock;
+			sourceTree = "<group>";
+		};
+		18FE1EF31628550100389A13 /* Helpers */ = {
+			isa = PBXGroup;
+			children = (
+				18FE1EF41628550100389A13 /* GNUmakefile */,
+				18FE1EF51628550100389A13 /* doubleNSConditionLock.m */,
+				18FE1EF61628550100389A13 /* doubleNSLock.m */,
+			);
+			path = Helpers;
+			sourceTree = "<group>";
+		};
+		18FE1EFC1628550100389A13 /* NSMapTable */ = {
+			isa = PBXGroup;
+			children = (
+				18FE1EFD1628550100389A13 /* TestInfo */,
+				18FE1EFE1628550100389A13 /* basic.m */,
+				18FE1EFF1628550100389A13 /* create.m */,
+				18FE1F001628550100389A13 /* general.m */,
+			);
+			path = NSMapTable;
+			sourceTree = "<group>";
+		};
+		18FE1F011628550100389A13 /* NSMethodSignature */ = {
+			isa = PBXGroup;
+			children = (
+				18FE1F021628550100389A13 /* TestInfo */,
+				18FE1F031628550100389A13 /* general.m */,
+			);
+			path = NSMethodSignature;
+			sourceTree = "<group>";
+		};
+		18FE1F041628550100389A13 /* NSMutableArray */ = {
+			isa = PBXGroup;
+			children = (
+				18FE1F051628550100389A13 /* TestInfo */,
+				18FE1F061628550100389A13 /* basic.m */,
+				18FE1F071628550100389A13 /* create.m */,
+				18FE1F081628550100389A13 /* general.m */,
+			);
+			path = NSMutableArray;
+			sourceTree = "<group>";
+		};
+		18FE1F091628550100389A13 /* NSMutableAttributedString */ = {
+			isa = PBXGroup;
+			children = (
+				18FE1F0A1628550100389A13 /* TestInfo */,
+				18FE1F0B1628550100389A13 /* basic.m */,
+				18FE1F0C1628550100389A13 /* test00.m */,
+				18FE1F0D1628550100389A13 /* test01.m */,
+			);
+			path = NSMutableAttributedString;
+			sourceTree = "<group>";
+		};
+		18FE1F0E1628550100389A13 /* NSMutableCharacterSet */ = {
+			isa = PBXGroup;
+			children = (
+				18FE1F0F1628550100389A13 /* TestInfo */,
+				18FE1F101628550100389A13 /* basic.m */,
+				18FE1F111628550100389A13 /* test00.m */,
+			);
+			path = NSMutableCharacterSet;
+			sourceTree = "<group>";
+		};
+		18FE1F121628550100389A13 /* NSMutableData */ = {
+			isa = PBXGroup;
+			children = (
+				18FE1F131628550100389A13 /* TestInfo */,
+				18FE1F141628550100389A13 /* basic.m */,
+				18FE1F151628550100389A13 /* general.m */,
+			);
+			path = NSMutableData;
+			sourceTree = "<group>";
+		};
+		18FE1F161628550100389A13 /* NSMutableDictionary */ = {
+			isa = PBXGroup;
+			children = (
+				18FE1F171628550100389A13 /* TestInfo */,
+				18FE1F181628550100389A13 /* basic.m */,
+				18FE1F191628550100389A13 /* general.m */,
+			);
+			path = NSMutableDictionary;
+			sourceTree = "<group>";
+		};
+		18FE1F1A1628550100389A13 /* NSMutableIndexSet */ = {
+			isa = PBXGroup;
+			children = (
+				18FE1F1B1628550100389A13 /* TestInfo */,
+				18FE1F1C1628550100389A13 /* blocks.m */,
+				18FE1F1D1628550100389A13 /* test0.m */,
+				18FE1F1E1628550100389A13 /* test1.m */,
+			);
+			path = NSMutableIndexSet;
+			sourceTree = "<group>";
+		};
+		18FE1F1F1628550100389A13 /* NSMutableSet */ = {
+			isa = PBXGroup;
+			children = (
+				18FE1F201628550100389A13 /* TestInfo */,
+				18FE1F211628550100389A13 /* basic.m */,
+			);
+			path = NSMutableSet;
+			sourceTree = "<group>";
+		};
+		18FE1F221628550100389A13 /* NSMutableString */ = {
+			isa = PBXGroup;
+			children = (
+				18FE1F231628550100389A13 /* GNUmakefile.preamble */,
+				18FE1F241628550100389A13 /* NSMutableString_string.m */,
+				18FE1F251628550100389A13 /* TestInfo */,
+				18FE1F261628550100389A13 /* basic.m */,
+			);
+			path = NSMutableString;
+			sourceTree = "<group>";
+		};
+		18FE1F271628550100389A13 /* NSNumber */ = {
+			isa = PBXGroup;
+			children = (
+				18FE1F281628550100389A13 /* TestInfo */,
+				18FE1F291628550100389A13 /* basic.m */,
+				18FE1F2A1628550100389A13 /* test00.m */,
+				18FE1F2B1628550100389A13 /* test01.m */,
+			);
+			path = NSNumber;
+			sourceTree = "<group>";
+		};
+		18FE1F2C1628550100389A13 /* NSNumberFormatter */ = {
+			isa = PBXGroup;
+			children = (
+				18FE1F2D1628550100389A13 /* TestInfo */,
+				18FE1F2E1628550100389A13 /* basic.m */,
+				18FE1F2F1628550100389A13 /* basic10_4.m */,
+			);
+			path = NSNumberFormatter;
+			sourceTree = "<group>";
+		};
+		18FE1F301628550100389A13 /* NSObject */ = {
+			isa = PBXGroup;
+			children = (
+				18FE1F311628550100389A13 /* TestInfo */,
+				18FE1F321628550100389A13 /* basic.m */,
+				18FE1F331628550100389A13 /* initialize.m */,
+				18FE1F341628550100389A13 /* objc++.mm */,
+				18FE1F351628550100389A13 /* test00.m */,
+				18FE1F361628550100389A13 /* test01.m */,
+				18FE1F371628550100389A13 /* test02.m */,
+			);
+			path = NSObject;
+			sourceTree = "<group>";
+		};
+		18FE1F381628550100389A13 /* NSOperation */ = {
+			isa = PBXGroup;
+			children = (
+				18FE1F391628550100389A13 /* TestInfo */,
+				18FE1F3A1628550100389A13 /* basic.m */,
+				18FE1F3B1628550100389A13 /* concurrent.m */,
+				18FE1F3C1628550100389A13 /* threads.m */,
+			);
+			path = NSOperation;
+			sourceTree = "<group>";
+		};
+		18FE1F3D1628550100389A13 /* NSOrderedSet */ = {
+			isa = PBXGroup;
+			children = (
+				18FE1F3E1628550100389A13 /* TestInfo */,
+				18FE1F3F1628550100389A13 /* basic.m */,
+			);
+			path = NSOrderedSet;
+			sourceTree = "<group>";
+		};
+		18FE1F401628550100389A13 /* NSPointerArray */ = {
+			isa = PBXGroup;
+			children = (
+				18FE1F411628550100389A13 /* TestInfo */,
+				18FE1F421628550100389A13 /* basic.m */,
+				18FE1F431628550100389A13 /* create.m */,
+				18FE1F441628550100389A13 /* general.m */,
+			);
+			path = NSPointerArray;
+			sourceTree = "<group>";
+		};
+		18FE1F451628550100389A13 /* NSPredicate */ = {
+			isa = PBXGroup;
+			children = (
+				18FE1F461628550100389A13 /* TestInfo */,
+				18FE1F471628550100389A13 /* basic.m */,
+			);
+			path = NSPredicate;
+			sourceTree = "<group>";
+		};
+		18FE1F481628550100389A13 /* NSProcessInfo */ = {
+			isa = PBXGroup;
+			children = (
+				18FE1F491628550100389A13 /* TestInfo */,
+				18FE1F4A1628550100389A13 /* basic.m */,
+				18FE1F4B1628550100389A13 /* general.m */,
+			);
+			path = NSProcessInfo;
+			sourceTree = "<group>";
+		};
+		18FE1F4C1628550100389A13 /* NSProxy */ = {
+			isa = PBXGroup;
+			children = (
+				18FE1F4D1628550100389A13 /* TestInfo */,
+				18FE1F4E1628550100389A13 /* basic.m */,
+				18FE1F4F1628550100389A13 /* test00.m */,
+				18FE1F501628550100389A13 /* test01.m */,
+			);
+			path = NSProxy;
+			sourceTree = "<group>";
+		};
+		18FE1F511628550100389A13 /* NSRunLoop */ = {
+			isa = PBXGroup;
+			children = (
+				18FE1F521628550100389A13 /* TestInfo */,
+				18FE1F531628550100389A13 /* basic.m */,
+				18FE1F541628550100389A13 /* general.m */,
+				18FE1F551628550100389A13 /* performers.m */,
+				18FE1F561628550100389A13 /* thread.m */,
+			);
+			path = NSRunLoop;
+			sourceTree = "<group>";
+		};
+		18FE1F571628550100389A13 /* NSScanner */ = {
+			isa = PBXGroup;
+			children = (
+				18FE1F581628550100389A13 /* TestInfo */,
+				18FE1F591628550100389A13 /* test00.m */,
+				18FE1F5A1628550100389A13 /* test01.m */,
+			);
+			path = NSScanner;
+			sourceTree = "<group>";
+		};
+		18FE1F5B1628550100389A13 /* NSSet */ = {
+			isa = PBXGroup;
+			children = (
+				18FE1F5C1628550100389A13 /* TestInfo */,
+				18FE1F5D1628550100389A13 /* basic.m */,
+			);
+			path = NSSet;
+			sourceTree = "<group>";
+		};
+		18FE1F5E1628550100389A13 /* NSSortDescriptor */ = {
+			isa = PBXGroup;
+			children = (
+				18FE1F5F1628550100389A13 /* TestInfo */,
+				18FE1F601628550100389A13 /* basic.m */,
+			);
+			path = NSSortDescriptor;
+			sourceTree = "<group>";
+		};
+		18FE1F611628550100389A13 /* NSStream */ = {
+			isa = PBXGroup;
+			children = (
+				18FE1F621628550100389A13 /* TestInfo */,
+				18FE1F631628550100389A13 /* basic.m */,
+				18FE1F641628550100389A13 /* memandfile.m */,
+				18FE1F651628550100389A13 /* memandfile_2.m */,
+				18FE1F661628550100389A13 /* pipe.m */,
+				18FE1F671628550100389A13 /* socket.m */,
+				18FE1F681628550100389A13 /* socket_cs.m */,
+			);
+			path = NSStream;
+			sourceTree = "<group>";
+		};
+		18FE1F691628550100389A13 /* NSString */ = {
+			isa = PBXGroup;
+			children = (
+				18FE1F6A1628550100389A13 /* NSString_base.m */,
+				18FE1F6B1628550100389A13 /* NSString_custom.m */,
+				18FE1F6C1628550100389A13 /* NSString_tests.h */,
+				18FE1F6D1628550100389A13 /* NSString_zero_hash.m */,
+				18FE1F6E1628550100389A13 /* TestInfo */,
+				18FE1F6F1628550100389A13 /* basic.m */,
+				18FE1F701628550100389A13 /* bom.m */,
+				18FE1F711628550100389A13 /* boolValue.m */,
+				18FE1F721628550100389A13 /* locale.m */,
+				18FE1F731628550100389A13 /* nuls_in_strings.m */,
+				18FE1F741628550100389A13 /* order.m */,
+				18FE1F751628550100389A13 /* regex.m */,
+				18FE1F761628550100389A13 /* test00.m */,
+				18FE1F771628550100389A13 /* test01.m */,
+				18FE1F781628550100389A13 /* test02.m */,
+				18FE1F791628550100389A13 /* test03.m */,
+				18FE1F7A1628550100389A13 /* test04.m */,
+				18FE1F7B1628550100389A13 /* test05.m */,
+				18FE1F7C1628550100389A13 /* test06.m */,
+				18FE1F7D1628550100389A13 /* test07.m */,
+				18FE1F7E1628550100389A13 /* utf8bom.txt */,
+			);
+			path = NSString;
+			sourceTree = "<group>";
+		};
+		18FE1F7F1628550100389A13 /* NSTask */ = {
+			isa = PBXGroup;
+			children = (
+				18FE1F801628550100389A13 /* GNUmakefile.preamble */,
+				18FE1F811628550100389A13 /* Helpers */,
+				18FE1F871628550100389A13 /* TestInfo */,
+				18FE1F881628550100389A13 /* basic.m */,
+				18FE1F891628550100389A13 /* general.m */,
+				18FE1F8A1628550100389A13 /* launch.m */,
+				18FE1F8B1628550100389A13 /* zombie.m */,
+			);
+			path = NSTask;
+			sourceTree = "<group>";
+		};
+		18FE1F811628550100389A13 /* Helpers */ = {
+			isa = PBXGroup;
+			children = (
+				18FE1F821628550100389A13 /* GNUmakefile */,
+				18FE1F831628550100389A13 /* NSZombie.m */,
+				18FE1F841628550100389A13 /* processgroup.m */,
+				18FE1F851628550100389A13 /* testcat.m */,
+				18FE1F861628550100389A13 /* testecho.m */,
+			);
+			path = Helpers;
+			sourceTree = "<group>";
+		};
+		18FE1F8C1628550100389A13 /* NSThread */ = {
+			isa = PBXGroup;
+			children = (
+				18FE1F8D1628550100389A13 /* lazy_thread.m */,
+			);
+			path = NSThread;
+			sourceTree = "<group>";
+		};
+		18FE1F8E1628550100389A13 /* NSTimeZone */ = {
+			isa = PBXGroup;
+			children = (
+				18FE1F8F1628550100389A13 /* TestInfo */,
+				18FE1F901628550100389A13 /* basic.m */,
+				18FE1F911628550100389A13 /* create.m */,
+				18FE1F921628550100389A13 /* use.m */,
+			);
+			path = NSTimeZone;
+			sourceTree = "<group>";
+		};
+		18FE1F931628550100389A13 /* NSURL */ = {
+			isa = PBXGroup;
+			children = (
+				18FE1F941628550100389A13 /* Chunked.dat */,
+				18FE1F951628550100389A13 /* GNUmakefile.preamble */,
+				18FE1F961628550100389A13 /* Helpers */,
+				18FE1F9B1628550100389A13 /* TestInfo */,
+				18FE1F9C1628550100389A13 /* basic.m */,
+				18FE1F9D1628550100389A13 /* test00.m */,
+				18FE1F9E1628550100389A13 /* test01.m */,
+			);
+			path = NSURL;
+			sourceTree = "<group>";
+		};
+		18FE1F961628550100389A13 /* Helpers */ = {
+			isa = PBXGroup;
+			children = (
+				18FE1F971628550100389A13 /* GNUmakefile */,
+				18FE1F981628550100389A13 /* capture.m */,
+				18FE1F991628550100389A13 /* keepalive.m */,
+				18FE1F9A1628550100389A13 /* respond.m */,
+			);
+			path = Helpers;
+			sourceTree = "<group>";
+		};
+		18FE1F9F1628550100389A13 /* NSURLConnection */ = {
+			isa = PBXGroup;
+			children = (
+				18FE1FA01628550100389A13 /* TestInfo */,
+				18FE1FA11628550100389A13 /* basic.m */,
+			);
+			path = NSURLConnection;
+			sourceTree = "<group>";
+		};
+		18FE1FA21628550100389A13 /* NSURLHandle */ = {
+			isa = PBXGroup;
+			children = (
+				18FE1FA31628550100389A13 /* GNUmakefile.preamble */,
+				18FE1FA41628550100389A13 /* Helpers */,
+				18FE1FA71628550100389A13 /* TestInfo */,
+				18FE1FA81628550100389A13 /* basic.m */,
+				18FE1FA91628550100389A13 /* test00.m */,
+				18FE1FAA1628550100389A13 /* test01.m */,
+			);
+			path = NSURLHandle;
+			sourceTree = "<group>";
+		};
+		18FE1FA41628550100389A13 /* Helpers */ = {
+			isa = PBXGroup;
+			children = (
+				18FE1FA51628550100389A13 /* GNUmakefile */,
+				18FE1FA61628550100389A13 /* StatusServer.m */,
+			);
+			path = Helpers;
+			sourceTree = "<group>";
+		};
+		18FE1FAB1628550100389A13 /* NSURLProtocol */ = {
+			isa = PBXGroup;
+			children = (
+				18FE1FAC1628550100389A13 /* TestInfo */,
+				18FE1FAD1628550100389A13 /* basic.m */,
+			);
+			path = NSURLProtocol;
+			sourceTree = "<group>";
+		};
+		18FE1FAE1628550100389A13 /* NSURLRequest */ = {
+			isa = PBXGroup;
+			children = (
+				18FE1FAF1628550100389A13 /* TestInfo */,
+				18FE1FB01628550100389A13 /* basic.m */,
+			);
+			path = NSURLRequest;
+			sourceTree = "<group>";
+		};
+		18FE1FB11628550100389A13 /* NSUndoManager */ = {
+			isa = PBXGroup;
+			children = (
+				18FE1FB21628550100389A13 /* NSUndoManager_basic.m */,
+				18FE1FB31628550100389A13 /* NSUndoManager_notifications.m */,
+				18FE1FB41628550100389A13 /* TestInfo */,
+			);
+			path = NSUndoManager;
+			sourceTree = "<group>";
+		};
+		18FE1FB51628550100389A13 /* NSUserDefaults */ = {
+			isa = PBXGroup;
+			children = (
+				18FE1FB61628550100389A13 /* TestInfo */,
+				18FE1FB71628550100389A13 /* basic.m */,
+				18FE1FB81628550100389A13 /* general.m */,
+			);
+			path = NSUserDefaults;
+			sourceTree = "<group>";
+		};
+		18FE1FB91628550100389A13 /* NSXMLDocument */ = {
+			isa = PBXGroup;
+			children = (
+				18FE1FBA1628550100389A13 /* TestInfo */,
+				18FE1FBB1628550100389A13 /* basic.m */,
+				18FE1FBC1628550100389A13 /* cdata.m */,
+			);
+			path = NSXMLDocument;
+			sourceTree = "<group>";
+		};
+		18FE1FBD1628550100389A13 /* NSXMLElement */ = {
+			isa = PBXGroup;
+			children = (
+				18FE1FBE1628550100389A13 /* TestInfo */,
+				18FE1FBF1628550100389A13 /* attributes.m */,
+				18FE1FC01628550100389A13 /* basic.m */,
+				18FE1FC11628550100389A13 /* children.m */,
+				18FE1FC21628550100389A13 /* transfer.m */,
+			);
+			path = NSXMLElement;
+			sourceTree = "<group>";
+		};
+		18FE1FC31628550100389A13 /* NSXMLNode */ = {
+			isa = PBXGroup;
+			children = (
+				18FE1FC41628550100389A13 /* TestInfo */,
+				18FE1FC51628550100389A13 /* basic.m */,
+				18FE1FC61628550100389A13 /* children.m */,
+				18FE1FC71628550100389A13 /* description.m */,
+				18FE1FC81628550100389A13 /* kinds.m */,
+				18FE1FC91628550100389A13 /* namespaces.m */,
+			);
+			path = NSXMLNode;
+			sourceTree = "<group>";
+		};
+		18FE1FCA1628550100389A13 /* NSXMLParser */ = {
+			isa = PBXGroup;
+			children = (
+				18FE1FCB1628550100389A13 /* ParseData */,
+				18FE1FCE1628550100389A13 /* TestInfo */,
+				18FE1FCF1628550100389A13 /* basic.m */,
+				18FE1FD01628550100389A13 /* parse.m */,
+			);
+			path = NSXMLParser;
+			sourceTree = "<group>";
+		};
+		18FE1FCB1628550100389A13 /* ParseData */ = {
+			isa = PBXGroup;
+			children = (
+				18FE1FCC1628550100389A13 /* internal-document.result */,
+				18FE1FCD1628550100389A13 /* internal-document.xml */,
+			);
+			path = ParseData;
+			sourceTree = "<group>";
+		};
+		18FE1FD11628550100389A13 /* PropertyLists */ = {
+			isa = PBXGroup;
+			children = (
+				18FE1FD21628550100389A13 /* TestInfo */,
+				18FE1FD31628550100389A13 /* non_ascii.m */,
+				18FE1FD41628550100389A13 /* non_ascii_utf16.plist */,
+				18FE1FD51628550100389A13 /* non_ascii_utf16.strings */,
+				18FE1FD61628550100389A13 /* non_ascii_utf8.plist */,
+				18FE1FD71628550100389A13 /* non_ascii_utf8.strings */,
+				18FE1FD81628550100389A13 /* test00.m */,
+				18FE1FD91628550100389A13 /* test01.m */,
+				18FE1FDA1628550100389A13 /* xml.m */,
+			);
+			path = PropertyLists;
+			sourceTree = "<group>";
+		};
+		18FE1FDC1628550100389A13 /* Unicode */ = {
+			isa = PBXGroup;
+			children = (
+				18FE1FDD1628550100389A13 /* TestInfo */,
+				18FE1FDE1628550100389A13 /* test00.m */,
+			);
+			path = Unicode;
+			sourceTree = "<group>";
+		};
+		18FE1FDF1628550100389A13 /* coding */ = {
+			isa = PBXGroup;
+			children = (
+				18578359175525A400CB7160 /* NSArray.1.32bit */,
+				1857835A175525A400CB7160 /* NSArray.1.64bit */,
+				1857835B175525A400CB7160 /* NSAttributedString.0.32bit */,
+				1857835C175525A400CB7160 /* NSAttributedString.0.64bit */,
+				1857835D175525A400CB7160 /* NSCharacterSet.0.32bit */,
+				1857835E175525A400CB7160 /* NSCharacterSet.0.64bit */,
+				1857835F175525A400CB7160 /* NSData.0.32bit */,
+				18578360175525A400CB7160 /* NSData.0.64bit */,
+				18578361175525A400CB7160 /* NSDate.1.32bit */,
+				18578362175525A400CB7160 /* NSDate.1.64bit */,
+				18578363175525A400CB7160 /* NSDateFormatter.0.32bit */,
+				18578364175525A400CB7160 /* NSDateFormatter.0.64bit */,
+				18578365175525A400CB7160 /* NSDictionary.0.32bit */,
+				18578366175525A400CB7160 /* NSDictionary.0.64bit */,
+				18578367175525A400CB7160 /* NSException.0.32bit */,
+				18578368175525A400CB7160 /* NSException.0.64bit */,
+				18578369175525A400CB7160 /* NSMutableData.0.32bit */,
+				1857836A175525A400CB7160 /* NSMutableData.0.64bit */,
+				1857836B175525A400CB7160 /* NSNotification.0.32bit */,
+				1857836C175525A400CB7160 /* NSNotification.0.64bit */,
+				1857836D175525A400CB7160 /* NSNull.0.32bit */,
+				1857836E175525A500CB7160 /* NSNull.0.64bit */,
+				1857836F175525A500CB7160 /* NSNumber.0.32bit */,
+				18578370175525A500CB7160 /* NSNumber.0.64bit */,
+				18578371175525A500CB7160 /* NSObject.0.32bit */,
+				18578372175525A500CB7160 /* NSObject.0.64bit */,
+				18578373175525A500CB7160 /* NSSet.0.32bit */,
+				18578374175525A500CB7160 /* NSSet.0.64bit */,
+				18578375175525A500CB7160 /* NSString.1.32bit */,
+				18578376175525A500CB7160 /* NSString.1.64bit */,
+				18578377175525A500CB7160 /* NSTableView.3.32bit */,
+				18578378175525A500CB7160 /* NSURL.0.32bit */,
+				18578379175525A500CB7160 /* NSURL.0.64bit */,
+				1857837A175525A500CB7160 /* NSValue.3.32bit */,
+				1857837B175525A500CB7160 /* NSValue.3.64bit */,
+				18FE1FF21628550100389A13 /* TestInfo */,
+				18FE1FF31628550100389A13 /* basictypes.m */,
+				18FE1FF41628550100389A13 /* decoding.m */,
+				18FE1FF51628550100389A13 /* double-8.type */,
+				18FE1FF61628550100389A13 /* float-4.type */,
+				18FE1FF71628550100389A13 /* int-4.type */,
+				18FE1FF81628550100389A13 /* llong-8.type */,
+				18FE1FF91628550100389A13 /* long-4.type */,
+				18FE1FFA1628550100389A13 /* schar-1.type */,
+				18FE1FFB1628550100389A13 /* short-2.type */,
+				18FE1FFC1628550100389A13 /* uchar-1.type */,
+				18FE1FFD1628550100389A13 /* uint-4.type */,
+				18FE1FFE1628550100389A13 /* ullong-8.type */,
+				18FE1FFF1628550100389A13 /* ulong-4.type */,
+				18FE20001628550100389A13 /* ushort-2.type */,
+			);
+			path = coding;
+			sourceTree = "<group>";
+		};
+		18FE20011628550100389A13 /* headers */ = {
+			isa = PBXGroup;
+			children = (
+				18FE20021628550100389A13 /* GSLock.m */,
+				18FE20031628550100389A13 /* GSMime.m */,
+				18FE20041628550100389A13 /* GSObjCRuntime.m */,
+				18FE20051628550100389A13 /* GSXML.m */,
+				18FE20061628550100389A13 /* NSArchiver.m */,
+				18FE20071628550100389A13 /* NSArray.m */,
+				18FE20081628550100389A13 /* NSAttributedString.m */,
+				18FE20091628550100389A13 /* NSAutoreleasePool.m */,
+				18FE200A1628550100389A13 /* NSBundle.m */,
+				18FE200B1628550100389A13 /* NSByteOrder.m */,
+				18FE200C1628550100389A13 /* NSCalendarDate.m */,
+				18FE200D1628550100389A13 /* NSCharacterSet.m */,
+				18FE200E1628550100389A13 /* NSClassDescription.m */,
+				18FE200F1628550100389A13 /* NSCoder.m */,
+				18FE20101628550100389A13 /* NSComparisonPredicate.m */,
+				18FE20111628550100389A13 /* NSCompoundPredicate.m */,
+				18FE20121628550100389A13 /* NSConnection.m */,
+				18FE20131628550100389A13 /* NSData.m */,
+				18FE20141628550100389A13 /* NSDate.m */,
+				18FE20151628550100389A13 /* NSDateFormatter.m */,
+				18FE20161628550100389A13 /* NSDebug.m */,
+				18FE20171628550100389A13 /* NSDecimal.m */,
+				18FE20181628550100389A13 /* NSDecimalNumber.m */,
+				18FE20191628550100389A13 /* NSDictionary.m */,
+				18FE201A1628550100389A13 /* NSDistantObject.m */,
+				18FE201B1628550100389A13 /* NSDistributedLock.m */,
+				18FE201C1628550100389A13 /* NSDistributedNotificationCenter.m */,
+				18FE201D1628550100389A13 /* NSEnumerator.m */,
+				18FE201E1628550100389A13 /* NSError.m */,
+				18FE201F1628550100389A13 /* NSException.m */,
+				18FE20201628550100389A13 /* NSExpression.m */,
+				18FE20211628550100389A13 /* NSFileHandle.m */,
+				18FE20221628550100389A13 /* NSFileManager.m */,
+				18FE20231628550100389A13 /* NSFormatter.m */,
+				18FE20241628550100389A13 /* NSGeometry.m */,
+				18FE20251628550100389A13 /* NSHTTPCookie.m */,
+				18FE20261628550100389A13 /* NSHTTPCookieStorage.m */,
+				18FE20271628550100389A13 /* NSHashTable.m */,
+				18FE20281628550100389A13 /* NSHost.m */,
+				18FE20291628550100389A13 /* NSIndexPath.m */,
+				18FE202A1628550100389A13 /* NSIndexSet.m */,
+				18FE202B1628550100389A13 /* NSInvocation.m */,
+				18FE202C1628550100389A13 /* NSKeyValueCoding.m */,
+				18FE202D1628550100389A13 /* NSKeyValueObserving.m */,
+				18FE202E1628550100389A13 /* NSKeyedArchiver.m */,
+				18FE202F1628550100389A13 /* NSLock.m */,
+				18FE20301628550100389A13 /* NSMapTable.m */,
+				18FE20311628550100389A13 /* NSMethodSignature.m */,
+				18FE20321628550100389A13 /* NSNotification.m */,
+				18FE20331628550100389A13 /* NSNotificationQueue.m */,
+				18FE20341628550100389A13 /* NSNull.m */,
+				18FE20351628550100389A13 /* NSNumberFormatter.m */,
+				18FE20361628550100389A13 /* NSObjCRuntime.m */,
+				18FE20371628550100389A13 /* NSObject.m */,
+				18FE20381628550100389A13 /* NSPathUtilities.m */,
+				18FE20391628550100389A13 /* NSPort.m */,
+				18FE203A1628550100389A13 /* NSPortCoder.m */,
+				18FE203B1628550100389A13 /* NSPortMessage.m */,
+				18FE203C1628550100389A13 /* NSPortNameServer.m */,
+				18FE203D1628550100389A13 /* NSPredicate.m */,
+				18FE203E1628550100389A13 /* NSProcessInfo.m */,
+				18FE203F1628550100389A13 /* NSPropertyList.m */,
+				18FE20401628550100389A13 /* NSProtocolChecker.m */,
+				18FE20411628550100389A13 /* NSProxy.m */,
+				18FE20421628550100389A13 /* NSRange.m */,
+				18FE20431628550100389A13 /* NSRunLoop.m */,
+				18FE20441628550100389A13 /* NSScanner.m */,
+				18FE20451628550100389A13 /* NSSerialization.m */,
+				18FE20461628550100389A13 /* NSSet.m */,
+				18FE20471628550100389A13 /* NSSortDescriptor.m */,
+				18FE20481628550100389A13 /* NSStream.m */,
+				18FE20491628550100389A13 /* NSString.m */,
+				18FE204A1628550100389A13 /* NSTask.m */,
+				18FE204B1628550100389A13 /* NSThread.m */,
+				18FE204C1628550100389A13 /* NSTimeZone.m */,
+				18FE204D1628550100389A13 /* NSTimer.m */,
+				18FE204E1628550100389A13 /* NSURL.m */,
+				18FE204F1628550100389A13 /* NSURLAuthenticationChallenge.m */,
+				18FE20501628550100389A13 /* NSURLCache.m */,
+				18FE20511628550100389A13 /* NSURLConnection.m */,
+				18FE20521628550100389A13 /* NSURLCredential.m */,
+				18FE20531628550100389A13 /* NSURLCredentialStorage.m */,
+				18FE20541628550100389A13 /* NSURLDownload.m */,
+				18FE20551628550100389A13 /* NSURLError.m */,
+				18FE20561628550100389A13 /* NSURLHandle.m */,
+				18FE20571628550100389A13 /* NSURLProtectionSpace.m */,
+				18FE20581628550100389A13 /* NSURLProtocol.m */,
+				18FE20591628550100389A13 /* NSURLRequest.m */,
+				18FE205A1628550100389A13 /* NSURLResponse.m */,
+				18FE205B1628550100389A13 /* NSUndoManager.m */,
+				18FE205C1628550100389A13 /* NSUserDefaults.m */,
+				18FE205D1628550100389A13 /* NSValue.m */,
+				18FE205E1628550100389A13 /* NSXMLParser.m */,
+				18FE205F1628550100389A13 /* NSZone.m */,
+				18FE20601628550100389A13 /* ObjCXX.mm */,
+				18FE20611628550100389A13 /* TestInfo */,
+				18FE20621628550100389A13 /* Unicode.m */,
+			);
+			path = headers;
+			sourceTree = "<group>";
+		};
+/* End PBXGroup section */
+
+/* Begin PBXHeadersBuildPhase section */
+		18394B191610D8E300335E85 /* Headers */ = {
+			isa = PBXHeadersBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				18394B351610D9D000335E85 /* Foundation.h in Headers */,
+				18394B361610D9D000335E85 /* FoundationErrors.h in Headers */,
+				18394B371610D9D000335E85 /* NSAffineTransform.h in Headers */,
+				18394B381610D9D000335E85 /* NSArchiver.h in Headers */,
+				18394B391610D9D000335E85 /* NSArray.h in Headers */,
+				18394B3A1610D9D000335E85 /* NSAttributedString.h in Headers */,
+				18394B3B1610D9D000335E85 /* NSAutoreleasePool.h in Headers */,
+				18394B3C1610D9D000335E85 /* NSBundle.h in Headers */,
+				18394B3D1610D9D000335E85 /* NSByteOrder.h in Headers */,
+				18394B3E1610D9D000335E85 /* NSCache.h in Headers */,
+				18394B3F1610D9D000335E85 /* NSCalendar.h in Headers */,
+				18394B401610D9D000335E85 /* NSCalendarDate.h in Headers */,
+				18394B411610D9D000335E85 /* NSCharacterSet.h in Headers */,
+				18394B421610D9D000335E85 /* NSClassDescription.h in Headers */,
+				18394B431610D9D000335E85 /* NSCoder.h in Headers */,
+				18394B441610D9D000335E85 /* NSComparisonPredicate.h in Headers */,
+				18394B451610D9D000335E85 /* NSCompoundPredicate.h in Headers */,
+				18394B461610D9D000335E85 /* NSConnection.h in Headers */,
+				18394B471610D9D000335E85 /* NSData.h in Headers */,
+				18394B481610D9D000335E85 /* NSDate.h in Headers */,
+				18394B491610D9D000335E85 /* NSDateFormatter.h in Headers */,
+				18394B4A1610D9D000335E85 /* NSDebug.h in Headers */,
+				18394B4B1610D9D000335E85 /* NSDecimal.h in Headers */,
+				18394B4C1610D9D000335E85 /* NSDecimalNumber.h in Headers */,
+				18394B4D1610D9D000335E85 /* NSDictionary.h in Headers */,
+				18394B4E1610D9D000335E85 /* NSDistantObject.h in Headers */,
+				18394B4F1610D9D000335E85 /* NSDistributedLock.h in Headers */,
+				18394B501610D9D000335E85 /* NSDistributedNotificationCenter.h in Headers */,
+				18394B511610D9D000335E85 /* NSEnumerator.h in Headers */,
+				18394B521610D9D000335E85 /* NSError.h in Headers */,
+				18394B531610D9D000335E85 /* NSErrorRecoveryAttempting.h in Headers */,
+				18394B541610D9D000335E85 /* NSException.h in Headers */,
+				18394B551610D9D000335E85 /* NSExpression.h in Headers */,
+				18394B561610D9D000335E85 /* NSFileHandle.h in Headers */,
+				18394B571610D9D000335E85 /* NSFileManager.h in Headers */,
+				18394B581610D9D000335E85 /* NSFormatter.h in Headers */,
+				18394B591610D9D000335E85 /* NSGarbageCollector.h in Headers */,
+				18394B5A1610D9D000335E85 /* NSGeometry.h in Headers */,
+				18394B5B1610D9D000335E85 /* NSHTTPCookie.h in Headers */,
+				18394B5C1610D9D000335E85 /* NSHTTPCookieStorage.h in Headers */,
+				18394B5D1610D9D000335E85 /* NSHashTable.h in Headers */,
+				18394B5E1610D9D000335E85 /* NSHost.h in Headers */,
+				18394B5F1610D9D000335E85 /* NSIndexPath.h in Headers */,
+				18394B601610D9D000335E85 /* NSIndexSet.h in Headers */,
+				18394B611610D9D000335E85 /* NSInvocation.h in Headers */,
+				18394B621610D9D000335E85 /* NSJSONSerialization.h in Headers */,
+				18394B631610D9D000335E85 /* NSKeyValueCoding.h in Headers */,
+				18394B641610D9D000335E85 /* NSKeyValueObserving.h in Headers */,
+				18394B651610D9D000335E85 /* NSKeyedArchiver.h in Headers */,
+				18394B661610D9D000335E85 /* NSLocale.h in Headers */,
+				18394B671610D9D000335E85 /* NSLock.h in Headers */,
+				18394B681610D9D000335E85 /* NSMapTable.h in Headers */,
+				18394B691610D9D000335E85 /* NSMethodSignature.h in Headers */,
+				18394B6A1610D9D000335E85 /* NSNetServices.h in Headers */,
+				18394B6B1610D9D000335E85 /* NSNotification.h in Headers */,
+				18394B6C1610D9D000335E85 /* NSNotificationQueue.h in Headers */,
+				18394B6D1610D9D000335E85 /* NSNull.h in Headers */,
+				18394B6E1610D9D000335E85 /* NSNumberFormatter.h in Headers */,
+				18394B6F1610D9D000335E85 /* NSObjCRuntime.h in Headers */,
+				18394B701610D9D000335E85 /* NSObject.h in Headers */,
+				18394B711610D9D000335E85 /* NSOperation.h in Headers */,
+				18394B721610D9D000335E85 /* NSPathUtilities.h in Headers */,
+				18394B731610D9D000335E85 /* NSPointerArray.h in Headers */,
+				18394B741610D9D000335E85 /* NSPointerFunctions.h in Headers */,
+				18394B751610D9D000335E85 /* NSPort.h in Headers */,
+				18394B761610D9D000335E85 /* NSPortCoder.h in Headers */,
+				18394B771610D9D000335E85 /* NSPortMessage.h in Headers */,
+				18394B781610D9D000335E85 /* NSPortNameServer.h in Headers */,
+				18394B791610D9D000335E85 /* NSPredicate.h in Headers */,
+				18394B7A1610D9D000335E85 /* NSProcessInfo.h in Headers */,
+				18394B7B1610D9D000335E85 /* NSPropertyList.h in Headers */,
+				18394B7C1610D9D000335E85 /* NSProtocolChecker.h in Headers */,
+				18394B7D1610D9D000335E85 /* NSProxy.h in Headers */,
+				18394B7E1610D9D000335E85 /* NSRange.h in Headers */,
+				18394B7F1610D9D000335E85 /* NSRegularExpression.h in Headers */,
+				18394B801610D9D000335E85 /* NSRunLoop.h in Headers */,
+				18394B811610D9D000335E85 /* NSScanner.h in Headers */,
+				18394B821610D9D000335E85 /* NSScriptWhoseTests.h in Headers */,
+				18394B831610D9D000335E85 /* NSSerialization.h in Headers */,
+				18394B841610D9D000335E85 /* NSSet.h in Headers */,
+				18394B851610D9D000335E85 /* NSSortDescriptor.h in Headers */,
+				18394B861610D9D000335E85 /* NSSpellServer.h in Headers */,
+				18394B871610D9D000335E85 /* NSStream.h in Headers */,
+				18394B881610D9D000335E85 /* NSString.h in Headers */,
+				18394B891610D9D000335E85 /* NSTask.h in Headers */,
+				18394B8A1610D9D000335E85 /* NSTextCheckingResult.h in Headers */,
+				18394B8B1610D9D000335E85 /* NSThread.h in Headers */,
+				18394B8C1610D9D000335E85 /* NSTimeZone.h in Headers */,
+				18394B8D1610D9D000335E85 /* NSTimer.h in Headers */,
+				18394B8E1610D9D000335E85 /* NSURL.h in Headers */,
+				18394B8F1610D9D000335E85 /* NSURLAuthenticationChallenge.h in Headers */,
+				18394B901610D9D000335E85 /* NSURLCache.h in Headers */,
+				18394B911610D9D000335E85 /* NSURLConnection.h in Headers */,
+				18394B921610D9D000335E85 /* NSURLCredential.h in Headers */,
+				18394B931610D9D000335E85 /* NSURLCredentialStorage.h in Headers */,
+				18394B941610D9D000335E85 /* NSURLDownload.h in Headers */,
+				18394B951610D9D000335E85 /* NSURLError.h in Headers */,
+				18394B961610D9D000335E85 /* NSURLHandle.h in Headers */,
+				18394B971610D9D000335E85 /* NSURLProtectionSpace.h in Headers */,
+				18394B981610D9D000335E85 /* NSURLProtocol.h in Headers */,
+				18394B991610D9D000335E85 /* NSURLRequest.h in Headers */,
+				18394B9A1610D9D000335E85 /* NSURLResponse.h in Headers */,
+				18394B9B1610D9D000335E85 /* NSUndoManager.h in Headers */,
+				18394B9C1610D9D000335E85 /* NSUserDefaults.h in Headers */,
+				18394B9D1610D9D000335E85 /* NSUtilities.h in Headers */,
+				18394B9E1610D9D000335E85 /* NSValue.h in Headers */,
+				18394B9F1610D9D000335E85 /* NSValueTransformer.h in Headers */,
+				18394BA01610D9D000335E85 /* NSXMLDTD.h in Headers */,
+				18394BA11610D9D000335E85 /* NSXMLDTDNode.h in Headers */,
+				18394BA21610D9D000335E85 /* NSXMLDocument.h in Headers */,
+				18394BA31610D9D000335E85 /* NSXMLElement.h in Headers */,
+				18394BA41610D9D000335E85 /* NSXMLNode.h in Headers */,
+				18394BA51610D9D000335E85 /* NSXMLNodeOptions.h in Headers */,
+				18394BA61610D9D000335E85 /* NSXMLParser.h in Headers */,
+				18394BA71610D9D000335E85 /* NSZone.h in Headers */,
+				18394BA81610D9ED00335E85 /* NSArray+GNUstepBase.h in Headers */,
+				18394BA91610D9ED00335E85 /* NSAttributedString+GNUstepBase.h in Headers */,
+				18394BAA1610D9ED00335E85 /* NSBundle+GNUstepBase.h in Headers */,
+				18394BAB1610D9ED00335E85 /* NSCalendarDate+GNUstepBase.h in Headers */,
+				18394BAC1610D9ED00335E85 /* NSData+GNUstepBase.h in Headers */,
+				18394BAD1610D9ED00335E85 /* NSDebug+GNUstepBase.h in Headers */,
+				18394BAE1610D9ED00335E85 /* NSFileHandle+GNUstepBase.h in Headers */,
+				18394BAF1610D9ED00335E85 /* NSLock+GNUstepBase.h in Headers */,
+				18394BB01610D9ED00335E85 /* NSMutableString+GNUstepBase.h in Headers */,
+				18394BB11610D9ED00335E85 /* NSNetServices+GNUstepBase.h in Headers */,
+				18394BB21610D9ED00335E85 /* NSNumber+GNUstepBase.h in Headers */,
+				18394BB31610D9ED00335E85 /* NSObject+GNUstepBase.h in Headers */,
+				18394BB41610D9ED00335E85 /* NSProcessInfo+GNUstepBase.h in Headers */,
+				18394BB51610D9ED00335E85 /* NSStream+GNUstepBase.h in Headers */,
+				18394BB61610D9ED00335E85 /* NSString+GNUstepBase.h in Headers */,
+				18394BB71610D9ED00335E85 /* NSTask+GNUstepBase.h in Headers */,
+				18394BB81610D9ED00335E85 /* NSThread+GNUstepBase.h in Headers */,
+				18394BB91610D9ED00335E85 /* NSURL+GNUstepBase.h in Headers */,
+				18394C7D1610EC5E00335E85 /* NSCallBacks.h in Headers */,
+				18394C7E1610EC5E00335E85 /* NSCharacterSetData.h in Headers */,
+				18394C7F1610EC5E00335E85 /* NSConcretePointerFunctions.h in Headers */,
+				18394C801610EC5E00335E85 /* NSNumberMethods.h in Headers */,
+				18394C811610EC5E00335E85 /* NSXMLPrivate.h in Headers */,
+				18394B341610D95600335E85 /* Foundation-Prefix.pch in Headers */,
+				18F8D05D1724534E00420DA5 /* NSKeyValueNestedProperty.h in Headers */,
+				18F8D05F1724534E00420DA5 /* NSKeyValueObservance.h in Headers */,
+				18F8D0611724534E00420DA5 /* NSKeyValueObservationInfo.h in Headers */,
+				18F8D0631724534E00420DA5 /* NSKeyValueObservingPrivate.h in Headers */,
+				18F8D0651724534E00420DA5 /* NSKeyValueProperty.h in Headers */,
+				18F8D0671724534E00420DA5 /* NSKeyValueUnnestedProperty.h in Headers */,
+				18F8D06C1725919A00420DA5 /* NSKVONotifying.h in Headers */,
+				18EA6764172EC7F70026AC34 /* GSTypeEncoding.h in Headers */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+/* End PBXHeadersBuildPhase section */
+
+/* Begin PBXNativeTarget section */
+		1837DA0D1652D18400197E53 /* gdnc */ = {
+			isa = PBXNativeTarget;
+			buildConfigurationList = 1837DA161652D18400197E53 /* Build configuration list for PBXNativeTarget "gdnc" */;
+			buildPhases = (
+				1837DA101652D18400197E53 /* Sources */,
+				1837DA121652D18400197E53 /* Frameworks */,
+				1837DA151652D18400197E53 /* CopyFiles */,
+			);
+			buildRules = (
+			);
+			dependencies = (
+				1837DA0E1652D18400197E53 /* PBXTargetDependency */,
+			);
+			name = gdnc;
+			productName = keepalive;
+			productReference = 1837DA191652D18400197E53 /* gdnc */;
+			productType = "com.apple.product-type.tool";
+		};
+		18394B1B1610D8E300335E85 /* Foundation */ = {
+			isa = PBXNativeTarget;
+			buildConfigurationList = 18394B2D1610D8E400335E85 /* Build configuration list for PBXNativeTarget "Foundation" */;
+			buildPhases = (
+				18394B171610D8E300335E85 /* Sources */,
+				18394B181610D8E300335E85 /* Frameworks */,
+				18394B191610D8E300335E85 /* Headers */,
+				18394B1A1610D8E300335E85 /* Resources */,
+			);
+			buildRules = (
+				1801C64416B5A8E400999B34 /* PBXBuildRule */,
+			);
+			dependencies = (
+			);
+			name = Foundation;
+			productName = Foundation;
+			productReference = 18394B1C1610D8E300335E85 /* Foundation.framework */;
+			productType = "com.apple.product-type.framework";
+		};
+/* End PBXNativeTarget section */
+
+/* Begin PBXProject section */
+		18906E371610BC4C0003C892 /* Project object */ = {
+			isa = PBXProject;
+			attributes = {
+				LastUpgradeCheck = 0420;
+			};
+			buildConfigurationList = 18906E3A1610BC4C0003C892 /* Build configuration list for PBXProject "base" */;
+			compatibilityVersion = "Xcode 3.2";
+			developmentRegion = English;
+			hasScannedForEncodings = 0;
+			knownRegions = (
+				en,
+				English,
+				French,
+				de,
+			);
+			mainGroup = 18906E351610BC4C0003C892;
+			productRefGroup = 18906E421610BC4C0003C892 /* Products */;
+			projectDirPath = "";
+			projectRoot = "";
+			targets = (
+				18394B1B1610D8E300335E85 /* Foundation */,
+				1837DA0D1652D18400197E53 /* gdnc */,
+			);
+		};
+/* End PBXProject section */
+
+/* Begin PBXResourcesBuildPhase section */
+		18394B1A1610D8E300335E85 /* Resources */ = {
+			isa = PBXResourcesBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+/* End PBXResourcesBuildPhase section */
+
+/* Begin PBXSourcesBuildPhase section */
+		1837DA101652D18400197E53 /* Sources */ = {
+			isa = PBXSourcesBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				18EFCC1F172B0B9A003304CA /* gdnc.m in Sources */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+		18394B171610D8E300335E85 /* Sources */ = {
+			isa = PBXSourcesBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				185289A516139AAF0016729B /* externs.m in Sources */,
+				180878891618537A006EBD74 /* objc-load.m in Sources */,
+				185289AA16139AAF0016729B /* preface.m in Sources */,
+				18528A001613AB940016729B /* GSRunLoopCtxt.m in Sources */,
+				18528A011613AB940016729B /* NSStream.m in Sources */,
+				1852895F161396450016729B /* GSArray.m in Sources */,
+				18528960161396450016729B /* GSAttributedString.m in Sources */,
+				18528961161396450016729B /* CXXException.m in Sources */,
+				18528966161396450016729B /* GSBlocks.m in Sources */,
+				18528967161396450016729B /* GSConcreteValue.m in Sources */,
+				18528969161396450016729B /* GSCountedSet.m in Sources */,
+				1852896A161396450016729B /* GSDictionary.m in Sources */,
+				1852896D161396450016729B /* GSFTPURLHandle.m in Sources */,
+				1852896E161396450016729B /* GSFileHandle.m in Sources */,
+				1852896F161396450016729B /* GSFormat.m in Sources */,
+				18528970161396450016729B /* GSHTTPAuthentication.m in Sources */,
+				18528971161396450016729B /* GSHTTPURLHandle.m in Sources */,
+				18528972161396450016729B /* GSICUString.m in Sources */,
+				18528973161396450016729B /* GSLocale.m in Sources */,
+				18528974161396450016729B /* GSMDNSNetServices.m in Sources */,
+				18528975161396450016729B /* GSQuickSort.m in Sources */,
+				18528976161396450016729B /* GSRunLoopWatcher.m in Sources */,
+				18528977161396450016729B /* GSSet.m in Sources */,
+				18528978161396450016729B /* GSShellSort.m in Sources */,
+				18528979161396450016729B /* GSSocketStream.m in Sources */,
+				1852897A161396450016729B /* GSStream.m in Sources */,
+				1852897B161396450016729B /* GSString.m in Sources */,
+				1852897C161396450016729B /* GSTLS.m in Sources */,
+				1852897D161396450016729B /* GSTimSort.m in Sources */,
+				1852897E161396450016729B /* GSValue.m in Sources */,
+				18641D211678AD41003C6E11 /* GSSocksParser.m in Sources */,
+				18641D221678AD46003C6E11 /* GSSocksParserPrivate.m in Sources */,
+				18641D1F1678AD34003C6E11 /* GSSocks4Parser.m in Sources */,
+				18641D201678AD39003C6E11 /* GSSocks5Parser.m in Sources */,
+				18528957161396130016729B /* GCArray.m in Sources */,
+				18528958161396160016729B /* GCDictionary.m in Sources */,
+				185289591613961A0016729B /* GCObject.m in Sources */,
+				1852895A161396200016729B /* GSFunctions.m in Sources */,
+				1852895B161396240016729B /* GSInsensitiveDictionary.m in Sources */,
+				1852895C161396280016729B /* GSLock.m in Sources */,
+				1852895D1613962B0016729B /* GSMime.m in Sources */,
+				185289511613861E0016729B /* GSObjCRuntime.m in Sources */,
+				1852895E161396310016729B /* GSXML.m in Sources */,
+				18528984161398FF0016729B /* NSArray+GNUstepBase.m in Sources */,
+				18528985161398FF0016729B /* NSAttributedString+GNUstepBase.m in Sources */,
+				18528986161398FF0016729B /* NSBundle+GNUstepBase.m in Sources */,
+				18528987161398FF0016729B /* NSCalendarDate+GNUstepBase.m in Sources */,
+				18528988161398FF0016729B /* NSData+GNUstepBase.m in Sources */,
+				18528989161398FF0016729B /* NSDebug+GNUstepBase.m in Sources */,
+				1852898A161398FF0016729B /* NSError+GNUstepBase.m in Sources */,
+				1852898B161398FF0016729B /* NSFileHandle+GNUstepBase.m in Sources */,
+				1852898C161399000016729B /* NSLock+GNUstepBase.m in Sources */,
+				1852898D161399000016729B /* NSMutableString+GNUstepBase.m in Sources */,
+				1852898E161399000016729B /* NSNumber+GNUstepBase.m in Sources */,
+				1852898F161399000016729B /* NSObject+GNUstepBase.m in Sources */,
+				18528990161399000016729B /* NSProcessInfo+GNUstepBase.m in Sources */,
+				18528991161399000016729B /* NSPropertyList+GNUstepBase.m in Sources */,
+				18528992161399000016729B /* NSStream+GNUstepBase.m in Sources */,
+				18528993161399000016729B /* NSString+GNUstepBase.m in Sources */,
+				18528994161399000016729B /* NSTask+GNUstepBase.m in Sources */,
+				18528995161399000016729B /* NSThread+GNUstepBase.m in Sources */,
+				18528996161399000016729B /* NSURL+GNUstepBase.m in Sources */,
+				18528997161399000016729B /* Unicode.m in Sources */,
+				185289A216139AAF0016729B /* NSObject+NSComparisonMethods.m in Sources */,
+				18394C011610EB7F00335E85 /* NSAffineTransform.m in Sources */,
+				1852895316138C5C0016729B /* NSArchiver.m in Sources */,
+				18394C031610EB7F00335E85 /* NSArray.m in Sources */,
+				18394C041610EB7F00335E85 /* NSAssertionHandler.m in Sources */,
+				18394C051610EB7F00335E85 /* NSAttributedString.m in Sources */,
+				18394C061610EB7F00335E85 /* NSAutoreleasePool.m in Sources */,
+				18394C071610EB7F00335E85 /* NSBundle.m in Sources */,
+				18394C081610EB7F00335E85 /* NSCache.m in Sources */,
+				18394C091610EB7F00335E85 /* NSCachedURLResponse.m in Sources */,
+				18394C0A1610EB7F00335E85 /* NSCalendar.m in Sources */,
+				18394C0B1610EB7F00335E85 /* NSCalendarDate.m in Sources */,
+				18394C0C1610EB7F00335E85 /* NSCallBacks.m in Sources */,
+				18394C0D1610EB7F00335E85 /* NSCharacterSet.m in Sources */,
+				18394C0E1610EB7F00335E85 /* NSClassDescription.m in Sources */,
+				18394C0F1610EB7F00335E85 /* NSCoder.m in Sources */,
+				18394C101610EB7F00335E85 /* NSConcreteHashTable.m in Sources */,
+				18394C111610EB7F00335E85 /* NSConcreteMapTable.m in Sources */,
+				18394C121610EB7F00335E85 /* NSConcretePointerFunctions.m in Sources */,
+				18394C131610EB7F00335E85 /* NSConnection.m in Sources */,
+				18394C141610EB7F00335E85 /* NSCopyObject.m in Sources */,
+				18394C151610EB7F00335E85 /* NSCountedSet.m in Sources */,
+				1852895416138CFB0016729B /* NSData.m in Sources */,
+				18394C171610EB7F00335E85 /* NSDate.m in Sources */,
+				18394C181610EB7F00335E85 /* NSDateFormatter.m in Sources */,
+				18394C191610EB7F00335E85 /* NSDebug.m in Sources */,
+				18394C1A1610EB7F00335E85 /* NSDecimal.m in Sources */,
+				18394C1B1610EB7F00335E85 /* NSDecimalNumber.m in Sources */,
+				18394C1C1610EB7F00335E85 /* NSDictionary.m in Sources */,
+				18394C1D1610EB7F00335E85 /* NSDistantObject.m in Sources */,
+				18394C1E1610EB7F00335E85 /* NSDistributedLock.m in Sources */,
+				18394C1F1610EB7F00335E85 /* NSDistributedNotificationCenter.m in Sources */,
+				18394C201610EB7F00335E85 /* NSEnumerator.m in Sources */,
+				18394C211610EB7F00335E85 /* NSError.m in Sources */,
+				18394C221610EB7F00335E85 /* NSException.m in Sources */,
+				18394C231610EB7F00335E85 /* NSFileHandle.m in Sources */,
+				18394C241610EB7F00335E85 /* NSFileManager.m in Sources */,
+				18394C251610EB7F00335E85 /* NSFormatter.m in Sources */,
+				18394C261610EB7F00335E85 /* NSGarbageCollector.m in Sources */,
+				18394C271610EB7F00335E85 /* NSGeometry.m in Sources */,
+				18394C281610EB7F00335E85 /* NSHTTPCookie.m in Sources */,
+				18394C291610EB7F00335E85 /* NSHTTPCookieStorage.m in Sources */,
+				18394C2A1610EB7F00335E85 /* NSHashTable.m in Sources */,
+				18394C2B1610EB7F00335E85 /* NSHost.m in Sources */,
+				18394C2C1610EB7F00335E85 /* NSIndexPath.m in Sources */,
+				18394C2D1610EB7F00335E85 /* NSIndexSet.m in Sources */,
+				18394C2E1610EB7F00335E85 /* NSInvocation.ff.m in Sources */,
+				18D8BEA4164B5FF800942A5D /* NSInvocation.x86_64.m in Sources */,
+				180DFAEB165BF98C00573635 /* NSInvocation.x86_64.S in Sources */,
+				18394C2F1610EB7F00335E85 /* NSJSONSerialization.m in Sources */,
+				18394C301610EB7F00335E85 /* NSKeyValueCoding.m in Sources */,
+				18394C341610EB7F00335E85 /* NSKeyedArchiver.m in Sources */,
+				185391931625FD0C0015BDFA /* NSKeyedUnarchiver.m in Sources */,
+				18394C361610EB7F00335E85 /* NSLocale.m in Sources */,
+				18394C371610EB7F00335E85 /* NSLock.m in Sources */,
+				18394C381610EB7F00335E85 /* NSLog.m in Sources */,
+				18394C391610EB7F00335E85 /* NSMapTable.m in Sources */,
+				18394C3A1610EB7F00335E85 /* NSMessagePort.m in Sources */,
+				18394C3B1610EB7F00335E85 /* NSMessagePortNameServer.m in Sources */,
+				18394C3C1610EB7F00335E85 /* NSMethodSignature.m in Sources */,
+				18394C3D1610EB7F00335E85 /* NSNetServices.m in Sources */,
+				18394C3E1610EB7F00335E85 /* NSNotification.m in Sources */,
+				185289FF1613A8840016729B /* NSNotificationCenter.m in Sources */,
+				18394C401610EB7F00335E85 /* NSNotificationQueue.m in Sources */,
+				18394C411610EB7F00335E85 /* NSNull.m in Sources */,
+				18394C421610EB7F00335E85 /* NSNumber.m in Sources */,
+				18394C431610EB7F00335E85 /* NSNumberFormatter.m in Sources */,
+				1852894F161243FC0016729B /* NSObjCRuntime.m in Sources */,
+				18394C451610EB7F00335E85 /* NSObject.m in Sources */,
+				18394C461610EB7F00335E85 /* NSOperation.m in Sources */,
+				18394C471610EB7F00335E85 /* NSPage.m in Sources */,
+				18394C481610EB7F00335E85 /* NSPathUtilities.m in Sources */,
+				18394C491610EB7F00335E85 /* NSPipe.m in Sources */,
+				18394C4A1610EB7F00335E85 /* NSPointerArray.m in Sources */,
+				18394C4B1610EB7F00335E85 /* NSPointerFunctions.m in Sources */,
+				18394C4C1610EB7F00335E85 /* NSPort.m in Sources */,
+				1852895516138E6F0016729B /* NSPortCoder.m in Sources */,
+				18394C4E1610EB7F00335E85 /* NSPortMessage.m in Sources */,
+				18394C4F1610EB7F00335E85 /* NSPortNameServer.m in Sources */,
+				18394C501610EB7F00335E85 /* NSPredicate.m in Sources */,
+				18394C511610EB7F00335E85 /* NSProcessInfo.m in Sources */,
+				18394C521610EB7F00335E85 /* NSPropertyList.m in Sources */,
+				18394C531610EB7F00335E85 /* NSProtocolChecker.m in Sources */,
+				18394C541610EB7F00335E85 /* NSProxy.m in Sources */,
+				18394C551610EB7F00335E85 /* NSRange.m in Sources */,
+				18394C561610EB7F00335E85 /* NSRegularExpression.m in Sources */,
+				18394C571610EB7F00335E85 /* NSRunLoop.m in Sources */,
+				18394C581610EB7F00335E85 /* NSScanner.m in Sources */,
+				18394C591610EB7F00335E85 /* NSSerializer.m in Sources */,
+				18394C5A1610EB7F00335E85 /* NSSet.m in Sources */,
+				18394C5B1610EB7F00335E85 /* NSSocketPort.m in Sources */,
+				18394C5C1610EB7F00335E85 /* NSSocketPortNameServer.m in Sources */,
+				18394C5D1610EB7F00335E85 /* NSSortDescriptor.m in Sources */,
+				18394C5E1610EB7F00335E85 /* NSSpellServer.m in Sources */,
+				18394C5F1610EB7F00335E85 /* NSString.m in Sources */,
+				18394C601610EB7F00335E85 /* NSTask.m in Sources */,
+				18394C611610EB7F00335E85 /* NSTextCheckingResult.m in Sources */,
+				18394C621610EB7F00335E85 /* NSThread.m in Sources */,
+				18394C631610EB7F00335E85 /* NSTimeZone.m in Sources */,
+				18394C641610EB7F00335E85 /* NSTimer.m in Sources */,
+				18394C651610EB7F00335E85 /* NSURL.m in Sources */,
+				18394C661610EB7F00335E85 /* NSURLAuthenticationChallenge.m in Sources */,
+				18394C671610EB7F00335E85 /* NSURLCache.m in Sources */,
+				18394C681610EB7F00335E85 /* NSURLConnection.m in Sources */,
+				18394C691610EB7F00335E85 /* NSURLCredential.m in Sources */,
+				18394C6A1610EB8000335E85 /* NSURLCredentialStorage.m in Sources */,
+				18394C6B1610EB8000335E85 /* NSURLDownload.m in Sources */,
+				18394C6C1610EB8000335E85 /* NSURLHandle.m in Sources */,
+				18394C6D1610EB8000335E85 /* NSURLProtectionSpace.m in Sources */,
+				18394C6E1610EB8000335E85 /* NSURLProtocol.m in Sources */,
+				18394C6F1610EB8000335E85 /* NSURLRequest.m in Sources */,
+				18394C701610EB8000335E85 /* NSURLResponse.m in Sources */,
+				1852895216138A7D0016729B /* NSUnarchiver.m in Sources */,
+				18394C721610EB8000335E85 /* NSUndoManager.m in Sources */,
+				18394C731610EB8000335E85 /* NSUserDefaults.m in Sources */,
+				18394C741610EB8000335E85 /* NSValue.m in Sources */,
+				18394C751610EB8000335E85 /* NSValueTransformer.m in Sources */,
+				18394C761610EB8000335E85 /* NSXMLDTD.m in Sources */,
+				18394C771610EB8000335E85 /* NSXMLDTDNode.m in Sources */,
+				18394C781610EB8000335E85 /* NSXMLDocument.m in Sources */,
+				18394C791610EB8000335E85 /* NSXMLElement.m in Sources */,
+				18394C7A1610EB8000335E85 /* NSXMLNode.m in Sources */,
+				18394C7B1610EB8000335E85 /* NSXMLParser.m in Sources */,
+				18394C7C1610EB8000335E85 /* NSZone.m in Sources */,
+				1890B34116F3BC3300187826 /* GSPrivateHash.m in Sources */,
+				18F8D05E1724534E00420DA5 /* NSKeyValueNestedProperty.m in Sources */,
+				18F8D0601724534E00420DA5 /* NSKeyValueObservance.m in Sources */,
+				18F8D0621724534E00420DA5 /* NSKeyValueObservationInfo.m in Sources */,
+				18F8D0641724534E00420DA5 /* NSKeyValueObservingPrivate.m in Sources */,
+				18F8D0661724534E00420DA5 /* NSKeyValueProperty.m in Sources */,
+				18F8D0681724534E00420DA5 /* NSKeyValueUnnestedProperty.m in Sources */,
+				18F8D0691724534E00420DA5 /* NSObject+KVO.m in Sources */,
+				18F8D06D1725919A00420DA5 /* NSKVONotifying.m in Sources */,
+				18408FF217271D3E00CFD080 /* NSKeyValueObserving.m in Sources */,
+				18408FF617271EAE00CFD080 /* NSArray+KVO.m in Sources */,
+				18408FFA1727200100CFD080 /* NSSet+KVO.m in Sources */,
+				18EA6761172EC6170026AC34 /* GSTypeEncoding.c in Sources */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+/* End PBXSourcesBuildPhase section */
+
+/* Begin PBXTargetDependency section */
+		1837DA0E1652D18400197E53 /* PBXTargetDependency */ = {
+			isa = PBXTargetDependency;
+			target = 18394B1B1610D8E300335E85 /* Foundation */;
+			targetProxy = 1837DA0F1652D18400197E53 /* PBXContainerItemProxy */;
+		};
+/* End PBXTargetDependency section */
+
+/* Begin PBXVariantGroup section */
+		18FE1E781628550000389A13 /* TextRes.txt */ = {
+			isa = PBXVariantGroup;
+			children = (
+				18FE1E791628550000389A13 /* English */,
+				18FE1E7A1628550000389A13 /* French */,
+				18FE1E7F1628550000389A13 /* de */,
+			);
+			name = TextRes.txt;
+			sourceTree = "<group>";
+		};
+/* End PBXVariantGroup section */
+
+/* Begin XCBuildConfiguration section */
+		1837DA171652D18400197E53 /* Debug */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				CLANG_LINK_OBJC_RUNTIME = NO;
+				GCC_PRECOMPILE_PREFIX_HEADER = NO;
+				GCC_PREFIX_HEADER = "";
+				HEADER_SEARCH_PATHS = (
+					/usr/GNUstep/System/Library/Makefiles/TestFramework/,
+					"$(SRCROOT)/Headers",
+				);
+				OTHER_CFLAGS = (
+					"-DGNUSTEP",
+					"-DGNUSTEP_BASE_LIBRARY",
+				);
+				PRODUCT_NAME = gdnc;
+			};
+			name = Debug;
+		};
+		1837DA181652D18400197E53 /* Release */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				CLANG_LINK_OBJC_RUNTIME = NO;
+				GCC_PRECOMPILE_PREFIX_HEADER = NO;
+				GCC_PREFIX_HEADER = "";
+				HEADER_SEARCH_PATHS = (
+					/usr/GNUstep/System/Library/Makefiles/TestFramework/,
+					"$(SRCROOT)/Headers",
+				);
+				OTHER_CFLAGS = (
+					"-DGNUSTEP",
+					"-DGNUSTEP_BASE_LIBRARY",
+				);
+				PRODUCT_NAME = gdnc;
+			};
+			name = Release;
+		};
+		18394B2E1610D8E400335E85 /* Debug */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				CLANG_LINK_OBJC_RUNTIME = NO;
+				DYLIB_COMPATIBILITY_VERSION = 1;
+				DYLIB_CURRENT_VERSION = 1;
+				FRAMEWORK_VERSION = A;
+				GCC_ENABLE_OBJC_EXCEPTIONS = YES;
+				GCC_FAST_OBJC_DISPATCH = YES;
+				GCC_PRECOMPILE_PREFIX_HEADER = YES;
+				GCC_PREFIX_HEADER = "Support/Foundation/Foundation-Prefix.pch";
+				GCC_VERSION = com.apple.compilers.llvm.clang.1_0;
+				GCC_WARN_ALLOW_INCOMPLETE_PROTOCOL = YES;
+				HEADER_SEARCH_PATHS = (
+					/opt/local/include,
+					/usr/include/libxml2,
+					/opt/local/include/libxml2,
+					"$(SRCROOT)/Headers",
+				);
+				INFOPLIST_FILE = "Support/Foundation/Foundation-Info.plist";
+				LIBRARY_SEARCH_PATHS = /opt/local/lib;
+				OTHER_CFLAGS = (
+					"-DGNUSTEP",
+					"-DNeXT_RUNTIME",
+					"-pthread",
+				);
+				OTHER_LDFLAGS = (
+					"-licudata",
+					"-licui18n",
+					"-licuuc",
+					"-Wl,-reexport_library",
+					/usr/lib/libobjc.dylib,
+				);
+				PRODUCT_NAME = "$(TARGET_NAME)";
+				WRAPPER_EXTENSION = framework;
+			};
+			name = Debug;
+		};
+		18394B2F1610D8E400335E85 /* Release */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				CLANG_LINK_OBJC_RUNTIME = NO;
+				DYLIB_COMPATIBILITY_VERSION = 1;
+				DYLIB_CURRENT_VERSION = 1;
+				FRAMEWORK_VERSION = A;
+				GCC_ENABLE_OBJC_EXCEPTIONS = YES;
+				GCC_FAST_OBJC_DISPATCH = YES;
+				GCC_PRECOMPILE_PREFIX_HEADER = YES;
+				GCC_PREFIX_HEADER = "Support/Foundation/Foundation-Prefix.pch";
+				GCC_VERSION = com.apple.compilers.llvm.clang.1_0;
+				GCC_WARN_ALLOW_INCOMPLETE_PROTOCOL = YES;
+				HEADER_SEARCH_PATHS = (
+					/opt/local/include,
+					/usr/include/libxml2,
+					/opt/local/include/libxml2,
+					"$(SRCROOT)/Headers",
+				);
+				INFOPLIST_FILE = "Support/Foundation/Foundation-Info.plist";
+				LIBRARY_SEARCH_PATHS = /opt/local/lib;
+				OTHER_CFLAGS = (
+					"-DGNUSTEP",
+					"-DNeXT_RUNTIME",
+					"-pthread",
+				);
+				OTHER_LDFLAGS = (
+					"-licudata",
+					"-licui18n",
+					"-licuuc",
+					"-Wl,-reexport_library",
+					/usr/lib/libobjc.dylib,
+				);
+				PRODUCT_NAME = "$(TARGET_NAME)";
+				WRAPPER_EXTENSION = framework;
+			};
+			name = Release;
+		};
+		18906E541610BC4C0003C892 /* Debug */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				ALWAYS_SEARCH_USER_PATHS = NO;
+				ARCHS = "$(ARCHS_STANDARD_64_BIT)";
+				COPY_PHASE_STRIP = NO;
+				GCC_C_LANGUAGE_STANDARD = gnu99;
+				GCC_DYNAMIC_NO_PIC = NO;
+				GCC_ENABLE_OBJC_EXCEPTIONS = YES;
+				GCC_OPTIMIZATION_LEVEL = 0;
+				GCC_PREPROCESSOR_DEFINITIONS = (
+					"DEBUG=1",
+					"$(inherited)",
+				);
+				GCC_SYMBOLS_PRIVATE_EXTERN = NO;
+				GCC_VERSION = com.apple.compilers.llvm.clang.1_0;
+				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
+				GCC_WARN_ABOUT_MISSING_PROTOTYPES = YES;
+				GCC_WARN_ABOUT_RETURN_TYPE = YES;
+				GCC_WARN_UNUSED_VARIABLE = YES;
+				MACOSX_DEPLOYMENT_TARGET = 10.6;
+				ONLY_ACTIVE_ARCH = YES;
+				SDKROOT = macosx;
+			};
+			name = Debug;
+		};
+		18906E551610BC4C0003C892 /* Release */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				ALWAYS_SEARCH_USER_PATHS = NO;
+				ARCHS = "$(ARCHS_STANDARD_64_BIT)";
+				COPY_PHASE_STRIP = YES;
+				DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
+				GCC_C_LANGUAGE_STANDARD = gnu99;
+				GCC_ENABLE_OBJC_EXCEPTIONS = YES;
+				GCC_VERSION = com.apple.compilers.llvm.clang.1_0;
+				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
+				GCC_WARN_ABOUT_MISSING_PROTOTYPES = YES;
+				GCC_WARN_ABOUT_RETURN_TYPE = YES;
+				GCC_WARN_UNUSED_VARIABLE = YES;
+				MACOSX_DEPLOYMENT_TARGET = 10.6;
+				SDKROOT = macosx;
+			};
+			name = Release;
+		};
+/* End XCBuildConfiguration section */
+
+/* Begin XCConfigurationList section */
+		1837DA161652D18400197E53 /* Build configuration list for PBXNativeTarget "gdnc" */ = {
+			isa = XCConfigurationList;
+			buildConfigurations = (
+				1837DA171652D18400197E53 /* Debug */,
+				1837DA181652D18400197E53 /* Release */,
+			);
+			defaultConfigurationIsVisible = 0;
+			defaultConfigurationName = Release;
+		};
+		18394B2D1610D8E400335E85 /* Build configuration list for PBXNativeTarget "Foundation" */ = {
+			isa = XCConfigurationList;
+			buildConfigurations = (
+				18394B2E1610D8E400335E85 /* Debug */,
+				18394B2F1610D8E400335E85 /* Release */,
+			);
+			defaultConfigurationIsVisible = 0;
+			defaultConfigurationName = Release;
+		};
+		18906E3A1610BC4C0003C892 /* Build configuration list for PBXProject "base" */ = {
+			isa = XCConfigurationList;
+			buildConfigurations = (
+				18906E541610BC4C0003C892 /* Debug */,
+				18906E551610BC4C0003C892 /* Release */,
+			);
+			defaultConfigurationIsVisible = 0;
+			defaultConfigurationName = Release;
+		};
+/* End XCConfigurationList section */
+	};
+	rootObject = 18906E371610BC4C0003C892 /* Project object */;
+}
diff --git a/config/config.constant-string-class.m b/config/config.constant-string-class.m
index 9e170dd..3fc2534 100644
--- a/config/config.constant-string-class.m
+++ b/config/config.constant-string-class.m
@@ -12,12 +12,42 @@
    version 2 of the License, or (at your option) any later version.
 */
 
-/* must be compiled compile using -fconstant-string-class=NSConstantString
+/* must be compiled compile using -fconstant-string-class=FooConstantString
    as an option to gcc.  If it doesn't work, it means your gcc doesn't
    support this option. */
 
 #include "objc-common.g"
 
+#if defined (NeXT_RUNTIME) && defined (__OBJC2__)
+Class _FooConstantStringClassReference;
+
+@interface FooConstantString : Object
+{
+  char*       c_string;
+  unsigned    length;
+}
+@end
+
+@implementation FooConstantString
+
++ (void)load;
+{
+  /* Our string literals will have their "isa" pointer set to 
+   * _FooConstantStringClassReference, but it points nowhere.
+   * We must set it to compiler-generated class.
+   */
+  _FooConstantStringClassReference = objc_getClass("FooConstantString");
+}
+
+- (const char *)cString;
+{
+  return c_string;
+}
+
+@end
+
+#else /* new NeXT_RUNTIME */
+
 /* Define our custom constant string class */
 GS_OBJC_ROOT_CLASS @interface FooConstantString
 {
@@ -35,19 +65,20 @@ struct objc_class _FooConstantStringClassReference;
 #endif
 
 @implementation FooConstantString
-- (char *) customString
+- (char *) cString
 {
     return c_string;
 }
 @end
 
+#endif
 
 int main (int argc, char **argv)
 {
    /* Create a test constant string */
    FooConstantString *string = @"Antonio Valente";
 
-#ifdef NeXT_RUNTIME
+#if defined(NeXT_RUNTIME) && !defined (__OBJC2__)
    /* This memcpy is needed here due to a bug in ObjC gcc when using
       next runtime. It has to be done once per program and before
       the first message is sent to a constant string. Can't be moved to
@@ -59,16 +90,15 @@ int main (int argc, char **argv)
 #endif
 
    /* Check that it really works */
-   if (strcmp ([string customString], "Antonio Valente"))
+   if (strcmp ([string cString], "Antonio Valente"))
      {
        abort ();
      }
 
    /* Do another, more direct test. */
-   if (strcmp ([@"Jump" customString], "Jump"))
-       {
-         abort ();
-       }
+   if (strcmp ([@"Jump" cString], "Jump"))
+     {
+       abort ();
+     }
    return 0;
 }
-
diff --git a/config/config.loadtest.m b/config/config.loadtest.m
index edc60e4..39a95ff 100644
--- a/config/config.loadtest.m
+++ b/config/config.loadtest.m
@@ -1,7 +1,7 @@
 
 #include "objc-common.g"
 
-@interface Test : NSObject
+@interface Test : Object
 +(void) load;
 +(int) test_result;
 @end
diff --git a/configure b/configure
index 594feda..08181f6 100755
--- a/configure
+++ b/configure
@@ -1,18 +1,20 @@
 #! /bin/sh
 # Guess values for system-dependent variables and create Makefiles.
-# Generated by GNU Autoconf 2.63.
+# Generated by GNU Autoconf 2.69.
+#
+#
+# Copyright (C) 1992-1996, 1998-2012 Free Software Foundation, Inc.
+#
 #
-# Copyright (C) 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
-# 2002, 2003, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.
 # This configure script is free software; the Free Software Foundation
 # gives unlimited permission to copy, distribute and modify it.
-## --------------------- ##
-## M4sh Initialization.  ##
-## --------------------- ##
+## -------------------- ##
+## M4sh Initialization. ##
+## -------------------- ##
 
 # Be more Bourne compatible
 DUALCASE=1; export DUALCASE # for MKS sh
-if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
+if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then :
   emulate sh
   NULLCMD=:
   # Pre-4.2 versions of Zsh do word splitting on ${1+"$@"}, which
@@ -20,23 +22,15 @@ if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
   alias -g '${1+"$@"}'='"$@"'
   setopt NO_GLOB_SUBST
 else
-  case `(set -o) 2>/dev/null` in
-  *posix*) set -o posix ;;
+  case `(set -o) 2>/dev/null` in #(
+  *posix*) :
+    set -o posix ;; #(
+  *) :
+     ;;
 esac
-
 fi
 
 
-
-
-# PATH needs CR
-# Avoid depending upon Character Ranges.
-as_cr_letters='abcdefghijklmnopqrstuvwxyz'
-as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
-as_cr_Letters=$as_cr_letters$as_cr_LETTERS
-as_cr_digits='0123456789'
-as_cr_alnum=$as_cr_Letters$as_cr_digits
-
 as_nl='
 '
 export as_nl
@@ -44,7 +38,13 @@ export as_nl
 as_echo='\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'
 as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo
 as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo$as_echo
-if (test "X`printf %s $as_echo`" = "X$as_echo") 2>/dev/null; then
+# Prefer a ksh shell builtin over an external printf program on Solaris,
+# but without wasting forks for bash or zsh.
+if test -z "$BASH_VERSION$ZSH_VERSION" \
+    && (test "X`print -r -- $as_echo`" = "X$as_echo") 2>/dev/null; then
+  as_echo='print -r --'
+  as_echo_n='print -rn --'
+elif (test "X`printf %s $as_echo`" = "X$as_echo") 2>/dev/null; then
   as_echo='printf %s\n'
   as_echo_n='printf %s'
 else
@@ -55,7 +55,7 @@ else
     as_echo_body='eval expr "X$1" : "X\\(.*\\)"'
     as_echo_n_body='eval
       arg=$1;
-      case $arg in
+      case $arg in #(
       *"$as_nl"*)
 	expr "X$arg" : "X\\(.*\\)$as_nl";
 	arg=`expr "X$arg" : ".*$as_nl\\(.*\\)"`;;
@@ -78,13 +78,6 @@ if test "${PATH_SEPARATOR+set}" != set; then
   }
 fi
 
-# Support unset when possible.
-if ( (MAIL=60; unset MAIL) || exit) >/dev/null 2>&1; then
-  as_unset=unset
-else
-  as_unset=false
-fi
-
 
 # IFS
 # We need space, tab and new line, in precisely that order.  Quoting is
@@ -94,15 +87,16 @@ fi
 IFS=" ""	$as_nl"
 
 # Find who we are.  Look in the path if we contain no directory separator.
-case $0 in
+as_myself=
+case $0 in #((
   *[\\/]* ) as_myself=$0 ;;
   *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
 for as_dir in $PATH
 do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
-  test -r "$as_dir/$0" && as_myself=$as_dir/$0 && break
-done
+    test -r "$as_dir/$0" && as_myself=$as_dir/$0 && break
+  done
 IFS=$as_save_IFS
 
      ;;
@@ -114,12 +108,16 @@ if test "x$as_myself" = x; then
 fi
 if test ! -f "$as_myself"; then
   $as_echo "$as_myself: error: cannot find myself; rerun with an absolute file name" >&2
-  { (exit 1); exit 1; }
+  exit 1
 fi
 
-# Work around bugs in pre-3.0 UWIN ksh.
-for as_var in ENV MAIL MAILPATH
-do ($as_unset $as_var) >/dev/null 2>&1 && $as_unset $as_var
+# Unset variables that we do not need and which cause bugs (e.g. in
+# pre-3.0 UWIN ksh).  But do not cause bugs in bash 2.01; the "|| exit 1"
+# suppresses any "Segmentation fault" message there.  '((' could
+# trigger a bug in pdksh 5.2.14.
+for as_var in BASH_ENV ENV MAIL MAILPATH
+do eval test x\${$as_var+set} = xset \
+  && ( (unset $as_var) || exit 1) >/dev/null 2>&1 && unset $as_var || :
 done
 PS1='$ '
 PS2='> '
@@ -131,7 +129,293 @@ export LC_ALL
 LANGUAGE=C
 export LANGUAGE
 
-# Required to use basename.
+# CDPATH.
+(unset CDPATH) >/dev/null 2>&1 && unset CDPATH
+
+# Use a proper internal environment variable to ensure we don't fall
+  # into an infinite loop, continuously re-executing ourselves.
+  if test x"${_as_can_reexec}" != xno && test "x$CONFIG_SHELL" != x; then
+    _as_can_reexec=no; export _as_can_reexec;
+    # We cannot yet assume a decent shell, so we have to provide a
+# neutralization value for shells without unset; and this also
+# works around shells that cannot unset nonexistent variables.
+# Preserve -v and -x to the replacement shell.
+BASH_ENV=/dev/null
+ENV=/dev/null
+(unset BASH_ENV) >/dev/null 2>&1 && unset BASH_ENV ENV
+case $- in # ((((
+  *v*x* | *x*v* ) as_opts=-vx ;;
+  *v* ) as_opts=-v ;;
+  *x* ) as_opts=-x ;;
+  * ) as_opts= ;;
+esac
+exec $CONFIG_SHELL $as_opts "$as_myself" ${1+"$@"}
+# Admittedly, this is quite paranoid, since all the known shells bail
+# out after a failed `exec'.
+$as_echo "$0: could not re-execute with $CONFIG_SHELL" >&2
+as_fn_exit 255
+  fi
+  # We don't want this to propagate to other subprocesses.
+          { _as_can_reexec=; unset _as_can_reexec;}
+if test "x$CONFIG_SHELL" = x; then
+  as_bourne_compatible="if test -n \"\${ZSH_VERSION+set}\" && (emulate sh) >/dev/null 2>&1; then :
+  emulate sh
+  NULLCMD=:
+  # Pre-4.2 versions of Zsh do word splitting on \${1+\"\$@\"}, which
+  # is contrary to our usage.  Disable this feature.
+  alias -g '\${1+\"\$@\"}'='\"\$@\"'
+  setopt NO_GLOB_SUBST
+else
+  case \`(set -o) 2>/dev/null\` in #(
+  *posix*) :
+    set -o posix ;; #(
+  *) :
+     ;;
+esac
+fi
+"
+  as_required="as_fn_return () { (exit \$1); }
+as_fn_success () { as_fn_return 0; }
+as_fn_failure () { as_fn_return 1; }
+as_fn_ret_success () { return 0; }
+as_fn_ret_failure () { return 1; }
+
+exitcode=0
+as_fn_success || { exitcode=1; echo as_fn_success failed.; }
+as_fn_failure && { exitcode=1; echo as_fn_failure succeeded.; }
+as_fn_ret_success || { exitcode=1; echo as_fn_ret_success failed.; }
+as_fn_ret_failure && { exitcode=1; echo as_fn_ret_failure succeeded.; }
+if ( set x; as_fn_ret_success y && test x = \"\$1\" ); then :
+
+else
+  exitcode=1; echo positional parameters were not saved.
+fi
+test x\$exitcode = x0 || exit 1
+test -x / || exit 1"
+  as_suggested="  as_lineno_1=";as_suggested=$as_suggested$LINENO;as_suggested=$as_suggested" as_lineno_1a=\$LINENO
+  as_lineno_2=";as_suggested=$as_suggested$LINENO;as_suggested=$as_suggested" as_lineno_2a=\$LINENO
+  eval 'test \"x\$as_lineno_1'\$as_run'\" != \"x\$as_lineno_2'\$as_run'\" &&
+  test \"x\`expr \$as_lineno_1'\$as_run' + 1\`\" = \"x\$as_lineno_2'\$as_run'\"' || exit 1
+test \$(( 1 + 1 )) = 2 || exit 1"
+  if (eval "$as_required") 2>/dev/null; then :
+  as_have_required=yes
+else
+  as_have_required=no
+fi
+  if test x$as_have_required = xyes && (eval "$as_suggested") 2>/dev/null; then :
+
+else
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+as_found=false
+for as_dir in /bin$PATH_SEPARATOR/usr/bin$PATH_SEPARATOR$PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  as_found=:
+  case $as_dir in #(
+	 /*)
+	   for as_base in sh bash ksh sh5; do
+	     # Try only shells that exist, to save several forks.
+	     as_shell=$as_dir/$as_base
+	     if { test -f "$as_shell" || test -f "$as_shell.exe"; } &&
+		    { $as_echo "$as_bourne_compatible""$as_required" | as_run=a "$as_shell"; } 2>/dev/null; then :
+  CONFIG_SHELL=$as_shell as_have_required=yes
+		   if { $as_echo "$as_bourne_compatible""$as_suggested" | as_run=a "$as_shell"; } 2>/dev/null; then :
+  break 2
+fi
+fi
+	   done;;
+       esac
+  as_found=false
+done
+$as_found || { if { test -f "$SHELL" || test -f "$SHELL.exe"; } &&
+	      { $as_echo "$as_bourne_compatible""$as_required" | as_run=a "$SHELL"; } 2>/dev/null; then :
+  CONFIG_SHELL=$SHELL as_have_required=yes
+fi; }
+IFS=$as_save_IFS
+
+
+      if test "x$CONFIG_SHELL" != x; then :
+  export CONFIG_SHELL
+             # We cannot yet assume a decent shell, so we have to provide a
+# neutralization value for shells without unset; and this also
+# works around shells that cannot unset nonexistent variables.
+# Preserve -v and -x to the replacement shell.
+BASH_ENV=/dev/null
+ENV=/dev/null
+(unset BASH_ENV) >/dev/null 2>&1 && unset BASH_ENV ENV
+case $- in # ((((
+  *v*x* | *x*v* ) as_opts=-vx ;;
+  *v* ) as_opts=-v ;;
+  *x* ) as_opts=-x ;;
+  * ) as_opts= ;;
+esac
+exec $CONFIG_SHELL $as_opts "$as_myself" ${1+"$@"}
+# Admittedly, this is quite paranoid, since all the known shells bail
+# out after a failed `exec'.
+$as_echo "$0: could not re-execute with $CONFIG_SHELL" >&2
+exit 255
+fi
+
+    if test x$as_have_required = xno; then :
+  $as_echo "$0: This script requires a shell more modern than all"
+  $as_echo "$0: the shells that I found on your system."
+  if test x${ZSH_VERSION+set} = xset ; then
+    $as_echo "$0: In particular, zsh $ZSH_VERSION has bugs and should"
+    $as_echo "$0: be upgraded to zsh 4.3.4 or later."
+  else
+    $as_echo "$0: Please tell bug-autoconf@gnu.org about your system,
+$0: including any error possibly output before this
+$0: message. Then install a modern shell, or manually run
+$0: the script under such a shell if you do have one."
+  fi
+  exit 1
+fi
+fi
+fi
+SHELL=${CONFIG_SHELL-/bin/sh}
+export SHELL
+# Unset more variables known to interfere with behavior of common tools.
+CLICOLOR_FORCE= GREP_OPTIONS=
+unset CLICOLOR_FORCE GREP_OPTIONS
+
+## --------------------- ##
+## M4sh Shell Functions. ##
+## --------------------- ##
+# as_fn_unset VAR
+# ---------------
+# Portably unset VAR.
+as_fn_unset ()
+{
+  { eval $1=; unset $1;}
+}
+as_unset=as_fn_unset
+
+# as_fn_set_status STATUS
+# -----------------------
+# Set $? to STATUS, without forking.
+as_fn_set_status ()
+{
+  return $1
+} # as_fn_set_status
+
+# as_fn_exit STATUS
+# -----------------
+# Exit the shell with STATUS, even in a "trap 0" or "set -e" context.
+as_fn_exit ()
+{
+  set +e
+  as_fn_set_status $1
+  exit $1
+} # as_fn_exit
+
+# as_fn_mkdir_p
+# -------------
+# Create "$as_dir" as a directory, including parents if necessary.
+as_fn_mkdir_p ()
+{
+
+  case $as_dir in #(
+  -*) as_dir=./$as_dir;;
+  esac
+  test -d "$as_dir" || eval $as_mkdir_p || {
+    as_dirs=
+    while :; do
+      case $as_dir in #(
+      *\'*) as_qdir=`$as_echo "$as_dir" | sed "s/'/'\\\\\\\\''/g"`;; #'(
+      *) as_qdir=$as_dir;;
+      esac
+      as_dirs="'$as_qdir' $as_dirs"
+      as_dir=`$as_dirname -- "$as_dir" ||
+$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$as_dir" : 'X\(//\)[^/]' \| \
+	 X"$as_dir" : 'X\(//\)$' \| \
+	 X"$as_dir" : 'X\(/\)' \| . 2>/dev/null ||
+$as_echo X"$as_dir" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)[^/].*/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+      test -d "$as_dir" && break
+    done
+    test -z "$as_dirs" || eval "mkdir $as_dirs"
+  } || test -d "$as_dir" || as_fn_error $? "cannot create directory $as_dir"
+
+
+} # as_fn_mkdir_p
+
+# as_fn_executable_p FILE
+# -----------------------
+# Test if FILE is an executable regular file.
+as_fn_executable_p ()
+{
+  test -f "$1" && test -x "$1"
+} # as_fn_executable_p
+# as_fn_append VAR VALUE
+# ----------------------
+# Append the text in VALUE to the end of the definition contained in VAR. Take
+# advantage of any shell optimizations that allow amortized linear growth over
+# repeated appends, instead of the typical quadratic growth present in naive
+# implementations.
+if (eval "as_var=1; as_var+=2; test x\$as_var = x12") 2>/dev/null; then :
+  eval 'as_fn_append ()
+  {
+    eval $1+=\$2
+  }'
+else
+  as_fn_append ()
+  {
+    eval $1=\$$1\$2
+  }
+fi # as_fn_append
+
+# as_fn_arith ARG...
+# ------------------
+# Perform arithmetic evaluation on the ARGs, and store the result in the
+# global $as_val. Take advantage of shells that can avoid forks. The arguments
+# must be portable across $(()) and expr.
+if (eval "test \$(( 1 + 1 )) = 2") 2>/dev/null; then :
+  eval 'as_fn_arith ()
+  {
+    as_val=$(( $* ))
+  }'
+else
+  as_fn_arith ()
+  {
+    as_val=`expr "$@" || test $? -eq 1`
+  }
+fi # as_fn_arith
+
+
+# as_fn_error STATUS ERROR [LINENO LOG_FD]
+# ----------------------------------------
+# Output "`basename $0`: error: ERROR" to stderr. If LINENO and LOG_FD are
+# provided, also output the error to LOG_FD, referencing LINENO. Then exit the
+# script with STATUS, using 1 if that was 0.
+as_fn_error ()
+{
+  as_status=$1; test $as_status -eq 0 && as_status=1
+  if test "$4"; then
+    as_lineno=${as_lineno-"$3"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+    $as_echo "$as_me:${as_lineno-$LINENO}: error: $2" >&$4
+  fi
+  $as_echo "$as_me: error: $2" >&2
+  as_fn_exit $as_status
+} # as_fn_error
+
 if expr a : '\(a\)' >/dev/null 2>&1 &&
    test "X`expr 00001 : '.*\(...\)'`" = X001; then
   as_expr=expr
@@ -145,8 +429,12 @@ else
   as_basename=false
 fi
 
+if (as_dir=`dirname -- /` && test "X$as_dir" = X/) >/dev/null 2>&1; then
+  as_dirname=dirname
+else
+  as_dirname=false
+fi
 
-# Name of the executable.
 as_me=`$as_basename -- "$0" ||
 $as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
 	 X"$0" : 'X\(//\)$' \| \
@@ -166,437 +454,133 @@ $as_echo X/"$0" |
 	  }
 	  s/.*/./; q'`
 
-# CDPATH.
-$as_unset CDPATH
+# Avoid depending upon Character Ranges.
+as_cr_letters='abcdefghijklmnopqrstuvwxyz'
+as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
+as_cr_Letters=$as_cr_letters$as_cr_LETTERS
+as_cr_digits='0123456789'
+as_cr_alnum=$as_cr_Letters$as_cr_digits
 
 
-if test "x$CONFIG_SHELL" = x; then
-  if (eval ":") 2>/dev/null; then
-  as_have_required=yes
-else
-  as_have_required=no
-fi
+  as_lineno_1=$LINENO as_lineno_1a=$LINENO
+  as_lineno_2=$LINENO as_lineno_2a=$LINENO
+  eval 'test "x$as_lineno_1'$as_run'" != "x$as_lineno_2'$as_run'" &&
+  test "x`expr $as_lineno_1'$as_run' + 1`" = "x$as_lineno_2'$as_run'"' || {
+  # Blame Lee E. McMahon (1931-1989) for sed's syntax.  :-)
+  sed -n '
+    p
+    /[$]LINENO/=
+  ' <$as_myself |
+    sed '
+      s/[$]LINENO.*/&-/
+      t lineno
+      b
+      :lineno
+      N
+      :loop
+      s/[$]LINENO\([^'$as_cr_alnum'_].*\n\)\(.*\)/\2\1\2/
+      t loop
+      s/-\n.*//
+    ' >$as_me.lineno &&
+  chmod +x "$as_me.lineno" ||
+    { $as_echo "$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&2; as_fn_exit 1; }
 
-  if test $as_have_required = yes &&	 (eval ":
-(as_func_return () {
-  (exit \$1)
-}
-as_func_success () {
-  as_func_return 0
-}
-as_func_failure () {
-  as_func_return 1
-}
-as_func_ret_success () {
-  return 0
-}
-as_func_ret_failure () {
-  return 1
+  # If we had to re-execute with $CONFIG_SHELL, we're ensured to have
+  # already done that, so ensure we don't try to do so again and fall
+  # in an infinite loop.  This has already happened in practice.
+  _as_can_reexec=no; export _as_can_reexec
+  # Don't try to exec as it changes $[0], causing all sort of problems
+  # (the dirname of $[0] is not the place where we might find the
+  # original and so on.  Autoconf is especially sensitive to this).
+  . "./$as_me.lineno"
+  # Exit status is that of the last command.
+  exit
 }
 
-exitcode=0
-if as_func_success; then
-  :
+ECHO_C= ECHO_N= ECHO_T=
+case `echo -n x` in #(((((
+-n*)
+  case `echo 'xy\c'` in
+  *c*) ECHO_T='	';;	# ECHO_T is single tab character.
+  xy)  ECHO_C='\c';;
+  *)   echo `echo ksh88 bug on AIX 6.1` > /dev/null
+       ECHO_T='	';;
+  esac;;
+*)
+  ECHO_N='-n';;
+esac
+
+rm -f conf$$ conf$$.exe conf$$.file
+if test -d conf$$.dir; then
+  rm -f conf$$.dir/conf$$.file
 else
-  exitcode=1
-  echo as_func_success failed.
+  rm -f conf$$.dir
+  mkdir conf$$.dir 2>/dev/null
 fi
-
-if as_func_failure; then
-  exitcode=1
-  echo as_func_failure succeeded.
+if (echo >conf$$.file) 2>/dev/null; then
+  if ln -s conf$$.file conf$$ 2>/dev/null; then
+    as_ln_s='ln -s'
+    # ... but there are two gotchas:
+    # 1) On MSYS, both `ln -s file dir' and `ln file dir' fail.
+    # 2) DJGPP < 2.04 has no symlinks; `ln -s' creates a wrapper executable.
+    # In both cases, we have to default to `cp -pR'.
+    ln -s conf$$.file conf$$.dir 2>/dev/null && test ! -f conf$$.exe ||
+      as_ln_s='cp -pR'
+  elif ln conf$$.file conf$$ 2>/dev/null; then
+    as_ln_s=ln
+  else
+    as_ln_s='cp -pR'
+  fi
+else
+  as_ln_s='cp -pR'
 fi
+rm -f conf$$ conf$$.exe conf$$.dir/conf$$.file conf$$.file
+rmdir conf$$.dir 2>/dev/null
 
-if as_func_ret_success; then
-  :
+if mkdir -p . 2>/dev/null; then
+  as_mkdir_p='mkdir -p "$as_dir"'
 else
-  exitcode=1
-  echo as_func_ret_success failed.
+  test -d ./-p && rmdir ./-p
+  as_mkdir_p=false
 fi
 
-if as_func_ret_failure; then
-  exitcode=1
-  echo as_func_ret_failure succeeded.
-fi
+as_test_x='test -x'
+as_executable_p=as_fn_executable_p
 
-if ( set x; as_func_ret_success y && test x = \"\$1\" ); then
-  :
-else
-  exitcode=1
-  echo positional parameters were not saved.
-fi
+# Sed expression to map a string onto a valid CPP name.
+as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"
 
-test \$exitcode = 0) || { (exit 1); exit 1; }
+# Sed expression to map a string onto a valid variable name.
+as_tr_sh="eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'"
 
-(
-  as_lineno_1=\$LINENO
-  as_lineno_2=\$LINENO
-  test \"x\$as_lineno_1\" != \"x\$as_lineno_2\" &&
-  test \"x\`expr \$as_lineno_1 + 1\`\" = \"x\$as_lineno_2\") || { (exit 1); exit 1; }
-") 2> /dev/null; then
-  :
-else
-  as_candidate_shells=
-    as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in /bin$PATH_SEPARATOR/usr/bin$PATH_SEPARATOR$PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-  case $as_dir in
-	 /*)
-	   for as_base in sh bash ksh sh5; do
-	     as_candidate_shells="$as_candidate_shells $as_dir/$as_base"
-	   done;;
-       esac
-done
-IFS=$as_save_IFS
 
+test -n "$DJDIR" || exec 7<&0 </dev/null
+exec 6>&1
 
-      for as_shell in $as_candidate_shells $SHELL; do
-	 # Try only shells that exist, to save several forks.
-	 if { test -f "$as_shell" || test -f "$as_shell.exe"; } &&
-		{ ("$as_shell") 2> /dev/null <<\_ASEOF
-if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
-  emulate sh
-  NULLCMD=:
-  # Pre-4.2 versions of Zsh do word splitting on ${1+"$@"}, which
-  # is contrary to our usage.  Disable this feature.
-  alias -g '${1+"$@"}'='"$@"'
-  setopt NO_GLOB_SUBST
-else
-  case `(set -o) 2>/dev/null` in
-  *posix*) set -o posix ;;
-esac
+# Name of the host.
+# hostname on some systems (SVR3.2, old GNU/Linux) returns a bogus exit status,
+# so uname gets run too.
+ac_hostname=`(hostname || uname -n) 2>/dev/null | sed 1q`
 
-fi
+#
+# Initializations.
+#
+ac_default_prefix=/usr/local
+ac_clean_files=
+ac_config_libobj_dir=.
+LIBOBJS=
+cross_compiling=no
+subdirs=
+MFLAGS=
+MAKEFLAGS=
 
-
-:
-_ASEOF
-}; then
-  CONFIG_SHELL=$as_shell
-	       as_have_required=yes
-	       if { "$as_shell" 2> /dev/null <<\_ASEOF
-if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
-  emulate sh
-  NULLCMD=:
-  # Pre-4.2 versions of Zsh do word splitting on ${1+"$@"}, which
-  # is contrary to our usage.  Disable this feature.
-  alias -g '${1+"$@"}'='"$@"'
-  setopt NO_GLOB_SUBST
-else
-  case `(set -o) 2>/dev/null` in
-  *posix*) set -o posix ;;
-esac
-
-fi
-
-
-:
-(as_func_return () {
-  (exit $1)
-}
-as_func_success () {
-  as_func_return 0
-}
-as_func_failure () {
-  as_func_return 1
-}
-as_func_ret_success () {
-  return 0
-}
-as_func_ret_failure () {
-  return 1
-}
-
-exitcode=0
-if as_func_success; then
-  :
-else
-  exitcode=1
-  echo as_func_success failed.
-fi
-
-if as_func_failure; then
-  exitcode=1
-  echo as_func_failure succeeded.
-fi
-
-if as_func_ret_success; then
-  :
-else
-  exitcode=1
-  echo as_func_ret_success failed.
-fi
-
-if as_func_ret_failure; then
-  exitcode=1
-  echo as_func_ret_failure succeeded.
-fi
-
-if ( set x; as_func_ret_success y && test x = "$1" ); then
-  :
-else
-  exitcode=1
-  echo positional parameters were not saved.
-fi
-
-test $exitcode = 0) || { (exit 1); exit 1; }
-
-(
-  as_lineno_1=$LINENO
-  as_lineno_2=$LINENO
-  test "x$as_lineno_1" != "x$as_lineno_2" &&
-  test "x`expr $as_lineno_1 + 1`" = "x$as_lineno_2") || { (exit 1); exit 1; }
-
-_ASEOF
-}; then
-  break
-fi
-
-fi
-
-      done
-
-      if test "x$CONFIG_SHELL" != x; then
-  for as_var in BASH_ENV ENV
-	do ($as_unset $as_var) >/dev/null 2>&1 && $as_unset $as_var
-	done
-	export CONFIG_SHELL
-	exec "$CONFIG_SHELL" "$as_myself" ${1+"$@"}
-fi
-
-
-    if test $as_have_required = no; then
-  echo This script requires a shell more modern than all the
-      echo shells that I found on your system.  Please install a
-      echo modern shell, or manually run the script under such a
-      echo shell if you do have one.
-      { (exit 1); exit 1; }
-fi
-
-
-fi
-
-fi
-
-
-
-(eval "as_func_return () {
-  (exit \$1)
-}
-as_func_success () {
-  as_func_return 0
-}
-as_func_failure () {
-  as_func_return 1
-}
-as_func_ret_success () {
-  return 0
-}
-as_func_ret_failure () {
-  return 1
-}
-
-exitcode=0
-if as_func_success; then
-  :
-else
-  exitcode=1
-  echo as_func_success failed.
-fi
-
-if as_func_failure; then
-  exitcode=1
-  echo as_func_failure succeeded.
-fi
-
-if as_func_ret_success; then
-  :
-else
-  exitcode=1
-  echo as_func_ret_success failed.
-fi
-
-if as_func_ret_failure; then
-  exitcode=1
-  echo as_func_ret_failure succeeded.
-fi
-
-if ( set x; as_func_ret_success y && test x = \"\$1\" ); then
-  :
-else
-  exitcode=1
-  echo positional parameters were not saved.
-fi
-
-test \$exitcode = 0") || {
-  echo No shell found that supports shell functions.
-  echo Please tell bug-autoconf@gnu.org about your system,
-  echo including any error possibly output before this message.
-  echo This can help us improve future autoconf versions.
-  echo Configuration will now proceed without shell functions.
-}
-
-
-
-  as_lineno_1=$LINENO
-  as_lineno_2=$LINENO
-  test "x$as_lineno_1" != "x$as_lineno_2" &&
-  test "x`expr $as_lineno_1 + 1`" = "x$as_lineno_2" || {
-
-  # Create $as_me.lineno as a copy of $as_myself, but with $LINENO
-  # uniformly replaced by the line number.  The first 'sed' inserts a
-  # line-number line after each line using $LINENO; the second 'sed'
-  # does the real work.  The second script uses 'N' to pair each
-  # line-number line with the line containing $LINENO, and appends
-  # trailing '-' during substitution so that $LINENO is not a special
-  # case at line end.
-  # (Raja R Harinath suggested sed '=', and Paul Eggert wrote the
-  # scripts with optimization help from Paolo Bonzini.  Blame Lee
-  # E. McMahon (1931-1989) for sed's syntax.  :-)
-  sed -n '
-    p
-    /[$]LINENO/=
-  ' <$as_myself |
-    sed '
-      s/[$]LINENO.*/&-/
-      t lineno
-      b
-      :lineno
-      N
-      :loop
-      s/[$]LINENO\([^'$as_cr_alnum'_].*\n\)\(.*\)/\2\1\2/
-      t loop
-      s/-\n.*//
-    ' >$as_me.lineno &&
-  chmod +x "$as_me.lineno" ||
-    { $as_echo "$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&2
-   { (exit 1); exit 1; }; }
-
-  # Don't try to exec as it changes $[0], causing all sort of problems
-  # (the dirname of $[0] is not the place where we might find the
-  # original and so on.  Autoconf is especially sensitive to this).
-  . "./$as_me.lineno"
-  # Exit status is that of the last command.
-  exit
-}
-
-
-if (as_dir=`dirname -- /` && test "X$as_dir" = X/) >/dev/null 2>&1; then
-  as_dirname=dirname
-else
-  as_dirname=false
-fi
-
-ECHO_C= ECHO_N= ECHO_T=
-case `echo -n x` in
--n*)
-  case `echo 'x\c'` in
-  *c*) ECHO_T='	';;	# ECHO_T is single tab character.
-  *)   ECHO_C='\c';;
-  esac;;
-*)
-  ECHO_N='-n';;
-esac
-if expr a : '\(a\)' >/dev/null 2>&1 &&
-   test "X`expr 00001 : '.*\(...\)'`" = X001; then
-  as_expr=expr
-else
-  as_expr=false
-fi
-
-rm -f conf$$ conf$$.exe conf$$.file
-if test -d conf$$.dir; then
-  rm -f conf$$.dir/conf$$.file
-else
-  rm -f conf$$.dir
-  mkdir conf$$.dir 2>/dev/null
-fi
-if (echo >conf$$.file) 2>/dev/null; then
-  if ln -s conf$$.file conf$$ 2>/dev/null; then
-    as_ln_s='ln -s'
-    # ... but there are two gotchas:
-    # 1) On MSYS, both `ln -s file dir' and `ln file dir' fail.
-    # 2) DJGPP < 2.04 has no symlinks; `ln -s' creates a wrapper executable.
-    # In both cases, we have to default to `cp -p'.
-    ln -s conf$$.file conf$$.dir 2>/dev/null && test ! -f conf$$.exe ||
-      as_ln_s='cp -p'
-  elif ln conf$$.file conf$$ 2>/dev/null; then
-    as_ln_s=ln
-  else
-    as_ln_s='cp -p'
-  fi
-else
-  as_ln_s='cp -p'
-fi
-rm -f conf$$ conf$$.exe conf$$.dir/conf$$.file conf$$.file
-rmdir conf$$.dir 2>/dev/null
-
-if mkdir -p . 2>/dev/null; then
-  as_mkdir_p=:
-else
-  test -d ./-p && rmdir ./-p
-  as_mkdir_p=false
-fi
-
-if test -x / >/dev/null 2>&1; then
-  as_test_x='test -x'
-else
-  if ls -dL / >/dev/null 2>&1; then
-    as_ls_L_option=L
-  else
-    as_ls_L_option=
-  fi
-  as_test_x='
-    eval sh -c '\''
-      if test -d "$1"; then
-	test -d "$1/.";
-      else
-	case $1 in
-	-*)set "./$1";;
-	esac;
-	case `ls -ld'$as_ls_L_option' "$1" 2>/dev/null` in
-	???[sx]*):;;*)false;;esac;fi
-    '\'' sh
-  '
-fi
-as_executable_p=$as_test_x
-
-# Sed expression to map a string onto a valid CPP name.
-as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"
-
-# Sed expression to map a string onto a valid variable name.
-as_tr_sh="eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'"
-
-
-
-exec 7<&0 </dev/null 6>&1
-
-# Name of the host.
-# hostname on some systems (SVR3.2, Linux) returns a bogus exit status,
-# so uname gets run too.
-ac_hostname=`(hostname || uname -n) 2>/dev/null | sed 1q`
-
-#
-# Initializations.
-#
-ac_default_prefix=/usr/local
-ac_clean_files=
-ac_config_libobj_dir=.
-LIBOBJS=
-cross_compiling=no
-subdirs=
-MFLAGS=
-MAKEFLAGS=
-SHELL=${CONFIG_SHELL-/bin/sh}
-
-# Identity of this package.
-PACKAGE_NAME=
-PACKAGE_TARNAME=
-PACKAGE_VERSION=
-PACKAGE_STRING=
-PACKAGE_BUGREPORT=
+# Identity of this package.
+PACKAGE_NAME=
+PACKAGE_TARNAME=
+PACKAGE_VERSION=
+PACKAGE_STRING=
+PACKAGE_BUGREPORT=
+PACKAGE_URL=
 
 ac_unique_file="Source/NSArray.m"
 # Factoring default headers for most tests.
@@ -643,7 +627,6 @@ SUBMINOR_VERSION
 MINOR_VERSION
 MAJOR_VERSION
 VERSION
-subdirs
 GNUSTEP_INSTALL_GDOMAP_AS_SETUID
 GNUSTEP_GDOMAP_PORT_OVERRIDE
 WARN_FLAGS
@@ -656,6 +639,7 @@ ICU_LIBS
 ICU_CONFIG
 HAVE_AVAHI
 HAVE_MDNS
+subdirs
 HAVE_GNUTLS
 TLS_LIBS
 TLS_CFLAGS
@@ -788,6 +772,7 @@ bindir
 program_transform_name
 prefix
 exec_prefix
+PACKAGE_URL
 PACKAGE_BUGREPORT
 PACKAGE_STRING
 PACKAGE_VERSION
@@ -826,9 +811,12 @@ enable_xml
 with_xml_prefix
 enable_xmltest
 enable_xslt
-enable_tls
+enable_gnutls
 with_tls_prefix
 enable_tlstest
+enable_openssl
+with_openssl_include
+with_openssl_library
 enable_zeroconf
 with_zeroconf_api
 enable_icu
@@ -840,9 +828,6 @@ with_gmp_library
 with_sort_algorithm
 with_gdomap_port
 enable_setuid_gdomap
-enable_openssl
-with_openssl_include
-with_openssl_library
 '
       ac_precious_vars='build_alias
 host_alias
@@ -915,8 +900,9 @@ do
   fi
 
   case $ac_option in
-  *=*)	ac_optarg=`expr "X$ac_option" : '[^=]*=\(.*\)'` ;;
-  *)	ac_optarg=yes ;;
+  *=?*) ac_optarg=`expr "X$ac_option" : '[^=]*=\(.*\)'` ;;
+  *=)   ac_optarg= ;;
+  *)    ac_optarg=yes ;;
   esac
 
   # Accept the important Cygnus configure options, so we can diagnose typos.
@@ -961,8 +947,7 @@ do
     ac_useropt=`expr "x$ac_option" : 'x-*disable-\(.*\)'`
     # Reject names that are not valid shell variable names.
     expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
-      { $as_echo "$as_me: error: invalid feature name: $ac_useropt" >&2
-   { (exit 1); exit 1; }; }
+      as_fn_error $? "invalid feature name: $ac_useropt"
     ac_useropt_orig=$ac_useropt
     ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
     case $ac_user_opts in
@@ -988,8 +973,7 @@ do
     ac_useropt=`expr "x$ac_option" : 'x-*enable-\([^=]*\)'`
     # Reject names that are not valid shell variable names.
     expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
-      { $as_echo "$as_me: error: invalid feature name: $ac_useropt" >&2
-   { (exit 1); exit 1; }; }
+      as_fn_error $? "invalid feature name: $ac_useropt"
     ac_useropt_orig=$ac_useropt
     ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
     case $ac_user_opts in
@@ -1193,8 +1177,7 @@ do
     ac_useropt=`expr "x$ac_option" : 'x-*with-\([^=]*\)'`
     # Reject names that are not valid shell variable names.
     expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
-      { $as_echo "$as_me: error: invalid package name: $ac_useropt" >&2
-   { (exit 1); exit 1; }; }
+      as_fn_error $? "invalid package name: $ac_useropt"
     ac_useropt_orig=$ac_useropt
     ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
     case $ac_user_opts in
@@ -1210,8 +1193,7 @@ do
     ac_useropt=`expr "x$ac_option" : 'x-*without-\(.*\)'`
     # Reject names that are not valid shell variable names.
     expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
-      { $as_echo "$as_me: error: invalid package name: $ac_useropt" >&2
-   { (exit 1); exit 1; }; }
+      as_fn_error $? "invalid package name: $ac_useropt"
     ac_useropt_orig=$ac_useropt
     ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
     case $ac_user_opts in
@@ -1241,17 +1223,17 @@ do
   | --x-librar=* | --x-libra=* | --x-libr=* | --x-lib=* | --x-li=* | --x-l=*)
     x_libraries=$ac_optarg ;;
 
-  -*) { $as_echo "$as_me: error: unrecognized option: $ac_option
-Try \`$0 --help' for more information." >&2
-   { (exit 1); exit 1; }; }
+  -*) as_fn_error $? "unrecognized option: \`$ac_option'
+Try \`$0 --help' for more information"
     ;;
 
   *=*)
     ac_envvar=`expr "x$ac_option" : 'x\([^=]*\)='`
     # Reject names that are not valid shell variable names.
-    expr "x$ac_envvar" : ".*[^_$as_cr_alnum]" >/dev/null &&
-      { $as_echo "$as_me: error: invalid variable name: $ac_envvar" >&2
-   { (exit 1); exit 1; }; }
+    case $ac_envvar in #(
+      '' | [0-9]* | *[!_$as_cr_alnum]* )
+      as_fn_error $? "invalid variable name: \`$ac_envvar'" ;;
+    esac
     eval $ac_envvar=\$ac_optarg
     export $ac_envvar ;;
 
@@ -1260,7 +1242,7 @@ Try \`$0 --help' for more information." >&2
     $as_echo "$as_me: WARNING: you should use --build, --host, --target" >&2
     expr "x$ac_option" : ".*[^-._$as_cr_alnum]" >/dev/null &&
       $as_echo "$as_me: WARNING: invalid host type: $ac_option" >&2
-    : ${build_alias=$ac_option} ${host_alias=$ac_option} ${target_alias=$ac_option}
+    : "${build_alias=$ac_option} ${host_alias=$ac_option} ${target_alias=$ac_option}"
     ;;
 
   esac
@@ -1268,15 +1250,13 @@ done
 
 if test -n "$ac_prev"; then
   ac_option=--`echo $ac_prev | sed 's/_/-/g'`
-  { $as_echo "$as_me: error: missing argument to $ac_option" >&2
-   { (exit 1); exit 1; }; }
+  as_fn_error $? "missing argument to $ac_option"
 fi
 
 if test -n "$ac_unrecognized_opts"; then
   case $enable_option_checking in
     no) ;;
-    fatal) { $as_echo "$as_me: error: unrecognized options: $ac_unrecognized_opts" >&2
-   { (exit 1); exit 1; }; } ;;
+    fatal) as_fn_error $? "unrecognized options: $ac_unrecognized_opts" ;;
     *)     $as_echo "$as_me: WARNING: unrecognized options: $ac_unrecognized_opts" >&2 ;;
   esac
 fi
@@ -1299,8 +1279,7 @@ do
     [\\/$]* | ?:[\\/]* )  continue;;
     NONE | '' ) case $ac_var in *prefix ) continue;; esac;;
   esac
-  { $as_echo "$as_me: error: expected an absolute directory name for --$ac_var: $ac_val" >&2
-   { (exit 1); exit 1; }; }
+  as_fn_error $? "expected an absolute directory name for --$ac_var: $ac_val"
 done
 
 # There might be people who depend on the old broken behavior: `$host'
@@ -1314,8 +1293,6 @@ target=$target_alias
 if test "x$host_alias" != x; then
   if test "x$build_alias" = x; then
     cross_compiling=maybe
-    $as_echo "$as_me: WARNING: If you wanted to set the --build type, don't use --host.
-    If a cross compiler is detected then cross compile mode will be used." >&2
   elif test "x$build_alias" != "x$host_alias"; then
     cross_compiling=yes
   fi
@@ -1330,11 +1307,9 @@ test "$silent" = yes && exec 6>/dev/null
 ac_pwd=`pwd` && test -n "$ac_pwd" &&
 ac_ls_di=`ls -di .` &&
 ac_pwd_ls_di=`cd "$ac_pwd" && ls -di .` ||
-  { $as_echo "$as_me: error: working directory cannot be determined" >&2
-   { (exit 1); exit 1; }; }
+  as_fn_error $? "working directory cannot be determined"
 test "X$ac_ls_di" = "X$ac_pwd_ls_di" ||
-  { $as_echo "$as_me: error: pwd does not report name of working directory" >&2
-   { (exit 1); exit 1; }; }
+  as_fn_error $? "pwd does not report name of working directory"
 
 
 # Find the source files, if location was not specified.
@@ -1373,13 +1348,11 @@ else
 fi
 if test ! -r "$srcdir/$ac_unique_file"; then
   test "$ac_srcdir_defaulted" = yes && srcdir="$ac_confdir or .."
-  { $as_echo "$as_me: error: cannot find sources ($ac_unique_file) in $srcdir" >&2
-   { (exit 1); exit 1; }; }
+  as_fn_error $? "cannot find sources ($ac_unique_file) in $srcdir"
 fi
 ac_msg="sources are in $srcdir, but \`cd $srcdir' does not work"
 ac_abs_confdir=`(
-	cd "$srcdir" && test -r "./$ac_unique_file" || { $as_echo "$as_me: error: $ac_msg" >&2
-   { (exit 1); exit 1; }; }
+	cd "$srcdir" && test -r "./$ac_unique_file" || as_fn_error $? "$ac_msg"
 	pwd)`
 # When building in place, set srcdir=.
 if test "$ac_abs_confdir" = "$ac_pwd"; then
@@ -1419,7 +1392,7 @@ Configuration:
       --help=short        display options specific to this package
       --help=recursive    display the short help of all the included packages
   -V, --version           display version information and exit
-  -q, --quiet, --silent   do not print \`checking...' messages
+  -q, --quiet, --silent   do not print \`checking ...' messages
       --cache-file=FILE   cache test results in FILE [disabled]
   -C, --config-cache      alias for \`--cache-file=config.cache'
   -n, --no-create         do not create output files
@@ -1524,8 +1497,10 @@ Optional Features:
   --disable-xml			Build even if XML-dependencies are not met
   --disable-xmltest		Do not try to compile and run a test XML program
   --disable-xslt		Build even if XSLT-dependency is not met
-  --disable-tls			Disable use of GNUTLS
+  --enable-gnutls           Enable use of GNUTLS
+  --disable-gnutls          Disable use of GNUTLS
   --disable-tlstest		Do not try to compile and run a test TLS program
+  --disable-openssl		Disable support for openssl in URL classes
   --disable-zeroconf		Disable NSNetServices support
   --disable-icu			Disable International Components for Unicode
   --disable-icu-config		Do not use the icu-config script to check
@@ -1541,7 +1516,6 @@ Optional Features:
                                 option if you are happy having the program
                                 started automatically on demand.
 
-  --disable-openssl		Disable support for openssl in URL classes
 
 Optional Packages:
   --with-PACKAGE[=ARG]    use PACKAGE [ARG=yes]
@@ -1601,6 +1575,8 @@ Optional Packages:
   --with-libiconv-library=PATH  Library path for libiconv libraries
   --with-xml-prefix=PFX    Prefix where libxml is installed (optional)
   --with-tls-prefix=PFX    Prefix where libgnutls is installed (optional)
+  --with-openssl-include=PATH  include path for openssl headers
+  --with-openssl-library=PATH  library path for openssl libraries
   --with-zeroconf-api=API  force use of a specific zeroconf API (mdns or avahi)
   --with-icu-library=PATH  	library path for ICU libraries (only checked
 				if not using icu-config)
@@ -1610,8 +1586,6 @@ Optional Packages:
 				Possible values are timsort, quicksort, and shellsort.
 				Defaults to shellsort (others broken).
   --with-gdomap-port=PORT  alternative port for gdomap
-  --with-openssl-include=PATH  include path for openssl headers
-  --with-openssl-library=PATH  library path for openssl libraries
 
 Some influential environment variables:
   CC          C compiler command
@@ -1619,13 +1593,14 @@ Some influential environment variables:
   LDFLAGS     linker flags, e.g. -L<lib dir> if you have libraries in a
               nonstandard directory <lib dir>
   LIBS        libraries to pass to the linker, e.g. -l<library>
-  CPPFLAGS    C/C++/Objective C preprocessor flags, e.g. -I<include dir> if
+  CPPFLAGS    (Objective) C/C++ preprocessor flags, e.g. -I<include dir> if
               you have headers in a nonstandard directory <include dir>
   CPP         C preprocessor
 
 Use these variables to override the choices made by `configure' or to help
 it to find libraries and programs with nonstandard names/locations.
 
+Report bugs to the package provider.
 _ACEOF
 ac_status=$?
 fi
@@ -1689,495 +1664,1105 @@ test -n "$ac_init_help" && exit $ac_status
 if $ac_init_version; then
   cat <<\_ACEOF
 configure
-generated by GNU Autoconf 2.63
+generated by GNU Autoconf 2.69
 
-Copyright (C) 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
-2002, 2003, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.
+Copyright (C) 2012 Free Software Foundation, Inc.
 This configure script is free software; the Free Software Foundation
 gives unlimited permission to copy, distribute and modify it.
 _ACEOF
   exit
 fi
-cat >config.log <<_ACEOF
-This file contains any messages produced by compilers while
-running configure, to aid debugging if configure makes a mistake.
-
-It was created by $as_me, which was
-generated by GNU Autoconf 2.63.  Invocation command line was
 
-  $ $0 $@
+## ------------------------ ##
+## Autoconf initialization. ##
+## ------------------------ ##
 
-_ACEOF
-exec 5>>config.log
+# ac_fn_c_try_compile LINENO
+# --------------------------
+# Try to compile conftest.$ac_ext, and return whether this succeeded.
+ac_fn_c_try_compile ()
 {
-cat <<_ASUNAME
-## --------- ##
-## Platform. ##
-## --------- ##
-
-hostname = `(hostname || uname -n) 2>/dev/null | sed 1q`
-uname -m = `(uname -m) 2>/dev/null || echo unknown`
-uname -r = `(uname -r) 2>/dev/null || echo unknown`
-uname -s = `(uname -s) 2>/dev/null || echo unknown`
-uname -v = `(uname -v) 2>/dev/null || echo unknown`
-
-/usr/bin/uname -p = `(/usr/bin/uname -p) 2>/dev/null || echo unknown`
-/bin/uname -X     = `(/bin/uname -X) 2>/dev/null     || echo unknown`
+  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+  rm -f conftest.$ac_objext
+  if { { ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_compile") 2>conftest.err
+  ac_status=$?
+  if test -s conftest.err; then
+    grep -v '^ *+' conftest.err >conftest.er1
+    cat conftest.er1 >&5
+    mv -f conftest.er1 conftest.err
+  fi
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then :
+  ac_retval=0
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
 
-/bin/arch              = `(/bin/arch) 2>/dev/null              || echo unknown`
-/usr/bin/arch -k       = `(/usr/bin/arch -k) 2>/dev/null       || echo unknown`
-/usr/convex/getsysinfo = `(/usr/convex/getsysinfo) 2>/dev/null || echo unknown`
-/usr/bin/hostinfo      = `(/usr/bin/hostinfo) 2>/dev/null      || echo unknown`
-/bin/machine           = `(/bin/machine) 2>/dev/null           || echo unknown`
-/usr/bin/oslevel       = `(/usr/bin/oslevel) 2>/dev/null       || echo unknown`
-/bin/universe          = `(/bin/universe) 2>/dev/null          || echo unknown`
+	ac_retval=1
+fi
+  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
+  as_fn_set_status $ac_retval
 
-_ASUNAME
+} # ac_fn_c_try_compile
 
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-  $as_echo "PATH: $as_dir"
-done
-IFS=$as_save_IFS
-
-} >&5
-
-cat >&5 <<_ACEOF
+# ac_fn_c_try_cpp LINENO
+# ----------------------
+# Try to preprocess conftest.$ac_ext, and return whether this succeeded.
+ac_fn_c_try_cpp ()
+{
+  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+  if { { ac_try="$ac_cpp conftest.$ac_ext"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.err
+  ac_status=$?
+  if test -s conftest.err; then
+    grep -v '^ *+' conftest.err >conftest.er1
+    cat conftest.er1 >&5
+    mv -f conftest.er1 conftest.err
+  fi
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; } > conftest.i && {
+	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       }; then :
+  ac_retval=0
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
 
+    ac_retval=1
+fi
+  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
+  as_fn_set_status $ac_retval
 
-## ----------- ##
-## Core tests. ##
-## ----------- ##
+} # ac_fn_c_try_cpp
 
+# ac_fn_c_check_header_mongrel LINENO HEADER VAR INCLUDES
+# -------------------------------------------------------
+# Tests whether HEADER exists, giving a warning if it cannot be compiled using
+# the include files in INCLUDES and setting the cache variable VAR
+# accordingly.
+ac_fn_c_check_header_mongrel ()
+{
+  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+  if eval \${$3+:} false; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
+$as_echo_n "checking for $2... " >&6; }
+if eval \${$3+:} false; then :
+  $as_echo_n "(cached) " >&6
+fi
+eval ac_res=\$$3
+	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+$as_echo "$ac_res" >&6; }
+else
+  # Is the header compilable?
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking $2 usability" >&5
+$as_echo_n "checking $2 usability... " >&6; }
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+$4
+#include <$2>
 _ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_header_compiler=yes
+else
+  ac_header_compiler=no
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_header_compiler" >&5
+$as_echo "$ac_header_compiler" >&6; }
 
+# Is the header present?
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking $2 presence" >&5
+$as_echo_n "checking $2 presence... " >&6; }
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <$2>
+_ACEOF
+if ac_fn_c_try_cpp "$LINENO"; then :
+  ac_header_preproc=yes
+else
+  ac_header_preproc=no
+fi
+rm -f conftest.err conftest.i conftest.$ac_ext
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_header_preproc" >&5
+$as_echo "$ac_header_preproc" >&6; }
 
-# Keep a trace of the command line.
-# Strip out --no-create and --no-recursion so they do not pile up.
-# Strip out --silent because we don't want to record it for future runs.
-# Also quote any args containing shell meta-characters.
-# Make two passes to allow for proper duplicate-argument suppression.
-ac_configure_args=
-ac_configure_args0=
-ac_configure_args1=
-ac_must_keep_next=false
-for ac_pass in 1 2
-do
-  for ac_arg
-  do
-    case $ac_arg in
-    -no-create | --no-c* | -n | -no-recursion | --no-r*) continue ;;
-    -q | -quiet | --quiet | --quie | --qui | --qu | --q \
-    | -silent | --silent | --silen | --sile | --sil)
-      continue ;;
-    *\'*)
-      ac_arg=`$as_echo "$ac_arg" | sed "s/'/'\\\\\\\\''/g"` ;;
-    esac
-    case $ac_pass in
-    1) ac_configure_args0="$ac_configure_args0 '$ac_arg'" ;;
-    2)
-      ac_configure_args1="$ac_configure_args1 '$ac_arg'"
-      if test $ac_must_keep_next = true; then
-	ac_must_keep_next=false # Got value, back to normal.
-      else
-	case $ac_arg in
-	  *=* | --config-cache | -C | -disable-* | --disable-* \
-	  | -enable-* | --enable-* | -gas | --g* | -nfp | --nf* \
-	  | -q | -quiet | --q* | -silent | --sil* | -v | -verb* \
-	  | -with-* | --with-* | -without-* | --without-* | --x)
-	    case "$ac_configure_args0 " in
-	      "$ac_configure_args1"*" '$ac_arg' "* ) continue ;;
-	    esac
-	    ;;
-	  -* ) ac_must_keep_next=true ;;
-	esac
-      fi
-      ac_configure_args="$ac_configure_args '$ac_arg'"
-      ;;
-    esac
-  done
-done
-$as_unset ac_configure_args0 || test "${ac_configure_args0+set}" != set || { ac_configure_args0=; export ac_configure_args0; }
-$as_unset ac_configure_args1 || test "${ac_configure_args1+set}" != set || { ac_configure_args1=; export ac_configure_args1; }
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in #((
+  yes:no: )
+    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2: accepted by the compiler, rejected by the preprocessor!" >&5
+$as_echo "$as_me: WARNING: $2: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2: proceeding with the compiler's result" >&5
+$as_echo "$as_me: WARNING: $2: proceeding with the compiler's result" >&2;}
+    ;;
+  no:yes:* )
+    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2: present but cannot be compiled" >&5
+$as_echo "$as_me: WARNING: $2: present but cannot be compiled" >&2;}
+    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2:     check for missing prerequisite headers?" >&5
+$as_echo "$as_me: WARNING: $2:     check for missing prerequisite headers?" >&2;}
+    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2: see the Autoconf documentation" >&5
+$as_echo "$as_me: WARNING: $2: see the Autoconf documentation" >&2;}
+    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2:     section \"Present But Cannot Be Compiled\"" >&5
+$as_echo "$as_me: WARNING: $2:     section \"Present But Cannot Be Compiled\"" >&2;}
+    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2: proceeding with the compiler's result" >&5
+$as_echo "$as_me: WARNING: $2: proceeding with the compiler's result" >&2;}
+    ;;
+esac
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
+$as_echo_n "checking for $2... " >&6; }
+if eval \${$3+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  eval "$3=\$ac_header_compiler"
+fi
+eval ac_res=\$$3
+	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+$as_echo "$ac_res" >&6; }
+fi
+  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
 
-# When interrupted or exit'd, cleanup temporary files, and complete
-# config.log.  We remove comments because anyway the quotes in there
-# would cause problems or look ugly.
-# WARNING: Use '\'' to represent an apostrophe within the trap.
-# WARNING: Do not start the trap code with a newline, due to a FreeBSD 4.0 bug.
-trap 'exit_status=$?
-  # Save into config.log some information that might help in debugging.
-  {
-    echo
+} # ac_fn_c_check_header_mongrel
 
-    cat <<\_ASBOX
-## ---------------- ##
-## Cache variables. ##
-## ---------------- ##
-_ASBOX
-    echo
-    # The following way of writing the cache mishandles newlines in values,
-(
-  for ac_var in `(set) 2>&1 | sed -n '\''s/^\([a-zA-Z_][a-zA-Z0-9_]*\)=.*/\1/p'\''`; do
-    eval ac_val=\$$ac_var
-    case $ac_val in #(
-    *${as_nl}*)
-      case $ac_var in #(
-      *_cv_*) { $as_echo "$as_me:$LINENO: WARNING: cache variable $ac_var contains a newline" >&5
-$as_echo "$as_me: WARNING: cache variable $ac_var contains a newline" >&2;} ;;
-      esac
-      case $ac_var in #(
-      _ | IFS | as_nl) ;; #(
-      BASH_ARGV | BASH_SOURCE) eval $ac_var= ;; #(
-      *) $as_unset $ac_var ;;
-      esac ;;
-    esac
-  done
-  (set) 2>&1 |
-    case $as_nl`(ac_space='\'' '\''; set) 2>&1` in #(
-    *${as_nl}ac_space=\ *)
-      sed -n \
-	"s/'\''/'\''\\\\'\'''\''/g;
-	  s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1='\''\\2'\''/p"
-      ;; #(
-    *)
-      sed -n "/^[_$as_cr_alnum]*_cv_[_$as_cr_alnum]*=/p"
-      ;;
-    esac |
-    sort
-)
-    echo
+# ac_fn_c_try_run LINENO
+# ----------------------
+# Try to link conftest.$ac_ext, and return whether this succeeded. Assumes
+# that executables *can* be run.
+ac_fn_c_try_run ()
+{
+  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+  if { { ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_link") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; } && { ac_try='./conftest$ac_exeext'
+  { { case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_try") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; }; then :
+  ac_retval=0
+else
+  $as_echo "$as_me: program exited with status $ac_status" >&5
+       $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
 
-    cat <<\_ASBOX
-## ----------------- ##
-## Output variables. ##
-## ----------------- ##
-_ASBOX
-    echo
-    for ac_var in $ac_subst_vars
-    do
-      eval ac_val=\$$ac_var
-      case $ac_val in
-      *\'\''*) ac_val=`$as_echo "$ac_val" | sed "s/'\''/'\''\\\\\\\\'\'''\''/g"`;;
-      esac
-      $as_echo "$ac_var='\''$ac_val'\''"
-    done | sort
-    echo
+       ac_retval=$ac_status
+fi
+  rm -rf conftest.dSYM conftest_ipa8_conftest.oo
+  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
+  as_fn_set_status $ac_retval
 
-    if test -n "$ac_subst_files"; then
-      cat <<\_ASBOX
-## ------------------- ##
-## File substitutions. ##
-## ------------------- ##
-_ASBOX
-      echo
-      for ac_var in $ac_subst_files
-      do
-	eval ac_val=\$$ac_var
-	case $ac_val in
-	*\'\''*) ac_val=`$as_echo "$ac_val" | sed "s/'\''/'\''\\\\\\\\'\'''\''/g"`;;
-	esac
-	$as_echo "$ac_var='\''$ac_val'\''"
-      done | sort
-      echo
-    fi
+} # ac_fn_c_try_run
 
-    if test -s confdefs.h; then
-      cat <<\_ASBOX
-## ----------- ##
-## confdefs.h. ##
-## ----------- ##
-_ASBOX
-      echo
-      cat confdefs.h
-      echo
-    fi
-    test "$ac_signal" != 0 &&
-      $as_echo "$as_me: caught signal $ac_signal"
-    $as_echo "$as_me: exit $exit_status"
-  } >&5
-  rm -f core *.core core.conftest.* &&
-    rm -f -r conftest* confdefs* conf$$* $ac_clean_files &&
-    exit $exit_status
-' 0
-for ac_signal in 1 2 13 15; do
-  trap 'ac_signal='$ac_signal'; { (exit 1); exit 1; }' $ac_signal
-done
-ac_signal=0
+# ac_fn_c_check_header_compile LINENO HEADER VAR INCLUDES
+# -------------------------------------------------------
+# Tests whether HEADER exists and can be compiled using the include files in
+# INCLUDES, setting the cache variable VAR accordingly.
+ac_fn_c_check_header_compile ()
+{
+  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
+$as_echo_n "checking for $2... " >&6; }
+if eval \${$3+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+$4
+#include <$2>
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  eval "$3=yes"
+else
+  eval "$3=no"
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+eval ac_res=\$$3
+	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+$as_echo "$ac_res" >&6; }
+  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
 
-# confdefs.h avoids OS command line length limits that DEFS can exceed.
-rm -f -r conftest* confdefs.h
+} # ac_fn_c_check_header_compile
 
-# Predefined preprocessor variables.
+# ac_fn_c_try_link LINENO
+# -----------------------
+# Try to link conftest.$ac_ext, and return whether this succeeded.
+ac_fn_c_try_link ()
+{
+  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+  rm -f conftest.$ac_objext conftest$ac_exeext
+  if { { ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_link") 2>conftest.err
+  ac_status=$?
+  if test -s conftest.err; then
+    grep -v '^ *+' conftest.err >conftest.er1
+    cat conftest.er1 >&5
+    mv -f conftest.er1 conftest.err
+  fi
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest$ac_exeext && {
+	 test "$cross_compiling" = yes ||
+	 test -x conftest$ac_exeext
+       }; then :
+  ac_retval=0
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
 
-cat >>confdefs.h <<_ACEOF
-#define PACKAGE_NAME "$PACKAGE_NAME"
-_ACEOF
+	ac_retval=1
+fi
+  # Delete the IPA/IPO (Inter Procedural Analysis/Optimization) information
+  # created by the PGI compiler (conftest_ipa8_conftest.oo), as it would
+  # interfere with the next link command; also delete a directory that is
+  # left behind by Apple's compiler.  We do this before executing the actions.
+  rm -rf conftest.dSYM conftest_ipa8_conftest.oo
+  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
+  as_fn_set_status $ac_retval
 
+} # ac_fn_c_try_link
 
-cat >>confdefs.h <<_ACEOF
-#define PACKAGE_TARNAME "$PACKAGE_TARNAME"
-_ACEOF
+# ac_fn_c_check_func LINENO FUNC VAR
+# ----------------------------------
+# Tests whether FUNC exists, setting the cache variable VAR accordingly
+ac_fn_c_check_func ()
+{
+  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
+$as_echo_n "checking for $2... " >&6; }
+if eval \${$3+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+/* Define $2 to an innocuous variant, in case <limits.h> declares $2.
+   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
+#define $2 innocuous_$2
 
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $2 (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
 
-cat >>confdefs.h <<_ACEOF
-#define PACKAGE_VERSION "$PACKAGE_VERSION"
-_ACEOF
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
 
+#undef $2
 
-cat >>confdefs.h <<_ACEOF
-#define PACKAGE_STRING "$PACKAGE_STRING"
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char $2 ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined __stub_$2 || defined __stub___$2
+choke me
+#endif
+
+int
+main ()
+{
+return $2 ();
+  ;
+  return 0;
+}
 _ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  eval "$3=yes"
+else
+  eval "$3=no"
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+fi
+eval ac_res=\$$3
+	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+$as_echo "$ac_res" >&6; }
+  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
 
+} # ac_fn_c_check_func
 
-cat >>confdefs.h <<_ACEOF
-#define PACKAGE_BUGREPORT "$PACKAGE_BUGREPORT"
-_ACEOF
+# ac_fn_c_compute_int LINENO EXPR VAR INCLUDES
+# --------------------------------------------
+# Tries to find the compile-time value of EXPR in a program that includes
+# INCLUDES, setting VAR accordingly. Returns whether the value could be
+# computed
+ac_fn_c_compute_int ()
+{
+  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+  if test "$cross_compiling" = yes; then
+    # Depending upon the size, compute the lo and hi bounds.
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+$4
+int
+main ()
+{
+static int test_array [1 - 2 * !(($2) >= 0)];
+test_array [0] = 0;
+return test_array [0];
 
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_lo=0 ac_mid=0
+  while :; do
+    cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+$4
+int
+main ()
+{
+static int test_array [1 - 2 * !(($2) <= $ac_mid)];
+test_array [0] = 0;
+return test_array [0];
 
-# Let the site file select an alternate cache file if it wants to.
-# Prefer an explicitly selected file to automatically selected ones.
-ac_site_file1=NONE
-ac_site_file2=NONE
-if test -n "$CONFIG_SITE"; then
-  ac_site_file1=$CONFIG_SITE
-elif test "x$prefix" != xNONE; then
-  ac_site_file1=$prefix/share/config.site
-  ac_site_file2=$prefix/etc/config.site
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_hi=$ac_mid; break
 else
-  ac_site_file1=$ac_default_prefix/share/config.site
-  ac_site_file2=$ac_default_prefix/etc/config.site
+  as_fn_arith $ac_mid + 1 && ac_lo=$as_val
+			if test $ac_lo -le $ac_mid; then
+			  ac_lo= ac_hi=
+			  break
+			fi
+			as_fn_arith 2 '*' $ac_mid + 1 && ac_mid=$as_val
 fi
-for ac_site_file in "$ac_site_file1" "$ac_site_file2"
-do
-  test "x$ac_site_file" = xNONE && continue
-  if test -r "$ac_site_file"; then
-    { $as_echo "$as_me:$LINENO: loading site script $ac_site_file" >&5
-$as_echo "$as_me: loading site script $ac_site_file" >&6;}
-    sed 's/^/| /' "$ac_site_file" >&5
-    . "$ac_site_file"
-  fi
-done
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+  done
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+$4
+int
+main ()
+{
+static int test_array [1 - 2 * !(($2) < 0)];
+test_array [0] = 0;
+return test_array [0];
 
-if test -r "$cache_file"; then
-  # Some versions of bash will fail to source /dev/null (special
-  # files actually), so we avoid doing that.
-  if test -f "$cache_file"; then
-    { $as_echo "$as_me:$LINENO: loading cache $cache_file" >&5
-$as_echo "$as_me: loading cache $cache_file" >&6;}
-    case $cache_file in
-      [\\/]* | ?:[\\/]* ) . "$cache_file";;
-      *)                      . "./$cache_file";;
-    esac
-  fi
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_hi=-1 ac_mid=-1
+  while :; do
+    cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+$4
+int
+main ()
+{
+static int test_array [1 - 2 * !(($2) >= $ac_mid)];
+test_array [0] = 0;
+return test_array [0];
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_lo=$ac_mid; break
 else
-  { $as_echo "$as_me:$LINENO: creating cache $cache_file" >&5
-$as_echo "$as_me: creating cache $cache_file" >&6;}
-  >$cache_file
+  as_fn_arith '(' $ac_mid ')' - 1 && ac_hi=$as_val
+			if test $ac_mid -le $ac_hi; then
+			  ac_lo= ac_hi=
+			  break
+			fi
+			as_fn_arith 2 '*' $ac_mid && ac_mid=$as_val
 fi
-
-# Check that the precious variables saved in the cache have kept the same
-# value.
-ac_cache_corrupted=false
-for ac_var in $ac_precious_vars; do
-  eval ac_old_set=\$ac_cv_env_${ac_var}_set
-  eval ac_new_set=\$ac_env_${ac_var}_set
-  eval ac_old_val=\$ac_cv_env_${ac_var}_value
-  eval ac_new_val=\$ac_env_${ac_var}_value
-  case $ac_old_set,$ac_new_set in
-    set,)
-      { $as_echo "$as_me:$LINENO: error: \`$ac_var' was set to \`$ac_old_val' in the previous run" >&5
-$as_echo "$as_me: error: \`$ac_var' was set to \`$ac_old_val' in the previous run" >&2;}
-      ac_cache_corrupted=: ;;
-    ,set)
-      { $as_echo "$as_me:$LINENO: error: \`$ac_var' was not set in the previous run" >&5
-$as_echo "$as_me: error: \`$ac_var' was not set in the previous run" >&2;}
-      ac_cache_corrupted=: ;;
-    ,);;
-    *)
-      if test "x$ac_old_val" != "x$ac_new_val"; then
-	# differences in whitespace do not lead to failure.
-	ac_old_val_w=`echo x $ac_old_val`
-	ac_new_val_w=`echo x $ac_new_val`
-	if test "$ac_old_val_w" != "$ac_new_val_w"; then
-	  { $as_echo "$as_me:$LINENO: error: \`$ac_var' has changed since the previous run:" >&5
-$as_echo "$as_me: error: \`$ac_var' has changed since the previous run:" >&2;}
-	  ac_cache_corrupted=:
-	else
-	  { $as_echo "$as_me:$LINENO: warning: ignoring whitespace changes in \`$ac_var' since the previous run:" >&5
-$as_echo "$as_me: warning: ignoring whitespace changes in \`$ac_var' since the previous run:" >&2;}
-	  eval $ac_var=\$ac_old_val
-	fi
-	{ $as_echo "$as_me:$LINENO:   former value:  \`$ac_old_val'" >&5
-$as_echo "$as_me:   former value:  \`$ac_old_val'" >&2;}
-	{ $as_echo "$as_me:$LINENO:   current value: \`$ac_new_val'" >&5
-$as_echo "$as_me:   current value: \`$ac_new_val'" >&2;}
-      fi;;
-  esac
-  # Pass precious variables to config.status.
-  if test "$ac_new_set" = set; then
-    case $ac_new_val in
-    *\'*) ac_arg=$ac_var=`$as_echo "$ac_new_val" | sed "s/'/'\\\\\\\\''/g"` ;;
-    *) ac_arg=$ac_var=$ac_new_val ;;
-    esac
-    case " $ac_configure_args " in
-      *" '$ac_arg' "*) ;; # Avoid dups.  Use of quotes ensures accuracy.
-      *) ac_configure_args="$ac_configure_args '$ac_arg'" ;;
-    esac
-  fi
-done
-if $ac_cache_corrupted; then
-  { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
-$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-  { $as_echo "$as_me:$LINENO: error: changes in the environment can compromise the build" >&5
-$as_echo "$as_me: error: changes in the environment can compromise the build" >&2;}
-  { { $as_echo "$as_me:$LINENO: error: run \`make distclean' and/or \`rm $cache_file' and start over" >&5
-$as_echo "$as_me: error: run \`make distclean' and/or \`rm $cache_file' and start over" >&2;}
-   { (exit 1); exit 1; }; }
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+  done
+else
+  ac_lo= ac_hi=
 fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+# Binary search between lo and hi bounds.
+while test "x$ac_lo" != "x$ac_hi"; do
+  as_fn_arith '(' $ac_hi - $ac_lo ')' / 2 + $ac_lo && ac_mid=$as_val
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+$4
+int
+main ()
+{
+static int test_array [1 - 2 * !(($2) <= $ac_mid)];
+test_array [0] = 0;
+return test_array [0];
 
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_hi=$ac_mid
+else
+  as_fn_arith '(' $ac_mid ')' + 1 && ac_lo=$as_val
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+done
+case $ac_lo in #((
+?*) eval "$3=\$ac_lo"; ac_retval=0 ;;
+'') ac_retval=1 ;;
+esac
+  else
+    cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+$4
+static long int longval () { return $2; }
+static unsigned long int ulongval () { return $2; }
+#include <stdio.h>
+#include <stdlib.h>
+int
+main ()
+{
 
+  FILE *f = fopen ("conftest.val", "w");
+  if (! f)
+    return 1;
+  if (($2) < 0)
+    {
+      long int i = longval ();
+      if (i != ($2))
+	return 1;
+      fprintf (f, "%ld", i);
+    }
+  else
+    {
+      unsigned long int i = ulongval ();
+      if (i != ($2))
+	return 1;
+      fprintf (f, "%lu", i);
+    }
+  /* Do not output a trailing newline, as this causes \r\n confusion
+     on some platforms.  */
+  return ferror (f) || fclose (f) != 0;
 
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_run "$LINENO"; then :
+  echo >>conftest.val; read $3 <conftest.val; ac_retval=0
+else
+  ac_retval=1
+fi
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
+  conftest.$ac_objext conftest.beam conftest.$ac_ext
+rm -f conftest.val
 
+  fi
+  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
+  as_fn_set_status $ac_retval
 
+} # ac_fn_c_compute_int
 
+# ac_fn_c_check_type LINENO TYPE VAR INCLUDES
+# -------------------------------------------
+# Tests whether TYPE exists after having included INCLUDES, setting cache
+# variable VAR accordingly.
+ac_fn_c_check_type ()
+{
+  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
+$as_echo_n "checking for $2... " >&6; }
+if eval \${$3+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  eval "$3=no"
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+$4
+int
+main ()
+{
+if (sizeof ($2))
+	 return 0;
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+$4
+int
+main ()
+{
+if (sizeof (($2)))
+	    return 0;
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
 
+else
+  eval "$3=yes"
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+eval ac_res=\$$3
+	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+$as_echo "$ac_res" >&6; }
+  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
 
+} # ac_fn_c_check_type
 
+# ac_fn_c_check_decl LINENO SYMBOL VAR INCLUDES
+# ---------------------------------------------
+# Tests whether SYMBOL is declared in INCLUDES, setting cache variable VAR
+# accordingly.
+ac_fn_c_check_decl ()
+{
+  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+  as_decl_name=`echo $2|sed 's/ *(.*//'`
+  as_decl_use=`echo $2|sed -e 's/(/((/' -e 's/)/) 0&/' -e 's/,/) 0& (/g'`
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether $as_decl_name is declared" >&5
+$as_echo_n "checking whether $as_decl_name is declared... " >&6; }
+if eval \${$3+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+$4
+int
+main ()
+{
+#ifndef $as_decl_name
+#ifdef __cplusplus
+  (void) $as_decl_use;
+#else
+  (void) $as_decl_name;
+#endif
+#endif
 
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  eval "$3=yes"
+else
+  eval "$3=no"
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+eval ac_res=\$$3
+	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+$as_echo "$ac_res" >&6; }
+  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
 
+} # ac_fn_c_check_decl
+cat >config.log <<_ACEOF
+This file contains any messages produced by compilers while
+running configure, to aid debugging if configure makes a mistake.
 
+It was created by $as_me, which was
+generated by GNU Autoconf 2.69.  Invocation command line was
 
+  $ $0 $@
 
+_ACEOF
+exec 5>>config.log
+{
+cat <<_ASUNAME
+## --------- ##
+## Platform. ##
+## --------- ##
 
+hostname = `(hostname || uname -n) 2>/dev/null | sed 1q`
+uname -m = `(uname -m) 2>/dev/null || echo unknown`
+uname -r = `(uname -r) 2>/dev/null || echo unknown`
+uname -s = `(uname -s) 2>/dev/null || echo unknown`
+uname -v = `(uname -v) 2>/dev/null || echo unknown`
 
+/usr/bin/uname -p = `(/usr/bin/uname -p) 2>/dev/null || echo unknown`
+/bin/uname -X     = `(/bin/uname -X) 2>/dev/null     || echo unknown`
 
-ac_ext=c
-ac_cpp='$CPP $CPPFLAGS'
-ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_c_compiler_gnu
-
+/bin/arch              = `(/bin/arch) 2>/dev/null              || echo unknown`
+/usr/bin/arch -k       = `(/usr/bin/arch -k) 2>/dev/null       || echo unknown`
+/usr/convex/getsysinfo = `(/usr/convex/getsysinfo) 2>/dev/null || echo unknown`
+/usr/bin/hostinfo      = `(/usr/bin/hostinfo) 2>/dev/null      || echo unknown`
+/bin/machine           = `(/bin/machine) 2>/dev/null           || echo unknown`
+/usr/bin/oslevel       = `(/usr/bin/oslevel) 2>/dev/null       || echo unknown`
+/bin/universe          = `(/bin/universe) 2>/dev/null          || echo unknown`
 
+_ASUNAME
 
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    $as_echo "PATH: $as_dir"
+  done
+IFS=$as_save_IFS
 
+} >&5
 
-# If GNUSTEP_MAKEFILES is undefined, try to use gnustep-config to determine it.
-if test -z "$GNUSTEP_MAKEFILES"; then
-  GNUSTEP_MAKEFILES=`gnustep-config --variable=GNUSTEP_MAKEFILES 2>&5`
-fi
+cat >&5 <<_ACEOF
 
-if test -z "$GNUSTEP_MAKEFILES"; then
-  { { $as_echo "$as_me:$LINENO: error: You must have the gnustep-make package installed and set up the GNUSTEP_MAKEFILES environment variable to contain the path to the makefiles directory before configuring!" >&5
-$as_echo "$as_me: error: You must have the gnustep-make package installed and set up the GNUSTEP_MAKEFILES environment variable to contain the path to the makefiles directory before configuring!" >&2;}
-   { (exit 1); exit 1; }; }
-fi
 
-# If LIBRARY_COMBO is undefined, try to use gnustep-config to determine it.
-if test -z "$LIBRARY_COMBO"; then
-  LIBRARY_COMBO=`gnustep-config --variable=LIBRARY_COMBO 2>&5`
-fi
+## ----------- ##
+## Core tests. ##
+## ----------- ##
 
-nonfragile=`gnustep-config --objc-flags | grep _NONFRAGILE_ABI 2>&5`
-if test -z "$nonfragile"; then
-  nonfragile=no
-  BASE_NONFRAGILE_ABI=0
-else
-  nonfragile=yes
-  BASE_NONFRAGILE_ABI=1
-fi
+_ACEOF
 
 
-# We shouldn't be loading GNUstep.sh here.  It would load in a lot of
-# variables which might get confused with the ones that will be used
-# at runtime.  We will load it later once we have determined (and
-# saved) the runtime configuration.
+# Keep a trace of the command line.
+# Strip out --no-create and --no-recursion so they do not pile up.
+# Strip out --silent because we don't want to record it for future runs.
+# Also quote any args containing shell meta-characters.
+# Make two passes to allow for proper duplicate-argument suppression.
+ac_configure_args=
+ac_configure_args0=
+ac_configure_args1=
+ac_must_keep_next=false
+for ac_pass in 1 2
+do
+  for ac_arg
+  do
+    case $ac_arg in
+    -no-create | --no-c* | -n | -no-recursion | --no-r*) continue ;;
+    -q | -quiet | --quiet | --quie | --qui | --qu | --q \
+    | -silent | --silent | --silen | --sile | --sil)
+      continue ;;
+    *\'*)
+      ac_arg=`$as_echo "$ac_arg" | sed "s/'/'\\\\\\\\''/g"` ;;
+    esac
+    case $ac_pass in
+    1) as_fn_append ac_configure_args0 " '$ac_arg'" ;;
+    2)
+      as_fn_append ac_configure_args1 " '$ac_arg'"
+      if test $ac_must_keep_next = true; then
+	ac_must_keep_next=false # Got value, back to normal.
+      else
+	case $ac_arg in
+	  *=* | --config-cache | -C | -disable-* | --disable-* \
+	  | -enable-* | --enable-* | -gas | --g* | -nfp | --nf* \
+	  | -q | -quiet | --q* | -silent | --sil* | -v | -verb* \
+	  | -with-* | --with-* | -without-* | --without-* | --x)
+	    case "$ac_configure_args0 " in
+	      "$ac_configure_args1"*" '$ac_arg' "* ) continue ;;
+	    esac
+	    ;;
+	  -* ) ac_must_keep_next=true ;;
+	esac
+      fi
+      as_fn_append ac_configure_args " '$ac_arg'"
+      ;;
+    esac
+  done
+done
+{ ac_configure_args0=; unset ac_configure_args0;}
+{ ac_configure_args1=; unset ac_configure_args1;}
 
-# This variable might get temporarily overwritten with the
-# GNUSTEP_MAKEFILES of the runtime configuration, make sure we keep
-# track of the original one.  CURRENT_GNUSTEP_MAKEFILES is the one
-# that we use to locate the actual gnustep-make installation that
-# will build the software.
-CURRENT_GNUSTEP_MAKEFILES="$GNUSTEP_MAKEFILES"
+# When interrupted or exit'd, cleanup temporary files, and complete
+# config.log.  We remove comments because anyway the quotes in there
+# would cause problems or look ugly.
+# WARNING: Use '\'' to represent an apostrophe within the trap.
+# WARNING: Do not start the trap code with a newline, due to a FreeBSD 4.0 bug.
+trap 'exit_status=$?
+  # Save into config.log some information that might help in debugging.
+  {
+    echo
 
-#--------------------------------------------------------------------
-# Use config.guess, config.sub and install-sh provided by gnustep-make
-#--------------------------------------------------------------------
-ac_aux_dir=
-for ac_dir in $CURRENT_GNUSTEP_MAKEFILES "$srcdir"/$CURRENT_GNUSTEP_MAKEFILES; do
-  if test -f "$ac_dir/install-sh"; then
-    ac_aux_dir=$ac_dir
-    ac_install_sh="$ac_aux_dir/install-sh -c"
-    break
-  elif test -f "$ac_dir/install.sh"; then
-    ac_aux_dir=$ac_dir
-    ac_install_sh="$ac_aux_dir/install.sh -c"
-    break
-  elif test -f "$ac_dir/shtool"; then
-    ac_aux_dir=$ac_dir
-    ac_install_sh="$ac_aux_dir/shtool install -c"
-    break
-  fi
+    $as_echo "## ---------------- ##
+## Cache variables. ##
+## ---------------- ##"
+    echo
+    # The following way of writing the cache mishandles newlines in values,
+(
+  for ac_var in `(set) 2>&1 | sed -n '\''s/^\([a-zA-Z_][a-zA-Z0-9_]*\)=.*/\1/p'\''`; do
+    eval ac_val=\$$ac_var
+    case $ac_val in #(
+    *${as_nl}*)
+      case $ac_var in #(
+      *_cv_*) { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: cache variable $ac_var contains a newline" >&5
+$as_echo "$as_me: WARNING: cache variable $ac_var contains a newline" >&2;} ;;
+      esac
+      case $ac_var in #(
+      _ | IFS | as_nl) ;; #(
+      BASH_ARGV | BASH_SOURCE) eval $ac_var= ;; #(
+      *) { eval $ac_var=; unset $ac_var;} ;;
+      esac ;;
+    esac
+  done
+  (set) 2>&1 |
+    case $as_nl`(ac_space='\'' '\''; set) 2>&1` in #(
+    *${as_nl}ac_space=\ *)
+      sed -n \
+	"s/'\''/'\''\\\\'\'''\''/g;
+	  s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1='\''\\2'\''/p"
+      ;; #(
+    *)
+      sed -n "/^[_$as_cr_alnum]*_cv_[_$as_cr_alnum]*=/p"
+      ;;
+    esac |
+    sort
+)
+    echo
+
+    $as_echo "## ----------------- ##
+## Output variables. ##
+## ----------------- ##"
+    echo
+    for ac_var in $ac_subst_vars
+    do
+      eval ac_val=\$$ac_var
+      case $ac_val in
+      *\'\''*) ac_val=`$as_echo "$ac_val" | sed "s/'\''/'\''\\\\\\\\'\'''\''/g"`;;
+      esac
+      $as_echo "$ac_var='\''$ac_val'\''"
+    done | sort
+    echo
+
+    if test -n "$ac_subst_files"; then
+      $as_echo "## ------------------- ##
+## File substitutions. ##
+## ------------------- ##"
+      echo
+      for ac_var in $ac_subst_files
+      do
+	eval ac_val=\$$ac_var
+	case $ac_val in
+	*\'\''*) ac_val=`$as_echo "$ac_val" | sed "s/'\''/'\''\\\\\\\\'\'''\''/g"`;;
+	esac
+	$as_echo "$ac_var='\''$ac_val'\''"
+      done | sort
+      echo
+    fi
+
+    if test -s confdefs.h; then
+      $as_echo "## ----------- ##
+## confdefs.h. ##
+## ----------- ##"
+      echo
+      cat confdefs.h
+      echo
+    fi
+    test "$ac_signal" != 0 &&
+      $as_echo "$as_me: caught signal $ac_signal"
+    $as_echo "$as_me: exit $exit_status"
+  } >&5
+  rm -f core *.core core.conftest.* &&
+    rm -f -r conftest* confdefs* conf$$* $ac_clean_files &&
+    exit $exit_status
+' 0
+for ac_signal in 1 2 13 15; do
+  trap 'ac_signal='$ac_signal'; as_fn_exit 1' $ac_signal
 done
-if test -z "$ac_aux_dir"; then
-  { { $as_echo "$as_me:$LINENO: error: cannot find install-sh or install.sh in $CURRENT_GNUSTEP_MAKEFILES \"$srcdir\"/$CURRENT_GNUSTEP_MAKEFILES" >&5
-$as_echo "$as_me: error: cannot find install-sh or install.sh in $CURRENT_GNUSTEP_MAKEFILES \"$srcdir\"/$CURRENT_GNUSTEP_MAKEFILES" >&2;}
-   { (exit 1); exit 1; }; }
-fi
+ac_signal=0
 
-# These three variables are undocumented and unsupported,
-# and are intended to be withdrawn in a future Autoconf release.
-# They can cause serious problems if a builder's source tree is in a directory
-# whose full name contains unusual characters.
-ac_config_guess="$SHELL $ac_aux_dir/config.guess"  # Please don't use this var.
-ac_config_sub="$SHELL $ac_aux_dir/config.sub"  # Please don't use this var.
-ac_configure="$SHELL $ac_aux_dir/configure"  # Please don't use this var.
+# confdefs.h avoids OS command line length limits that DEFS can exceed.
+rm -f -r conftest* confdefs.h
 
+$as_echo "/* confdefs.h */" > confdefs.h
 
+# Predefined preprocessor variables.
 
-#--------------------------------------------------------------------
-# Use a .h file with #define's, instead of -D command-line switches
-#--------------------------------------------------------------------
-ac_config_headers="$ac_config_headers Headers/GNUstepBase/config.h"
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_NAME "$PACKAGE_NAME"
+_ACEOF
 
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_TARNAME "$PACKAGE_TARNAME"
+_ACEOF
 
-#--------------------------------------------------------------------
-# Determine the host, build, and target systems
-#--------------------------------------------------------------------
-# Make sure we can run config.sub.
-$SHELL "$ac_aux_dir/config.sub" sun4 >/dev/null 2>&1 ||
-  { { $as_echo "$as_me:$LINENO: error: cannot run $SHELL $ac_aux_dir/config.sub" >&5
-$as_echo "$as_me: error: cannot run $SHELL $ac_aux_dir/config.sub" >&2;}
-   { (exit 1); exit 1; }; }
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_VERSION "$PACKAGE_VERSION"
+_ACEOF
 
-{ $as_echo "$as_me:$LINENO: checking build system type" >&5
-$as_echo_n "checking build system type... " >&6; }
-if test "${ac_cv_build+set}" = set; then
-  $as_echo_n "(cached) " >&6
-else
-  ac_build_alias=$build_alias
-test "x$ac_build_alias" = x &&
-  ac_build_alias=`$SHELL "$ac_aux_dir/config.guess"`
-test "x$ac_build_alias" = x &&
-  { { $as_echo "$as_me:$LINENO: error: cannot guess build type; you must specify one" >&5
-$as_echo "$as_me: error: cannot guess build type; you must specify one" >&2;}
-   { (exit 1); exit 1; }; }
-ac_cv_build=`$SHELL "$ac_aux_dir/config.sub" $ac_build_alias` ||
-  { { $as_echo "$as_me:$LINENO: error: $SHELL $ac_aux_dir/config.sub $ac_build_alias failed" >&5
-$as_echo "$as_me: error: $SHELL $ac_aux_dir/config.sub $ac_build_alias failed" >&2;}
-   { (exit 1); exit 1; }; }
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_STRING "$PACKAGE_STRING"
+_ACEOF
 
-fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_build" >&5
-$as_echo "$ac_cv_build" >&6; }
-case $ac_cv_build in
-*-*-*) ;;
-*) { { $as_echo "$as_me:$LINENO: error: invalid value of canonical build" >&5
-$as_echo "$as_me: error: invalid value of canonical build" >&2;}
-   { (exit 1); exit 1; }; };;
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_BUGREPORT "$PACKAGE_BUGREPORT"
+_ACEOF
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_URL "$PACKAGE_URL"
+_ACEOF
+
+
+# Let the site file select an alternate cache file if it wants to.
+# Prefer an explicitly selected file to automatically selected ones.
+ac_site_file1=NONE
+ac_site_file2=NONE
+if test -n "$CONFIG_SITE"; then
+  # We do not want a PATH search for config.site.
+  case $CONFIG_SITE in #((
+    -*)  ac_site_file1=./$CONFIG_SITE;;
+    */*) ac_site_file1=$CONFIG_SITE;;
+    *)   ac_site_file1=./$CONFIG_SITE;;
+  esac
+elif test "x$prefix" != xNONE; then
+  ac_site_file1=$prefix/share/config.site
+  ac_site_file2=$prefix/etc/config.site
+else
+  ac_site_file1=$ac_default_prefix/share/config.site
+  ac_site_file2=$ac_default_prefix/etc/config.site
+fi
+for ac_site_file in "$ac_site_file1" "$ac_site_file2"
+do
+  test "x$ac_site_file" = xNONE && continue
+  if test /dev/null != "$ac_site_file" && test -r "$ac_site_file"; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: loading site script $ac_site_file" >&5
+$as_echo "$as_me: loading site script $ac_site_file" >&6;}
+    sed 's/^/| /' "$ac_site_file" >&5
+    . "$ac_site_file" \
+      || { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+as_fn_error $? "failed to load site script $ac_site_file
+See \`config.log' for more details" "$LINENO" 5; }
+  fi
+done
+
+if test -r "$cache_file"; then
+  # Some versions of bash will fail to source /dev/null (special files
+  # actually), so we avoid doing that.  DJGPP emulates it as a regular file.
+  if test /dev/null != "$cache_file" && test -f "$cache_file"; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: loading cache $cache_file" >&5
+$as_echo "$as_me: loading cache $cache_file" >&6;}
+    case $cache_file in
+      [\\/]* | ?:[\\/]* ) . "$cache_file";;
+      *)                      . "./$cache_file";;
+    esac
+  fi
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: creating cache $cache_file" >&5
+$as_echo "$as_me: creating cache $cache_file" >&6;}
+  >$cache_file
+fi
+
+# Check that the precious variables saved in the cache have kept the same
+# value.
+ac_cache_corrupted=false
+for ac_var in $ac_precious_vars; do
+  eval ac_old_set=\$ac_cv_env_${ac_var}_set
+  eval ac_new_set=\$ac_env_${ac_var}_set
+  eval ac_old_val=\$ac_cv_env_${ac_var}_value
+  eval ac_new_val=\$ac_env_${ac_var}_value
+  case $ac_old_set,$ac_new_set in
+    set,)
+      { $as_echo "$as_me:${as_lineno-$LINENO}: error: \`$ac_var' was set to \`$ac_old_val' in the previous run" >&5
+$as_echo "$as_me: error: \`$ac_var' was set to \`$ac_old_val' in the previous run" >&2;}
+      ac_cache_corrupted=: ;;
+    ,set)
+      { $as_echo "$as_me:${as_lineno-$LINENO}: error: \`$ac_var' was not set in the previous run" >&5
+$as_echo "$as_me: error: \`$ac_var' was not set in the previous run" >&2;}
+      ac_cache_corrupted=: ;;
+    ,);;
+    *)
+      if test "x$ac_old_val" != "x$ac_new_val"; then
+	# differences in whitespace do not lead to failure.
+	ac_old_val_w=`echo x $ac_old_val`
+	ac_new_val_w=`echo x $ac_new_val`
+	if test "$ac_old_val_w" != "$ac_new_val_w"; then
+	  { $as_echo "$as_me:${as_lineno-$LINENO}: error: \`$ac_var' has changed since the previous run:" >&5
+$as_echo "$as_me: error: \`$ac_var' has changed since the previous run:" >&2;}
+	  ac_cache_corrupted=:
+	else
+	  { $as_echo "$as_me:${as_lineno-$LINENO}: warning: ignoring whitespace changes in \`$ac_var' since the previous run:" >&5
+$as_echo "$as_me: warning: ignoring whitespace changes in \`$ac_var' since the previous run:" >&2;}
+	  eval $ac_var=\$ac_old_val
+	fi
+	{ $as_echo "$as_me:${as_lineno-$LINENO}:   former value:  \`$ac_old_val'" >&5
+$as_echo "$as_me:   former value:  \`$ac_old_val'" >&2;}
+	{ $as_echo "$as_me:${as_lineno-$LINENO}:   current value: \`$ac_new_val'" >&5
+$as_echo "$as_me:   current value: \`$ac_new_val'" >&2;}
+      fi;;
+  esac
+  # Pass precious variables to config.status.
+  if test "$ac_new_set" = set; then
+    case $ac_new_val in
+    *\'*) ac_arg=$ac_var=`$as_echo "$ac_new_val" | sed "s/'/'\\\\\\\\''/g"` ;;
+    *) ac_arg=$ac_var=$ac_new_val ;;
+    esac
+    case " $ac_configure_args " in
+      *" '$ac_arg' "*) ;; # Avoid dups.  Use of quotes ensures accuracy.
+      *) as_fn_append ac_configure_args " '$ac_arg'" ;;
+    esac
+  fi
+done
+if $ac_cache_corrupted; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+  { $as_echo "$as_me:${as_lineno-$LINENO}: error: changes in the environment can compromise the build" >&5
+$as_echo "$as_me: error: changes in the environment can compromise the build" >&2;}
+  as_fn_error $? "run \`make distclean' and/or \`rm $cache_file' and start over" "$LINENO" 5
+fi
+## -------------------- ##
+## Main body of script. ##
+## -------------------- ##
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+
+
+
+
+# If GNUSTEP_MAKEFILES is undefined, try to use gnustep-config to determine it.
+if test -z "$GNUSTEP_MAKEFILES"; then
+  GNUSTEP_MAKEFILES=`gnustep-config --variable=GNUSTEP_MAKEFILES 2>&5`
+fi
+
+if test -z "$GNUSTEP_MAKEFILES"; then
+  as_fn_error $? "You must have the gnustep-make package installed and set up the GNUSTEP_MAKEFILES environment variable to contain the path to the makefiles directory before configuring!" "$LINENO" 5
+fi
+
+# If LIBRARY_COMBO is undefined, try to use gnustep-config to determine it.
+if test -z "$LIBRARY_COMBO"; then
+  LIBRARY_COMBO=`gnustep-config --variable=LIBRARY_COMBO 2>&5`
+fi
+
+nonfragile=`gnustep-config --objc-flags | grep _NONFRAGILE_ABI 2>&5`
+if test -z "$nonfragile"; then
+  nonfragile=no
+  BASE_NONFRAGILE_ABI=0
+else
+  nonfragile=yes
+  BASE_NONFRAGILE_ABI=1
+fi
+
+
+# We shouldn't be loading GNUstep.sh here.  It would load in a lot of
+# variables which might get confused with the ones that will be used
+# at runtime.  We will load it later once we have determined (and
+# saved) the runtime configuration.
+
+# This variable might get temporarily overwritten with the
+# GNUSTEP_MAKEFILES of the runtime configuration, make sure we keep
+# track of the original one.  CURRENT_GNUSTEP_MAKEFILES is the one
+# that we use to locate the actual gnustep-make installation that
+# will build the software.
+CURRENT_GNUSTEP_MAKEFILES="$GNUSTEP_MAKEFILES"
+
+#--------------------------------------------------------------------
+# Use config.guess, config.sub and install-sh provided by gnustep-make
+#--------------------------------------------------------------------
+ac_aux_dir=
+for ac_dir in $CURRENT_GNUSTEP_MAKEFILES "$srcdir"/$CURRENT_GNUSTEP_MAKEFILES; do
+  if test -f "$ac_dir/install-sh"; then
+    ac_aux_dir=$ac_dir
+    ac_install_sh="$ac_aux_dir/install-sh -c"
+    break
+  elif test -f "$ac_dir/install.sh"; then
+    ac_aux_dir=$ac_dir
+    ac_install_sh="$ac_aux_dir/install.sh -c"
+    break
+  elif test -f "$ac_dir/shtool"; then
+    ac_aux_dir=$ac_dir
+    ac_install_sh="$ac_aux_dir/shtool install -c"
+    break
+  fi
+done
+if test -z "$ac_aux_dir"; then
+  as_fn_error $? "cannot find install-sh, install.sh, or shtool in $CURRENT_GNUSTEP_MAKEFILES \"$srcdir\"/$CURRENT_GNUSTEP_MAKEFILES" "$LINENO" 5
+fi
+
+# These three variables are undocumented and unsupported,
+# and are intended to be withdrawn in a future Autoconf release.
+# They can cause serious problems if a builder's source tree is in a directory
+# whose full name contains unusual characters.
+ac_config_guess="$SHELL $ac_aux_dir/config.guess"  # Please don't use this var.
+ac_config_sub="$SHELL $ac_aux_dir/config.sub"  # Please don't use this var.
+ac_configure="$SHELL $ac_aux_dir/configure"  # Please don't use this var.
+
+
+
+#--------------------------------------------------------------------
+# Use a .h file with #define's, instead of -D command-line switches
+#--------------------------------------------------------------------
+ac_config_headers="$ac_config_headers Headers/GNUstepBase/config.h"
+
+
+#--------------------------------------------------------------------
+# Determine the host, build, and target systems
+#--------------------------------------------------------------------
+# Make sure we can run config.sub.
+$SHELL "$ac_aux_dir/config.sub" sun4 >/dev/null 2>&1 ||
+  as_fn_error $? "cannot run $SHELL $ac_aux_dir/config.sub" "$LINENO" 5
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking build system type" >&5
+$as_echo_n "checking build system type... " >&6; }
+if ${ac_cv_build+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_build_alias=$build_alias
+test "x$ac_build_alias" = x &&
+  ac_build_alias=`$SHELL "$ac_aux_dir/config.guess"`
+test "x$ac_build_alias" = x &&
+  as_fn_error $? "cannot guess build type; you must specify one" "$LINENO" 5
+ac_cv_build=`$SHELL "$ac_aux_dir/config.sub" $ac_build_alias` ||
+  as_fn_error $? "$SHELL $ac_aux_dir/config.sub $ac_build_alias failed" "$LINENO" 5
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_build" >&5
+$as_echo "$ac_cv_build" >&6; }
+case $ac_cv_build in
+*-*-*) ;;
+*) as_fn_error $? "invalid value of canonical build" "$LINENO" 5;;
 esac
 build=$ac_cv_build
 ac_save_IFS=$IFS; IFS='-'
@@ -2193,28 +2778,24 @@ IFS=$ac_save_IFS
 case $build_os in *\ *) build_os=`echo "$build_os" | sed 's/ /-/g'`;; esac
 
 
-{ $as_echo "$as_me:$LINENO: checking host system type" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking host system type" >&5
 $as_echo_n "checking host system type... " >&6; }
-if test "${ac_cv_host+set}" = set; then
+if ${ac_cv_host+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   if test "x$host_alias" = x; then
   ac_cv_host=$ac_cv_build
 else
   ac_cv_host=`$SHELL "$ac_aux_dir/config.sub" $host_alias` ||
-    { { $as_echo "$as_me:$LINENO: error: $SHELL $ac_aux_dir/config.sub $host_alias failed" >&5
-$as_echo "$as_me: error: $SHELL $ac_aux_dir/config.sub $host_alias failed" >&2;}
-   { (exit 1); exit 1; }; }
+    as_fn_error $? "$SHELL $ac_aux_dir/config.sub $host_alias failed" "$LINENO" 5
 fi
 
 fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_host" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_host" >&5
 $as_echo "$ac_cv_host" >&6; }
 case $ac_cv_host in
 *-*-*) ;;
-*) { { $as_echo "$as_me:$LINENO: error: invalid value of canonical host" >&5
-$as_echo "$as_me: error: invalid value of canonical host" >&2;}
-   { (exit 1); exit 1; }; };;
+*) as_fn_error $? "invalid value of canonical host" "$LINENO" 5;;
 esac
 host=$ac_cv_host
 ac_save_IFS=$IFS; IFS='-'
@@ -2230,28 +2811,24 @@ IFS=$ac_save_IFS
 case $host_os in *\ *) host_os=`echo "$host_os" | sed 's/ /-/g'`;; esac
 
 
-{ $as_echo "$as_me:$LINENO: checking target system type" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking target system type" >&5
 $as_echo_n "checking target system type... " >&6; }
-if test "${ac_cv_target+set}" = set; then
+if ${ac_cv_target+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   if test "x$target_alias" = x; then
   ac_cv_target=$ac_cv_host
 else
   ac_cv_target=`$SHELL "$ac_aux_dir/config.sub" $target_alias` ||
-    { { $as_echo "$as_me:$LINENO: error: $SHELL $ac_aux_dir/config.sub $target_alias failed" >&5
-$as_echo "$as_me: error: $SHELL $ac_aux_dir/config.sub $target_alias failed" >&2;}
-   { (exit 1); exit 1; }; }
+    as_fn_error $? "$SHELL $ac_aux_dir/config.sub $target_alias failed" "$LINENO" 5
 fi
 
 fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_target" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_target" >&5
 $as_echo "$ac_cv_target" >&6; }
 case $ac_cv_target in
 *-*-*) ;;
-*) { { $as_echo "$as_me:$LINENO: error: invalid value of canonical target" >&5
-$as_echo "$as_me: error: invalid value of canonical target" >&2;}
-   { (exit 1); exit 1; }; };;
+*) as_fn_error $? "invalid value of canonical target" "$LINENO" 5;;
 esac
 target=$ac_cv_target
 ac_save_IFS=$IFS; IFS='-'
@@ -2280,7 +2857,7 @@ test -n "$target_alias" &&
 
 
 # Check whether --with-cross-compilation-info was given.
-if test "${with_cross_compilation_info+set}" = set; then
+if test "${with_cross_compilation_info+set}" = set; then :
   withval=$with_cross_compilation_info; cross_result="$withval"
 else
   cross_result="no"
@@ -2294,9 +2871,7 @@ then
   then
     CROSS_CONFIG="$cross_result"
   else
-    { { $as_echo "$as_me:$LINENO: error: \"Could not load cross-compilation variables from $cross_result\"" >&5
-$as_echo "$as_me: error: \"Could not load cross-compilation variables from $cross_result\"" >&2;}
-   { (exit 1); exit 1; }; }
+    as_fn_error $? "\"Could not load cross-compilation variables from $cross_result\"" "$LINENO" 5
   fi
 fi
 
@@ -2308,7 +2883,7 @@ fi
 #---------------------------------------------------------------------
 # Location of the GNUstep.conf config file (--with-config-file)
 #---------------------------------------------------------------------
-{ $as_echo "$as_me:$LINENO: checking for GNUstep configuration file to use at runtime" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for GNUstep configuration file to use at runtime" >&5
 $as_echo_n "checking for GNUstep configuration file to use at runtime... " >&6; }
 
 # This requires gnustep-make > 1.13.0 to work.  For gnustep-make =
@@ -2328,7 +2903,7 @@ fi
 
 
 # Check whether --with-config-file was given.
-if test "${with_config_file+set}" = set; then
+if test "${with_config_file+set}" = set; then :
   withval=$with_config_file; result="$withval"
 else
   result="no"
@@ -2347,7 +2922,7 @@ if test x"$GNUSTEP_TARGET_CONFIG_FILE" = x""; then
       GNUSTEP_TARGET_CONFIG_FILE="$GNUSTEP_MAKE_CONFIG" ;;
   esac
 fi
-{ $as_echo "$as_me:$LINENO: result: $GNUSTEP_TARGET_CONFIG_FILE" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $GNUSTEP_TARGET_CONFIG_FILE" >&5
 $as_echo "$GNUSTEP_TARGET_CONFIG_FILE" >&6; }
 
 #-----------------------------------------------------------------
@@ -2362,10 +2937,10 @@ case "$target_os" in
     mingw*)	enable_env_config=no;;
     *)		enable_env_config=yes;;
 esac
-{ $as_echo "$as_me:$LINENO: checking whether the GNUstep.conf file path can be set in the environment" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the GNUstep.conf file path can be set in the environment" >&5
 $as_echo_n "checking whether the GNUstep.conf file path can be set in the environment... " >&6; }
 # Check whether --enable-environment-config-file was given.
-if test "${enable_environment_config_file+set}" = set; then
+if test "${enable_environment_config_file+set}" = set; then :
   enableval=$enable_environment_config_file; ac_cv_environment_config_file=$enableval
 else
   ac_cv_environment_config_file=$enable_env_config
@@ -2373,19 +2948,15 @@ fi
 
 if test "$ac_cv_environment_config_file" = "yes"; then
 
-cat >>confdefs.h <<\_ACEOF
-#define OPTION_NO_ENVIRONMENT 0
-_ACEOF
+$as_echo "#define OPTION_NO_ENVIRONMENT 0" >>confdefs.h
 
-  { $as_echo "$as_me:$LINENO: result: yes" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
 $as_echo "yes" >&6; }
 else
 
-cat >>confdefs.h <<\_ACEOF
-#define OPTION_NO_ENVIRONMENT 1
-_ACEOF
+$as_echo "#define OPTION_NO_ENVIRONMENT 1" >>confdefs.h
 
-  { $as_echo "$as_me:$LINENO: result: no: disabled from the command-line" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no: disabled from the command-line" >&5
 $as_echo "no: disabled from the command-line" >&6; }
 fi
 
@@ -2419,31 +2990,31 @@ esac
 # installation (or of the config file you specify).
 # It can be annoying in certain cases though; this option lets you
 # turn it off.
-{ $as_echo "$as_me:$LINENO: checking if we should import an existing configuration file now" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking if we should import an existing configuration file now" >&5
 $as_echo_n "checking if we should import an existing configuration file now... " >&6; }
 # Check whether --enable-importing-config-file was given.
-if test "${enable_importing_config_file+set}" = set; then
+if test "${enable_importing_config_file+set}" = set; then :
   enableval=$enable_importing_config_file; ac_cv_importing_config_file=$enableval
 else
   ac_cv_importing_config_file="yes"
 fi
 
 if test "$ac_cv_importing_config_file" = "no"; then
-  { $as_echo "$as_me:$LINENO: result: no: disabled from the command-line" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no: disabled from the command-line" >&5
 $as_echo "no: disabled from the command-line" >&6; }
 else
-  { $as_echo "$as_me:$LINENO: result: yes" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
 $as_echo "yes" >&6; }
 fi
 
 
 if test "$ac_cv_importing_config_file" = "yes" ;
 then
-  { $as_echo "$as_me:$LINENO: checking for default GNUstep configuration file to use" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for default GNUstep configuration file to use" >&5
 $as_echo_n "checking for default GNUstep configuration file to use... " >&6; }
 
 # Check whether --with-default-config was given.
-if test "${with_default_config+set}" = set; then
+if test "${with_default_config+set}" = set; then :
   withval=$with_default_config; result="$withval"
 else
   result="no"
@@ -2467,7 +3038,7 @@ fi
     # installed.
     GNUSTEP_DEFAULT_CONFIG="$GNUSTEP_MAKE_CONFIG"
   fi
-  { $as_echo "$as_me:$LINENO: result: $GNUSTEP_DEFAULT_CONFIG" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $GNUSTEP_DEFAULT_CONFIG" >&5
 $as_echo "$GNUSTEP_DEFAULT_CONFIG" >&6; }
 
   #
@@ -2483,7 +3054,7 @@ $as_echo "$GNUSTEP_DEFAULT_CONFIG" >&6; }
     # Use the default config file to override standard values.
     #
     if test ! -f "$GNUSTEP_DEFAULT_CONFIG"; then
-      { $as_echo "$as_me:$LINENO: result: fail: file \"$GNUSTEP_DEFAULT_CONFIG\" does not exist" >&5
+      { $as_echo "$as_me:${as_lineno-$LINENO}: result: fail: file \"$GNUSTEP_DEFAULT_CONFIG\" does not exist" >&5
 $as_echo "fail: file \"$GNUSTEP_DEFAULT_CONFIG\" does not exist" >&6; }
       # Ohoh ... things are not going well.  We are asked to import
       # a config file that doesn't exist.  So all paths might be unset
@@ -2494,24 +3065,20 @@ $as_echo "fail: file \"$GNUSTEP_DEFAULT_CONFIG\" does not exist" >&6; }
       # system might be already screwed.  If they don't want to import
       # a config file (eg, they don't have one and they don't care about
       # the hardcoded paths) they should just say so. ;-)
-      { { $as_echo "$as_me:$LINENO: error: Please run configure again with the --disable-importing-config-file option or specifying an alternative file using the --with-default-config= option" >&5
-$as_echo "$as_me: error: Please run configure again with the --disable-importing-config-file option or specifying an alternative file using the --with-default-config= option" >&2;}
-   { (exit 1); exit 1; }; }
+      as_fn_error $? "Please run configure again with the --disable-importing-config-file option or specifying an alternative file using the --with-default-config= option" "$LINENO" 5
       exit 1
     else
-      { $as_echo "$as_me:$LINENO: result: trying to import \"$GNUSTEP_DEFAULT_CONFIG\"" >&5
+      { $as_echo "$as_me:${as_lineno-$LINENO}: result: trying to import \"$GNUSTEP_DEFAULT_CONFIG\"" >&5
 $as_echo "trying to import \"$GNUSTEP_DEFAULT_CONFIG\"" >&6; }
       if test -r "$GNUSTEP_DEFAULT_CONFIG"
       then
-        { $as_echo "$as_me:$LINENO: If this fails, please run configure again with the --disable-importing-config-file option or specifying an alternative file using the --with-default-config= option" >&5
+        { $as_echo "$as_me:${as_lineno-$LINENO}: If this fails, please run configure again with the --disable-importing-config-file option or specifying an alternative file using the --with-default-config= option" >&5
 $as_echo "$as_me: If this fails, please run configure again with the --disable-importing-config-file option or specifying an alternative file using the --with-default-config= option" >&6;}
         . "$GNUSTEP_DEFAULT_CONFIG"
       else
-        { $as_echo "$as_me:$LINENO: result: fail: file \"$GNUSTEP_DEFAULT_CONFIG\" is not readable" >&5
+        { $as_echo "$as_me:${as_lineno-$LINENO}: result: fail: file \"$GNUSTEP_DEFAULT_CONFIG\" is not readable" >&5
 $as_echo "fail: file \"$GNUSTEP_DEFAULT_CONFIG\" is not readable" >&6; }
-	{ { $as_echo "$as_me:$LINENO: error: Unable to import configuration file at $GNUSTEP_DEFAULT_CONFIG.  Please run configure again with a revised/corrected --with-default-config= option or with --disable-importing-config-file." >&5
-$as_echo "$as_me: error: Unable to import configuration file at $GNUSTEP_DEFAULT_CONFIG.  Please run configure again with a revised/corrected --with-default-config= option or with --disable-importing-config-file." >&2;}
-   { (exit 1); exit 1; }; }
+	as_fn_error $? "Unable to import configuration file at $GNUSTEP_DEFAULT_CONFIG.  Please run configure again with a revised/corrected --with-default-config= option or with --disable-importing-config-file." "$LINENO" 5
 	exit 1
       fi
     fi
@@ -2581,11 +3148,11 @@ if test x"$GNUSTEP_USER_DIR_DOC" = x""; then GNUSTEP_USER_DIR_DOC=$GNUSTEP_USER_
 if test x"$GNUSTEP_USER_DIR_DOC_MAN" = x""; then GNUSTEP_USER_DIR_DOC_MAN=$GNUSTEP_USER_DIR/Documentation/man; fi
 if test x"$GNUSTEP_USER_DIR_DOC_INFO" = x""; then GNUSTEP_USER_DIR_DOC_INFO=$GNUSTEP_USER_DIR/Documentation/info; fi
 
-{ $as_echo "$as_me:$LINENO: checking for GNUstep-base installation domain" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for GNUstep-base installation domain" >&5
 $as_echo_n "checking for GNUstep-base installation domain... " >&6; }
 
 # Check whether --with-installation-domain was given.
-if test "${with_installation_domain+set}" = set; then
+if test "${with_installation_domain+set}" = set; then :
   withval=$with_installation_domain; result="$withval"
 else
   result="no"
@@ -2604,7 +3171,7 @@ then
   then
     result=`gnustep-config --installation-domain-for=gnustep-base 2>&5`
   else
-    { $as_echo "$as_me:$LINENO: WARNING: The 'gnustep-config' script was not found or out of date." >&5
+    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: The 'gnustep-config' script was not found or out of date." >&5
 $as_echo "$as_me: WARNING: The 'gnustep-config' script was not found or out of date." >&2;}
     result=$GNUSTEP_INSTALLATION_DOMAIN
     if test "$result" = ""
@@ -2617,25 +3184,23 @@ $as_echo "$as_me: WARNING: The 'gnustep-config' script was not found or out of d
 fi
 case "$result" in
   SYSTEM)
-    { $as_echo "$as_me:$LINENO: result: SYSTEM" >&5
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: SYSTEM" >&5
 $as_echo "SYSTEM" >&6; }
     GNUSTEP_BASE_PATH="$GNUSTEP_SYSTEM_TOOLS";;
   LOCAL)
-    { $as_echo "$as_me:$LINENO: result: LOCAL" >&5
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: LOCAL" >&5
 $as_echo "LOCAL" >&6; }
     GNUSTEP_BASE_PATH="$GNUSTEP_LOCAL_TOOLS";;
   NETWORK)
-    { $as_echo "$as_me:$LINENO: result: NETWORK" >&5
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: NETWORK" >&5
 $as_echo "NETWORK" >&6; }
     GNUSTEP_BASE_PATH="$GNUSTEP_NETWORK_TOOLS";;
   USER)
-    { $as_echo "$as_me:$LINENO: result: USER" >&5
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: USER" >&5
 $as_echo "USER" >&6; }
     GNUSTEP_BASE_PATH="$GNUSTEP_USER_TOOLS";;
   *)
-    { { $as_echo "$as_me:$LINENO: error: Unknown installation domain '$result' (it should be SYSTEM, LOCAL, NETWORK or USER).  Please run configure again with the option --with-installation-domain=LOCAL (or whatever domain you want to install into)." >&5
-$as_echo "$as_me: error: Unknown installation domain '$result' (it should be SYSTEM, LOCAL, NETWORK or USER).  Please run configure again with the option --with-installation-domain=LOCAL (or whatever domain you want to install into)." >&2;}
-   { (exit 1); exit 1; }; }
+    as_fn_error $? "Unknown installation domain '$result' (it should be SYSTEM, LOCAL, NETWORK or USER).  Please run configure again with the option --with-installation-domain=LOCAL (or whatever domain you want to install into)." "$LINENO" 5
     exit 1;;
 esac
 # We store GNUSTEP_BASE_DOMAIN in config.mak so that we can check
@@ -2730,9 +3295,9 @@ case "$path" in
 esac
 done
 
-{ $as_echo "$as_me:$LINENO: checking if we are hardcoding any relative paths in gnustep-base" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking if we are hardcoding any relative paths in gnustep-base" >&5
 $as_echo_n "checking if we are hardcoding any relative paths in gnustep-base... " >&6; }
-{ $as_echo "$as_me:$LINENO: result: $GNUSTEP_BASE_RELATIVE_PATHS" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $GNUSTEP_BASE_RELATIVE_PATHS" >&5
 $as_echo "$GNUSTEP_BASE_RELATIVE_PATHS" >&6; }
 
 
@@ -2741,15733 +3306,3359 @@ $as_echo "$GNUSTEP_BASE_RELATIVE_PATHS" >&6; }
 # into gnustep-base.  This is to help users in finding
 # misconfigurations.
 #
-{ $as_echo "$as_me:$LINENO: We store the following filesystem layout into gnustep-base, to be used when no config file is found" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: We store the following filesystem layout into gnustep-base, to be used when no config file is found" >&5
 $as_echo "$as_me: We store the following filesystem layout into gnustep-base, to be used when no config file is found" >&6;}
-{ $as_echo "$as_me:$LINENO: checking for Makefiles directory" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for Makefiles directory" >&5
 $as_echo_n "checking for Makefiles directory... " >&6; }
-{ $as_echo "$as_me:$LINENO: result: $GNUSTEP_MAKEFILES" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $GNUSTEP_MAKEFILES" >&5
 $as_echo "$GNUSTEP_MAKEFILES" >&6; }
-{ $as_echo "$as_me:$LINENO: checking for user defaults directory" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for user defaults directory" >&5
 $as_echo_n "checking for user defaults directory... " >&6; }
-{ $as_echo "$as_me:$LINENO: result: $GNUSTEP_USER_DEFAULTS_DIR" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $GNUSTEP_USER_DEFAULTS_DIR" >&5
 $as_echo "$GNUSTEP_USER_DEFAULTS_DIR" >&6; }
-{ $as_echo "$as_me:$LINENO: checking for user config file" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for user config file" >&5
 $as_echo_n "checking for user config file... " >&6; }
-{ $as_echo "$as_me:$LINENO: result: $GNUSTEP_USER_CONFIG_FILE" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $GNUSTEP_USER_CONFIG_FILE" >&5
 $as_echo "$GNUSTEP_USER_CONFIG_FILE" >&6; }
 
-{ $as_echo "$as_me:$LINENO: checking for System Applications directory" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for System Applications directory" >&5
 $as_echo_n "checking for System Applications directory... " >&6; }
-{ $as_echo "$as_me:$LINENO: result: $GNUSTEP_SYSTEM_APPS" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $GNUSTEP_SYSTEM_APPS" >&5
 $as_echo "$GNUSTEP_SYSTEM_APPS" >&6; }
-{ $as_echo "$as_me:$LINENO: checking for System Admin Applications directory" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for System Admin Applications directory" >&5
 $as_echo_n "checking for System Admin Applications directory... " >&6; }
-{ $as_echo "$as_me:$LINENO: result: $GNUSTEP_SYSTEM_ADMIN_APPS" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $GNUSTEP_SYSTEM_ADMIN_APPS" >&5
 $as_echo "$GNUSTEP_SYSTEM_ADMIN_APPS" >&6; }
-{ $as_echo "$as_me:$LINENO: checking for System Web Applications directory" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for System Web Applications directory" >&5
 $as_echo_n "checking for System Web Applications directory... " >&6; }
-{ $as_echo "$as_me:$LINENO: result: $GNUSTEP_SYSTEM_WEB_APPS" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $GNUSTEP_SYSTEM_WEB_APPS" >&5
 $as_echo "$GNUSTEP_SYSTEM_WEB_APPS" >&6; }
-{ $as_echo "$as_me:$LINENO: checking for System Tools directory" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for System Tools directory" >&5
 $as_echo_n "checking for System Tools directory... " >&6; }
-{ $as_echo "$as_me:$LINENO: result: $GNUSTEP_SYSTEM_TOOLS" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $GNUSTEP_SYSTEM_TOOLS" >&5
 $as_echo "$GNUSTEP_SYSTEM_TOOLS" >&6; }
-{ $as_echo "$as_me:$LINENO: checking for System Admin Tools directory" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for System Admin Tools directory" >&5
 $as_echo_n "checking for System Admin Tools directory... " >&6; }
-{ $as_echo "$as_me:$LINENO: result: $GNUSTEP_SYSTEM_ADMIN_TOOLS" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $GNUSTEP_SYSTEM_ADMIN_TOOLS" >&5
 $as_echo "$GNUSTEP_SYSTEM_ADMIN_TOOLS" >&6; }
-{ $as_echo "$as_me:$LINENO: checking for System Library directory" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for System Library directory" >&5
 $as_echo_n "checking for System Library directory... " >&6; }
-{ $as_echo "$as_me:$LINENO: result: $GNUSTEP_SYSTEM_LIBRARY" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $GNUSTEP_SYSTEM_LIBRARY" >&5
 $as_echo "$GNUSTEP_SYSTEM_LIBRARY" >&6; }
-{ $as_echo "$as_me:$LINENO: checking for System Libraries directory" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for System Libraries directory" >&5
 $as_echo_n "checking for System Libraries directory... " >&6; }
-{ $as_echo "$as_me:$LINENO: result: $GNUSTEP_SYSTEM_LIBRARIES" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $GNUSTEP_SYSTEM_LIBRARIES" >&5
 $as_echo "$GNUSTEP_SYSTEM_LIBRARIES" >&6; }
-{ $as_echo "$as_me:$LINENO: checking for System Headers directory" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for System Headers directory" >&5
 $as_echo_n "checking for System Headers directory... " >&6; }
-{ $as_echo "$as_me:$LINENO: result: $GNUSTEP_SYSTEM_HEADERS" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $GNUSTEP_SYSTEM_HEADERS" >&5
 $as_echo "$GNUSTEP_SYSTEM_HEADERS" >&6; }
-{ $as_echo "$as_me:$LINENO: checking for System Documentation directory" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for System Documentation directory" >&5
 $as_echo_n "checking for System Documentation directory... " >&6; }
-{ $as_echo "$as_me:$LINENO: result: $GNUSTEP_SYSTEM_DOC" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $GNUSTEP_SYSTEM_DOC" >&5
 $as_echo "$GNUSTEP_SYSTEM_DOC" >&6; }
-{ $as_echo "$as_me:$LINENO: checking for System Info Documentation directory" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for System Info Documentation directory" >&5
 $as_echo_n "checking for System Info Documentation directory... " >&6; }
-{ $as_echo "$as_me:$LINENO: result: $GNUSTEP_SYSTEM_DOC_INFO" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $GNUSTEP_SYSTEM_DOC_INFO" >&5
 $as_echo "$GNUSTEP_SYSTEM_DOC_INFO" >&6; }
-{ $as_echo "$as_me:$LINENO: checking for System Man Documentation directory" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for System Man Documentation directory" >&5
 $as_echo_n "checking for System Man Documentation directory... " >&6; }
-{ $as_echo "$as_me:$LINENO: result: $GNUSTEP_SYSTEM_DOC_MAN" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $GNUSTEP_SYSTEM_DOC_MAN" >&5
 $as_echo "$GNUSTEP_SYSTEM_DOC_MAN" >&6; }
 
-{ $as_echo "$as_me:$LINENO: checking for Network Applications directory" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for Network Applications directory" >&5
 $as_echo_n "checking for Network Applications directory... " >&6; }
-{ $as_echo "$as_me:$LINENO: result: $GNUSTEP_NETWORK_APPS" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $GNUSTEP_NETWORK_APPS" >&5
 $as_echo "$GNUSTEP_NETWORK_APPS" >&6; }
-{ $as_echo "$as_me:$LINENO: checking for Network Admin Applications directory" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for Network Admin Applications directory" >&5
 $as_echo_n "checking for Network Admin Applications directory... " >&6; }
-{ $as_echo "$as_me:$LINENO: result: $GNUSTEP_NETWORK_ADMIN_APPS" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $GNUSTEP_NETWORK_ADMIN_APPS" >&5
 $as_echo "$GNUSTEP_NETWORK_ADMIN_APPS" >&6; }
-{ $as_echo "$as_me:$LINENO: checking for Network Web Applications directory" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for Network Web Applications directory" >&5
 $as_echo_n "checking for Network Web Applications directory... " >&6; }
-{ $as_echo "$as_me:$LINENO: result: $GNUSTEP_NETWORK_WEB_APPS" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $GNUSTEP_NETWORK_WEB_APPS" >&5
 $as_echo "$GNUSTEP_NETWORK_WEB_APPS" >&6; }
-{ $as_echo "$as_me:$LINENO: checking for Network Tools directory" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for Network Tools directory" >&5
 $as_echo_n "checking for Network Tools directory... " >&6; }
-{ $as_echo "$as_me:$LINENO: result: $GNUSTEP_NETWORK_TOOLS" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $GNUSTEP_NETWORK_TOOLS" >&5
 $as_echo "$GNUSTEP_NETWORK_TOOLS" >&6; }
-{ $as_echo "$as_me:$LINENO: checking for Network Admin Tools directory" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for Network Admin Tools directory" >&5
 $as_echo_n "checking for Network Admin Tools directory... " >&6; }
-{ $as_echo "$as_me:$LINENO: result: $GNUSTEP_NETWORK_ADMIN_TOOLS" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $GNUSTEP_NETWORK_ADMIN_TOOLS" >&5
 $as_echo "$GNUSTEP_NETWORK_ADMIN_TOOLS" >&6; }
-{ $as_echo "$as_me:$LINENO: checking for Network Library directory" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for Network Library directory" >&5
 $as_echo_n "checking for Network Library directory... " >&6; }
-{ $as_echo "$as_me:$LINENO: result: $GNUSTEP_NETWORK_LIBRARY" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $GNUSTEP_NETWORK_LIBRARY" >&5
 $as_echo "$GNUSTEP_NETWORK_LIBRARY" >&6; }
-{ $as_echo "$as_me:$LINENO: checking for Network Libraries directory" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for Network Libraries directory" >&5
 $as_echo_n "checking for Network Libraries directory... " >&6; }
-{ $as_echo "$as_me:$LINENO: result: $GNUSTEP_NETWORK_LIBRARIES" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $GNUSTEP_NETWORK_LIBRARIES" >&5
 $as_echo "$GNUSTEP_NETWORK_LIBRARIES" >&6; }
-{ $as_echo "$as_me:$LINENO: checking for Network Headers directory" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for Network Headers directory" >&5
 $as_echo_n "checking for Network Headers directory... " >&6; }
-{ $as_echo "$as_me:$LINENO: result: $GNUSTEP_NETWORK_HEADERS" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $GNUSTEP_NETWORK_HEADERS" >&5
 $as_echo "$GNUSTEP_NETWORK_HEADERS" >&6; }
-{ $as_echo "$as_me:$LINENO: checking for Network Documentation directory" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for Network Documentation directory" >&5
 $as_echo_n "checking for Network Documentation directory... " >&6; }
-{ $as_echo "$as_me:$LINENO: result: $GNUSTEP_NETWORK_DOC" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $GNUSTEP_NETWORK_DOC" >&5
 $as_echo "$GNUSTEP_NETWORK_DOC" >&6; }
-{ $as_echo "$as_me:$LINENO: checking for Network Info Documentation directory" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for Network Info Documentation directory" >&5
 $as_echo_n "checking for Network Info Documentation directory... " >&6; }
-{ $as_echo "$as_me:$LINENO: result: $GNUSTEP_NETWORK_DOC_INFO" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $GNUSTEP_NETWORK_DOC_INFO" >&5
 $as_echo "$GNUSTEP_NETWORK_DOC_INFO" >&6; }
-{ $as_echo "$as_me:$LINENO: checking for Network Man Documentation directory" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for Network Man Documentation directory" >&5
 $as_echo_n "checking for Network Man Documentation directory... " >&6; }
-{ $as_echo "$as_me:$LINENO: result: $GNUSTEP_NETWORK_DOC_MAN" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $GNUSTEP_NETWORK_DOC_MAN" >&5
 $as_echo "$GNUSTEP_NETWORK_DOC_MAN" >&6; }
 
-{ $as_echo "$as_me:$LINENO: checking for Local Applications directory" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for Local Applications directory" >&5
 $as_echo_n "checking for Local Applications directory... " >&6; }
-{ $as_echo "$as_me:$LINENO: result: $GNUSTEP_LOCAL_APPS" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $GNUSTEP_LOCAL_APPS" >&5
 $as_echo "$GNUSTEP_LOCAL_APPS" >&6; }
-{ $as_echo "$as_me:$LINENO: checking for Local Admin Applications directory" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for Local Admin Applications directory" >&5
 $as_echo_n "checking for Local Admin Applications directory... " >&6; }
-{ $as_echo "$as_me:$LINENO: result: $GNUSTEP_LOCAL_ADMIN_APPS" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $GNUSTEP_LOCAL_ADMIN_APPS" >&5
 $as_echo "$GNUSTEP_LOCAL_ADMIN_APPS" >&6; }
-{ $as_echo "$as_me:$LINENO: checking for Local Web Applications directory" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for Local Web Applications directory" >&5
 $as_echo_n "checking for Local Web Applications directory... " >&6; }
-{ $as_echo "$as_me:$LINENO: result: $GNUSTEP_LOCAL_WEB_APPS" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $GNUSTEP_LOCAL_WEB_APPS" >&5
 $as_echo "$GNUSTEP_LOCAL_WEB_APPS" >&6; }
-{ $as_echo "$as_me:$LINENO: checking for Local Tools directory" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for Local Tools directory" >&5
 $as_echo_n "checking for Local Tools directory... " >&6; }
-{ $as_echo "$as_me:$LINENO: result: $GNUSTEP_LOCAL_TOOLS" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $GNUSTEP_LOCAL_TOOLS" >&5
 $as_echo "$GNUSTEP_LOCAL_TOOLS" >&6; }
-{ $as_echo "$as_me:$LINENO: checking for Local Admin Tools directory" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for Local Admin Tools directory" >&5
 $as_echo_n "checking for Local Admin Tools directory... " >&6; }
-{ $as_echo "$as_me:$LINENO: result: $GNUSTEP_LOCAL_ADMIN_TOOLS" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $GNUSTEP_LOCAL_ADMIN_TOOLS" >&5
 $as_echo "$GNUSTEP_LOCAL_ADMIN_TOOLS" >&6; }
-{ $as_echo "$as_me:$LINENO: checking for Local Library directory" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for Local Library directory" >&5
 $as_echo_n "checking for Local Library directory... " >&6; }
-{ $as_echo "$as_me:$LINENO: result: $GNUSTEP_LOCAL_LIBRARY" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $GNUSTEP_LOCAL_LIBRARY" >&5
 $as_echo "$GNUSTEP_LOCAL_LIBRARY" >&6; }
-{ $as_echo "$as_me:$LINENO: checking for Local Libraries directory" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for Local Libraries directory" >&5
 $as_echo_n "checking for Local Libraries directory... " >&6; }
-{ $as_echo "$as_me:$LINENO: result: $GNUSTEP_LOCAL_LIBRARIES" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $GNUSTEP_LOCAL_LIBRARIES" >&5
 $as_echo "$GNUSTEP_LOCAL_LIBRARIES" >&6; }
-{ $as_echo "$as_me:$LINENO: checking for Local Headers directory" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for Local Headers directory" >&5
 $as_echo_n "checking for Local Headers directory... " >&6; }
-{ $as_echo "$as_me:$LINENO: result: $GNUSTEP_LOCAL_HEADERS" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $GNUSTEP_LOCAL_HEADERS" >&5
 $as_echo "$GNUSTEP_LOCAL_HEADERS" >&6; }
-{ $as_echo "$as_me:$LINENO: checking for Local Documentation directory" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for Local Documentation directory" >&5
 $as_echo_n "checking for Local Documentation directory... " >&6; }
-{ $as_echo "$as_me:$LINENO: result: $GNUSTEP_LOCAL_DOC" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $GNUSTEP_LOCAL_DOC" >&5
 $as_echo "$GNUSTEP_LOCAL_DOC" >&6; }
-{ $as_echo "$as_me:$LINENO: checking for Local Info Documentation directory" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for Local Info Documentation directory" >&5
 $as_echo_n "checking for Local Info Documentation directory... " >&6; }
-{ $as_echo "$as_me:$LINENO: result: $GNUSTEP_LOCAL_DOC_INFO" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $GNUSTEP_LOCAL_DOC_INFO" >&5
 $as_echo "$GNUSTEP_LOCAL_DOC_INFO" >&6; }
-{ $as_echo "$as_me:$LINENO: checking for Local Man Documentation directory" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for Local Man Documentation directory" >&5
 $as_echo_n "checking for Local Man Documentation directory... " >&6; }
-{ $as_echo "$as_me:$LINENO: result: $GNUSTEP_LOCAL_DOC_MAN" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $GNUSTEP_LOCAL_DOC_MAN" >&5
 $as_echo "$GNUSTEP_LOCAL_DOC_MAN" >&6; }
 
-{ $as_echo "$as_me:$LINENO: checking for User Applications directory" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for User Applications directory" >&5
 $as_echo_n "checking for User Applications directory... " >&6; }
-{ $as_echo "$as_me:$LINENO: result: $GNUSTEP_USER_DIR_APPS" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $GNUSTEP_USER_DIR_APPS" >&5
 $as_echo "$GNUSTEP_USER_DIR_APPS" >&6; }
-{ $as_echo "$as_me:$LINENO: checking for User Admin Applications directory" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for User Admin Applications directory" >&5
 $as_echo_n "checking for User Admin Applications directory... " >&6; }
-{ $as_echo "$as_me:$LINENO: result: $GNUSTEP_USER_DIR_ADMIN_APPS" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $GNUSTEP_USER_DIR_ADMIN_APPS" >&5
 $as_echo "$GNUSTEP_USER_DIR_ADMIN_APPS" >&6; }
-{ $as_echo "$as_me:$LINENO: checking for User Web Applications directory" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for User Web Applications directory" >&5
 $as_echo_n "checking for User Web Applications directory... " >&6; }
-{ $as_echo "$as_me:$LINENO: result: $GNUSTEP_USER_DIR_WEB_APPS" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $GNUSTEP_USER_DIR_WEB_APPS" >&5
 $as_echo "$GNUSTEP_USER_DIR_WEB_APPS" >&6; }
-{ $as_echo "$as_me:$LINENO: checking for User Tools directory" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for User Tools directory" >&5
 $as_echo_n "checking for User Tools directory... " >&6; }
-{ $as_echo "$as_me:$LINENO: result: $GNUSTEP_USER_DIR_TOOLS" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $GNUSTEP_USER_DIR_TOOLS" >&5
 $as_echo "$GNUSTEP_USER_DIR_TOOLS" >&6; }
-{ $as_echo "$as_me:$LINENO: checking for User Admin Tools directory" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for User Admin Tools directory" >&5
 $as_echo_n "checking for User Admin Tools directory... " >&6; }
-{ $as_echo "$as_me:$LINENO: result: $GNUSTEP_USER_DIR_ADMIN_TOOLS" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $GNUSTEP_USER_DIR_ADMIN_TOOLS" >&5
 $as_echo "$GNUSTEP_USER_DIR_ADMIN_TOOLS" >&6; }
-{ $as_echo "$as_me:$LINENO: checking for User Library directory" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for User Library directory" >&5
 $as_echo_n "checking for User Library directory... " >&6; }
-{ $as_echo "$as_me:$LINENO: result: $GNUSTEP_USER_DIR_LIBRARY" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $GNUSTEP_USER_DIR_LIBRARY" >&5
 $as_echo "$GNUSTEP_USER_DIR_LIBRARY" >&6; }
-{ $as_echo "$as_me:$LINENO: checking for User Libraries directory" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for User Libraries directory" >&5
 $as_echo_n "checking for User Libraries directory... " >&6; }
-{ $as_echo "$as_me:$LINENO: result: $GNUSTEP_USER_DIR_LIBRARIES" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $GNUSTEP_USER_DIR_LIBRARIES" >&5
 $as_echo "$GNUSTEP_USER_DIR_LIBRARIES" >&6; }
-{ $as_echo "$as_me:$LINENO: checking for User Headers directory" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for User Headers directory" >&5
 $as_echo_n "checking for User Headers directory... " >&6; }
-{ $as_echo "$as_me:$LINENO: result: $GNUSTEP_USER_DIR_HEADERS" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $GNUSTEP_USER_DIR_HEADERS" >&5
 $as_echo "$GNUSTEP_USER_DIR_HEADERS" >&6; }
-{ $as_echo "$as_me:$LINENO: checking for User Documentation directory" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for User Documentation directory" >&5
 $as_echo_n "checking for User Documentation directory... " >&6; }
-{ $as_echo "$as_me:$LINENO: result: $GNUSTEP_USER_DIR_DOC" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $GNUSTEP_USER_DIR_DOC" >&5
 $as_echo "$GNUSTEP_USER_DIR_DOC" >&6; }
-{ $as_echo "$as_me:$LINENO: checking for User Info Documentation directory" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for User Info Documentation directory" >&5
 $as_echo_n "checking for User Info Documentation directory... " >&6; }
-{ $as_echo "$as_me:$LINENO: result: $GNUSTEP_USER_DIR_DOC_INFO" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $GNUSTEP_USER_DIR_DOC_INFO" >&5
 $as_echo "$GNUSTEP_USER_DIR_DOC_INFO" >&6; }
-{ $as_echo "$as_me:$LINENO: checking for User Man Documentation directory" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for User Man Documentation directory" >&5
 $as_echo_n "checking for User Man Documentation directory... " >&6; }
-{ $as_echo "$as_me:$LINENO: result: $GNUSTEP_USER_DIR_DOC_MAN" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $GNUSTEP_USER_DIR_DOC_MAN" >&5
 $as_echo "$GNUSTEP_USER_DIR_DOC_MAN" >&6; }
 
-{ $as_echo "$as_me:$LINENO: checking for System User directory" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for System User directory" >&5
 $as_echo_n "checking for System User directory... " >&6; }
-{ $as_echo "$as_me:$LINENO: result: $GNUSTEP_SYSTEM_USERS_DIR" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $GNUSTEP_SYSTEM_USERS_DIR" >&5
 $as_echo "$GNUSTEP_SYSTEM_USERS_DIR" >&6; }
-{ $as_echo "$as_me:$LINENO: checking for Network User directory" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for Network User directory" >&5
 $as_echo_n "checking for Network User directory... " >&6; }
-{ $as_echo "$as_me:$LINENO: result: $GNUSTEP_NETWORK_USERS_DIR" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $GNUSTEP_NETWORK_USERS_DIR" >&5
 $as_echo "$GNUSTEP_NETWORK_USERS_DIR" >&6; }
-{ $as_echo "$as_me:$LINENO: checking for Local User directory" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for Local User directory" >&5
 $as_echo_n "checking for Local User directory... " >&6; }
-{ $as_echo "$as_me:$LINENO: result: $GNUSTEP_LOCAL_USERS_DIR" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $GNUSTEP_LOCAL_USERS_DIR" >&5
 $as_echo "$GNUSTEP_LOCAL_USERS_DIR" >&6; }
 
 #
 # Set the default configuration file values in config.h to be hard-coded
 # into NSPathUtilities.m
 #
-GNUSTEP_MAKEFILES=`echo $GNUSTEP_MAKEFILES|sed -e 's/\\\\/\\\\\\\\/g'`
-
-cat >>confdefs.h <<_ACEOF
-#define GNUSTEP_TARGET_MAKEFILES "$GNUSTEP_MAKEFILES"
-_ACEOF
-
-GNUSTEP_USER_DEFAULTS_DIR=`echo $GNUSTEP_USER_DEFAULTS_DIR|sed -e 's/\\\\/\\\\\\\\/g'`
-
-cat >>confdefs.h <<_ACEOF
-#define GNUSTEP_TARGET_USER_DEFAULTS_DIR "$GNUSTEP_USER_DEFAULTS_DIR"
-_ACEOF
-
-GNUSTEP_USER_CONFIG_FILE=`echo $GNUSTEP_USER_CONFIG_FILE|sed -e 's/\\\\/\\\\\\\\/g'`
-
-cat >>confdefs.h <<_ACEOF
-#define GNUSTEP_TARGET_USER_CONFIG_FILE "$GNUSTEP_USER_CONFIG_FILE"
-_ACEOF
-
-GNUSTEP_TARGET_CONFIG_FILE=`echo $GNUSTEP_TARGET_CONFIG_FILE|sed -e 's/\\\\/\\\\\\\\/g'`
-
-cat >>confdefs.h <<_ACEOF
-#define GNUSTEP_TARGET_CONFIG_FILE "$GNUSTEP_TARGET_CONFIG_FILE"
-_ACEOF
-
-
-#
-# SYSTEM domain paths
-#
-GNUSTEP_SYSTEM_APPS=`echo $GNUSTEP_SYSTEM_APPS|sed -e 's/\\\\/\\\\\\\\/g'`
-
-cat >>confdefs.h <<_ACEOF
-#define GNUSTEP_TARGET_SYSTEM_APPS "$GNUSTEP_SYSTEM_APPS"
-_ACEOF
-
-
-GNUSTEP_SYSTEM_ADMIN_APPS=`echo $GNUSTEP_SYSTEM_ADMIN_APPS|sed -e 's/\\\\/\\\\\\\\/g'`
-
-cat >>confdefs.h <<_ACEOF
-#define GNUSTEP_TARGET_SYSTEM_ADMIN_APPS "$GNUSTEP_SYSTEM_ADMIN_APPS"
-_ACEOF
-
-
-GNUSTEP_SYSTEM_WEB_APPS=`echo $GNUSTEP_SYSTEM_WEB_APPS|sed -e 's/\\\\/\\\\\\\\/g'`
-
-cat >>confdefs.h <<_ACEOF
-#define GNUSTEP_TARGET_SYSTEM_WEB_APPS "$GNUSTEP_SYSTEM_WEB_APPS"
-_ACEOF
-
-
-GNUSTEP_SYSTEM_TOOLS=`echo $GNUSTEP_SYSTEM_TOOLS|sed -e 's/\\\\/\\\\\\\\/g'`
-
-cat >>confdefs.h <<_ACEOF
-#define GNUSTEP_TARGET_SYSTEM_TOOLS "$GNUSTEP_SYSTEM_TOOLS"
-_ACEOF
-
-
-GNUSTEP_SYSTEM_ADMIN_TOOLS=`echo $GNUSTEP_SYSTEM_ADMIN_TOOLS|sed -e 's/\\\\/\\\\\\\\/g'`
-
-cat >>confdefs.h <<_ACEOF
-#define GNUSTEP_TARGET_SYSTEM_ADMIN_TOOLS "$GNUSTEP_SYSTEM_ADMIN_TOOLS"
-_ACEOF
-
-
-GNUSTEP_SYSTEM_LIBRARY=`echo $GNUSTEP_SYSTEM_LIBRARY|sed -e 's/\\\\/\\\\\\\\/g'`
-
-cat >>confdefs.h <<_ACEOF
-#define GNUSTEP_TARGET_SYSTEM_LIBRARY "$GNUSTEP_SYSTEM_LIBRARY"
-_ACEOF
-
-
-GNUSTEP_SYSTEM_LIBRARIES=`echo $GNUSTEP_SYSTEM_LIBRARIES|sed -e 's/\\\\/\\\\\\\\/g'`
-
-cat >>confdefs.h <<_ACEOF
-#define GNUSTEP_TARGET_SYSTEM_LIBRARIES "$GNUSTEP_SYSTEM_LIBRARIES"
-_ACEOF
-
-
-GNUSTEP_SYSTEM_HEADERS=`echo $GNUSTEP_SYSTEM_HEADERS|sed -e 's/\\\\/\\\\\\\\/g'`
-
-cat >>confdefs.h <<_ACEOF
-#define GNUSTEP_TARGET_SYSTEM_HEADERS "$GNUSTEP_SYSTEM_HEADERS"
-_ACEOF
-
-
-GNUSTEP_SYSTEM_DOC=`echo $GNUSTEP_SYSTEM_DOC|sed -e 's/\\\\/\\\\\\\\/g'`
-
-cat >>confdefs.h <<_ACEOF
-#define GNUSTEP_TARGET_SYSTEM_DOC "$GNUSTEP_SYSTEM_DOC"
-_ACEOF
-
-
-GNUSTEP_SYSTEM_DOC_MAN=`echo $GNUSTEP_SYSTEM_DOC_MAN|sed -e 's/\\\\/\\\\\\\\/g'`
-
-cat >>confdefs.h <<_ACEOF
-#define GNUSTEP_TARGET_SYSTEM_DOC_MAN "$GNUSTEP_SYSTEM_DOC_MAN"
-_ACEOF
-
-
-GNUSTEP_SYSTEM_DOC_INFO=`echo $GNUSTEP_SYSTEM_DOC_INFO|sed -e 's/\\\\/\\\\\\\\/g'`
-
-cat >>confdefs.h <<_ACEOF
-#define GNUSTEP_TARGET_SYSTEM_DOC_INFO "$GNUSTEP_SYSTEM_DOC_INFO"
-_ACEOF
-
-
-#
-# NETWORK domain paths
-#
-GNUSTEP_NETWORK_APPS=`echo $GNUSTEP_NETWORK_APPS|sed -e 's/\\\\/\\\\\\\\/g'`
-
-cat >>confdefs.h <<_ACEOF
-#define GNUSTEP_TARGET_NETWORK_APPS "$GNUSTEP_NETWORK_APPS"
-_ACEOF
-
-
-GNUSTEP_NETWORK_ADMIN_APPS=`echo $GNUSTEP_NETWORK_ADMIN_APPS|sed -e 's/\\\\/\\\\\\\\/g'`
-
-cat >>confdefs.h <<_ACEOF
-#define GNUSTEP_TARGET_NETWORK_ADMIN_APPS "$GNUSTEP_NETWORK_ADMIN_APPS"
-_ACEOF
-
-
-GNUSTEP_NETWORK_WEB_APPS=`echo $GNUSTEP_NETWORK_WEB_APPS|sed -e 's/\\\\/\\\\\\\\/g'`
-
-cat >>confdefs.h <<_ACEOF
-#define GNUSTEP_TARGET_NETWORK_WEB_APPS "$GNUSTEP_NETWORK_WEB_APPS"
-_ACEOF
-
-
-GNUSTEP_NETWORK_TOOLS=`echo $GNUSTEP_NETWORK_TOOLS|sed -e 's/\\\\/\\\\\\\\/g'`
-
-cat >>confdefs.h <<_ACEOF
-#define GNUSTEP_TARGET_NETWORK_TOOLS "$GNUSTEP_NETWORK_TOOLS"
-_ACEOF
-
-
-GNUSTEP_NETWORK_ADMIN_TOOLS=`echo $GNUSTEP_NETWORK_ADMIN_TOOLS|sed -e 's/\\\\/\\\\\\\\/g'`
-
-cat >>confdefs.h <<_ACEOF
-#define GNUSTEP_TARGET_NETWORK_ADMIN_TOOLS "$GNUSTEP_NETWORK_ADMIN_TOOLS"
-_ACEOF
-
-
-GNUSTEP_NETWORK_LIBRARY=`echo $GNUSTEP_NETWORK_LIBRARY|sed -e 's/\\\\/\\\\\\\\/g'`
-
-cat >>confdefs.h <<_ACEOF
-#define GNUSTEP_TARGET_NETWORK_LIBRARY "$GNUSTEP_NETWORK_LIBRARY"
-_ACEOF
-
-
-GNUSTEP_NETWORK_LIBRARIES=`echo $GNUSTEP_NETWORK_LIBRARIES|sed -e 's/\\\\/\\\\\\\\/g'`
-
-cat >>confdefs.h <<_ACEOF
-#define GNUSTEP_TARGET_NETWORK_LIBRARIES "$GNUSTEP_NETWORK_LIBRARIES"
-_ACEOF
-
-
-GNUSTEP_NETWORK_HEADERS=`echo $GNUSTEP_NETWORK_HEADERS|sed -e 's/\\\\/\\\\\\\\/g'`
-
-cat >>confdefs.h <<_ACEOF
-#define GNUSTEP_TARGET_NETWORK_HEADERS "$GNUSTEP_NETWORK_HEADERS"
-_ACEOF
-
-
-GNUSTEP_NETWORK_DOC=`echo $GNUSTEP_NETWORK_DOC|sed -e 's/\\\\/\\\\\\\\/g'`
-
-cat >>confdefs.h <<_ACEOF
-#define GNUSTEP_TARGET_NETWORK_DOC "$GNUSTEP_NETWORK_DOC"
-_ACEOF
-
-
-GNUSTEP_NETWORK_DOC_MAN=`echo $GNUSTEP_NETWORK_DOC_MAN|sed -e 's/\\\\/\\\\\\\\/g'`
-
-cat >>confdefs.h <<_ACEOF
-#define GNUSTEP_TARGET_NETWORK_DOC_MAN "$GNUSTEP_NETWORK_DOC_MAN"
-_ACEOF
-
-
-GNUSTEP_NETWORK_DOC_INFO=`echo $GNUSTEP_NETWORK_DOC_INFO|sed -e 's/\\\\/\\\\\\\\/g'`
-
-cat >>confdefs.h <<_ACEOF
-#define GNUSTEP_TARGET_NETWORK_DOC_INFO "$GNUSTEP_NETWORK_DOC_INFO"
-_ACEOF
-
-
-#
-# LOCAL domain paths
-#
-GNUSTEP_LOCAL_APPS=`echo $GNUSTEP_LOCAL_APPS|sed -e 's/\\\\/\\\\\\\\/g'`
-
-cat >>confdefs.h <<_ACEOF
-#define GNUSTEP_TARGET_LOCAL_APPS "$GNUSTEP_LOCAL_APPS"
-_ACEOF
-
-
-GNUSTEP_LOCAL_ADMIN_APPS=`echo $GNUSTEP_LOCAL_ADMIN_APPS|sed -e 's/\\\\/\\\\\\\\/g'`
-
-cat >>confdefs.h <<_ACEOF
-#define GNUSTEP_TARGET_LOCAL_ADMIN_APPS "$GNUSTEP_LOCAL_ADMIN_APPS"
-_ACEOF
-
-
-GNUSTEP_LOCAL_WEB_APPS=`echo $GNUSTEP_LOCAL_WEB_APPS|sed -e 's/\\\\/\\\\\\\\/g'`
-
-cat >>confdefs.h <<_ACEOF
-#define GNUSTEP_TARGET_LOCAL_WEB_APPS "$GNUSTEP_LOCAL_WEB_APPS"
-_ACEOF
-
-
-GNUSTEP_LOCAL_TOOLS=`echo $GNUSTEP_LOCAL_TOOLS|sed -e 's/\\\\/\\\\\\\\/g'`
-
-cat >>confdefs.h <<_ACEOF
-#define GNUSTEP_TARGET_LOCAL_TOOLS "$GNUSTEP_LOCAL_TOOLS"
-_ACEOF
-
-
-GNUSTEP_LOCAL_ADMIN_TOOLS=`echo $GNUSTEP_LOCAL_ADMIN_TOOLS|sed -e 's/\\\\/\\\\\\\\/g'`
-
-cat >>confdefs.h <<_ACEOF
-#define GNUSTEP_TARGET_LOCAL_ADMIN_TOOLS "$GNUSTEP_LOCAL_ADMIN_TOOLS"
-_ACEOF
-
-
-GNUSTEP_LOCAL_LIBRARY=`echo $GNUSTEP_LOCAL_LIBRARY|sed -e 's/\\\\/\\\\\\\\/g'`
-
-cat >>confdefs.h <<_ACEOF
-#define GNUSTEP_TARGET_LOCAL_LIBRARY "$GNUSTEP_LOCAL_LIBRARY"
-_ACEOF
-
-
-GNUSTEP_LOCAL_LIBRARIES=`echo $GNUSTEP_LOCAL_LIBRARIES|sed -e 's/\\\\/\\\\\\\\/g'`
-
-cat >>confdefs.h <<_ACEOF
-#define GNUSTEP_TARGET_LOCAL_LIBRARIES "$GNUSTEP_LOCAL_LIBRARIES"
-_ACEOF
-
-
-GNUSTEP_LOCAL_HEADERS=`echo $GNUSTEP_LOCAL_HEADERS|sed -e 's/\\\\/\\\\\\\\/g'`
-
-cat >>confdefs.h <<_ACEOF
-#define GNUSTEP_TARGET_LOCAL_HEADERS "$GNUSTEP_LOCAL_HEADERS"
-_ACEOF
-
-
-GNUSTEP_LOCAL_DOC=`echo $GNUSTEP_LOCAL_DOC|sed -e 's/\\\\/\\\\\\\\/g'`
-
-cat >>confdefs.h <<_ACEOF
-#define GNUSTEP_TARGET_LOCAL_DOC "$GNUSTEP_LOCAL_DOC"
-_ACEOF
-
-
-GNUSTEP_LOCAL_DOC_MAN=`echo $GNUSTEP_LOCAL_DOC_MAN|sed -e 's/\\\\/\\\\\\\\/g'`
-
-cat >>confdefs.h <<_ACEOF
-#define GNUSTEP_TARGET_LOCAL_DOC_MAN "$GNUSTEP_LOCAL_DOC_MAN"
-_ACEOF
-
-
-GNUSTEP_LOCAL_DOC_INFO=`echo $GNUSTEP_LOCAL_DOC_INFO|sed -e 's/\\\\/\\\\\\\\/g'`
-
-cat >>confdefs.h <<_ACEOF
-#define GNUSTEP_TARGET_LOCAL_DOC_INFO "$GNUSTEP_LOCAL_DOC_INFO"
-_ACEOF
-
-
-#
-# USER_DIR domain paths
-#
-GNUSTEP_USER_DIR_APPS=`echo $GNUSTEP_USER_DIR_APPS|sed -e 's/\\\\/\\\\\\\\/g'`
-
-cat >>confdefs.h <<_ACEOF
-#define GNUSTEP_TARGET_USER_DIR_APPS "$GNUSTEP_USER_DIR_APPS"
-_ACEOF
-
-
-GNUSTEP_USER_DIR_ADMIN_APPS=`echo $GNUSTEP_USER_DIR_ADMIN_APPS|sed -e 's/\\\\/\\\\\\\\/g'`
-
-cat >>confdefs.h <<_ACEOF
-#define GNUSTEP_TARGET_USER_DIR_ADMIN_APPS "$GNUSTEP_USER_DIR_ADMIN_APPS"
-_ACEOF
-
-
-GNUSTEP_USER_DIR_WEB_APPS=`echo $GNUSTEP_USER_DIR_WEB_APPS|sed -e 's/\\\\/\\\\\\\\/g'`
-
-cat >>confdefs.h <<_ACEOF
-#define GNUSTEP_TARGET_USER_DIR_WEB_APPS "$GNUSTEP_USER_DIR_WEB_APPS"
-_ACEOF
-
-
-GNUSTEP_USER_DIR_TOOLS=`echo $GNUSTEP_USER_DIR_TOOLS|sed -e 's/\\\\/\\\\\\\\/g'`
-
-cat >>confdefs.h <<_ACEOF
-#define GNUSTEP_TARGET_USER_DIR_TOOLS "$GNUSTEP_USER_DIR_TOOLS"
-_ACEOF
-
-
-GNUSTEP_USER_DIR_ADMIN_TOOLS=`echo $GNUSTEP_USER_DIR_ADMIN_TOOLS|sed -e 's/\\\\/\\\\\\\\/g'`
-
-cat >>confdefs.h <<_ACEOF
-#define GNUSTEP_TARGET_USER_DIR_ADMIN_TOOLS "$GNUSTEP_USER_DIR_ADMIN_TOOLS"
-_ACEOF
-
-
-GNUSTEP_USER_DIR_LIBRARY=`echo $GNUSTEP_USER_DIR_LIBRARY|sed -e 's/\\\\/\\\\\\\\/g'`
-
-cat >>confdefs.h <<_ACEOF
-#define GNUSTEP_TARGET_USER_DIR_LIBRARY "$GNUSTEP_USER_DIR_LIBRARY"
-_ACEOF
-
-
-GNUSTEP_USER_DIR_LIBRARIES=`echo $GNUSTEP_USER_DIR_LIBRARIES|sed -e 's/\\\\/\\\\\\\\/g'`
-
-cat >>confdefs.h <<_ACEOF
-#define GNUSTEP_TARGET_USER_DIR_LIBRARIES "$GNUSTEP_USER_DIR_LIBRARIES"
-_ACEOF
-
-
-GNUSTEP_USER_DIR_HEADERS=`echo $GNUSTEP_USER_DIR_HEADERS|sed -e 's/\\\\/\\\\\\\\/g'`
-
-cat >>confdefs.h <<_ACEOF
-#define GNUSTEP_TARGET_USER_DIR_HEADERS "$GNUSTEP_USER_DIR_HEADERS"
-_ACEOF
-
-
-GNUSTEP_USER_DIR_DOC=`echo $GNUSTEP_USER_DIR_DOC|sed -e 's/\\\\/\\\\\\\\/g'`
-
-cat >>confdefs.h <<_ACEOF
-#define GNUSTEP_TARGET_USER_DIR_DOC "$GNUSTEP_USER_DIR_DOC"
-_ACEOF
-
-
-GNUSTEP_USER_DIR_DOC_MAN=`echo $GNUSTEP_USER_DIR_DOC_MAN|sed -e 's/\\\\/\\\\\\\\/g'`
-
-cat >>confdefs.h <<_ACEOF
-#define GNUSTEP_TARGET_USER_DIR_DOC_MAN "$GNUSTEP_USER_DIR_DOC_MAN"
-_ACEOF
-
-
-GNUSTEP_USER_DIR_DOC_INFO=`echo $GNUSTEP_USER_DIR_DOC_INFO|sed -e 's/\\\\/\\\\\\\\/g'`
-
-cat >>confdefs.h <<_ACEOF
-#define GNUSTEP_TARGET_USER_DIR_DOC_INFO "$GNUSTEP_USER_DIR_DOC_INFO"
-_ACEOF
-
-
-GNUSTEP_TARGET_SYSTEM_USERS_DIR=`echo $GNUSTEP_TARGET_SYSTEM_USERS_DIR|sed -e 's/\\\\/\\\\\\\\/g'`
-
-cat >>confdefs.h <<_ACEOF
-#define GNUSTEP_TARGET_SYSTEM_USERS_DIR "$GNUSTEP_TARGET_SYSTEM_USERS_DIR"
-_ACEOF
-
-GNUSTEP_TARGET_NETWORK_USERS_DIR=`echo $GNUSTEP_TARGET_NETWORK_USERS_DIR|sed -e 's/\\\\/\\\\\\\\/g'`
-
-cat >>confdefs.h <<_ACEOF
-#define GNUSTEP_TARGET_NETWORK_USERS_DIR "$GNUSTEP_TARGET_NETWORK_USERS_DIR"
-_ACEOF
-
-GNUSTEP_TARGET_LOCAL_USERS_DIR=`echo $GNUSTEP_TARGET_LOCAL_USERS_DIR|sed -e 's/\\\\/\\\\\\\\/g'`
-
-cat >>confdefs.h <<_ACEOF
-#define GNUSTEP_TARGET_LOCAL_USERS_DIR "$GNUSTEP_TARGET_LOCAL_USERS_DIR"
-_ACEOF
-
-
-#
-# Now load the values to be used in locating libraries etc used when
-# building the base library ... as supplied by the gnustep-make package
-#
-# It looks like we ought to source the whole GNUstep.sh here, and even
-# ask it to output all variables!  That way we have access to (eg)
-# GNUSTEP_SYSTEM_HEADERS below.
-#
-# We need to unset any values that we really need, or existing settings
-# would be used by GNUstep.sh
-#
-unset GNUSTEP_SYSTEM_HEADERS
-unset GNUSTEP_SYSTEM_LIBRARIES
-unset GNUSTEP_NETWORK_HEADERS
-unset GNUSTEP_NETWORK_LIBRARIES
-unset GNUSTEP_LOCAL_HEADERS
-unset GNUSTEP_LOCAL_LIBRARIES
-GNUSTEP_MAKEFILES="$CURRENT_GNUSTEP_MAKEFILES"
-GNUSTEP_SH_EXPORT_ALL_VARIABLES=yes
-. "$CURRENT_GNUSTEP_MAKEFILES/GNUstep.sh"
-unset GNUSTEP_SH_EXPORT_ALL_VARIABLES
-
-# For backwards compatibility, define GNUSTEP_SYSTEM_HEADERS from
-# GNUSTEP_SYSTEM_ROOT if not set yet.
-if test x"$GNUSTEP_SYSTEM_HEADERS" = x""; then
-  GNUSTEP_SYSTEM_HEADERS="$GNUSTEP_SYSTEM_ROOT/Library/Headers"
-fi
-
-if test x"$GNUSTEP_SYSTEM_LIBRARIES" = x""; then
-  GNUSTEP_SYSTEM_LIBRARIES="$GNUSTEP_SYSTEM_ROOT/Library/Libraries"
-fi
-
-if test x"$GNUSTEP_NETWORK_HEADERS" = x""; then
-  GNUSTEP_NETWORK_HEADERS="$GNUSTEP_NETWORK_ROOT/Library/Headers"
-fi
-
-if test x"$GNUSTEP_NETWORK_LIBRARIES" = x""; then
-  GNUSTEP_NETWORK_LIBRARIES="$GNUSTEP_NETWORK_ROOT/Library/Libraries"
-fi
-
-if test x"$GNUSTEP_LOCAL_HEADERS" = x""; then
-  GNUSTEP_LOCAL_HEADERS="$GNUSTEP_LOCAL_ROOT/Library/Headers"
-fi
-
-if test x"$GNUSTEP_LOCAL_LIBRARIES" = x""; then
-  GNUSTEP_LOCAL_LIBRARIES="$GNUSTEP_LOCAL_ROOT/Library/Libraries"
-fi
-
-if test x"$GNUSTEP_IS_FLATTENED" = x"no"; then
-  GNUSTEP_SYSTEM_HEADERS="$GNUSTEP_SYSTEM_HEADERS/$LIBRARY_COMBO"
-  GNUSTEP_NETWORK_HEADERS="$GNUSTEP_NETWORK_HEADERS/$LIBRARY_COMBO"
-  GNUSTEP_LOCAL_HEADERS="$GNUSTEP_LOCAL_HEADERS/$LIBRARY_COMBO"
-  # FIXME: Cross-compiling should read the target from the configure
-  # options and use it.   GNUSTEP_TARGET_* variables do not exist in
-  # this context (so "$GNUSTEP_TARGET_CPU" will always be "")
-  if test x"$GNUSTEP_TARGET_CPU" = x""; then
-    GNUSTEP_SYSTEM_LIBRARIES="$GNUSTEP_SYSTEM_LIBRARIES/$GNUSTEP_HOST_CPU/$GNUSTEP_HOST_OS/$LIBRARY_COMBO"
-    GNUSTEP_NETWORK_LIBRARIES="$GNUSTEP_NETWORK_LIBRARIES/$GNUSTEP_HOST_CPU/$GNUSTEP_HOST_OS/$LIBRARY_COMBO"
-    GNUSTEP_LOCAL_LIBRARIES="$GNUSTEP_LOCAL_LIBRARIES/$GNUSTEP_HOST_CPU/$GNUSTEP_HOST_OS/$LIBRARY_COMBO"
-  else
-    GNUSTEP_SYSTEM_LIBRARIES="$GNUSTEP_SYSTEM_LIBRARIES/$GNUSTEP_TARGET_CPU/$GNUSTEP_TARGET_OS/$LIBRARY_COMBO"
-    GNUSTEP_NETWORK_LIBRARIES="$GNUSTEP_NETWORK_LIBRARIES/$GNUSTEP_TARGET_CPU/$GNUSTEP_TARGET_OS/$LIBRARY_COMBO"
-    GNUSTEP_LOCAL_LIBRARIES="$GNUSTEP_LOCAL_LIBRARIES/$GNUSTEP_TARGET_CPU/$GNUSTEP_TARGET_OS/$LIBRARY_COMBO"
-  fi
-fi
-
-#
-# Add standard library and header directories for configure to use to locate
-# plain C developer headers/libraries which haver been installed in the
-# GNUstep hierarchy.
-#
-CPPFLAGS="$CPPFLAGS -I$GNUSTEP_SYSTEM_HEADERS -I$GNUSTEP_NETWORK_HEADERS -I$GNUSTEP_LOCAL_HEADERS"
-LDFLAGS="$LDFLAGS -L$GNUSTEP_SYSTEM_LIBRARIES -L$GNUSTEP_NETWORK_LIBRARIES -L$GNUSTEP_LOCAL_LIBRARIES"
-
-#--------------------------------------------------------------------
-# Find the compiler
-#--------------------------------------------------------------------
-ac_ext=c
-ac_cpp='$CPP $CPPFLAGS'
-ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_c_compiler_gnu
-if test -n "$ac_tool_prefix"; then
-  # Extract the first word of "${ac_tool_prefix}gcc", so it can be a program name with args.
-set dummy ${ac_tool_prefix}gcc; ac_word=$2
-{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_CC+set}" = set; then
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$CC"; then
-  ac_cv_prog_CC="$CC" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-  for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_CC="${ac_tool_prefix}gcc"
-    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-done
-IFS=$as_save_IFS
-
-fi
-fi
-CC=$ac_cv_prog_CC
-if test -n "$CC"; then
-  { $as_echo "$as_me:$LINENO: result: $CC" >&5
-$as_echo "$CC" >&6; }
-else
-  { $as_echo "$as_me:$LINENO: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-fi
-if test -z "$ac_cv_prog_CC"; then
-  ac_ct_CC=$CC
-  # Extract the first word of "gcc", so it can be a program name with args.
-set dummy gcc; ac_word=$2
-{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_ac_ct_CC+set}" = set; then
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$ac_ct_CC"; then
-  ac_cv_prog_ac_ct_CC="$ac_ct_CC" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-  for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_ac_ct_CC="gcc"
-    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-done
-IFS=$as_save_IFS
-
-fi
-fi
-ac_ct_CC=$ac_cv_prog_ac_ct_CC
-if test -n "$ac_ct_CC"; then
-  { $as_echo "$as_me:$LINENO: result: $ac_ct_CC" >&5
-$as_echo "$ac_ct_CC" >&6; }
-else
-  { $as_echo "$as_me:$LINENO: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-  if test "x$ac_ct_CC" = x; then
-    CC=""
-  else
-    case $cross_compiling:$ac_tool_warned in
-yes:)
-{ $as_echo "$as_me:$LINENO: WARNING: using cross tools not prefixed with host triplet" >&5
-$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
-ac_tool_warned=yes ;;
-esac
-    CC=$ac_ct_CC
-  fi
-else
-  CC="$ac_cv_prog_CC"
-fi
-
-if test -z "$CC"; then
-          if test -n "$ac_tool_prefix"; then
-    # Extract the first word of "${ac_tool_prefix}cc", so it can be a program name with args.
-set dummy ${ac_tool_prefix}cc; ac_word=$2
-{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_CC+set}" = set; then
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$CC"; then
-  ac_cv_prog_CC="$CC" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-  for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_CC="${ac_tool_prefix}cc"
-    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-done
-IFS=$as_save_IFS
-
-fi
-fi
-CC=$ac_cv_prog_CC
-if test -n "$CC"; then
-  { $as_echo "$as_me:$LINENO: result: $CC" >&5
-$as_echo "$CC" >&6; }
-else
-  { $as_echo "$as_me:$LINENO: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-  fi
-fi
-if test -z "$CC"; then
-  # Extract the first word of "cc", so it can be a program name with args.
-set dummy cc; ac_word=$2
-{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_CC+set}" = set; then
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$CC"; then
-  ac_cv_prog_CC="$CC" # Let the user override the test.
-else
-  ac_prog_rejected=no
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-  for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    if test "$as_dir/$ac_word$ac_exec_ext" = "/usr/ucb/cc"; then
-       ac_prog_rejected=yes
-       continue
-     fi
-    ac_cv_prog_CC="cc"
-    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-done
-IFS=$as_save_IFS
-
-if test $ac_prog_rejected = yes; then
-  # We found a bogon in the path, so make sure we never use it.
-  set dummy $ac_cv_prog_CC
-  shift
-  if test $# != 0; then
-    # We chose a different compiler from the bogus one.
-    # However, it has the same basename, so the bogon will be chosen
-    # first if we set CC to just the basename; use the full file name.
-    shift
-    ac_cv_prog_CC="$as_dir/$ac_word${1+' '}$@"
-  fi
-fi
-fi
-fi
-CC=$ac_cv_prog_CC
-if test -n "$CC"; then
-  { $as_echo "$as_me:$LINENO: result: $CC" >&5
-$as_echo "$CC" >&6; }
-else
-  { $as_echo "$as_me:$LINENO: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-fi
-if test -z "$CC"; then
-  if test -n "$ac_tool_prefix"; then
-  for ac_prog in cl.exe
-  do
-    # Extract the first word of "$ac_tool_prefix$ac_prog", so it can be a program name with args.
-set dummy $ac_tool_prefix$ac_prog; ac_word=$2
-{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_CC+set}" = set; then
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$CC"; then
-  ac_cv_prog_CC="$CC" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-  for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_CC="$ac_tool_prefix$ac_prog"
-    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-done
-IFS=$as_save_IFS
-
-fi
-fi
-CC=$ac_cv_prog_CC
-if test -n "$CC"; then
-  { $as_echo "$as_me:$LINENO: result: $CC" >&5
-$as_echo "$CC" >&6; }
-else
-  { $as_echo "$as_me:$LINENO: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-    test -n "$CC" && break
-  done
-fi
-if test -z "$CC"; then
-  ac_ct_CC=$CC
-  for ac_prog in cl.exe
-do
-  # Extract the first word of "$ac_prog", so it can be a program name with args.
-set dummy $ac_prog; ac_word=$2
-{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_ac_ct_CC+set}" = set; then
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$ac_ct_CC"; then
-  ac_cv_prog_ac_ct_CC="$ac_ct_CC" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-  for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_ac_ct_CC="$ac_prog"
-    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-done
-IFS=$as_save_IFS
-
-fi
-fi
-ac_ct_CC=$ac_cv_prog_ac_ct_CC
-if test -n "$ac_ct_CC"; then
-  { $as_echo "$as_me:$LINENO: result: $ac_ct_CC" >&5
-$as_echo "$ac_ct_CC" >&6; }
-else
-  { $as_echo "$as_me:$LINENO: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-  test -n "$ac_ct_CC" && break
-done
-
-  if test "x$ac_ct_CC" = x; then
-    CC=""
-  else
-    case $cross_compiling:$ac_tool_warned in
-yes:)
-{ $as_echo "$as_me:$LINENO: WARNING: using cross tools not prefixed with host triplet" >&5
-$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
-ac_tool_warned=yes ;;
-esac
-    CC=$ac_ct_CC
-  fi
-fi
-
-fi
-
-
-test -z "$CC" && { { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
-$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-{ { $as_echo "$as_me:$LINENO: error: no acceptable C compiler found in \$PATH
-See \`config.log' for more details." >&5
-$as_echo "$as_me: error: no acceptable C compiler found in \$PATH
-See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; }; }
-
-# Provide some information about the compiler.
-$as_echo "$as_me:$LINENO: checking for C compiler version" >&5
-set X $ac_compile
-ac_compiler=$2
-{ (ac_try="$ac_compiler --version >&5"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compiler --version >&5") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }
-{ (ac_try="$ac_compiler -v >&5"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compiler -v >&5") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }
-{ (ac_try="$ac_compiler -V >&5"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compiler -V >&5") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }
-
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-
-int
-main ()
-{
-
-  ;
-  return 0;
-}
-_ACEOF
-ac_clean_files_save=$ac_clean_files
-ac_clean_files="$ac_clean_files a.out a.out.dSYM a.exe b.out"
-# Try to create an executable without -o first, disregard a.out.
-# It will help us diagnose broken compilers, and finding out an intuition
-# of exeext.
-{ $as_echo "$as_me:$LINENO: checking for C compiler default output file name" >&5
-$as_echo_n "checking for C compiler default output file name... " >&6; }
-ac_link_default=`$as_echo "$ac_link" | sed 's/ -o *conftest[^ ]*//'`
-
-# The possible output files:
-ac_files="a.out conftest.exe conftest a.exe a_out.exe b.out conftest.*"
-
-ac_rmfiles=
-for ac_file in $ac_files
-do
-  case $ac_file in
-    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM | *.o | *.obj ) ;;
-    * ) ac_rmfiles="$ac_rmfiles $ac_file";;
-  esac
-done
-rm -f $ac_rmfiles
-
-if { (ac_try="$ac_link_default"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link_default") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; then
-  # Autoconf-2.13 could set the ac_cv_exeext variable to `no'.
-# So ignore a value of `no', otherwise this would lead to `EXEEXT = no'
-# in a Makefile.  We should not override ac_cv_exeext if it was cached,
-# so that the user can short-circuit this test for compilers unknown to
-# Autoconf.
-for ac_file in $ac_files ''
-do
-  test -f "$ac_file" || continue
-  case $ac_file in
-    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM | *.o | *.obj )
-	;;
-    [ab].out )
-	# We found the default executable, but exeext='' is most
-	# certainly right.
-	break;;
-    *.* )
-        if test "${ac_cv_exeext+set}" = set && test "$ac_cv_exeext" != no;
-	then :; else
-	   ac_cv_exeext=`expr "$ac_file" : '[^.]*\(\..*\)'`
-	fi
-	# We set ac_cv_exeext here because the later test for it is not
-	# safe: cross compilers may not add the suffix if given an `-o'
-	# argument, so we may need to know it at that point already.
-	# Even if this section looks crufty: it has the advantage of
-	# actually working.
-	break;;
-    * )
-	break;;
-  esac
-done
-test "$ac_cv_exeext" = no && ac_cv_exeext=
-
-else
-  ac_file=''
-fi
-
-{ $as_echo "$as_me:$LINENO: result: $ac_file" >&5
-$as_echo "$ac_file" >&6; }
-if test -z "$ac_file"; then
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-{ { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
-$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-{ { $as_echo "$as_me:$LINENO: error: C compiler cannot create executables
-See \`config.log' for more details." >&5
-$as_echo "$as_me: error: C compiler cannot create executables
-See \`config.log' for more details." >&2;}
-   { (exit 77); exit 77; }; }; }
-fi
-
-ac_exeext=$ac_cv_exeext
-
-# Check that the compiler produces executables we can run.  If not, either
-# the compiler is broken, or we cross compile.
-{ $as_echo "$as_me:$LINENO: checking whether the C compiler works" >&5
-$as_echo_n "checking whether the C compiler works... " >&6; }
-# FIXME: These cross compiler hacks should be removed for Autoconf 3.0
-# If not cross compiling, check that we can run a simple program.
-if test "$cross_compiling" != yes; then
-  if { ac_try='./$ac_file'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-    cross_compiling=no
-  else
-    if test "$cross_compiling" = maybe; then
-	cross_compiling=yes
-    else
-	{ { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
-$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-{ { $as_echo "$as_me:$LINENO: error: cannot run C compiled programs.
-If you meant to cross compile, use \`--host'.
-See \`config.log' for more details." >&5
-$as_echo "$as_me: error: cannot run C compiled programs.
-If you meant to cross compile, use \`--host'.
-See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; }; }
-    fi
-  fi
-fi
-{ $as_echo "$as_me:$LINENO: result: yes" >&5
-$as_echo "yes" >&6; }
-
-rm -f -r a.out a.out.dSYM a.exe conftest$ac_cv_exeext b.out
-ac_clean_files=$ac_clean_files_save
-# Check that the compiler produces executables we can run.  If not, either
-# the compiler is broken, or we cross compile.
-{ $as_echo "$as_me:$LINENO: checking whether we are cross compiling" >&5
-$as_echo_n "checking whether we are cross compiling... " >&6; }
-{ $as_echo "$as_me:$LINENO: result: $cross_compiling" >&5
-$as_echo "$cross_compiling" >&6; }
-
-{ $as_echo "$as_me:$LINENO: checking for suffix of executables" >&5
-$as_echo_n "checking for suffix of executables... " >&6; }
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; then
-  # If both `conftest.exe' and `conftest' are `present' (well, observable)
-# catch `conftest.exe'.  For instance with Cygwin, `ls conftest' will
-# work properly (i.e., refer to `conftest.exe'), while it won't with
-# `rm'.
-for ac_file in conftest.exe conftest conftest.*; do
-  test -f "$ac_file" || continue
-  case $ac_file in
-    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM | *.o | *.obj ) ;;
-    *.* ) ac_cv_exeext=`expr "$ac_file" : '[^.]*\(\..*\)'`
-	  break;;
-    * ) break;;
-  esac
-done
-else
-  { { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
-$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-{ { $as_echo "$as_me:$LINENO: error: cannot compute suffix of executables: cannot compile and link
-See \`config.log' for more details." >&5
-$as_echo "$as_me: error: cannot compute suffix of executables: cannot compile and link
-See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; }; }
-fi
-
-rm -f conftest$ac_cv_exeext
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_exeext" >&5
-$as_echo "$ac_cv_exeext" >&6; }
-
-rm -f conftest.$ac_ext
-EXEEXT=$ac_cv_exeext
-ac_exeext=$EXEEXT
-{ $as_echo "$as_me:$LINENO: checking for suffix of object files" >&5
-$as_echo_n "checking for suffix of object files... " >&6; }
-if test "${ac_cv_objext+set}" = set; then
-  $as_echo_n "(cached) " >&6
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-
-int
-main ()
-{
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.o conftest.obj
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; then
-  for ac_file in conftest.o conftest.obj conftest.*; do
-  test -f "$ac_file" || continue;
-  case $ac_file in
-    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM ) ;;
-    *) ac_cv_objext=`expr "$ac_file" : '.*\.\(.*\)'`
-       break;;
-  esac
-done
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-{ { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
-$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-{ { $as_echo "$as_me:$LINENO: error: cannot compute suffix of object files: cannot compile
-See \`config.log' for more details." >&5
-$as_echo "$as_me: error: cannot compute suffix of object files: cannot compile
-See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; }; }
-fi
-
-rm -f conftest.$ac_cv_objext conftest.$ac_ext
-fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_objext" >&5
-$as_echo "$ac_cv_objext" >&6; }
-OBJEXT=$ac_cv_objext
-ac_objext=$OBJEXT
-{ $as_echo "$as_me:$LINENO: checking whether we are using the GNU C compiler" >&5
-$as_echo_n "checking whether we are using the GNU C compiler... " >&6; }
-if test "${ac_cv_c_compiler_gnu+set}" = set; then
-  $as_echo_n "(cached) " >&6
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-
-int
-main ()
-{
-#ifndef __GNUC__
-       choke me
-#endif
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_compiler_gnu=yes
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_compiler_gnu=no
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-ac_cv_c_compiler_gnu=$ac_compiler_gnu
-
-fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_c_compiler_gnu" >&5
-$as_echo "$ac_cv_c_compiler_gnu" >&6; }
-if test $ac_compiler_gnu = yes; then
-  GCC=yes
-else
-  GCC=
-fi
-ac_test_CFLAGS=${CFLAGS+set}
-ac_save_CFLAGS=$CFLAGS
-{ $as_echo "$as_me:$LINENO: checking whether $CC accepts -g" >&5
-$as_echo_n "checking whether $CC accepts -g... " >&6; }
-if test "${ac_cv_prog_cc_g+set}" = set; then
-  $as_echo_n "(cached) " >&6
-else
-  ac_save_c_werror_flag=$ac_c_werror_flag
-   ac_c_werror_flag=yes
-   ac_cv_prog_cc_g=no
-   CFLAGS="-g"
-   cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-
-int
-main ()
-{
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_cv_prog_cc_g=yes
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	CFLAGS=""
-      cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-
-int
-main ()
-{
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  :
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_c_werror_flag=$ac_save_c_werror_flag
-	 CFLAGS="-g"
-	 cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-
-int
-main ()
-{
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_cv_prog_cc_g=yes
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-   ac_c_werror_flag=$ac_save_c_werror_flag
-fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_prog_cc_g" >&5
-$as_echo "$ac_cv_prog_cc_g" >&6; }
-if test "$ac_test_CFLAGS" = set; then
-  CFLAGS=$ac_save_CFLAGS
-elif test $ac_cv_prog_cc_g = yes; then
-  if test "$GCC" = yes; then
-    CFLAGS="-g -O2"
-  else
-    CFLAGS="-g"
-  fi
-else
-  if test "$GCC" = yes; then
-    CFLAGS="-O2"
-  else
-    CFLAGS=
-  fi
-fi
-{ $as_echo "$as_me:$LINENO: checking for $CC option to accept ISO C89" >&5
-$as_echo_n "checking for $CC option to accept ISO C89... " >&6; }
-if test "${ac_cv_prog_cc_c89+set}" = set; then
-  $as_echo_n "(cached) " >&6
-else
-  ac_cv_prog_cc_c89=no
-ac_save_CC=$CC
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <stdarg.h>
-#include <stdio.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-/* Most of the following tests are stolen from RCS 5.7's src/conf.sh.  */
-struct buf { int x; };
-FILE * (*rcsopen) (struct buf *, struct stat *, int);
-static char *e (p, i)
-     char **p;
-     int i;
-{
-  return p[i];
-}
-static char *f (char * (*g) (char **, int), char **p, ...)
-{
-  char *s;
-  va_list v;
-  va_start (v,p);
-  s = g (p, va_arg (v,int));
-  va_end (v);
-  return s;
-}
-
-/* OSF 4.0 Compaq cc is some sort of almost-ANSI by default.  It has
-   function prototypes and stuff, but not '\xHH' hex character constants.
-   These don't provoke an error unfortunately, instead are silently treated
-   as 'x'.  The following induces an error, until -std is added to get
-   proper ANSI mode.  Curiously '\x00'!='x' always comes out true, for an
-   array size at least.  It's necessary to write '\x00'==0 to get something
-   that's true only with -std.  */
-int osf4_cc_array ['\x00' == 0 ? 1 : -1];
-
-/* IBM C 6 for AIX is almost-ANSI by default, but it replaces macro parameters
-   inside strings and character constants.  */
-#define FOO(x) 'x'
-int xlc6_cc_array[FOO(a) == 'x' ? 1 : -1];
-
-int test (int i, double x);
-struct s1 {int (*f) (int a);};
-struct s2 {int (*f) (double a);};
-int pairnames (int, char **, FILE *(*)(struct buf *, struct stat *, int), int, int);
-int argc;
-char **argv;
-int
-main ()
-{
-return f (e, argv, 0) != argv[0]  ||  f (e, argv, 1) != argv[1];
-  ;
-  return 0;
-}
-_ACEOF
-for ac_arg in '' -qlanglvl=extc89 -qlanglvl=ansi -std \
-	-Ae "-Aa -D_HPUX_SOURCE" "-Xc -D__EXTENSIONS__"
-do
-  CC="$ac_save_CC $ac_arg"
-  rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_cv_prog_cc_c89=$ac_arg
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-
-fi
-
-rm -f core conftest.err conftest.$ac_objext
-  test "x$ac_cv_prog_cc_c89" != "xno" && break
-done
-rm -f conftest.$ac_ext
-CC=$ac_save_CC
-
-fi
-# AC_CACHE_VAL
-case "x$ac_cv_prog_cc_c89" in
-  x)
-    { $as_echo "$as_me:$LINENO: result: none needed" >&5
-$as_echo "none needed" >&6; } ;;
-  xno)
-    { $as_echo "$as_me:$LINENO: result: unsupported" >&5
-$as_echo "unsupported" >&6; } ;;
-  *)
-    CC="$CC $ac_cv_prog_cc_c89"
-    { $as_echo "$as_me:$LINENO: result: $ac_cv_prog_cc_c89" >&5
-$as_echo "$ac_cv_prog_cc_c89" >&6; } ;;
-esac
-
-
-ac_ext=c
-ac_cpp='$CPP $CPPFLAGS'
-ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_c_compiler_gnu
-
-ac_ext=c
-ac_cpp='$CPP $CPPFLAGS'
-ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_c_compiler_gnu
-{ $as_echo "$as_me:$LINENO: checking how to run the C preprocessor" >&5
-$as_echo_n "checking how to run the C preprocessor... " >&6; }
-# On Suns, sometimes $CPP names a directory.
-if test -n "$CPP" && test -d "$CPP"; then
-  CPP=
-fi
-if test -z "$CPP"; then
-  if test "${ac_cv_prog_CPP+set}" = set; then
-  $as_echo_n "(cached) " >&6
-else
-      # Double quotes because CPP needs to be expanded
-    for CPP in "$CC -E" "$CC -E -traditional-cpp" "/lib/cpp"
-    do
-      ac_preproc_ok=false
-for ac_c_preproc_warn_flag in '' yes
-do
-  # Use a header file that comes with gcc, so configuring glibc
-  # with a fresh cross-compiler works.
-  # Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-  # <limits.h> exists even on freestanding compilers.
-  # On the NeXT, cc -E runs the code through the compiler's parser,
-  # not just through cpp. "Syntax error" is here to catch this case.
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
-		     Syntax error
-_ACEOF
-if { (ac_try="$ac_cpp conftest.$ac_ext"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } >/dev/null && {
-	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       }; then
-  :
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-  # Broken: fails on valid input.
-continue
-fi
-
-rm -f conftest.err conftest.$ac_ext
-
-  # OK, works on sane cases.  Now check whether nonexistent headers
-  # can be detected and how.
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <ac_nonexistent.h>
-_ACEOF
-if { (ac_try="$ac_cpp conftest.$ac_ext"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } >/dev/null && {
-	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       }; then
-  # Broken: success on invalid input.
-continue
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-  # Passes both tests.
-ac_preproc_ok=:
-break
-fi
-
-rm -f conftest.err conftest.$ac_ext
-
-done
-# Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
-rm -f conftest.err conftest.$ac_ext
-if $ac_preproc_ok; then
-  break
-fi
-
-    done
-    ac_cv_prog_CPP=$CPP
-
-fi
-  CPP=$ac_cv_prog_CPP
-else
-  ac_cv_prog_CPP=$CPP
-fi
-{ $as_echo "$as_me:$LINENO: result: $CPP" >&5
-$as_echo "$CPP" >&6; }
-ac_preproc_ok=false
-for ac_c_preproc_warn_flag in '' yes
-do
-  # Use a header file that comes with gcc, so configuring glibc
-  # with a fresh cross-compiler works.
-  # Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-  # <limits.h> exists even on freestanding compilers.
-  # On the NeXT, cc -E runs the code through the compiler's parser,
-  # not just through cpp. "Syntax error" is here to catch this case.
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
-		     Syntax error
-_ACEOF
-if { (ac_try="$ac_cpp conftest.$ac_ext"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } >/dev/null && {
-	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       }; then
-  :
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-  # Broken: fails on valid input.
-continue
-fi
-
-rm -f conftest.err conftest.$ac_ext
-
-  # OK, works on sane cases.  Now check whether nonexistent headers
-  # can be detected and how.
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <ac_nonexistent.h>
-_ACEOF
-if { (ac_try="$ac_cpp conftest.$ac_ext"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } >/dev/null && {
-	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       }; then
-  # Broken: success on invalid input.
-continue
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-  # Passes both tests.
-ac_preproc_ok=:
-break
-fi
-
-rm -f conftest.err conftest.$ac_ext
-
-done
-# Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
-rm -f conftest.err conftest.$ac_ext
-if $ac_preproc_ok; then
-  :
-else
-  { { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
-$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-{ { $as_echo "$as_me:$LINENO: error: C preprocessor \"$CPP\" fails sanity check
-See \`config.log' for more details." >&5
-$as_echo "$as_me: error: C preprocessor \"$CPP\" fails sanity check
-See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; }; }
-fi
-
-ac_ext=c
-ac_cpp='$CPP $CPPFLAGS'
-ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_c_compiler_gnu
-
-
-
-{ $as_echo "$as_me:$LINENO: checking for grep that handles long lines and -e" >&5
-$as_echo_n "checking for grep that handles long lines and -e... " >&6; }
-if test "${ac_cv_path_GREP+set}" = set; then
-  $as_echo_n "(cached) " >&6
-else
-  if test -z "$GREP"; then
-  ac_path_GREP_found=false
-  # Loop through the user's path and test for each of PROGNAME-LIST
-  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH$PATH_SEPARATOR/usr/xpg4/bin
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-  for ac_prog in grep ggrep; do
-    for ac_exec_ext in '' $ac_executable_extensions; do
-      ac_path_GREP="$as_dir/$ac_prog$ac_exec_ext"
-      { test -f "$ac_path_GREP" && $as_test_x "$ac_path_GREP"; } || continue
-# Check for GNU ac_path_GREP and select it if it is found.
-  # Check for GNU $ac_path_GREP
-case `"$ac_path_GREP" --version 2>&1` in
-*GNU*)
-  ac_cv_path_GREP="$ac_path_GREP" ac_path_GREP_found=:;;
-*)
-  ac_count=0
-  $as_echo_n 0123456789 >"conftest.in"
-  while :
-  do
-    cat "conftest.in" "conftest.in" >"conftest.tmp"
-    mv "conftest.tmp" "conftest.in"
-    cp "conftest.in" "conftest.nl"
-    $as_echo 'GREP' >> "conftest.nl"
-    "$ac_path_GREP" -e 'GREP$' -e '-(cannot match)-' < "conftest.nl" >"conftest.out" 2>/dev/null || break
-    diff "conftest.out" "conftest.nl" >/dev/null 2>&1 || break
-    ac_count=`expr $ac_count + 1`
-    if test $ac_count -gt ${ac_path_GREP_max-0}; then
-      # Best one so far, save it but keep looking for a better one
-      ac_cv_path_GREP="$ac_path_GREP"
-      ac_path_GREP_max=$ac_count
-    fi
-    # 10*(2^10) chars as input seems more than enough
-    test $ac_count -gt 10 && break
-  done
-  rm -f conftest.in conftest.tmp conftest.nl conftest.out;;
-esac
-
-      $ac_path_GREP_found && break 3
-    done
-  done
-done
-IFS=$as_save_IFS
-  if test -z "$ac_cv_path_GREP"; then
-    { { $as_echo "$as_me:$LINENO: error: no acceptable grep could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" >&5
-$as_echo "$as_me: error: no acceptable grep could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" >&2;}
-   { (exit 1); exit 1; }; }
-  fi
-else
-  ac_cv_path_GREP=$GREP
-fi
-
-fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_path_GREP" >&5
-$as_echo "$ac_cv_path_GREP" >&6; }
- GREP="$ac_cv_path_GREP"
-
-
-{ $as_echo "$as_me:$LINENO: checking for egrep" >&5
-$as_echo_n "checking for egrep... " >&6; }
-if test "${ac_cv_path_EGREP+set}" = set; then
-  $as_echo_n "(cached) " >&6
-else
-  if echo a | $GREP -E '(a|b)' >/dev/null 2>&1
-   then ac_cv_path_EGREP="$GREP -E"
-   else
-     if test -z "$EGREP"; then
-  ac_path_EGREP_found=false
-  # Loop through the user's path and test for each of PROGNAME-LIST
-  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH$PATH_SEPARATOR/usr/xpg4/bin
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-  for ac_prog in egrep; do
-    for ac_exec_ext in '' $ac_executable_extensions; do
-      ac_path_EGREP="$as_dir/$ac_prog$ac_exec_ext"
-      { test -f "$ac_path_EGREP" && $as_test_x "$ac_path_EGREP"; } || continue
-# Check for GNU ac_path_EGREP and select it if it is found.
-  # Check for GNU $ac_path_EGREP
-case `"$ac_path_EGREP" --version 2>&1` in
-*GNU*)
-  ac_cv_path_EGREP="$ac_path_EGREP" ac_path_EGREP_found=:;;
-*)
-  ac_count=0
-  $as_echo_n 0123456789 >"conftest.in"
-  while :
-  do
-    cat "conftest.in" "conftest.in" >"conftest.tmp"
-    mv "conftest.tmp" "conftest.in"
-    cp "conftest.in" "conftest.nl"
-    $as_echo 'EGREP' >> "conftest.nl"
-    "$ac_path_EGREP" 'EGREP$' < "conftest.nl" >"conftest.out" 2>/dev/null || break
-    diff "conftest.out" "conftest.nl" >/dev/null 2>&1 || break
-    ac_count=`expr $ac_count + 1`
-    if test $ac_count -gt ${ac_path_EGREP_max-0}; then
-      # Best one so far, save it but keep looking for a better one
-      ac_cv_path_EGREP="$ac_path_EGREP"
-      ac_path_EGREP_max=$ac_count
-    fi
-    # 10*(2^10) chars as input seems more than enough
-    test $ac_count -gt 10 && break
-  done
-  rm -f conftest.in conftest.tmp conftest.nl conftest.out;;
-esac
-
-      $ac_path_EGREP_found && break 3
-    done
-  done
-done
-IFS=$as_save_IFS
-  if test -z "$ac_cv_path_EGREP"; then
-    { { $as_echo "$as_me:$LINENO: error: no acceptable egrep could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" >&5
-$as_echo "$as_me: error: no acceptable egrep could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" >&2;}
-   { (exit 1); exit 1; }; }
-  fi
-else
-  ac_cv_path_EGREP=$EGREP
-fi
-
-   fi
-fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_path_EGREP" >&5
-$as_echo "$ac_cv_path_EGREP" >&6; }
- EGREP="$ac_cv_path_EGREP"
-
-
-{ $as_echo "$as_me:$LINENO: checking for ANSI C header files" >&5
-$as_echo_n "checking for ANSI C header files... " >&6; }
-if test "${ac_cv_header_stdc+set}" = set; then
-  $as_echo_n "(cached) " >&6
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <stdlib.h>
-#include <stdarg.h>
-#include <string.h>
-#include <float.h>
-
-int
-main ()
-{
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_cv_header_stdc=yes
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_cv_header_stdc=no
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-
-if test $ac_cv_header_stdc = yes; then
-  # SunOS 4.x string.h does not declare mem*, contrary to ANSI.
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <string.h>
-
-_ACEOF
-if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
-  $EGREP "memchr" >/dev/null 2>&1; then
-  :
-else
-  ac_cv_header_stdc=no
-fi
-rm -f conftest*
-
-fi
-
-if test $ac_cv_header_stdc = yes; then
-  # ISC 2.0.2 stdlib.h does not declare free, contrary to ANSI.
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <stdlib.h>
-
-_ACEOF
-if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
-  $EGREP "free" >/dev/null 2>&1; then
-  :
-else
-  ac_cv_header_stdc=no
-fi
-rm -f conftest*
-
-fi
-
-if test $ac_cv_header_stdc = yes; then
-  # /bin/cc in Irix-4.0.5 gets non-ANSI ctype macros unless using -ansi.
-  if test "$cross_compiling" = yes; then
-  :
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <ctype.h>
-#include <stdlib.h>
-#if ((' ' & 0x0FF) == 0x020)
-# define ISLOWER(c) ('a' <= (c) && (c) <= 'z')
-# define TOUPPER(c) (ISLOWER(c) ? 'A' + ((c) - 'a') : (c))
-#else
-# define ISLOWER(c) \
-		   (('a' <= (c) && (c) <= 'i') \
-		     || ('j' <= (c) && (c) <= 'r') \
-		     || ('s' <= (c) && (c) <= 'z'))
-# define TOUPPER(c) (ISLOWER(c) ? ((c) | 0x40) : (c))
-#endif
-
-#define XOR(e, f) (((e) && !(f)) || (!(e) && (f)))
-int
-main ()
-{
-  int i;
-  for (i = 0; i < 256; i++)
-    if (XOR (islower (i), ISLOWER (i))
-	|| toupper (i) != TOUPPER (i))
-      return 2;
-  return 0;
-}
-_ACEOF
-rm -f conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  :
-else
-  $as_echo "$as_me: program exited with status $ac_status" >&5
-$as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-( exit $ac_status )
-ac_cv_header_stdc=no
-fi
-rm -rf conftest.dSYM
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
-fi
-
-
-fi
-fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_header_stdc" >&5
-$as_echo "$ac_cv_header_stdc" >&6; }
-if test $ac_cv_header_stdc = yes; then
-
-cat >>confdefs.h <<\_ACEOF
-#define STDC_HEADERS 1
-_ACEOF
-
-fi
-
-# On IRIX 5.3, sys/types and inttypes.h are conflicting.
-
-
-
-
-
-
-
-
-
-for ac_header in sys/types.h sys/stat.h stdlib.h string.h memory.h strings.h \
-		  inttypes.h stdint.h unistd.h
-do
-as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
-{ $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
-$as_echo_n "checking for $ac_header... " >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  $as_echo_n "(cached) " >&6
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-
-#include <$ac_header>
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  eval "$as_ac_Header=yes"
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	eval "$as_ac_Header=no"
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-ac_res=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-as_val=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-   if test "x$as_val" = x""yes; then
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
-_ACEOF
-
-fi
-
-done
-
-
-
-  if test "${ac_cv_header_minix_config_h+set}" = set; then
-  { $as_echo "$as_me:$LINENO: checking for minix/config.h" >&5
-$as_echo_n "checking for minix/config.h... " >&6; }
-if test "${ac_cv_header_minix_config_h+set}" = set; then
-  $as_echo_n "(cached) " >&6
-fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_header_minix_config_h" >&5
-$as_echo "$ac_cv_header_minix_config_h" >&6; }
-else
-  # Is the header compilable?
-{ $as_echo "$as_me:$LINENO: checking minix/config.h usability" >&5
-$as_echo_n "checking minix/config.h usability... " >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-#include <minix/config.h>
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_header_compiler=yes
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_header_compiler=no
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-{ $as_echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
-$as_echo "$ac_header_compiler" >&6; }
-
-# Is the header present?
-{ $as_echo "$as_me:$LINENO: checking minix/config.h presence" >&5
-$as_echo_n "checking minix/config.h presence... " >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <minix/config.h>
-_ACEOF
-if { (ac_try="$ac_cpp conftest.$ac_ext"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } >/dev/null && {
-	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       }; then
-  ac_header_preproc=yes
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-  ac_header_preproc=no
-fi
-
-rm -f conftest.err conftest.$ac_ext
-{ $as_echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
-$as_echo "$ac_header_preproc" >&6; }
-
-# So?  What about this header?
-case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
-  yes:no: )
-    { $as_echo "$as_me:$LINENO: WARNING: minix/config.h: accepted by the compiler, rejected by the preprocessor!" >&5
-$as_echo "$as_me: WARNING: minix/config.h: accepted by the compiler, rejected by the preprocessor!" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: minix/config.h: proceeding with the compiler's result" >&5
-$as_echo "$as_me: WARNING: minix/config.h: proceeding with the compiler's result" >&2;}
-    ac_header_preproc=yes
-    ;;
-  no:yes:* )
-    { $as_echo "$as_me:$LINENO: WARNING: minix/config.h: present but cannot be compiled" >&5
-$as_echo "$as_me: WARNING: minix/config.h: present but cannot be compiled" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: minix/config.h:     check for missing prerequisite headers?" >&5
-$as_echo "$as_me: WARNING: minix/config.h:     check for missing prerequisite headers?" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: minix/config.h: see the Autoconf documentation" >&5
-$as_echo "$as_me: WARNING: minix/config.h: see the Autoconf documentation" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: minix/config.h:     section \"Present But Cannot Be Compiled\"" >&5
-$as_echo "$as_me: WARNING: minix/config.h:     section \"Present But Cannot Be Compiled\"" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: minix/config.h: proceeding with the preprocessor's result" >&5
-$as_echo "$as_me: WARNING: minix/config.h: proceeding with the preprocessor's result" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: minix/config.h: in the future, the compiler will take precedence" >&5
-$as_echo "$as_me: WARNING: minix/config.h: in the future, the compiler will take precedence" >&2;}
-
-    ;;
-esac
-{ $as_echo "$as_me:$LINENO: checking for minix/config.h" >&5
-$as_echo_n "checking for minix/config.h... " >&6; }
-if test "${ac_cv_header_minix_config_h+set}" = set; then
-  $as_echo_n "(cached) " >&6
-else
-  ac_cv_header_minix_config_h=$ac_header_preproc
-fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_header_minix_config_h" >&5
-$as_echo "$ac_cv_header_minix_config_h" >&6; }
-
-fi
-if test "x$ac_cv_header_minix_config_h" = x""yes; then
-  MINIX=yes
-else
-  MINIX=
-fi
-
-
-  if test "$MINIX" = yes; then
-
-cat >>confdefs.h <<\_ACEOF
-#define _POSIX_SOURCE 1
-_ACEOF
-
-
-cat >>confdefs.h <<\_ACEOF
-#define _POSIX_1_SOURCE 2
-_ACEOF
-
-
-cat >>confdefs.h <<\_ACEOF
-#define _MINIX 1
-_ACEOF
-
-  fi
-
-
-
-  { $as_echo "$as_me:$LINENO: checking whether it is safe to define __EXTENSIONS__" >&5
-$as_echo_n "checking whether it is safe to define __EXTENSIONS__... " >&6; }
-if test "${ac_cv_safe_to_define___extensions__+set}" = set; then
-  $as_echo_n "(cached) " >&6
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-
-#	  define __EXTENSIONS__ 1
-	  $ac_includes_default
-int
-main ()
-{
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_cv_safe_to_define___extensions__=yes
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_cv_safe_to_define___extensions__=no
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_safe_to_define___extensions__" >&5
-$as_echo "$ac_cv_safe_to_define___extensions__" >&6; }
-  test $ac_cv_safe_to_define___extensions__ = yes &&
-    cat >>confdefs.h <<\_ACEOF
-#define __EXTENSIONS__ 1
-_ACEOF
-
-  cat >>confdefs.h <<\_ACEOF
-#define _ALL_SOURCE 1
-_ACEOF
-
-  cat >>confdefs.h <<\_ACEOF
-#define _GNU_SOURCE 1
-_ACEOF
-
-  cat >>confdefs.h <<\_ACEOF
-#define _POSIX_PTHREAD_SEMANTICS 1
-_ACEOF
-
-  cat >>confdefs.h <<\_ACEOF
-#define _TANDEM_SOURCE 1
-_ACEOF
-
-
-
-MAKECC=`gnustep-config --variable=CC`
-if test "$CC" != "$MAKECC"; then
-  { { $as_echo "$as_me:$LINENO: error: You are running configure with the compiler ($CC) set to a different value from that used by gnustep-make ($MAKECC).  Please run configure again with your environment set to match your gnustep-make" >&5
-$as_echo "$as_me: error: You are running configure with the compiler ($CC) set to a different value from that used by gnustep-make ($MAKECC).  Please run configure again with your environment set to match your gnustep-make" >&2;}
-   { (exit 1); exit 1; }; }
-  exit 1
-fi
-
-#--------------------------------------------------------------------
-# Check wether the compiler supports UTF-8 constant strings
-#--------------------------------------------------------------------
-
-GS_EXEC_CHARSET=
-GS_INPUT_CHARSET=
-# Check whether --enable-unicodeconstants was given.
-if test "${enable_unicodeconstants+set}" = set; then
-  enableval=$enable_unicodeconstants;
-fi
-
-if test "$enable_unicodeconstants" != "no"; then
-  ac_ext=c
-ac_cpp='$CPP $CPPFLAGS'
-ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_c_compiler_gnu
-
-  { $as_echo "$as_me:$LINENO: checking whether compiler supports UTF-8 constants in executable" >&5
-$as_echo_n "checking whether compiler supports UTF-8 constants in executable... " >&6; }
-  saved_CFLAGS="$CFLAGS"
-  saved_LANG="$LANG"
-  saved_LC_ALL="$LC_ALL"
-  export LANG="en_US.ISO-8859-1"
-  export LC_ALL="en_US.ISO-8859-1"
-  # We are working in a latin1 locale so we can build a program containing
-  # a latin1 pound character, and see if the executable has a utf-8 literal.
-  if test "$cross_compiling" = yes; then
-  utf8literal_ok="$cross_utf8literal_ok"
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include "$srcdir/config/config.constant-string-encoding.c"
-_ACEOF
-rm -f conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  utf8literal_ok=yes
-else
-  $as_echo "$as_me: program exited with status $ac_status" >&5
-$as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-( exit $ac_status )
-utf8literal_ok=no
-fi
-rm -rf conftest.dSYM
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
-fi
-
-
-  if test "$utf8literal_ok" = "yes"; then
-    { $as_echo "$as_me:$LINENO: result: yes" >&5
-$as_echo "yes" >&6; };
-  else
-    # The compiler did not produce a utf-8 literal ... see if it does so when
-    # given the appropriate flags to tell it what charactersets to use.
-    CFLAGS="$CFLAGS -finput-charset=ISO-8859-1 -fexec-charset=UTF-8"
-    if test "$cross_compiling" = yes; then
-  utf8literal_ok="$cross_utf8literal_ok"
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include "$srcdir/config/config.constant-string-encoding.c"
-_ACEOF
-rm -f conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  utf8literal_ok=yes
-else
-  $as_echo "$as_me: program exited with status $ac_status" >&5
-$as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-( exit $ac_status )
-utf8literal_ok=no
-fi
-rm -rf conftest.dSYM
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
-fi
-
-
-    if test "$utf8literal_ok" = "yes"; then
-      { $as_echo "$as_me:$LINENO: result: yes" >&5
-$as_echo "yes" >&6; };
-      GS_EXEC_CHARSET=-fexec-charset=UTF-8
-      GS_INPUT_CHARSET=-finput-charset=UTF-8
-    else
-      { $as_echo "$as_me:$LINENO: result: no" >&5
-$as_echo "no" >&6; };
-      { $as_echo "$as_me:$LINENO: WARNING: Your compiler does not appear to support locales or command line options to control handling of charactersets, so we cannot be sure that the compiled code will contain the UTF-8 string literals expected by gnustep-base.  This means that using any source code code containing non US-ASCII text in string literals may give unexpected results (or crashes) at runtime.  However, as long as any such literals only use the UTF-8 characterset, this is unlikely to be a problem (since old/faulty compilers are likely to pass the UTF-8 literals through to the compiled code). Please configure using --disable-unicodeconstants to avoid seeing this warning." >&5
-$as_echo "$as_me: WARNING: Your compiler does not appear to support locales or command line options to control handling of charactersets, so we cannot be sure that the compiled code will contain the UTF-8 string literals expected by gnustep-base.  This means that using any source code code containing non US-ASCII text in string literals may give unexpected results (or crashes) at runtime.  However, as long as any such literals only use the UTF-8 characterset, this is unlikely to be a problem (since old/faulty compilers are likely to pass the UTF-8 literals through to the compiled code). Please configure using --disable-unicodeconstants to avoid seeing this warning." >&2;}
-    fi
-  fi
-  export LANG="$saved_LANG"
-  export LC_ALL="$saved_LC_ALL"
-  CFLAGS="$saved_CFLAGS"
-  ac_ext=c
-ac_cpp='$CPP $CPPFLAGS'
-ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_c_compiler_gnu
-
-fi
-
-
-
-#--------------------------------------------------------------------
-# Check how to enable builtins for atomic operations
-#--------------------------------------------------------------------
-
-ac_ext=c
-ac_cpp='$CPP $CPPFLAGS'
-ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_c_compiler_gnu
-
-{ $as_echo "$as_me:$LINENO: checking whether the compiler supports atomic operations" >&5
-$as_echo_n "checking whether the compiler supports atomic operations... " >&6; };
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-typedef int atomic;
-int
-main ()
-{
-atomic x; atomic y; __sync_bool_compare_and_swap(&x, y, y + 1);
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then
-  have_atomic=yes
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	have_atomic=no
-fi
-
-rm -rf conftest.dSYM
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext;
-  if test "$have_atomic" = "yes"; then
-    { $as_echo "$as_me:$LINENO: result: yes" >&5
-$as_echo "yes" >&6; };
-
-cat >>confdefs.h <<\_ACEOF
-#define USE_ATOMIC_BUILTINS 1
-_ACEOF
-
-  else
-    { $as_echo "$as_me:$LINENO: result: no" >&5
-$as_echo "no" >&6; };
-    if test "$CC" = "gcc"; then
-      saved_CFLAGS="$CFLAGS";
-      ATOMIC_CFLAGS="";
-
-      # FIXME: Forcing -march=i568 for any i568 or later CPU is a
-      # stop gap measure to make the compiler emit native assembly
-      # for atomic operations on i586 or latter processors (GCC by
-      # default emits code compatible with the original i386 and
-      # requires library functions to emulate atomic operations).
-      # When gnustep-make takes care of this kind of target setting,
-      # the check can safely be removed.
-      case "$target_cpu" in
-        i586*|i686*|i786*)
-          ATOMIC_CFLAGS="-march=i586"
-          CFLAGS="$saved_CFLAGS $ATOMIC_CFLAGS"
-          ;;
-        x86_64)
-          ATOMIC_CFLAGS="-march=x86-64"
-          CFLAGS="$saved_CFLAGS $ATOMIC_CFLAGS"
-          ;;
-      esac
-      { $as_echo "$as_me:$LINENO: checking whether gcc supports atomic operations with -march" >&5
-$as_echo_n "checking whether gcc supports atomic operations with -march... " >&6; };
-        cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-typedef int atomic;
-int
-main ()
-{
-atomic x; atomic y; __sync_bool_compare_and_swap(&x, y, y+1);
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then
-  need_march=yes
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	need_march=no
-fi
-
-rm -rf conftest.dSYM
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext;
-
-      if test "$need_march" = "yes"; then
-        { $as_echo "$as_me:$LINENO: result: yes" >&5
-$as_echo "yes" >&6; };
-	OBJCFLAGS="$OBJCFLAGS $ATOMIC_CFLAGS";
-
-cat >>confdefs.h <<\_ACEOF
-#define USE_ATOMIC_BUILTINS 1
-_ACEOF
-
-      else
-        { $as_echo "$as_me:$LINENO: result: no" >&5
-$as_echo "no" >&6; };
-        saved_LDFLAGS="$LDFLAGS";
-        LDFLAGS="$saved_LDFLAGS -lgcc";
-        { $as_echo "$as_me:$LINENO: checking whether gcc supports atomic operations using libgcc" >&5
-$as_echo_n "checking whether gcc supports atomic operations using libgcc... " >&6; };
-          cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-typedef int atomic;
-int
-main ()
-{
-atomic x; atomic y; __sync_bool_compare_and_swap(&x, y, y+1);
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then
-  atomic_in_libgcc=yes
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	atomic_in_libgcc=no
-fi
-
-rm -rf conftest.dSYM
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext;
-        if test "$atomic_in_libgcc" = "yes"; then
-          { $as_echo "$as_me:$LINENO: result: yes" >&5
-$as_echo "yes" >&6; };
-          LIBS="$LIBS -lgcc";
-
-cat >>confdefs.h <<\_ACEOF
-#define USE_ATOMIC_BUILTINS 1
-_ACEOF
-
-        else
-          LDFLAGS="$saved_LDFLAGS";
-          { $as_echo "$as_me:$LINENO: result: no" >&5
-$as_echo "no" >&6; };
-        fi
-      fi
-    fi
-  fi
-ac_ext=c
-ac_cpp='$CPP $CPPFLAGS'
-ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_c_compiler_gnu
-
-
-
-# Extract the first word of "whoami", so it can be a program name with args.
-set dummy whoami; ac_word=$2
-{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_path_WHOAMI+set}" = set; then
-  $as_echo_n "(cached) " >&6
-else
-  case $WHOAMI in
-  [\\/]* | ?:[\\/]*)
-  ac_cv_path_WHOAMI="$WHOAMI" # Let the user override the test with a path.
-  ;;
-  *)
-  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-as_dummy="$PATH:/usr/ucb"
-for as_dir in $as_dummy
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-  for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_path_WHOAMI="$as_dir/$ac_word$ac_exec_ext"
-    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-done
-IFS=$as_save_IFS
-
-  test -z "$ac_cv_path_WHOAMI" && ac_cv_path_WHOAMI="echo"
-  ;;
-esac
-fi
-WHOAMI=$ac_cv_path_WHOAMI
-if test -n "$WHOAMI"; then
-  { $as_echo "$as_me:$LINENO: result: $WHOAMI" >&5
-$as_echo "$WHOAMI" >&6; }
-else
-  { $as_echo "$as_me:$LINENO: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-# Extract the first word of "pkg-config", so it can be a program name with args.
-set dummy pkg-config; ac_word=$2
-{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_path_PKGCONFIG+set}" = set; then
-  $as_echo_n "(cached) " >&6
-else
-  case $PKGCONFIG in
-  [\\/]* | ?:[\\/]*)
-  ac_cv_path_PKGCONFIG="$PKGCONFIG" # Let the user override the test with a path.
-  ;;
-  *)
-  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in no
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-  for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_path_PKGCONFIG="$as_dir/$ac_word$ac_exec_ext"
-    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-done
-IFS=$as_save_IFS
-
-  test -z "$ac_cv_path_PKGCONFIG" && ac_cv_path_PKGCONFIG="yes"
-  ;;
-esac
-fi
-PKGCONFIG=$ac_cv_path_PKGCONFIG
-if test -n "$PKGCONFIG"; then
-  { $as_echo "$as_me:$LINENO: result: $PKGCONFIG" >&5
-$as_echo "$PKGCONFIG" >&6; }
-else
-  { $as_echo "$as_me:$LINENO: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-
-#--------------------------------------------------------------------
-# specific target_os options
-#--------------------------------------------------------------------
-INCLUDE_FLAGS="$CPPFLAGS"
-LDIR_FLAGS="$LDFLAGS"
-# This is just for configuring. Later, in config.make, INCLUDE_FLAGS
-# goes in CONFIG_SYSTEM_INCL and LIBS goes in CONFIG_SYSTEM_LIBS
-case "$target_os" in
-  freebsd* | openbsd* )
-	        CPPFLAGS="$CPPFLAGS -I/usr/local/include"
-		LDFLAGS="$LDFLAGS -L/usr/local/lib";;
-  netbsd*)	CPPFLAGS="$CPPFLAGS -I/usr/pkg/include"
-		LDFLAGS="$LDFLAGS -Wl,-R/usr/pkg/lib -L/usr/pkg/lib";;
-esac
-
-#--------------------------------------------------------------------
-# Set Apple/Darwin/OSX/NeXT information for other tests
-#--------------------------------------------------------------------
-OBJC_WITH_GC=no
-OBJC_RUNTIME_LIB=`echo $LIBRARY_COMBO | tr '-' ' ' | awk '{print $1}'`
-{ $as_echo "$as_me:$LINENO: checking the Objective-C runtime" >&5
-$as_echo_n "checking the Objective-C runtime... " >&6; }
-if test "$OBJC_RUNTIME_LIB" = "nx" -o "$OBJC_RUNTIME_LIB" = "apple"; then
-  { $as_echo "$as_me:$LINENO: result: NeXT" >&5
-$as_echo "NeXT" >&6; }
-  OBJCFLAGS="$OBJCFLAGS -fnext-runtime -DNeXT_RUNTIME"
-elif test "$OBJC_RUNTIME_LIB" = "gnugc"; then
-  { $as_echo "$as_me:$LINENO: result: GNU" >&5
-$as_echo "GNU" >&6; }
-  OBJCFLAGS="$OBJCFLAGS -fgnu-runtime"
-  OBJC_WITH_GC=yes
-else
-  { $as_echo "$as_me:$LINENO: result: GNU" >&5
-$as_echo "GNU" >&6; }
-  OBJCFLAGS="$OBJCFLAGS -fgnu-runtime"
-fi
-LIBOBJC=`gnustep-config --objc-libs`
-if test "$LIBOBJC" = ""; then
-  { { $as_echo "$as_me:$LINENO: error: The command 'gnustep-config --objc-libs' (provided by the gnustep-make package) returned no Objective-C library.  Unable to continue configuring without Objective-C support." >&5
-$as_echo "$as_me: error: The command 'gnustep-config --objc-libs' (provided by the gnustep-make package) returned no Objective-C library.  Unable to continue configuring without Objective-C support." >&2;}
-   { (exit 1); exit 1; }; }
-  exit 1
-fi
-
-#--------------------------------------------------------------------
-# Miscellaneous flags
-#--------------------------------------------------------------------
-
-# Check to see if the libobjc library is in our GNUSTEP_SYSTEM_LIBRARIES.
-# If so, there are probably other libraries that we want there also, so
-# leave the proper includes in CPPFLAGS and LDFLAGS
-{ $as_echo "$as_me:$LINENO: checking for custom shared objc library" >&5
-$as_echo_n "checking for custom shared objc library... " >&6; }
-if test "${gs_cv_objc_libdir+set}" = set; then
-  $as_echo_n "(cached) " >&6
-else
-  gs_cv_objc_libdir=NONE
-gs_cv_objc_incdir=NONE
-# Try GNUSTEP_SYSTEM_LIBRARIES first
-if test "$GNUSTEP_IS_FLATTENED" = yes; then
-  GNUSTEP_LDIR="$GNUSTEP_SYSTEM_LIBRARIES"
-  GNUSTEP_HDIR="$GNUSTEP_SYSTEM_HEADERS"
-else
-  GNUSTEP_LDIR="$GNUSTEP_SYSTEM_LIBRARIES/$obj_dir"
-  GNUSTEP_HDIR="$GNUSTEP_SYSTEM_HEADERS/$LIBRARY_COMBO"
-fi
-
-if test -f "$GNUSTEP_HDIR/objc/objc.h"; then
-  if test -f "$GNUSTEP_LDIR/libobjc.a" -o -f "$GNUSTEP_LDIR/libobjc.so" -o -f "$GNUSTEP_LDIR/libobjc.dll.a" -o -f "$GNUSTEP_LDIR/libobjc-gnu.dylib" -o -f "$GNUSTEP_LDIR/libobjc_gc.a" -o -f "$GNUSTEP_LDIR/libobjc_gc.so" -o -f "$GNUSTEP_LDIR/libobjc_gc.dll.a" -o -f "$GNUSTEP_LDIR/libobjc_gc-gnu.dylib"; then
-    gs_cv_objc_libdir="$GNUSTEP_LDIR"
-    gs_cv_objc_incdir="$GNUSTEP_HDIR"
-  fi
-fi
-
-# Try GNUSTEP_NETWORK_LIBRARIES second (override GNUSTEP_SYSTEM if
-# found)
-if test "$GNUSTEP_IS_FLATTENED" = yes; then
-  GNUSTEP_LDIR="$GNUSTEP_NETWORK_LIBRARIES"
-  GNUSTEP_HDIR="$GNUSTEP_NETWORK_HEADERS"
-else
-  GNUSTEP_LDIR="$GNUSTEP_NETWORK_LIBRARIES/$obj_dir"
-  GNUSTEP_HDIR="$GNUSTEP_NETWORK_HEADERS/$LIBRARY_COMBO"
-fi
-
-if test -f "$GNUSTEP_HDIR/objc/objc.h"; then
-  if test -f "$GNUSTEP_LDIR/libobjc.a" -o -f "$GNUSTEP_LDIR/libobjc.so" -o -f "$GNUSTEP_LDIR/libobjc.dll.a" -o -f "$GNUSTEP_LDIR/libobjc-gnu.dylib" -o -f "$GNUSTEP_LDIR/libobjc_gc.a" -o -f "$GNUSTEP_LDIR/libobjc_gc.so" -o -f "$GNUSTEP_LDIR/libobjc_gc.dll.a" -o -f "$GNUSTEP_LDIR/libobjc_gc-gnu.dylib"; then
-    gs_cv_objc_libdir="$GNUSTEP_LDIR"
-    gs_cv_objc_incdir="$GNUSTEP_HDIR"
-  fi
-fi
-
-# Try GNUSTEP_LOCAL_LIBRARIES third (override GNUSTEP_SYSTEM and
-# GNUSTEP_NETWORK if found)
-if test "$GNUSTEP_IS_FLATTENED" = yes; then
-  GNUSTEP_LDIR="$GNUSTEP_LOCAL_LIBRARIES"
-  GNUSTEP_HDIR="$GNUSTEP_LOCAL_HEADERS"
-else
-  GNUSTEP_LDIR="$GNUSTEP_LOCAL_LIBRARIES/$obj_dir"
-  GNUSTEP_HDIR="$GNUSTEP_LOCAL_HEADERS/$LIBRARY_COMBO"
-fi
-
-if test -f "$GNUSTEP_HDIR/objc/objc.h"; then
-  if test -f "$GNUSTEP_LDIR/libobjc.a" -o -f "$GNUSTEP_LDIR/libobjc.so" -o -f "$GNUSTEP_LDIR/libobjc.dll.a" -o -f "$GNUSTEP_LDIR/libobjc-gnu.dylib" -o -f "$GNUSTEP_LDIR/libobjc_gc.a" -o -f "$GNUSTEP_LDIR/libobjc_gc.so" -o -f "$GNUSTEP_LDIR/libobjc_gc.dll.a" -o -f "$GNUSTEP_LDIR/libobjc_gc-gnu.dylib"; then
-    gs_cv_objc_libdir="$GNUSTEP_LDIR"
-    gs_cv_objc_incdir="$GNUSTEP_HDIR"
-  fi
-fi
-
-fi
-
-{ $as_echo "$as_me:$LINENO: result: $gs_cv_objc_libdir" >&5
-$as_echo "$gs_cv_objc_libdir" >&6; }
-
-if test "$gs_cv_objc_libdir" != "NONE"; then
-  #
-  # The following one is so that headers of custom libraries into
-  # $GNUSTEP_HDIR are used before the standard ones
-  #
-  INCLUDE_FLAGS="$INCLUDE_FLAGS -I$gs_cv_objc_incdir"
-  LDIR_FLAGS="$LDIR_FLAGS -L$gs_cv_objc_libdir/$LIBRARY_COMBO -L$gs_cv_objc_libdir"
-  CPPFLAGS="$CPPFLAGS -I$gs_cv_objc_incdir"
-  LDFLAGS="$LDFLAGS -L$gs_cv_objc_libdir"
-fi
-
-#--------------------------------------------------------------------
-# Check if Objective-C is installed
-#--------------------------------------------------------------------
-
-for ac_header in objc/runtime.h
-do
-as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  { $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
-$as_echo_n "checking for $ac_header... " >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  $as_echo_n "(cached) " >&6
-fi
-ac_res=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-else
-  # Is the header compilable?
-{ $as_echo "$as_me:$LINENO: checking $ac_header usability" >&5
-$as_echo_n "checking $ac_header usability... " >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-#include <$ac_header>
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_header_compiler=yes
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_header_compiler=no
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-{ $as_echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
-$as_echo "$ac_header_compiler" >&6; }
-
-# Is the header present?
-{ $as_echo "$as_me:$LINENO: checking $ac_header presence" >&5
-$as_echo_n "checking $ac_header presence... " >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <$ac_header>
-_ACEOF
-if { (ac_try="$ac_cpp conftest.$ac_ext"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } >/dev/null && {
-	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       }; then
-  ac_header_preproc=yes
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-  ac_header_preproc=no
-fi
-
-rm -f conftest.err conftest.$ac_ext
-{ $as_echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
-$as_echo "$ac_header_preproc" >&6; }
-
-# So?  What about this header?
-case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
-  yes:no: )
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
-$as_echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the compiler's result" >&5
-$as_echo "$as_me: WARNING: $ac_header: proceeding with the compiler's result" >&2;}
-    ac_header_preproc=yes
-    ;;
-  no:yes:* )
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
-$as_echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header:     check for missing prerequisite headers?" >&5
-$as_echo "$as_me: WARNING: $ac_header:     check for missing prerequisite headers?" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: see the Autoconf documentation" >&5
-$as_echo "$as_me: WARNING: $ac_header: see the Autoconf documentation" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&5
-$as_echo "$as_me: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
-$as_echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: in the future, the compiler will take precedence" >&5
-$as_echo "$as_me: WARNING: $ac_header: in the future, the compiler will take precedence" >&2;}
-
-    ;;
-esac
-{ $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
-$as_echo_n "checking for $ac_header... " >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  $as_echo_n "(cached) " >&6
-else
-  eval "$as_ac_Header=\$ac_header_preproc"
-fi
-ac_res=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-
-fi
-as_val=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-   if test "x$as_val" = x""yes; then
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
-_ACEOF
-
-fi
-
-done
-
-
-for ac_header in objc/objc.h
-do
-as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  { $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
-$as_echo_n "checking for $ac_header... " >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  $as_echo_n "(cached) " >&6
-fi
-ac_res=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-else
-  # Is the header compilable?
-{ $as_echo "$as_me:$LINENO: checking $ac_header usability" >&5
-$as_echo_n "checking $ac_header usability... " >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-#include <$ac_header>
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_header_compiler=yes
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_header_compiler=no
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-{ $as_echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
-$as_echo "$ac_header_compiler" >&6; }
-
-# Is the header present?
-{ $as_echo "$as_me:$LINENO: checking $ac_header presence" >&5
-$as_echo_n "checking $ac_header presence... " >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <$ac_header>
-_ACEOF
-if { (ac_try="$ac_cpp conftest.$ac_ext"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } >/dev/null && {
-	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       }; then
-  ac_header_preproc=yes
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-  ac_header_preproc=no
-fi
-
-rm -f conftest.err conftest.$ac_ext
-{ $as_echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
-$as_echo "$ac_header_preproc" >&6; }
-
-# So?  What about this header?
-case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
-  yes:no: )
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
-$as_echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the compiler's result" >&5
-$as_echo "$as_me: WARNING: $ac_header: proceeding with the compiler's result" >&2;}
-    ac_header_preproc=yes
-    ;;
-  no:yes:* )
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
-$as_echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header:     check for missing prerequisite headers?" >&5
-$as_echo "$as_me: WARNING: $ac_header:     check for missing prerequisite headers?" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: see the Autoconf documentation" >&5
-$as_echo "$as_me: WARNING: $ac_header: see the Autoconf documentation" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&5
-$as_echo "$as_me: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
-$as_echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: in the future, the compiler will take precedence" >&5
-$as_echo "$as_me: WARNING: $ac_header: in the future, the compiler will take precedence" >&2;}
-
-    ;;
-esac
-{ $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
-$as_echo_n "checking for $ac_header... " >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  $as_echo_n "(cached) " >&6
-else
-  eval "$as_ac_Header=\$ac_header_preproc"
-fi
-ac_res=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-
-fi
-as_val=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-   if test "x$as_val" = x""yes; then
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
-_ACEOF
-
-fi
-
-done
-
-if test $ac_cv_header_objc_objc_h = no; then
-  echo "Check to make sure you have a full installation of the GCC"
-  echo "compiler that includes the Objective-C headers and libraries"
-  { { $as_echo "$as_me:$LINENO: error: Could not find Objective-C headers" >&5
-$as_echo "$as_me: error: Could not find Objective-C headers" >&2;}
-   { (exit 1); exit 1; }; }
-fi
-
-if test $OBJC_WITH_GC = yes; then
-
-for ac_header in gc/gc.h
-do
-as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  { $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
-$as_echo_n "checking for $ac_header... " >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  $as_echo_n "(cached) " >&6
-fi
-ac_res=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-else
-  # Is the header compilable?
-{ $as_echo "$as_me:$LINENO: checking $ac_header usability" >&5
-$as_echo_n "checking $ac_header usability... " >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-#include <$ac_header>
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_header_compiler=yes
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_header_compiler=no
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-{ $as_echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
-$as_echo "$ac_header_compiler" >&6; }
-
-# Is the header present?
-{ $as_echo "$as_me:$LINENO: checking $ac_header presence" >&5
-$as_echo_n "checking $ac_header presence... " >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <$ac_header>
-_ACEOF
-if { (ac_try="$ac_cpp conftest.$ac_ext"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } >/dev/null && {
-	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       }; then
-  ac_header_preproc=yes
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-  ac_header_preproc=no
-fi
-
-rm -f conftest.err conftest.$ac_ext
-{ $as_echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
-$as_echo "$ac_header_preproc" >&6; }
-
-# So?  What about this header?
-case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
-  yes:no: )
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
-$as_echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the compiler's result" >&5
-$as_echo "$as_me: WARNING: $ac_header: proceeding with the compiler's result" >&2;}
-    ac_header_preproc=yes
-    ;;
-  no:yes:* )
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
-$as_echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header:     check for missing prerequisite headers?" >&5
-$as_echo "$as_me: WARNING: $ac_header:     check for missing prerequisite headers?" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: see the Autoconf documentation" >&5
-$as_echo "$as_me: WARNING: $ac_header: see the Autoconf documentation" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&5
-$as_echo "$as_me: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
-$as_echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: in the future, the compiler will take precedence" >&5
-$as_echo "$as_me: WARNING: $ac_header: in the future, the compiler will take precedence" >&2;}
-
-    ;;
-esac
-{ $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
-$as_echo_n "checking for $ac_header... " >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  $as_echo_n "(cached) " >&6
-else
-  eval "$as_ac_Header=\$ac_header_preproc"
-fi
-ac_res=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-
-fi
-as_val=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-   if test "x$as_val" = x""yes; then
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
-_ACEOF
- gc_ok=yes
-else
-  gc_ok=no
-fi
-
-done
-
-  if test "$gc_ok" = no; then
-    { { $as_echo "$as_me:$LINENO: error: Garbage collection was required, but the gc/gc.h header couldn't be found." >&5
-$as_echo "$as_me: error: Garbage collection was required, but the gc/gc.h header couldn't be found." >&2;}
-   { (exit 1); exit 1; }; }
-  fi
-  saved_LIBS="$LIBS"
-  LIBS+=" -lgc"
-  { $as_echo "$as_me:$LINENO: checking for GC_malloc" >&5
-$as_echo_n "checking for GC_malloc... " >&6; }
-if test "${ac_cv_func_GC_malloc+set}" = set; then
-  $as_echo_n "(cached) " >&6
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-/* Define GC_malloc to an innocuous variant, in case <limits.h> declares GC_malloc.
-   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
-#define GC_malloc innocuous_GC_malloc
-
-/* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char GC_malloc (); below.
-    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-    <limits.h> exists even on freestanding compilers.  */
-
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
-
-#undef GC_malloc
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char GC_malloc ();
-/* The GNU C library defines this for functions which it implements
-    to always fail with ENOSYS.  Some functions are actually named
-    something starting with __ and the normal name is an alias.  */
-#if defined __stub_GC_malloc || defined __stub___GC_malloc
-choke me
-#endif
-
-int
-main ()
-{
-return GC_malloc ();
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then
-  ac_cv_func_GC_malloc=yes
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_cv_func_GC_malloc=no
-fi
-
-rm -rf conftest.dSYM
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
-fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_func_GC_malloc" >&5
-$as_echo "$ac_cv_func_GC_malloc" >&6; }
-if test "x$ac_cv_func_GC_malloc" = x""yes; then
-  gc_ok=yes
-else
-  gc_ok=no
-fi
-
-  if test "$gc_ok" = no; then
-    { { $as_echo "$as_me:$LINENO: error: Garbage collection was required, but the gc library couldn't be found." >&5
-$as_echo "$as_me: error: Garbage collection was required, but the gc library couldn't be found." >&2;}
-   { (exit 1); exit 1; }; }
-  fi
-  { $as_echo "$as_me:$LINENO: checking for GC_register_my_thread" >&5
-$as_echo_n "checking for GC_register_my_thread... " >&6; }
-if test "${ac_cv_func_GC_register_my_thread+set}" = set; then
-  $as_echo_n "(cached) " >&6
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-/* Define GC_register_my_thread to an innocuous variant, in case <limits.h> declares GC_register_my_thread.
-   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
-#define GC_register_my_thread innocuous_GC_register_my_thread
-
-/* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char GC_register_my_thread (); below.
-    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-    <limits.h> exists even on freestanding compilers.  */
-
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
-
-#undef GC_register_my_thread
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char GC_register_my_thread ();
-/* The GNU C library defines this for functions which it implements
-    to always fail with ENOSYS.  Some functions are actually named
-    something starting with __ and the normal name is an alias.  */
-#if defined __stub_GC_register_my_thread || defined __stub___GC_register_my_thread
-choke me
-#endif
-
-int
-main ()
-{
-return GC_register_my_thread ();
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then
-  ac_cv_func_GC_register_my_thread=yes
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_cv_func_GC_register_my_thread=no
-fi
-
-rm -rf conftest.dSYM
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
-fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_func_GC_register_my_thread" >&5
-$as_echo "$ac_cv_func_GC_register_my_thread" >&6; }
-
-  if test "$ac_cv_func_GC_register_my_thread" = yes; then
-
-cat >>confdefs.h <<\_ACEOF
-#define HAVE_GC_REGISTER_MY_THREAD 1
-_ACEOF
-
-  fi
-  { $as_echo "$as_me:$LINENO: checking for GC_allow_register_threads" >&5
-$as_echo_n "checking for GC_allow_register_threads... " >&6; }
-if test "${ac_cv_func_GC_allow_register_threads+set}" = set; then
-  $as_echo_n "(cached) " >&6
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-/* Define GC_allow_register_threads to an innocuous variant, in case <limits.h> declares GC_allow_register_threads.
-   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
-#define GC_allow_register_threads innocuous_GC_allow_register_threads
-
-/* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char GC_allow_register_threads (); below.
-    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-    <limits.h> exists even on freestanding compilers.  */
-
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
-
-#undef GC_allow_register_threads
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char GC_allow_register_threads ();
-/* The GNU C library defines this for functions which it implements
-    to always fail with ENOSYS.  Some functions are actually named
-    something starting with __ and the normal name is an alias.  */
-#if defined __stub_GC_allow_register_threads || defined __stub___GC_allow_register_threads
-choke me
-#endif
-
-int
-main ()
-{
-return GC_allow_register_threads ();
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then
-  ac_cv_func_GC_allow_register_threads=yes
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_cv_func_GC_allow_register_threads=no
-fi
-
-rm -rf conftest.dSYM
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
-fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_func_GC_allow_register_threads" >&5
-$as_echo "$ac_cv_func_GC_allow_register_threads" >&6; }
-
-  if test "$ac_cv_func_GC_allow_register_threads" = yes; then
-
-cat >>confdefs.h <<\_ACEOF
-#define HAVE_GC_ALLOW_REGISTER_THREADS 1
-_ACEOF
-
-  fi
-  LIBS="-lobjc_gc -ldl"
-  { $as_echo "$as_me:$LINENO: checking for class_ivar_set_gcinvisible" >&5
-$as_echo_n "checking for class_ivar_set_gcinvisible... " >&6; }
-if test "${ac_cv_func_class_ivar_set_gcinvisible+set}" = set; then
-  $as_echo_n "(cached) " >&6
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-/* Define class_ivar_set_gcinvisible to an innocuous variant, in case <limits.h> declares class_ivar_set_gcinvisible.
-   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
-#define class_ivar_set_gcinvisible innocuous_class_ivar_set_gcinvisible
-
-/* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char class_ivar_set_gcinvisible (); below.
-    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-    <limits.h> exists even on freestanding compilers.  */
-
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
-
-#undef class_ivar_set_gcinvisible
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char class_ivar_set_gcinvisible ();
-/* The GNU C library defines this for functions which it implements
-    to always fail with ENOSYS.  Some functions are actually named
-    something starting with __ and the normal name is an alias.  */
-#if defined __stub_class_ivar_set_gcinvisible || defined __stub___class_ivar_set_gcinvisible
-choke me
-#endif
-
-int
-main ()
-{
-return class_ivar_set_gcinvisible ();
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then
-  ac_cv_func_class_ivar_set_gcinvisible=yes
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_cv_func_class_ivar_set_gcinvisible=no
-fi
-
-rm -rf conftest.dSYM
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
-fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_func_class_ivar_set_gcinvisible" >&5
-$as_echo "$ac_cv_func_class_ivar_set_gcinvisible" >&6; }
-if test "x$ac_cv_func_class_ivar_set_gcinvisible" = x""yes; then
-  gc_ok=yes
-else
-  gc_ok=no
-fi
-
-  if test "$gc_ok" = no; then
-    { { $as_echo "$as_me:$LINENO: error: Garbage collection was required, but the gc runtime couldn't be found." >&5
-$as_echo "$as_me: error: Garbage collection was required, but the gc runtime couldn't be found." >&2;}
-   { (exit 1); exit 1; }; }
-  fi
-  LIBS="$saved_LIBS"
-
-fi
-
-#--------------------------------------------------------------------
-# Check for strange network stuff used by gdomap
-#--------------------------------------------------------------------
-{ $as_echo "$as_me:$LINENO: for gdomap network details" >&5
-$as_echo "$as_me: for gdomap network details" >&6;}
-{ $as_echo "$as_me:$LINENO: checking for variable length socket addresses" >&5
-$as_echo_n "checking for variable length socket addresses... " >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-
-  #include <sys/types.h>
-  #include <sys/socket.h>
-  #include <net/if.h>
-
-int
-main ()
-{
-struct ifreq s; s.ifr_addr.sa_len = 0;
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  sa_len=1
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	sa_len=0
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-if test $sa_len = 1; then
-  { $as_echo "$as_me:$LINENO: result: found" >&5
-$as_echo "found" >&6; }
-
-cat >>confdefs.h <<\_ACEOF
-#define HAVE_SA_LEN 1
-_ACEOF
-
-else
-  { $as_echo "$as_me:$LINENO: result: not found" >&5
-$as_echo "not found" >&6; }
-fi
-
-{ $as_echo "$as_me:$LINENO: checking for gcc visibility attribute support" >&5
-$as_echo_n "checking for gcc visibility attribute support... " >&6; }
-saved_CFLAGS="$CFLAGS"
-CFLAGS="$CFLAGS -Werror"
-cat >conftest.$ac_ext <<_ACEOF
-
-  #include <stdio.h>
-  int foo() __attribute__ ((visibility("internal")));
-  int foo(){ return 1; }
-  int main(){ return foo(); }
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  { $as_echo "$as_me:$LINENO: result: found" >&5
-$as_echo "found" >&6; }
-  gs_visibility=1
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	{ $as_echo "$as_me:$LINENO: result: not present" >&5
-$as_echo "not present" >&6; }
-  gs_visibility=0
-
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-
-cat >>confdefs.h <<_ACEOF
-#define HAVE_VISIBILITY_ATTRIBUTE $gs_visibility
-_ACEOF
-
-CFLAGS="$saved_CFLAGS"
-
-
-#--------------------------------------------------------------------
-# Check if system has buggy SO_REUSEADDR
-#--------------------------------------------------------------------
-{ $as_echo "$as_me:$LINENO: checking whether SO_REUSEADDR is broken" >&5
-$as_echo_n "checking whether SO_REUSEADDR is broken... " >&6; }
-if test "$cross_compiling" = yes; then
-  reuseaddr_ok="$cross_reuseaddr_ok"
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include "$srcdir/config/config.reuseaddr.c"
-_ACEOF
-rm -f conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  reuseaddr_ok=1
-else
-  $as_echo "$as_me: program exited with status $ac_status" >&5
-$as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-( exit $ac_status )
-reuseaddr_ok=0
-fi
-rm -rf conftest.dSYM
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
-fi
-
-
-if test $reuseaddr_ok = 0; then
-
-cat >>confdefs.h <<\_ACEOF
-#define BROKEN_SO_REUSEADDR 1
-_ACEOF
-
-  echo
-  echo "The SO_REUSEADDR socket option for controlling re-use of network"
-  echo "sockets immediately after shutdown appears to be broken on this"
-  echo "machine.  Networking code will be built without using this"
-  echo "feature."
-  echo "The effect of this lack is that when a network service is shut"
-  echo "down, it cannot be re-started on the same network port until"
-  echo "an operating-system timeout has expired."
-  echo "For servers other than gdomap, GNUstep does not normally need"
-  echo "a particular network port, so the problem is unlikely to arise."
-  { $as_echo "$as_me:$LINENO: result: yes" >&5
-$as_echo "yes" >&6; }
-else
-  { $as_echo "$as_me:$LINENO: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-#--------------------------------------------------------------------
-# Check for thread flags for libobjc.
-#--------------------------------------------------------------------
-#
-{ $as_echo "$as_me:$LINENO: checking for objc threading flags" >&5
-$as_echo_n "checking for objc threading flags... " >&6; }
-#
-# Get them from gnustep-make which contains the real code to get them
-#
-objc_threaded=`grep objc_threaded: $CURRENT_GNUSTEP_MAKEFILES/$lobj_dir/config.make | sed -e 's/objc_threaded:=//'`
-#
-{ $as_echo "$as_me:$LINENO: result: $objc_threaded" >&5
-$as_echo "$objc_threaded" >&6; }
-
-#--------------------------------------------------------------------
-# Byte order information needed for foundation headers.
-#--------------------------------------------------------------------
-
- { $as_echo "$as_me:$LINENO: checking whether byte ordering is bigendian" >&5
-$as_echo_n "checking whether byte ordering is bigendian... " >&6; }
-if test "${ac_cv_c_bigendian+set}" = set; then
-  $as_echo_n "(cached) " >&6
-else
-  ac_cv_c_bigendian=unknown
-    # See if we're dealing with a universal compiler.
-    cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#ifndef __APPLE_CC__
-	       not a universal capable compiler
-	     #endif
-	     typedef int dummy;
-
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-
-	# Check for potential -arch flags.  It is not universal unless
-	# there are some -arch flags.  Note that *ppc* also matches
-	# ppc64.  This check is also rather less than ideal.
-	case "${CC} ${CFLAGS} ${CPPFLAGS} ${LDFLAGS}" in  #(
-	  *-arch*ppc*|*-arch*i386*|*-arch*x86_64*) ac_cv_c_bigendian=universal;;
-	esac
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-    if test $ac_cv_c_bigendian = unknown; then
-      # See if sys/param.h defines the BYTE_ORDER macro.
-      cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <sys/types.h>
-	     #include <sys/param.h>
-
-int
-main ()
-{
-#if ! (defined BYTE_ORDER && defined BIG_ENDIAN \
-		     && defined LITTLE_ENDIAN && BYTE_ORDER && BIG_ENDIAN \
-		     && LITTLE_ENDIAN)
-	      bogus endian macros
-	     #endif
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  # It does; now see whether it defined to BIG_ENDIAN or not.
-	 cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <sys/types.h>
-		#include <sys/param.h>
-
-int
-main ()
-{
-#if BYTE_ORDER != BIG_ENDIAN
-		 not big endian
-		#endif
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_cv_c_bigendian=yes
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_cv_c_bigendian=no
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-    fi
-    if test $ac_cv_c_bigendian = unknown; then
-      # See if <limits.h> defines _LITTLE_ENDIAN or _BIG_ENDIAN (e.g., Solaris).
-      cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <limits.h>
-
-int
-main ()
-{
-#if ! (defined _LITTLE_ENDIAN || defined _BIG_ENDIAN)
-	      bogus endian macros
-	     #endif
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  # It does; now see whether it defined to _BIG_ENDIAN or not.
-	 cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <limits.h>
-
-int
-main ()
-{
-#ifndef _BIG_ENDIAN
-		 not big endian
-		#endif
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_cv_c_bigendian=yes
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_cv_c_bigendian=no
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-    fi
-    if test $ac_cv_c_bigendian = unknown; then
-      # Compile a test program.
-      if test "$cross_compiling" = yes; then
-  # Try to guess by grepping values from an object file.
-	 cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-short int ascii_mm[] =
-		  { 0x4249, 0x4765, 0x6E44, 0x6961, 0x6E53, 0x7953, 0 };
-		short int ascii_ii[] =
-		  { 0x694C, 0x5454, 0x656C, 0x6E45, 0x6944, 0x6E61, 0 };
-		int use_ascii (int i) {
-		  return ascii_mm[i] + ascii_ii[i];
-		}
-		short int ebcdic_ii[] =
-		  { 0x89D3, 0xE3E3, 0x8593, 0x95C5, 0x89C4, 0x9581, 0 };
-		short int ebcdic_mm[] =
-		  { 0xC2C9, 0xC785, 0x95C4, 0x8981, 0x95E2, 0xA8E2, 0 };
-		int use_ebcdic (int i) {
-		  return ebcdic_mm[i] + ebcdic_ii[i];
-		}
-		extern int foo;
-
-int
-main ()
-{
-return use_ascii (foo) == use_ebcdic (foo);
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  if grep BIGenDianSyS conftest.$ac_objext >/dev/null; then
-	      ac_cv_c_bigendian=yes
-	    fi
-	    if grep LiTTleEnDian conftest.$ac_objext >/dev/null ; then
-	      if test "$ac_cv_c_bigendian" = unknown; then
-		ac_cv_c_bigendian=no
-	      else
-		# finding both strings is unlikely to happen, but who knows?
-		ac_cv_c_bigendian=unknown
-	      fi
-	    fi
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-int
-main ()
-{
-
-	     /* Are we little or big endian?  From Harbison&Steele.  */
-	     union
-	     {
-	       long int l;
-	       char c[sizeof (long int)];
-	     } u;
-	     u.l = 1;
-	     return u.c[sizeof (long int) - 1] == 1;
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_cv_c_bigendian=no
-else
-  $as_echo "$as_me: program exited with status $ac_status" >&5
-$as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-( exit $ac_status )
-ac_cv_c_bigendian=yes
-fi
-rm -rf conftest.dSYM
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
-fi
-
-
-    fi
-fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_c_bigendian" >&5
-$as_echo "$ac_cv_c_bigendian" >&6; }
- case $ac_cv_c_bigendian in #(
-   yes)
-     cat >>confdefs.h <<\_ACEOF
-#define WORDS_BIGENDIAN 1
-_ACEOF
-;; #(
-   no)
-      ;; #(
-   universal)
-
-cat >>confdefs.h <<\_ACEOF
-#define AC_APPLE_UNIVERSAL_BUILD 1
-_ACEOF
-
-     ;; #(
-   *)
-     { { $as_echo "$as_me:$LINENO: error: unknown endianness
- presetting ac_cv_c_bigendian=no (or yes) will help" >&5
-$as_echo "$as_me: error: unknown endianness
- presetting ac_cv_c_bigendian=no (or yes) will help" >&2;}
-   { (exit 1); exit 1; }; } ;;
- esac
-
-if test $ac_cv_c_bigendian = yes; then
-  GS_WORDS_BIGENDIAN=1
-else
-  GS_WORDS_BIGENDIAN=0
-fi
-
-
-#--------------------------------------------------------------------
-# Type size information needed for foundation headers.
-#--------------------------------------------------------------------
-# The cast to long int works around a bug in the HP C Compiler
-# version HP92453-01 B.11.11.23709.GP, which incorrectly rejects
-# declarations like `int a3[[(sizeof (unsigned char)) >= 0]];'.
-# This bug is HP SR number 8606223364.
-{ $as_echo "$as_me:$LINENO: checking size of void*" >&5
-$as_echo_n "checking size of void*... " >&6; }
-if test "${ac_cv_sizeof_voidp+set}" = set; then
-  $as_echo_n "(cached) " >&6
-else
-  if test "$cross_compiling" = yes; then
-  # Depending upon the size, compute the lo and hi bounds.
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-int
-main ()
-{
-static int test_array [1 - 2 * !(((long int) (sizeof (void*))) >= 0)];
-test_array [0] = 0
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_lo=0 ac_mid=0
-  while :; do
-    cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-int
-main ()
-{
-static int test_array [1 - 2 * !(((long int) (sizeof (void*))) <= $ac_mid)];
-test_array [0] = 0
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_hi=$ac_mid; break
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_lo=`expr $ac_mid + 1`
-			if test $ac_lo -le $ac_mid; then
-			  ac_lo= ac_hi=
-			  break
-			fi
-			ac_mid=`expr 2 '*' $ac_mid + 1`
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-  done
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-int
-main ()
-{
-static int test_array [1 - 2 * !(((long int) (sizeof (void*))) < 0)];
-test_array [0] = 0
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_hi=-1 ac_mid=-1
-  while :; do
-    cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-int
-main ()
-{
-static int test_array [1 - 2 * !(((long int) (sizeof (void*))) >= $ac_mid)];
-test_array [0] = 0
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_lo=$ac_mid; break
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_hi=`expr '(' $ac_mid ')' - 1`
-			if test $ac_mid -le $ac_hi; then
-			  ac_lo= ac_hi=
-			  break
-			fi
-			ac_mid=`expr 2 '*' $ac_mid`
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-  done
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_lo= ac_hi=
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-# Binary search between lo and hi bounds.
-while test "x$ac_lo" != "x$ac_hi"; do
-  ac_mid=`expr '(' $ac_hi - $ac_lo ')' / 2 + $ac_lo`
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-int
-main ()
-{
-static int test_array [1 - 2 * !(((long int) (sizeof (void*))) <= $ac_mid)];
-test_array [0] = 0
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_hi=$ac_mid
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_lo=`expr '(' $ac_mid ')' + 1`
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-done
-case $ac_lo in
-?*) ac_cv_sizeof_voidp=$ac_lo;;
-'') if test "$ac_cv_type_voidp" = yes; then
-     { { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
-$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-{ { $as_echo "$as_me:$LINENO: error: cannot compute sizeof (void*)
-See \`config.log' for more details." >&5
-$as_echo "$as_me: error: cannot compute sizeof (void*)
-See \`config.log' for more details." >&2;}
-   { (exit 77); exit 77; }; }; }
-   else
-     ac_cv_sizeof_voidp=0
-   fi ;;
-esac
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-static long int longval () { return (long int) (sizeof (void*)); }
-static unsigned long int ulongval () { return (long int) (sizeof (void*)); }
-#include <stdio.h>
-#include <stdlib.h>
-int
-main ()
-{
-
-  FILE *f = fopen ("conftest.val", "w");
-  if (! f)
-    return 1;
-  if (((long int) (sizeof (void*))) < 0)
-    {
-      long int i = longval ();
-      if (i != ((long int) (sizeof (void*))))
-	return 1;
-      fprintf (f, "%ld", i);
-    }
-  else
-    {
-      unsigned long int i = ulongval ();
-      if (i != ((long int) (sizeof (void*))))
-	return 1;
-      fprintf (f, "%lu", i);
-    }
-  /* Do not output a trailing newline, as this causes \r\n confusion
-     on some platforms.  */
-  return ferror (f) || fclose (f) != 0;
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_cv_sizeof_voidp=`cat conftest.val`
-else
-  $as_echo "$as_me: program exited with status $ac_status" >&5
-$as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-( exit $ac_status )
-if test "$ac_cv_type_voidp" = yes; then
-     { { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
-$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-{ { $as_echo "$as_me:$LINENO: error: cannot compute sizeof (void*)
-See \`config.log' for more details." >&5
-$as_echo "$as_me: error: cannot compute sizeof (void*)
-See \`config.log' for more details." >&2;}
-   { (exit 77); exit 77; }; }; }
-   else
-     ac_cv_sizeof_voidp=0
-   fi
-fi
-rm -rf conftest.dSYM
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
-fi
-rm -f conftest.val
-fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_sizeof_voidp" >&5
-$as_echo "$ac_cv_sizeof_voidp" >&6; }
-
-
-
-cat >>confdefs.h <<_ACEOF
-#define SIZEOF_VOIDP $ac_cv_sizeof_voidp
-_ACEOF
-
-
-
-GS_SINT8="signed char"
-GS_UINT8="unsigned char"
-
-
-
-# The cast to long int works around a bug in the HP C Compiler
-# version HP92453-01 B.11.11.23709.GP, which incorrectly rejects
-# declarations like `int a3[[(sizeof (unsigned char)) >= 0]];'.
-# This bug is HP SR number 8606223364.
-{ $as_echo "$as_me:$LINENO: checking size of short" >&5
-$as_echo_n "checking size of short... " >&6; }
-if test "${ac_cv_sizeof_short+set}" = set; then
-  $as_echo_n "(cached) " >&6
-else
-  if test "$cross_compiling" = yes; then
-  # Depending upon the size, compute the lo and hi bounds.
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-int
-main ()
-{
-static int test_array [1 - 2 * !(((long int) (sizeof (short))) >= 0)];
-test_array [0] = 0
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_lo=0 ac_mid=0
-  while :; do
-    cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-int
-main ()
-{
-static int test_array [1 - 2 * !(((long int) (sizeof (short))) <= $ac_mid)];
-test_array [0] = 0
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_hi=$ac_mid; break
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_lo=`expr $ac_mid + 1`
-			if test $ac_lo -le $ac_mid; then
-			  ac_lo= ac_hi=
-			  break
-			fi
-			ac_mid=`expr 2 '*' $ac_mid + 1`
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-  done
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-int
-main ()
-{
-static int test_array [1 - 2 * !(((long int) (sizeof (short))) < 0)];
-test_array [0] = 0
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_hi=-1 ac_mid=-1
-  while :; do
-    cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-int
-main ()
-{
-static int test_array [1 - 2 * !(((long int) (sizeof (short))) >= $ac_mid)];
-test_array [0] = 0
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_lo=$ac_mid; break
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_hi=`expr '(' $ac_mid ')' - 1`
-			if test $ac_mid -le $ac_hi; then
-			  ac_lo= ac_hi=
-			  break
-			fi
-			ac_mid=`expr 2 '*' $ac_mid`
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-  done
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_lo= ac_hi=
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-# Binary search between lo and hi bounds.
-while test "x$ac_lo" != "x$ac_hi"; do
-  ac_mid=`expr '(' $ac_hi - $ac_lo ')' / 2 + $ac_lo`
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-int
-main ()
-{
-static int test_array [1 - 2 * !(((long int) (sizeof (short))) <= $ac_mid)];
-test_array [0] = 0
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_hi=$ac_mid
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_lo=`expr '(' $ac_mid ')' + 1`
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-done
-case $ac_lo in
-?*) ac_cv_sizeof_short=$ac_lo;;
-'') if test "$ac_cv_type_short" = yes; then
-     { { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
-$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-{ { $as_echo "$as_me:$LINENO: error: cannot compute sizeof (short)
-See \`config.log' for more details." >&5
-$as_echo "$as_me: error: cannot compute sizeof (short)
-See \`config.log' for more details." >&2;}
-   { (exit 77); exit 77; }; }; }
-   else
-     ac_cv_sizeof_short=0
-   fi ;;
-esac
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-static long int longval () { return (long int) (sizeof (short)); }
-static unsigned long int ulongval () { return (long int) (sizeof (short)); }
-#include <stdio.h>
-#include <stdlib.h>
-int
-main ()
-{
-
-  FILE *f = fopen ("conftest.val", "w");
-  if (! f)
-    return 1;
-  if (((long int) (sizeof (short))) < 0)
-    {
-      long int i = longval ();
-      if (i != ((long int) (sizeof (short))))
-	return 1;
-      fprintf (f, "%ld", i);
-    }
-  else
-    {
-      unsigned long int i = ulongval ();
-      if (i != ((long int) (sizeof (short))))
-	return 1;
-      fprintf (f, "%lu", i);
-    }
-  /* Do not output a trailing newline, as this causes \r\n confusion
-     on some platforms.  */
-  return ferror (f) || fclose (f) != 0;
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_cv_sizeof_short=`cat conftest.val`
-else
-  $as_echo "$as_me: program exited with status $ac_status" >&5
-$as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-( exit $ac_status )
-if test "$ac_cv_type_short" = yes; then
-     { { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
-$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-{ { $as_echo "$as_me:$LINENO: error: cannot compute sizeof (short)
-See \`config.log' for more details." >&5
-$as_echo "$as_me: error: cannot compute sizeof (short)
-See \`config.log' for more details." >&2;}
-   { (exit 77); exit 77; }; }; }
-   else
-     ac_cv_sizeof_short=0
-   fi
-fi
-rm -rf conftest.dSYM
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
-fi
-rm -f conftest.val
-fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_sizeof_short" >&5
-$as_echo "$ac_cv_sizeof_short" >&6; }
-
-
-
-cat >>confdefs.h <<_ACEOF
-#define SIZEOF_SHORT $ac_cv_sizeof_short
-_ACEOF
-
-
-
-
-# The cast to long int works around a bug in the HP C Compiler
-# version HP92453-01 B.11.11.23709.GP, which incorrectly rejects
-# declarations like `int a3[[(sizeof (unsigned char)) >= 0]];'.
-# This bug is HP SR number 8606223364.
-{ $as_echo "$as_me:$LINENO: checking size of int" >&5
-$as_echo_n "checking size of int... " >&6; }
-if test "${ac_cv_sizeof_int+set}" = set; then
-  $as_echo_n "(cached) " >&6
-else
-  if test "$cross_compiling" = yes; then
-  # Depending upon the size, compute the lo and hi bounds.
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-int
-main ()
-{
-static int test_array [1 - 2 * !(((long int) (sizeof (int))) >= 0)];
-test_array [0] = 0
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_lo=0 ac_mid=0
-  while :; do
-    cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-int
-main ()
-{
-static int test_array [1 - 2 * !(((long int) (sizeof (int))) <= $ac_mid)];
-test_array [0] = 0
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_hi=$ac_mid; break
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_lo=`expr $ac_mid + 1`
-			if test $ac_lo -le $ac_mid; then
-			  ac_lo= ac_hi=
-			  break
-			fi
-			ac_mid=`expr 2 '*' $ac_mid + 1`
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-  done
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-int
-main ()
-{
-static int test_array [1 - 2 * !(((long int) (sizeof (int))) < 0)];
-test_array [0] = 0
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_hi=-1 ac_mid=-1
-  while :; do
-    cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-int
-main ()
-{
-static int test_array [1 - 2 * !(((long int) (sizeof (int))) >= $ac_mid)];
-test_array [0] = 0
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_lo=$ac_mid; break
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_hi=`expr '(' $ac_mid ')' - 1`
-			if test $ac_mid -le $ac_hi; then
-			  ac_lo= ac_hi=
-			  break
-			fi
-			ac_mid=`expr 2 '*' $ac_mid`
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-  done
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_lo= ac_hi=
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-# Binary search between lo and hi bounds.
-while test "x$ac_lo" != "x$ac_hi"; do
-  ac_mid=`expr '(' $ac_hi - $ac_lo ')' / 2 + $ac_lo`
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-int
-main ()
-{
-static int test_array [1 - 2 * !(((long int) (sizeof (int))) <= $ac_mid)];
-test_array [0] = 0
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_hi=$ac_mid
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_lo=`expr '(' $ac_mid ')' + 1`
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-done
-case $ac_lo in
-?*) ac_cv_sizeof_int=$ac_lo;;
-'') if test "$ac_cv_type_int" = yes; then
-     { { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
-$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-{ { $as_echo "$as_me:$LINENO: error: cannot compute sizeof (int)
-See \`config.log' for more details." >&5
-$as_echo "$as_me: error: cannot compute sizeof (int)
-See \`config.log' for more details." >&2;}
-   { (exit 77); exit 77; }; }; }
-   else
-     ac_cv_sizeof_int=0
-   fi ;;
-esac
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-static long int longval () { return (long int) (sizeof (int)); }
-static unsigned long int ulongval () { return (long int) (sizeof (int)); }
-#include <stdio.h>
-#include <stdlib.h>
-int
-main ()
-{
-
-  FILE *f = fopen ("conftest.val", "w");
-  if (! f)
-    return 1;
-  if (((long int) (sizeof (int))) < 0)
-    {
-      long int i = longval ();
-      if (i != ((long int) (sizeof (int))))
-	return 1;
-      fprintf (f, "%ld", i);
-    }
-  else
-    {
-      unsigned long int i = ulongval ();
-      if (i != ((long int) (sizeof (int))))
-	return 1;
-      fprintf (f, "%lu", i);
-    }
-  /* Do not output a trailing newline, as this causes \r\n confusion
-     on some platforms.  */
-  return ferror (f) || fclose (f) != 0;
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_cv_sizeof_int=`cat conftest.val`
-else
-  $as_echo "$as_me: program exited with status $ac_status" >&5
-$as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-( exit $ac_status )
-if test "$ac_cv_type_int" = yes; then
-     { { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
-$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-{ { $as_echo "$as_me:$LINENO: error: cannot compute sizeof (int)
-See \`config.log' for more details." >&5
-$as_echo "$as_me: error: cannot compute sizeof (int)
-See \`config.log' for more details." >&2;}
-   { (exit 77); exit 77; }; }; }
-   else
-     ac_cv_sizeof_int=0
-   fi
-fi
-rm -rf conftest.dSYM
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
-fi
-rm -f conftest.val
-fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_sizeof_int" >&5
-$as_echo "$ac_cv_sizeof_int" >&6; }
-
-
-
-cat >>confdefs.h <<_ACEOF
-#define SIZEOF_INT $ac_cv_sizeof_int
-_ACEOF
-
-
-
-
-# The cast to long int works around a bug in the HP C Compiler
-# version HP92453-01 B.11.11.23709.GP, which incorrectly rejects
-# declarations like `int a3[[(sizeof (unsigned char)) >= 0]];'.
-# This bug is HP SR number 8606223364.
-{ $as_echo "$as_me:$LINENO: checking size of long" >&5
-$as_echo_n "checking size of long... " >&6; }
-if test "${ac_cv_sizeof_long+set}" = set; then
-  $as_echo_n "(cached) " >&6
-else
-  if test "$cross_compiling" = yes; then
-  # Depending upon the size, compute the lo and hi bounds.
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-int
-main ()
-{
-static int test_array [1 - 2 * !(((long int) (sizeof (long))) >= 0)];
-test_array [0] = 0
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_lo=0 ac_mid=0
-  while :; do
-    cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-int
-main ()
-{
-static int test_array [1 - 2 * !(((long int) (sizeof (long))) <= $ac_mid)];
-test_array [0] = 0
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_hi=$ac_mid; break
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_lo=`expr $ac_mid + 1`
-			if test $ac_lo -le $ac_mid; then
-			  ac_lo= ac_hi=
-			  break
-			fi
-			ac_mid=`expr 2 '*' $ac_mid + 1`
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-  done
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-int
-main ()
-{
-static int test_array [1 - 2 * !(((long int) (sizeof (long))) < 0)];
-test_array [0] = 0
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_hi=-1 ac_mid=-1
-  while :; do
-    cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-int
-main ()
-{
-static int test_array [1 - 2 * !(((long int) (sizeof (long))) >= $ac_mid)];
-test_array [0] = 0
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_lo=$ac_mid; break
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_hi=`expr '(' $ac_mid ')' - 1`
-			if test $ac_mid -le $ac_hi; then
-			  ac_lo= ac_hi=
-			  break
-			fi
-			ac_mid=`expr 2 '*' $ac_mid`
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-  done
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_lo= ac_hi=
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-# Binary search between lo and hi bounds.
-while test "x$ac_lo" != "x$ac_hi"; do
-  ac_mid=`expr '(' $ac_hi - $ac_lo ')' / 2 + $ac_lo`
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-int
-main ()
-{
-static int test_array [1 - 2 * !(((long int) (sizeof (long))) <= $ac_mid)];
-test_array [0] = 0
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_hi=$ac_mid
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_lo=`expr '(' $ac_mid ')' + 1`
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-done
-case $ac_lo in
-?*) ac_cv_sizeof_long=$ac_lo;;
-'') if test "$ac_cv_type_long" = yes; then
-     { { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
-$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-{ { $as_echo "$as_me:$LINENO: error: cannot compute sizeof (long)
-See \`config.log' for more details." >&5
-$as_echo "$as_me: error: cannot compute sizeof (long)
-See \`config.log' for more details." >&2;}
-   { (exit 77); exit 77; }; }; }
-   else
-     ac_cv_sizeof_long=0
-   fi ;;
-esac
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-static long int longval () { return (long int) (sizeof (long)); }
-static unsigned long int ulongval () { return (long int) (sizeof (long)); }
-#include <stdio.h>
-#include <stdlib.h>
-int
-main ()
-{
-
-  FILE *f = fopen ("conftest.val", "w");
-  if (! f)
-    return 1;
-  if (((long int) (sizeof (long))) < 0)
-    {
-      long int i = longval ();
-      if (i != ((long int) (sizeof (long))))
-	return 1;
-      fprintf (f, "%ld", i);
-    }
-  else
-    {
-      unsigned long int i = ulongval ();
-      if (i != ((long int) (sizeof (long))))
-	return 1;
-      fprintf (f, "%lu", i);
-    }
-  /* Do not output a trailing newline, as this causes \r\n confusion
-     on some platforms.  */
-  return ferror (f) || fclose (f) != 0;
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_cv_sizeof_long=`cat conftest.val`
-else
-  $as_echo "$as_me: program exited with status $ac_status" >&5
-$as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-( exit $ac_status )
-if test "$ac_cv_type_long" = yes; then
-     { { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
-$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-{ { $as_echo "$as_me:$LINENO: error: cannot compute sizeof (long)
-See \`config.log' for more details." >&5
-$as_echo "$as_me: error: cannot compute sizeof (long)
-See \`config.log' for more details." >&2;}
-   { (exit 77); exit 77; }; }; }
-   else
-     ac_cv_sizeof_long=0
-   fi
-fi
-rm -rf conftest.dSYM
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
-fi
-rm -f conftest.val
-fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_sizeof_long" >&5
-$as_echo "$ac_cv_sizeof_long" >&6; }
-
-
-
-cat >>confdefs.h <<_ACEOF
-#define SIZEOF_LONG $ac_cv_sizeof_long
-_ACEOF
-
-
-
-
-# The cast to long int works around a bug in the HP C Compiler
-# version HP92453-01 B.11.11.23709.GP, which incorrectly rejects
-# declarations like `int a3[[(sizeof (unsigned char)) >= 0]];'.
-# This bug is HP SR number 8606223364.
-{ $as_echo "$as_me:$LINENO: checking size of long long" >&5
-$as_echo_n "checking size of long long... " >&6; }
-if test "${ac_cv_sizeof_long_long+set}" = set; then
-  $as_echo_n "(cached) " >&6
-else
-  if test "$cross_compiling" = yes; then
-  # Depending upon the size, compute the lo and hi bounds.
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-int
-main ()
-{
-static int test_array [1 - 2 * !(((long int) (sizeof (long long))) >= 0)];
-test_array [0] = 0
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_lo=0 ac_mid=0
-  while :; do
-    cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-int
-main ()
-{
-static int test_array [1 - 2 * !(((long int) (sizeof (long long))) <= $ac_mid)];
-test_array [0] = 0
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_hi=$ac_mid; break
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_lo=`expr $ac_mid + 1`
-			if test $ac_lo -le $ac_mid; then
-			  ac_lo= ac_hi=
-			  break
-			fi
-			ac_mid=`expr 2 '*' $ac_mid + 1`
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-  done
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-int
-main ()
-{
-static int test_array [1 - 2 * !(((long int) (sizeof (long long))) < 0)];
-test_array [0] = 0
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_hi=-1 ac_mid=-1
-  while :; do
-    cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-int
-main ()
-{
-static int test_array [1 - 2 * !(((long int) (sizeof (long long))) >= $ac_mid)];
-test_array [0] = 0
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_lo=$ac_mid; break
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_hi=`expr '(' $ac_mid ')' - 1`
-			if test $ac_mid -le $ac_hi; then
-			  ac_lo= ac_hi=
-			  break
-			fi
-			ac_mid=`expr 2 '*' $ac_mid`
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-  done
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_lo= ac_hi=
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-# Binary search between lo and hi bounds.
-while test "x$ac_lo" != "x$ac_hi"; do
-  ac_mid=`expr '(' $ac_hi - $ac_lo ')' / 2 + $ac_lo`
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-int
-main ()
-{
-static int test_array [1 - 2 * !(((long int) (sizeof (long long))) <= $ac_mid)];
-test_array [0] = 0
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_hi=$ac_mid
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_lo=`expr '(' $ac_mid ')' + 1`
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-done
-case $ac_lo in
-?*) ac_cv_sizeof_long_long=$ac_lo;;
-'') if test "$ac_cv_type_long_long" = yes; then
-     { { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
-$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-{ { $as_echo "$as_me:$LINENO: error: cannot compute sizeof (long long)
-See \`config.log' for more details." >&5
-$as_echo "$as_me: error: cannot compute sizeof (long long)
-See \`config.log' for more details." >&2;}
-   { (exit 77); exit 77; }; }; }
-   else
-     ac_cv_sizeof_long_long=0
-   fi ;;
-esac
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-static long int longval () { return (long int) (sizeof (long long)); }
-static unsigned long int ulongval () { return (long int) (sizeof (long long)); }
-#include <stdio.h>
-#include <stdlib.h>
-int
-main ()
-{
-
-  FILE *f = fopen ("conftest.val", "w");
-  if (! f)
-    return 1;
-  if (((long int) (sizeof (long long))) < 0)
-    {
-      long int i = longval ();
-      if (i != ((long int) (sizeof (long long))))
-	return 1;
-      fprintf (f, "%ld", i);
-    }
-  else
-    {
-      unsigned long int i = ulongval ();
-      if (i != ((long int) (sizeof (long long))))
-	return 1;
-      fprintf (f, "%lu", i);
-    }
-  /* Do not output a trailing newline, as this causes \r\n confusion
-     on some platforms.  */
-  return ferror (f) || fclose (f) != 0;
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_cv_sizeof_long_long=`cat conftest.val`
-else
-  $as_echo "$as_me: program exited with status $ac_status" >&5
-$as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-( exit $ac_status )
-if test "$ac_cv_type_long_long" = yes; then
-     { { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
-$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-{ { $as_echo "$as_me:$LINENO: error: cannot compute sizeof (long long)
-See \`config.log' for more details." >&5
-$as_echo "$as_me: error: cannot compute sizeof (long long)
-See \`config.log' for more details." >&2;}
-   { (exit 77); exit 77; }; }; }
-   else
-     ac_cv_sizeof_long_long=0
-   fi
-fi
-rm -rf conftest.dSYM
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
-fi
-rm -f conftest.val
-fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_sizeof_long_long" >&5
-$as_echo "$ac_cv_sizeof_long_long" >&6; }
-
-
-
-cat >>confdefs.h <<_ACEOF
-#define SIZEOF_LONG_LONG $ac_cv_sizeof_long_long
-_ACEOF
-
-
-
-
-# The cast to long int works around a bug in the HP C Compiler
-# version HP92453-01 B.11.11.23709.GP, which incorrectly rejects
-# declarations like `int a3[[(sizeof (unsigned char)) >= 0]];'.
-# This bug is HP SR number 8606223364.
-{ $as_echo "$as_me:$LINENO: checking size of float" >&5
-$as_echo_n "checking size of float... " >&6; }
-if test "${ac_cv_sizeof_float+set}" = set; then
-  $as_echo_n "(cached) " >&6
-else
-  if test "$cross_compiling" = yes; then
-  # Depending upon the size, compute the lo and hi bounds.
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-int
-main ()
-{
-static int test_array [1 - 2 * !(((long int) (sizeof (float))) >= 0)];
-test_array [0] = 0
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_lo=0 ac_mid=0
-  while :; do
-    cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-int
-main ()
-{
-static int test_array [1 - 2 * !(((long int) (sizeof (float))) <= $ac_mid)];
-test_array [0] = 0
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_hi=$ac_mid; break
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_lo=`expr $ac_mid + 1`
-			if test $ac_lo -le $ac_mid; then
-			  ac_lo= ac_hi=
-			  break
-			fi
-			ac_mid=`expr 2 '*' $ac_mid + 1`
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-  done
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-int
-main ()
-{
-static int test_array [1 - 2 * !(((long int) (sizeof (float))) < 0)];
-test_array [0] = 0
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_hi=-1 ac_mid=-1
-  while :; do
-    cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-int
-main ()
-{
-static int test_array [1 - 2 * !(((long int) (sizeof (float))) >= $ac_mid)];
-test_array [0] = 0
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_lo=$ac_mid; break
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_hi=`expr '(' $ac_mid ')' - 1`
-			if test $ac_mid -le $ac_hi; then
-			  ac_lo= ac_hi=
-			  break
-			fi
-			ac_mid=`expr 2 '*' $ac_mid`
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-  done
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_lo= ac_hi=
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-# Binary search between lo and hi bounds.
-while test "x$ac_lo" != "x$ac_hi"; do
-  ac_mid=`expr '(' $ac_hi - $ac_lo ')' / 2 + $ac_lo`
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-int
-main ()
-{
-static int test_array [1 - 2 * !(((long int) (sizeof (float))) <= $ac_mid)];
-test_array [0] = 0
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_hi=$ac_mid
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_lo=`expr '(' $ac_mid ')' + 1`
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-done
-case $ac_lo in
-?*) ac_cv_sizeof_float=$ac_lo;;
-'') if test "$ac_cv_type_float" = yes; then
-     { { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
-$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-{ { $as_echo "$as_me:$LINENO: error: cannot compute sizeof (float)
-See \`config.log' for more details." >&5
-$as_echo "$as_me: error: cannot compute sizeof (float)
-See \`config.log' for more details." >&2;}
-   { (exit 77); exit 77; }; }; }
-   else
-     ac_cv_sizeof_float=0
-   fi ;;
-esac
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-static long int longval () { return (long int) (sizeof (float)); }
-static unsigned long int ulongval () { return (long int) (sizeof (float)); }
-#include <stdio.h>
-#include <stdlib.h>
-int
-main ()
-{
-
-  FILE *f = fopen ("conftest.val", "w");
-  if (! f)
-    return 1;
-  if (((long int) (sizeof (float))) < 0)
-    {
-      long int i = longval ();
-      if (i != ((long int) (sizeof (float))))
-	return 1;
-      fprintf (f, "%ld", i);
-    }
-  else
-    {
-      unsigned long int i = ulongval ();
-      if (i != ((long int) (sizeof (float))))
-	return 1;
-      fprintf (f, "%lu", i);
-    }
-  /* Do not output a trailing newline, as this causes \r\n confusion
-     on some platforms.  */
-  return ferror (f) || fclose (f) != 0;
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_cv_sizeof_float=`cat conftest.val`
-else
-  $as_echo "$as_me: program exited with status $ac_status" >&5
-$as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-( exit $ac_status )
-if test "$ac_cv_type_float" = yes; then
-     { { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
-$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-{ { $as_echo "$as_me:$LINENO: error: cannot compute sizeof (float)
-See \`config.log' for more details." >&5
-$as_echo "$as_me: error: cannot compute sizeof (float)
-See \`config.log' for more details." >&2;}
-   { (exit 77); exit 77; }; }; }
-   else
-     ac_cv_sizeof_float=0
-   fi
-fi
-rm -rf conftest.dSYM
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
-fi
-rm -f conftest.val
-fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_sizeof_float" >&5
-$as_echo "$ac_cv_sizeof_float" >&6; }
-
-
-
-cat >>confdefs.h <<_ACEOF
-#define SIZEOF_FLOAT $ac_cv_sizeof_float
-_ACEOF
-
-
-
-
-# The cast to long int works around a bug in the HP C Compiler
-# version HP92453-01 B.11.11.23709.GP, which incorrectly rejects
-# declarations like `int a3[[(sizeof (unsigned char)) >= 0]];'.
-# This bug is HP SR number 8606223364.
-{ $as_echo "$as_me:$LINENO: checking size of double" >&5
-$as_echo_n "checking size of double... " >&6; }
-if test "${ac_cv_sizeof_double+set}" = set; then
-  $as_echo_n "(cached) " >&6
-else
-  if test "$cross_compiling" = yes; then
-  # Depending upon the size, compute the lo and hi bounds.
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-int
-main ()
-{
-static int test_array [1 - 2 * !(((long int) (sizeof (double))) >= 0)];
-test_array [0] = 0
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_lo=0 ac_mid=0
-  while :; do
-    cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-int
-main ()
-{
-static int test_array [1 - 2 * !(((long int) (sizeof (double))) <= $ac_mid)];
-test_array [0] = 0
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_hi=$ac_mid; break
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_lo=`expr $ac_mid + 1`
-			if test $ac_lo -le $ac_mid; then
-			  ac_lo= ac_hi=
-			  break
-			fi
-			ac_mid=`expr 2 '*' $ac_mid + 1`
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-  done
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-int
-main ()
-{
-static int test_array [1 - 2 * !(((long int) (sizeof (double))) < 0)];
-test_array [0] = 0
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_hi=-1 ac_mid=-1
-  while :; do
-    cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-int
-main ()
-{
-static int test_array [1 - 2 * !(((long int) (sizeof (double))) >= $ac_mid)];
-test_array [0] = 0
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_lo=$ac_mid; break
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_hi=`expr '(' $ac_mid ')' - 1`
-			if test $ac_mid -le $ac_hi; then
-			  ac_lo= ac_hi=
-			  break
-			fi
-			ac_mid=`expr 2 '*' $ac_mid`
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-  done
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_lo= ac_hi=
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-# Binary search between lo and hi bounds.
-while test "x$ac_lo" != "x$ac_hi"; do
-  ac_mid=`expr '(' $ac_hi - $ac_lo ')' / 2 + $ac_lo`
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-int
-main ()
-{
-static int test_array [1 - 2 * !(((long int) (sizeof (double))) <= $ac_mid)];
-test_array [0] = 0
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_hi=$ac_mid
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_lo=`expr '(' $ac_mid ')' + 1`
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-done
-case $ac_lo in
-?*) ac_cv_sizeof_double=$ac_lo;;
-'') if test "$ac_cv_type_double" = yes; then
-     { { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
-$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-{ { $as_echo "$as_me:$LINENO: error: cannot compute sizeof (double)
-See \`config.log' for more details." >&5
-$as_echo "$as_me: error: cannot compute sizeof (double)
-See \`config.log' for more details." >&2;}
-   { (exit 77); exit 77; }; }; }
-   else
-     ac_cv_sizeof_double=0
-   fi ;;
-esac
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-static long int longval () { return (long int) (sizeof (double)); }
-static unsigned long int ulongval () { return (long int) (sizeof (double)); }
-#include <stdio.h>
-#include <stdlib.h>
-int
-main ()
-{
-
-  FILE *f = fopen ("conftest.val", "w");
-  if (! f)
-    return 1;
-  if (((long int) (sizeof (double))) < 0)
-    {
-      long int i = longval ();
-      if (i != ((long int) (sizeof (double))))
-	return 1;
-      fprintf (f, "%ld", i);
-    }
-  else
-    {
-      unsigned long int i = ulongval ();
-      if (i != ((long int) (sizeof (double))))
-	return 1;
-      fprintf (f, "%lu", i);
-    }
-  /* Do not output a trailing newline, as this causes \r\n confusion
-     on some platforms.  */
-  return ferror (f) || fclose (f) != 0;
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_cv_sizeof_double=`cat conftest.val`
-else
-  $as_echo "$as_me: program exited with status $ac_status" >&5
-$as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-( exit $ac_status )
-if test "$ac_cv_type_double" = yes; then
-     { { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
-$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-{ { $as_echo "$as_me:$LINENO: error: cannot compute sizeof (double)
-See \`config.log' for more details." >&5
-$as_echo "$as_me: error: cannot compute sizeof (double)
-See \`config.log' for more details." >&2;}
-   { (exit 77); exit 77; }; }; }
-   else
-     ac_cv_sizeof_double=0
-   fi
-fi
-rm -rf conftest.dSYM
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
-fi
-rm -f conftest.val
-fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_sizeof_double" >&5
-$as_echo "$ac_cv_sizeof_double" >&6; }
-
-
-
-cat >>confdefs.h <<_ACEOF
-#define SIZEOF_DOUBLE $ac_cv_sizeof_double
-_ACEOF
-
-
-
-
-
-if test $ac_cv_sizeof_voidp = $ac_cv_sizeof_int; then
-  GS_SADDR="int"
-  GS_UADDR="unsigned int"
-else
-  if test $ac_cv_sizeof_voidp = $ac_cv_sizeof_long; then
-    GS_SADDR="long"
-    GS_UADDR="unsigned long"
-  else
-    if test $ac_cv_sizeof_voidp = $ac_cv_sizeof_long_long; then
-      GS_SADDR="long long"
-      GS_UADDR="unsigned long long"
-    else
-      { { $as_echo "$as_me:$LINENO: error: Unable to find integer of same size as void*" >&5
-$as_echo "$as_me: error: Unable to find integer of same size as void*" >&2;}
-   { (exit 1); exit 1; }; }
-    fi
-  fi
-fi
-
-
-
-if test $ac_cv_sizeof_short = 2; then
-  GS_SINT16="signed short"
-  GS_UINT16="unsigned short"
-else
-  if test $ac_cv_sizeof_int = 2; then
-    GS_SINT16="signed int"
-    GS_UINT16="unsigned int"
-  else
-    { { $as_echo "$as_me:$LINENO: error: Unable to determine type for 16-bit integer" >&5
-$as_echo "$as_me: error: Unable to determine type for 16-bit integer" >&2;}
-   { (exit 1); exit 1; }; }
-  fi
-fi
-
-
-
-if test $ac_cv_sizeof_int = 4; then
-  GS_SINT32="signed int"
-  GS_UINT32="unsigned int"
-else
-  if test $ac_cv_sizeof_long = 4; then
-    GS_SINT32="signed long"
-    GS_UINT32="unsigned long"
-  else
-    if test $ac_cv_sizeof_short = 4; then
-      GS_SINT32="signed short"
-      GS_UINT32="unsigned short"
-    else
-      { { $as_echo "$as_me:$LINENO: error: Unable to determine type for 32-bit integer" >&5
-$as_echo "$as_me: error: Unable to determine type for 32-bit integer" >&2;}
-   { (exit 1); exit 1; }; }
-    fi
-  fi
-fi
-
-
-
-GS_HAVE_I64=1
-if test $ac_cv_sizeof_int = 8; then
-  GS_SINT64="signed int"
-  GS_UINT64="unsigned int"
-else
-  if test $ac_cv_sizeof_long = 8; then
-    GS_SINT64="signed long"
-    GS_UINT64="unsigned long"
-  else
-    if test $ac_cv_sizeof_long_long = 8; then
-      GS_SINT64="signed long long"
-      GS_UINT64="unsigned long long"
-    else
-#     64-bit ints not supported - but we need a dummy type for byte-swapping
-#     of 64-bit values arriving from another system.
-      GS_SINT64="struct { gsu8 a8; }"
-      GS_UINT64="struct { gsu8 a8; }"
-      GS_HAVE_I64=0
-    fi
-  fi
-fi
-
-
-
-
-GS_HAVE_I128=1
-if test $ac_cv_sizeof_long = 16; then
-  GS_SINT128="signed long"
-  GS_UINT128="unsigned long"
-else
-  if test $ac_cv_sizeof_long_long = 16; then
-    GS_SINT128="signed long long"
-    GS_UINT128="unsigned long long"
-  else
-#     128-bit ints not supported - but we need a dummy type for byte-swapping
-#     of 128-bit values arriving from another system.
-    GS_SINT128="struct { gsu8 a[16]; }"
-    GS_UINT128="struct { gsu8 a[16]; }"
-    GS_HAVE_I128=0
-  fi
-fi
-
-
-
-
-if test $ac_cv_sizeof_float = 4; then
-  GS_FLT32="float"
-else
-  { { $as_echo "$as_me:$LINENO: error: Unable to determine type for 32-bit float" >&5
-$as_echo "$as_me: error: Unable to determine type for 32-bit float" >&2;}
-   { (exit 1); exit 1; }; }
-fi
-
-
-if test $ac_cv_sizeof_double = 8; then
-  GS_FLT64="double"
-else
-  { { $as_echo "$as_me:$LINENO: error: Unable to determine type for 64-bit float" >&5
-$as_echo "$as_me: error: Unable to determine type for 64-bit float" >&2;}
-   { (exit 1); exit 1; }; }
-fi
-
-
-#--------------------------------------------------------------------
-# Type-size information for encoding into archives using NSArchiver etc.
-#--------------------------------------------------------------------
-if test $ac_cv_sizeof_short = 2; then
-  _GSC_S_SHT=_GSC_I16
-else
-  _GSC_S_SHT=_GSC_I32
-fi
-
-
-if test $ac_cv_sizeof_int = 2; then
-  _GSC_S_INT=_GSC_I16
-else
-  if test $ac_cv_sizeof_int = 4; then
-    _GSC_S_INT=_GSC_I32
-  else
-    if test $ac_cv_sizeof_int = 8; then
-      _GSC_S_INT=_GSC_I64
-    else
-      if test $ac_cv_sizeof_int = 16; then
-	_GSC_S_INT=_GSC_I128
-      fi
-    fi
-  fi
-fi
-
-
-if test $ac_cv_sizeof_long = 4; then
-  _GSC_S_LNG=_GSC_I32
-else
-  if test $ac_cv_sizeof_long = 8; then
-    _GSC_S_LNG=_GSC_I64
-  else
-    if test $ac_cv_sizeof_long = 16; then
-      _GSC_S_LNG=_GSC_I128
-    fi
-  fi
-fi
-
-
-if test $ac_cv_sizeof_long_long = 4; then
-  _GSC_S_LNG_LNG=_GSC_I32
-else
-  if test $ac_cv_sizeof_long_long = 8; then
-    _GSC_S_LNG_LNG=_GSC_I64
-  else
-    if test $ac_cv_sizeof_long_long = 16; then
-      _GSC_S_LNG_LNG=_GSC_I128
-    fi
-  fi
-fi
-
-
-#--------------------------------------------------------------------
-# Setup dynamic linking
-#--------------------------------------------------------------------
-# Copyright (C) 2005 Free Software Foundation
-#
-# Copying and distribution of this file, with or without modification,
-# are permitted in any medium without royalty provided the copyright
-# notice and this notice are preserved.
-#--------------------------------------------------------------------
-# Guess if we are using a object file format that supports automatic
-# loading of constructor functions.
-#
-# If this system supports autoloading of constructors, that means that gcc
-# doesn't have to do it for us via collect2. This routine tests for this
-# in a very roundabout way by compiling a program with a constructor and
-# testing the file, via nm, for certain symbols that collect2 includes to
-# handle loading of constructors.
-#
-# Makes the following substitutions:
-#	Defines CON_AUTOLOAD (whether constructor functions are autoloaded)
-#--------------------------------------------------------------------
-{ $as_echo "$as_me:$LINENO: checking loading of constructor functions" >&5
-$as_echo_n "checking loading of constructor functions... " >&6; }
-if test "${objc_cv_con_autoload+set}" = set; then
-  $as_echo_n "(cached) " >&6
-else
-  if test "$cross_compiling" = yes; then
-  objc_cv_con_autoload=no
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-static int loaded = 0;
-	void cons_functions() __attribute__ ((constructor));
-	void cons_functions() { loaded = 1; }
-	int main()
-	{
-  	  return ( (loaded == 1) ? 0 : 1);
-	}
-_ACEOF
-rm -f conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  objc_cv_con_autoload=yes
-else
-  $as_echo "$as_me: program exited with status $ac_status" >&5
-$as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-( exit $ac_status )
-objc_cv_con_autoload=no
-fi
-rm -rf conftest.dSYM
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
-fi
-
-
-case "$target_os" in
-    cygwin*)	objc_cv_con_autoload=yes;;
-    mingw*)	objc_cv_con_autoload=yes;;
-esac
-
-fi
-
-if test $objc_cv_con_autoload = yes; then
-  { $as_echo "$as_me:$LINENO: result: yes" >&5
-$as_echo "yes" >&6; }
-
-cat >>confdefs.h <<\_ACEOF
-#define CON_AUTOLOAD 1
-_ACEOF
-
-else
-  { $as_echo "$as_me:$LINENO: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-# Copyright (C) 2005 Free Software Foundation
-# Copying and distribution of this file, with or without modification,
-# are permitted in any medium without royalty provided the copyright
-# notice and this notice are preserved.
-#--------------------------------------------------------------------
-# Guess the type of dynamic linker for the system
-#
-# Makes the following substitutions:
-#	DYNAMIC_LINKER	- cooresponds to the interface that is included
-#		in objc-load.c (i.e. #include "${DYNAMIC_LINKER}-load.h")
-#--------------------------------------------------------------------
-DYNAMIC_LINKER=null
-if test "${ac_cv_header_dlfcn_h+set}" = set; then
-  { $as_echo "$as_me:$LINENO: checking for dlfcn.h" >&5
-$as_echo_n "checking for dlfcn.h... " >&6; }
-if test "${ac_cv_header_dlfcn_h+set}" = set; then
-  $as_echo_n "(cached) " >&6
-fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_header_dlfcn_h" >&5
-$as_echo "$ac_cv_header_dlfcn_h" >&6; }
-else
-  # Is the header compilable?
-{ $as_echo "$as_me:$LINENO: checking dlfcn.h usability" >&5
-$as_echo_n "checking dlfcn.h usability... " >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-#include <dlfcn.h>
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_header_compiler=yes
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_header_compiler=no
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-{ $as_echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
-$as_echo "$ac_header_compiler" >&6; }
-
-# Is the header present?
-{ $as_echo "$as_me:$LINENO: checking dlfcn.h presence" >&5
-$as_echo_n "checking dlfcn.h presence... " >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <dlfcn.h>
-_ACEOF
-if { (ac_try="$ac_cpp conftest.$ac_ext"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } >/dev/null && {
-	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       }; then
-  ac_header_preproc=yes
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-  ac_header_preproc=no
-fi
-
-rm -f conftest.err conftest.$ac_ext
-{ $as_echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
-$as_echo "$ac_header_preproc" >&6; }
-
-# So?  What about this header?
-case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
-  yes:no: )
-    { $as_echo "$as_me:$LINENO: WARNING: dlfcn.h: accepted by the compiler, rejected by the preprocessor!" >&5
-$as_echo "$as_me: WARNING: dlfcn.h: accepted by the compiler, rejected by the preprocessor!" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: dlfcn.h: proceeding with the compiler's result" >&5
-$as_echo "$as_me: WARNING: dlfcn.h: proceeding with the compiler's result" >&2;}
-    ac_header_preproc=yes
-    ;;
-  no:yes:* )
-    { $as_echo "$as_me:$LINENO: WARNING: dlfcn.h: present but cannot be compiled" >&5
-$as_echo "$as_me: WARNING: dlfcn.h: present but cannot be compiled" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: dlfcn.h:     check for missing prerequisite headers?" >&5
-$as_echo "$as_me: WARNING: dlfcn.h:     check for missing prerequisite headers?" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: dlfcn.h: see the Autoconf documentation" >&5
-$as_echo "$as_me: WARNING: dlfcn.h: see the Autoconf documentation" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: dlfcn.h:     section \"Present But Cannot Be Compiled\"" >&5
-$as_echo "$as_me: WARNING: dlfcn.h:     section \"Present But Cannot Be Compiled\"" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: dlfcn.h: proceeding with the preprocessor's result" >&5
-$as_echo "$as_me: WARNING: dlfcn.h: proceeding with the preprocessor's result" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: dlfcn.h: in the future, the compiler will take precedence" >&5
-$as_echo "$as_me: WARNING: dlfcn.h: in the future, the compiler will take precedence" >&2;}
-
-    ;;
-esac
-{ $as_echo "$as_me:$LINENO: checking for dlfcn.h" >&5
-$as_echo_n "checking for dlfcn.h... " >&6; }
-if test "${ac_cv_header_dlfcn_h+set}" = set; then
-  $as_echo_n "(cached) " >&6
-else
-  ac_cv_header_dlfcn_h=$ac_header_preproc
-fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_header_dlfcn_h" >&5
-$as_echo "$ac_cv_header_dlfcn_h" >&6; }
-
-fi
-if test "x$ac_cv_header_dlfcn_h" = x""yes; then
-  DYNAMIC_LINKER=simple
-fi
-
-
-if test $DYNAMIC_LINKER = null; then
-  if test "${ac_cv_header_dl_h+set}" = set; then
-  { $as_echo "$as_me:$LINENO: checking for dl.h" >&5
-$as_echo_n "checking for dl.h... " >&6; }
-if test "${ac_cv_header_dl_h+set}" = set; then
-  $as_echo_n "(cached) " >&6
-fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_header_dl_h" >&5
-$as_echo "$ac_cv_header_dl_h" >&6; }
-else
-  # Is the header compilable?
-{ $as_echo "$as_me:$LINENO: checking dl.h usability" >&5
-$as_echo_n "checking dl.h usability... " >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-#include <dl.h>
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_header_compiler=yes
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_header_compiler=no
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-{ $as_echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
-$as_echo "$ac_header_compiler" >&6; }
-
-# Is the header present?
-{ $as_echo "$as_me:$LINENO: checking dl.h presence" >&5
-$as_echo_n "checking dl.h presence... " >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <dl.h>
-_ACEOF
-if { (ac_try="$ac_cpp conftest.$ac_ext"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } >/dev/null && {
-	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       }; then
-  ac_header_preproc=yes
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-  ac_header_preproc=no
-fi
-
-rm -f conftest.err conftest.$ac_ext
-{ $as_echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
-$as_echo "$ac_header_preproc" >&6; }
-
-# So?  What about this header?
-case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
-  yes:no: )
-    { $as_echo "$as_me:$LINENO: WARNING: dl.h: accepted by the compiler, rejected by the preprocessor!" >&5
-$as_echo "$as_me: WARNING: dl.h: accepted by the compiler, rejected by the preprocessor!" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: dl.h: proceeding with the compiler's result" >&5
-$as_echo "$as_me: WARNING: dl.h: proceeding with the compiler's result" >&2;}
-    ac_header_preproc=yes
-    ;;
-  no:yes:* )
-    { $as_echo "$as_me:$LINENO: WARNING: dl.h: present but cannot be compiled" >&5
-$as_echo "$as_me: WARNING: dl.h: present but cannot be compiled" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: dl.h:     check for missing prerequisite headers?" >&5
-$as_echo "$as_me: WARNING: dl.h:     check for missing prerequisite headers?" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: dl.h: see the Autoconf documentation" >&5
-$as_echo "$as_me: WARNING: dl.h: see the Autoconf documentation" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: dl.h:     section \"Present But Cannot Be Compiled\"" >&5
-$as_echo "$as_me: WARNING: dl.h:     section \"Present But Cannot Be Compiled\"" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: dl.h: proceeding with the preprocessor's result" >&5
-$as_echo "$as_me: WARNING: dl.h: proceeding with the preprocessor's result" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: dl.h: in the future, the compiler will take precedence" >&5
-$as_echo "$as_me: WARNING: dl.h: in the future, the compiler will take precedence" >&2;}
-
-    ;;
-esac
-{ $as_echo "$as_me:$LINENO: checking for dl.h" >&5
-$as_echo_n "checking for dl.h... " >&6; }
-if test "${ac_cv_header_dl_h+set}" = set; then
-  $as_echo_n "(cached) " >&6
-else
-  ac_cv_header_dl_h=$ac_header_preproc
-fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_header_dl_h" >&5
-$as_echo "$ac_cv_header_dl_h" >&6; }
-
-fi
-if test "x$ac_cv_header_dl_h" = x""yes; then
-  DYNAMIC_LINKER=hpux
-fi
-
-
-fi
-if test $DYNAMIC_LINKER = null; then
-  if test "${ac_cv_header_windows_h+set}" = set; then
-  { $as_echo "$as_me:$LINENO: checking for windows.h" >&5
-$as_echo_n "checking for windows.h... " >&6; }
-if test "${ac_cv_header_windows_h+set}" = set; then
-  $as_echo_n "(cached) " >&6
-fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_header_windows_h" >&5
-$as_echo "$ac_cv_header_windows_h" >&6; }
-else
-  # Is the header compilable?
-{ $as_echo "$as_me:$LINENO: checking windows.h usability" >&5
-$as_echo_n "checking windows.h usability... " >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-#include <windows.h>
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_header_compiler=yes
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_header_compiler=no
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-{ $as_echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
-$as_echo "$ac_header_compiler" >&6; }
-
-# Is the header present?
-{ $as_echo "$as_me:$LINENO: checking windows.h presence" >&5
-$as_echo_n "checking windows.h presence... " >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <windows.h>
-_ACEOF
-if { (ac_try="$ac_cpp conftest.$ac_ext"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } >/dev/null && {
-	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       }; then
-  ac_header_preproc=yes
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-  ac_header_preproc=no
-fi
-
-rm -f conftest.err conftest.$ac_ext
-{ $as_echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
-$as_echo "$ac_header_preproc" >&6; }
-
-# So?  What about this header?
-case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
-  yes:no: )
-    { $as_echo "$as_me:$LINENO: WARNING: windows.h: accepted by the compiler, rejected by the preprocessor!" >&5
-$as_echo "$as_me: WARNING: windows.h: accepted by the compiler, rejected by the preprocessor!" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: windows.h: proceeding with the compiler's result" >&5
-$as_echo "$as_me: WARNING: windows.h: proceeding with the compiler's result" >&2;}
-    ac_header_preproc=yes
-    ;;
-  no:yes:* )
-    { $as_echo "$as_me:$LINENO: WARNING: windows.h: present but cannot be compiled" >&5
-$as_echo "$as_me: WARNING: windows.h: present but cannot be compiled" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: windows.h:     check for missing prerequisite headers?" >&5
-$as_echo "$as_me: WARNING: windows.h:     check for missing prerequisite headers?" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: windows.h: see the Autoconf documentation" >&5
-$as_echo "$as_me: WARNING: windows.h: see the Autoconf documentation" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: windows.h:     section \"Present But Cannot Be Compiled\"" >&5
-$as_echo "$as_me: WARNING: windows.h:     section \"Present But Cannot Be Compiled\"" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: windows.h: proceeding with the preprocessor's result" >&5
-$as_echo "$as_me: WARNING: windows.h: proceeding with the preprocessor's result" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: windows.h: in the future, the compiler will take precedence" >&5
-$as_echo "$as_me: WARNING: windows.h: in the future, the compiler will take precedence" >&2;}
-
-    ;;
-esac
-{ $as_echo "$as_me:$LINENO: checking for windows.h" >&5
-$as_echo_n "checking for windows.h... " >&6; }
-if test "${ac_cv_header_windows_h+set}" = set; then
-  $as_echo_n "(cached) " >&6
-else
-  ac_cv_header_windows_h=$ac_header_preproc
-fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_header_windows_h" >&5
-$as_echo "$ac_cv_header_windows_h" >&6; }
-
-fi
-if test "x$ac_cv_header_windows_h" = x""yes; then
-  DYNAMIC_LINKER=win32
-fi
-
-
-fi
-if test $DYNAMIC_LINKER = null; then
-  if test "${ac_cv_header_dld_defs_h+set}" = set; then
-  { $as_echo "$as_me:$LINENO: checking for dld/defs.h" >&5
-$as_echo_n "checking for dld/defs.h... " >&6; }
-if test "${ac_cv_header_dld_defs_h+set}" = set; then
-  $as_echo_n "(cached) " >&6
-fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_header_dld_defs_h" >&5
-$as_echo "$ac_cv_header_dld_defs_h" >&6; }
-else
-  # Is the header compilable?
-{ $as_echo "$as_me:$LINENO: checking dld/defs.h usability" >&5
-$as_echo_n "checking dld/defs.h usability... " >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-#include <dld/defs.h>
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_header_compiler=yes
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_header_compiler=no
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-{ $as_echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
-$as_echo "$ac_header_compiler" >&6; }
-
-# Is the header present?
-{ $as_echo "$as_me:$LINENO: checking dld/defs.h presence" >&5
-$as_echo_n "checking dld/defs.h presence... " >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <dld/defs.h>
-_ACEOF
-if { (ac_try="$ac_cpp conftest.$ac_ext"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } >/dev/null && {
-	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       }; then
-  ac_header_preproc=yes
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-  ac_header_preproc=no
-fi
-
-rm -f conftest.err conftest.$ac_ext
-{ $as_echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
-$as_echo "$ac_header_preproc" >&6; }
-
-# So?  What about this header?
-case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
-  yes:no: )
-    { $as_echo "$as_me:$LINENO: WARNING: dld/defs.h: accepted by the compiler, rejected by the preprocessor!" >&5
-$as_echo "$as_me: WARNING: dld/defs.h: accepted by the compiler, rejected by the preprocessor!" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: dld/defs.h: proceeding with the compiler's result" >&5
-$as_echo "$as_me: WARNING: dld/defs.h: proceeding with the compiler's result" >&2;}
-    ac_header_preproc=yes
-    ;;
-  no:yes:* )
-    { $as_echo "$as_me:$LINENO: WARNING: dld/defs.h: present but cannot be compiled" >&5
-$as_echo "$as_me: WARNING: dld/defs.h: present but cannot be compiled" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: dld/defs.h:     check for missing prerequisite headers?" >&5
-$as_echo "$as_me: WARNING: dld/defs.h:     check for missing prerequisite headers?" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: dld/defs.h: see the Autoconf documentation" >&5
-$as_echo "$as_me: WARNING: dld/defs.h: see the Autoconf documentation" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: dld/defs.h:     section \"Present But Cannot Be Compiled\"" >&5
-$as_echo "$as_me: WARNING: dld/defs.h:     section \"Present But Cannot Be Compiled\"" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: dld/defs.h: proceeding with the preprocessor's result" >&5
-$as_echo "$as_me: WARNING: dld/defs.h: proceeding with the preprocessor's result" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: dld/defs.h: in the future, the compiler will take precedence" >&5
-$as_echo "$as_me: WARNING: dld/defs.h: in the future, the compiler will take precedence" >&2;}
-
-    ;;
-esac
-{ $as_echo "$as_me:$LINENO: checking for dld/defs.h" >&5
-$as_echo_n "checking for dld/defs.h... " >&6; }
-if test "${ac_cv_header_dld_defs_h+set}" = set; then
-  $as_echo_n "(cached) " >&6
-else
-  ac_cv_header_dld_defs_h=$ac_header_preproc
-fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_header_dld_defs_h" >&5
-$as_echo "$ac_cv_header_dld_defs_h" >&6; }
-
-fi
-if test "x$ac_cv_header_dld_defs_h" = x""yes; then
-  DYNAMIC_LINKER=dld
-fi
-
-
-fi
-
-# NB: This is used as follows: in Source/Makefile.postamble we copy
-# $(DYNAMIC_LINKER)-load.h into dynamic-load.h
-{ $as_echo "$as_me:$LINENO: checking for dynamic linker type" >&5
-$as_echo_n "checking for dynamic linker type... " >&6; }
-{ $as_echo "$as_me:$LINENO: result: $DYNAMIC_LINKER" >&5
-$as_echo "$DYNAMIC_LINKER" >&6; }
-
-if test $DYNAMIC_LINKER = simple; then
-
-{ $as_echo "$as_me:$LINENO: checking for dladdr in -ldl" >&5
-$as_echo_n "checking for dladdr in -ldl... " >&6; }
-if test "${ac_cv_lib_dl_dladdr+set}" = set; then
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-ldl  $LIBS"
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char dladdr ();
-int
-main ()
-{
-return dladdr ();
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then
-  ac_cv_lib_dl_dladdr=yes
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_cv_lib_dl_dladdr=no
-fi
-
-rm -rf conftest.dSYM
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_lib_dl_dladdr" >&5
-$as_echo "$ac_cv_lib_dl_dladdr" >&6; }
-if test "x$ac_cv_lib_dl_dladdr" = x""yes; then
-  cat >>confdefs.h <<_ACEOF
-#define HAVE_LIBDL 1
-_ACEOF
-
-  LIBS="-ldl $LIBS"
-
-fi
-
-fi
-
-
-# NOTE: libdl should be in LIBS now if it's available.
-
-for ac_func in dladdr
-do
-as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
-{ $as_echo "$as_me:$LINENO: checking for $ac_func" >&5
-$as_echo_n "checking for $ac_func... " >&6; }
-if { as_var=$as_ac_var; eval "test \"\${$as_var+set}\" = set"; }; then
-  $as_echo_n "(cached) " >&6
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.
-   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
-#define $ac_func innocuous_$ac_func
-
-/* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char $ac_func (); below.
-    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-    <limits.h> exists even on freestanding compilers.  */
-
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
-
-#undef $ac_func
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char $ac_func ();
-/* The GNU C library defines this for functions which it implements
-    to always fail with ENOSYS.  Some functions are actually named
-    something starting with __ and the normal name is an alias.  */
-#if defined __stub_$ac_func || defined __stub___$ac_func
-choke me
-#endif
-
-int
-main ()
-{
-return $ac_func ();
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then
-  eval "$as_ac_var=yes"
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	eval "$as_ac_var=no"
-fi
-
-rm -rf conftest.dSYM
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
-fi
-ac_res=`eval 'as_val=${'$as_ac_var'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-as_val=`eval 'as_val=${'$as_ac_var'}
-		 $as_echo "$as_val"'`
-   if test "x$as_val" = x""yes; then
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
-_ACEOF
-
-fi
-done
-
-
-
-for ac_func in gethostbyname
-do
-as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
-{ $as_echo "$as_me:$LINENO: checking for $ac_func" >&5
-$as_echo_n "checking for $ac_func... " >&6; }
-if { as_var=$as_ac_var; eval "test \"\${$as_var+set}\" = set"; }; then
-  $as_echo_n "(cached) " >&6
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.
-   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
-#define $ac_func innocuous_$ac_func
-
-/* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char $ac_func (); below.
-    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-    <limits.h> exists even on freestanding compilers.  */
-
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
-
-#undef $ac_func
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char $ac_func ();
-/* The GNU C library defines this for functions which it implements
-    to always fail with ENOSYS.  Some functions are actually named
-    something starting with __ and the normal name is an alias.  */
-#if defined __stub_$ac_func || defined __stub___$ac_func
-choke me
-#endif
-
-int
-main ()
-{
-return $ac_func ();
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then
-  eval "$as_ac_var=yes"
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	eval "$as_ac_var=no"
-fi
-
-rm -rf conftest.dSYM
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
-fi
-ac_res=`eval 'as_val=${'$as_ac_var'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-as_val=`eval 'as_val=${'$as_ac_var'}
-		 $as_echo "$as_val"'`
-   if test "x$as_val" = x""yes; then
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
-_ACEOF
-
-fi
-done
-
-if test "$ac_cv_func_gethostbyname" = "no"; then
-  # QNX has gethostbyname and friends in libsocket
-
-{ $as_echo "$as_me:$LINENO: checking for gethostbyname in -lsocket" >&5
-$as_echo_n "checking for gethostbyname in -lsocket... " >&6; }
-if test "${ac_cv_lib_socket_gethostbyname+set}" = set; then
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-lsocket  $LIBS"
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char gethostbyname ();
-int
-main ()
-{
-return gethostbyname ();
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then
-  ac_cv_lib_socket_gethostbyname=yes
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_cv_lib_socket_gethostbyname=no
-fi
-
-rm -rf conftest.dSYM
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_lib_socket_gethostbyname" >&5
-$as_echo "$ac_cv_lib_socket_gethostbyname" >&6; }
-if test "x$ac_cv_lib_socket_gethostbyname" = x""yes; then
-  cat >>confdefs.h <<_ACEOF
-#define HAVE_LIBSOCKET 1
-_ACEOF
-
-  LIBS="-lsocket $LIBS"
-
-fi
-
-fi
-
-#--------------------------------------------------------------------
-# Check for pthread.h
-#--------------------------------------------------------------------
-
-for ac_header in pthread.h
-do
-as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  { $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
-$as_echo_n "checking for $ac_header... " >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  $as_echo_n "(cached) " >&6
-fi
-ac_res=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-else
-  # Is the header compilable?
-{ $as_echo "$as_me:$LINENO: checking $ac_header usability" >&5
-$as_echo_n "checking $ac_header usability... " >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-#include <$ac_header>
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_header_compiler=yes
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_header_compiler=no
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-{ $as_echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
-$as_echo "$ac_header_compiler" >&6; }
-
-# Is the header present?
-{ $as_echo "$as_me:$LINENO: checking $ac_header presence" >&5
-$as_echo_n "checking $ac_header presence... " >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <$ac_header>
-_ACEOF
-if { (ac_try="$ac_cpp conftest.$ac_ext"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } >/dev/null && {
-	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       }; then
-  ac_header_preproc=yes
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-  ac_header_preproc=no
-fi
-
-rm -f conftest.err conftest.$ac_ext
-{ $as_echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
-$as_echo "$ac_header_preproc" >&6; }
-
-# So?  What about this header?
-case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
-  yes:no: )
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
-$as_echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the compiler's result" >&5
-$as_echo "$as_me: WARNING: $ac_header: proceeding with the compiler's result" >&2;}
-    ac_header_preproc=yes
-    ;;
-  no:yes:* )
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
-$as_echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header:     check for missing prerequisite headers?" >&5
-$as_echo "$as_me: WARNING: $ac_header:     check for missing prerequisite headers?" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: see the Autoconf documentation" >&5
-$as_echo "$as_me: WARNING: $ac_header: see the Autoconf documentation" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&5
-$as_echo "$as_me: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
-$as_echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: in the future, the compiler will take precedence" >&5
-$as_echo "$as_me: WARNING: $ac_header: in the future, the compiler will take precedence" >&2;}
-
-    ;;
-esac
-{ $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
-$as_echo_n "checking for $ac_header... " >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  $as_echo_n "(cached) " >&6
-else
-  eval "$as_ac_Header=\$ac_header_preproc"
-fi
-ac_res=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-
-fi
-as_val=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-   if test "x$as_val" = x""yes; then
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
-_ACEOF
-
-fi
-
-done
-
-if test $ac_cv_header_pthread_h = yes ; then
-  # The cast to long int works around a bug in the HP C Compiler
-# version HP92453-01 B.11.11.23709.GP, which incorrectly rejects
-# declarations like `int a3[[(sizeof (unsigned char)) >= 0]];'.
-# This bug is HP SR number 8606223364.
-{ $as_echo "$as_me:$LINENO: checking size of pthread_mutex_t" >&5
-$as_echo_n "checking size of pthread_mutex_t... " >&6; }
-if test "${ac_cv_sizeof_pthread_mutex_t+set}" = set; then
-  $as_echo_n "(cached) " >&6
-else
-  if test "$cross_compiling" = yes; then
-  # Depending upon the size, compute the lo and hi bounds.
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-#include <pthread.h>
-
-int
-main ()
-{
-static int test_array [1 - 2 * !(((long int) (sizeof (pthread_mutex_t))) >= 0)];
-test_array [0] = 0
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_lo=0 ac_mid=0
-  while :; do
-    cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-#include <pthread.h>
-
-int
-main ()
-{
-static int test_array [1 - 2 * !(((long int) (sizeof (pthread_mutex_t))) <= $ac_mid)];
-test_array [0] = 0
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_hi=$ac_mid; break
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_lo=`expr $ac_mid + 1`
-			if test $ac_lo -le $ac_mid; then
-			  ac_lo= ac_hi=
-			  break
-			fi
-			ac_mid=`expr 2 '*' $ac_mid + 1`
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-  done
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-#include <pthread.h>
-
-int
-main ()
-{
-static int test_array [1 - 2 * !(((long int) (sizeof (pthread_mutex_t))) < 0)];
-test_array [0] = 0
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_hi=-1 ac_mid=-1
-  while :; do
-    cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-#include <pthread.h>
-
-int
-main ()
-{
-static int test_array [1 - 2 * !(((long int) (sizeof (pthread_mutex_t))) >= $ac_mid)];
-test_array [0] = 0
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_lo=$ac_mid; break
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_hi=`expr '(' $ac_mid ')' - 1`
-			if test $ac_mid -le $ac_hi; then
-			  ac_lo= ac_hi=
-			  break
-			fi
-			ac_mid=`expr 2 '*' $ac_mid`
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-  done
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_lo= ac_hi=
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-# Binary search between lo and hi bounds.
-while test "x$ac_lo" != "x$ac_hi"; do
-  ac_mid=`expr '(' $ac_hi - $ac_lo ')' / 2 + $ac_lo`
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-#include <pthread.h>
-
-int
-main ()
-{
-static int test_array [1 - 2 * !(((long int) (sizeof (pthread_mutex_t))) <= $ac_mid)];
-test_array [0] = 0
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_hi=$ac_mid
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_lo=`expr '(' $ac_mid ')' + 1`
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-done
-case $ac_lo in
-?*) ac_cv_sizeof_pthread_mutex_t=$ac_lo;;
-'') if test "$ac_cv_type_pthread_mutex_t" = yes; then
-     { { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
-$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-{ { $as_echo "$as_me:$LINENO: error: cannot compute sizeof (pthread_mutex_t)
-See \`config.log' for more details." >&5
-$as_echo "$as_me: error: cannot compute sizeof (pthread_mutex_t)
-See \`config.log' for more details." >&2;}
-   { (exit 77); exit 77; }; }; }
-   else
-     ac_cv_sizeof_pthread_mutex_t=0
-   fi ;;
-esac
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-#include <pthread.h>
-
-static long int longval () { return (long int) (sizeof (pthread_mutex_t)); }
-static unsigned long int ulongval () { return (long int) (sizeof (pthread_mutex_t)); }
-#include <stdio.h>
-#include <stdlib.h>
-int
-main ()
-{
-
-  FILE *f = fopen ("conftest.val", "w");
-  if (! f)
-    return 1;
-  if (((long int) (sizeof (pthread_mutex_t))) < 0)
-    {
-      long int i = longval ();
-      if (i != ((long int) (sizeof (pthread_mutex_t))))
-	return 1;
-      fprintf (f, "%ld", i);
-    }
-  else
-    {
-      unsigned long int i = ulongval ();
-      if (i != ((long int) (sizeof (pthread_mutex_t))))
-	return 1;
-      fprintf (f, "%lu", i);
-    }
-  /* Do not output a trailing newline, as this causes \r\n confusion
-     on some platforms.  */
-  return ferror (f) || fclose (f) != 0;
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_cv_sizeof_pthread_mutex_t=`cat conftest.val`
-else
-  $as_echo "$as_me: program exited with status $ac_status" >&5
-$as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-( exit $ac_status )
-if test "$ac_cv_type_pthread_mutex_t" = yes; then
-     { { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
-$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-{ { $as_echo "$as_me:$LINENO: error: cannot compute sizeof (pthread_mutex_t)
-See \`config.log' for more details." >&5
-$as_echo "$as_me: error: cannot compute sizeof (pthread_mutex_t)
-See \`config.log' for more details." >&2;}
-   { (exit 77); exit 77; }; }; }
-   else
-     ac_cv_sizeof_pthread_mutex_t=0
-   fi
-fi
-rm -rf conftest.dSYM
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
-fi
-rm -f conftest.val
-fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_sizeof_pthread_mutex_t" >&5
-$as_echo "$ac_cv_sizeof_pthread_mutex_t" >&6; }
-
-
-
-cat >>confdefs.h <<_ACEOF
-#define SIZEOF_PTHREAD_MUTEX_T $ac_cv_sizeof_pthread_mutex_t
-_ACEOF
-
-
-  GS_SIZEOF_MUTEX_T=$ac_cv_sizeof_pthread_mutex_t
-  if test $ac_cv_sizeof_pthread_mutex_t = 0 ; then
-    { { $as_echo "$as_me:$LINENO: error: Unable to find size of pthread_mutex_t (required)." >&5
-$as_echo "$as_me: error: Unable to find size of pthread_mutex_t (required)." >&2;}
-   { (exit 1); exit 1; }; }
-  fi
-
-  # The cast to long int works around a bug in the HP C Compiler
-# version HP92453-01 B.11.11.23709.GP, which incorrectly rejects
-# declarations like `int a3[[(sizeof (unsigned char)) >= 0]];'.
-# This bug is HP SR number 8606223364.
-{ $as_echo "$as_me:$LINENO: checking size of pthread_cond_t" >&5
-$as_echo_n "checking size of pthread_cond_t... " >&6; }
-if test "${ac_cv_sizeof_pthread_cond_t+set}" = set; then
-  $as_echo_n "(cached) " >&6
-else
-  if test "$cross_compiling" = yes; then
-  # Depending upon the size, compute the lo and hi bounds.
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-#include <pthread.h>
-
-int
-main ()
-{
-static int test_array [1 - 2 * !(((long int) (sizeof (pthread_cond_t))) >= 0)];
-test_array [0] = 0
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_lo=0 ac_mid=0
-  while :; do
-    cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-#include <pthread.h>
-
-int
-main ()
-{
-static int test_array [1 - 2 * !(((long int) (sizeof (pthread_cond_t))) <= $ac_mid)];
-test_array [0] = 0
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_hi=$ac_mid; break
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_lo=`expr $ac_mid + 1`
-			if test $ac_lo -le $ac_mid; then
-			  ac_lo= ac_hi=
-			  break
-			fi
-			ac_mid=`expr 2 '*' $ac_mid + 1`
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-  done
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-#include <pthread.h>
-
-int
-main ()
-{
-static int test_array [1 - 2 * !(((long int) (sizeof (pthread_cond_t))) < 0)];
-test_array [0] = 0
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_hi=-1 ac_mid=-1
-  while :; do
-    cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-#include <pthread.h>
-
-int
-main ()
-{
-static int test_array [1 - 2 * !(((long int) (sizeof (pthread_cond_t))) >= $ac_mid)];
-test_array [0] = 0
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_lo=$ac_mid; break
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_hi=`expr '(' $ac_mid ')' - 1`
-			if test $ac_mid -le $ac_hi; then
-			  ac_lo= ac_hi=
-			  break
-			fi
-			ac_mid=`expr 2 '*' $ac_mid`
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-  done
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_lo= ac_hi=
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-# Binary search between lo and hi bounds.
-while test "x$ac_lo" != "x$ac_hi"; do
-  ac_mid=`expr '(' $ac_hi - $ac_lo ')' / 2 + $ac_lo`
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-#include <pthread.h>
-
-int
-main ()
-{
-static int test_array [1 - 2 * !(((long int) (sizeof (pthread_cond_t))) <= $ac_mid)];
-test_array [0] = 0
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_hi=$ac_mid
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_lo=`expr '(' $ac_mid ')' + 1`
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-done
-case $ac_lo in
-?*) ac_cv_sizeof_pthread_cond_t=$ac_lo;;
-'') if test "$ac_cv_type_pthread_cond_t" = yes; then
-     { { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
-$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-{ { $as_echo "$as_me:$LINENO: error: cannot compute sizeof (pthread_cond_t)
-See \`config.log' for more details." >&5
-$as_echo "$as_me: error: cannot compute sizeof (pthread_cond_t)
-See \`config.log' for more details." >&2;}
-   { (exit 77); exit 77; }; }; }
-   else
-     ac_cv_sizeof_pthread_cond_t=0
-   fi ;;
-esac
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-#include <pthread.h>
-
-static long int longval () { return (long int) (sizeof (pthread_cond_t)); }
-static unsigned long int ulongval () { return (long int) (sizeof (pthread_cond_t)); }
-#include <stdio.h>
-#include <stdlib.h>
-int
-main ()
-{
-
-  FILE *f = fopen ("conftest.val", "w");
-  if (! f)
-    return 1;
-  if (((long int) (sizeof (pthread_cond_t))) < 0)
-    {
-      long int i = longval ();
-      if (i != ((long int) (sizeof (pthread_cond_t))))
-	return 1;
-      fprintf (f, "%ld", i);
-    }
-  else
-    {
-      unsigned long int i = ulongval ();
-      if (i != ((long int) (sizeof (pthread_cond_t))))
-	return 1;
-      fprintf (f, "%lu", i);
-    }
-  /* Do not output a trailing newline, as this causes \r\n confusion
-     on some platforms.  */
-  return ferror (f) || fclose (f) != 0;
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_cv_sizeof_pthread_cond_t=`cat conftest.val`
-else
-  $as_echo "$as_me: program exited with status $ac_status" >&5
-$as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-( exit $ac_status )
-if test "$ac_cv_type_pthread_cond_t" = yes; then
-     { { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
-$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-{ { $as_echo "$as_me:$LINENO: error: cannot compute sizeof (pthread_cond_t)
-See \`config.log' for more details." >&5
-$as_echo "$as_me: error: cannot compute sizeof (pthread_cond_t)
-See \`config.log' for more details." >&2;}
-   { (exit 77); exit 77; }; }; }
-   else
-     ac_cv_sizeof_pthread_cond_t=0
-   fi
-fi
-rm -rf conftest.dSYM
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
-fi
-rm -f conftest.val
-fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_sizeof_pthread_cond_t" >&5
-$as_echo "$ac_cv_sizeof_pthread_cond_t" >&6; }
-
-
-
-cat >>confdefs.h <<_ACEOF
-#define SIZEOF_PTHREAD_COND_T $ac_cv_sizeof_pthread_cond_t
-_ACEOF
-
-
-  if test $ac_cv_sizeof_pthread_cond_t = 0 ; then
-    { { $as_echo "$as_me:$LINENO: error: Unable to find size of pthread_cond_t (required)." >&5
-$as_echo "$as_me: error: Unable to find size of pthread_cond_t (required)." >&2;}
-   { (exit 1); exit 1; }; }
-  fi
-  GS_SIZEOF_COND_T=$ac_cv_sizeof_pthread_cond_t
-
-  # The cast to long int works around a bug in the HP C Compiler,
-# see AC_CHECK_SIZEOF for more information.
-{ $as_echo "$as_me:$LINENO: checking alignment of pthread_mutex_t" >&5
-$as_echo_n "checking alignment of pthread_mutex_t... " >&6; }
-if test "${ac_cv_alignof_pthread_mutex_t+set}" = set; then
-  $as_echo_n "(cached) " >&6
-else
-  if test "$cross_compiling" = yes; then
-  # Depending upon the size, compute the lo and hi bounds.
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-#include <pthread.h>
-
-#ifndef offsetof
-# define offsetof(type, member) ((char *) &((type *) 0)->member - (char *) 0)
-#endif
-typedef struct { char x; pthread_mutex_t y; } ac__type_alignof_;
-int
-main ()
-{
-static int test_array [1 - 2 * !(((long int) offsetof (ac__type_alignof_, y)) >= 0)];
-test_array [0] = 0
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_lo=0 ac_mid=0
-  while :; do
-    cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-#include <pthread.h>
-
-#ifndef offsetof
-# define offsetof(type, member) ((char *) &((type *) 0)->member - (char *) 0)
-#endif
-typedef struct { char x; pthread_mutex_t y; } ac__type_alignof_;
-int
-main ()
-{
-static int test_array [1 - 2 * !(((long int) offsetof (ac__type_alignof_, y)) <= $ac_mid)];
-test_array [0] = 0
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_hi=$ac_mid; break
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_lo=`expr $ac_mid + 1`
-			if test $ac_lo -le $ac_mid; then
-			  ac_lo= ac_hi=
-			  break
-			fi
-			ac_mid=`expr 2 '*' $ac_mid + 1`
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-  done
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-#include <pthread.h>
-
-#ifndef offsetof
-# define offsetof(type, member) ((char *) &((type *) 0)->member - (char *) 0)
-#endif
-typedef struct { char x; pthread_mutex_t y; } ac__type_alignof_;
-int
-main ()
-{
-static int test_array [1 - 2 * !(((long int) offsetof (ac__type_alignof_, y)) < 0)];
-test_array [0] = 0
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_hi=-1 ac_mid=-1
-  while :; do
-    cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-#include <pthread.h>
-
-#ifndef offsetof
-# define offsetof(type, member) ((char *) &((type *) 0)->member - (char *) 0)
-#endif
-typedef struct { char x; pthread_mutex_t y; } ac__type_alignof_;
-int
-main ()
-{
-static int test_array [1 - 2 * !(((long int) offsetof (ac__type_alignof_, y)) >= $ac_mid)];
-test_array [0] = 0
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_lo=$ac_mid; break
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_hi=`expr '(' $ac_mid ')' - 1`
-			if test $ac_mid -le $ac_hi; then
-			  ac_lo= ac_hi=
-			  break
-			fi
-			ac_mid=`expr 2 '*' $ac_mid`
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-  done
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_lo= ac_hi=
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-# Binary search between lo and hi bounds.
-while test "x$ac_lo" != "x$ac_hi"; do
-  ac_mid=`expr '(' $ac_hi - $ac_lo ')' / 2 + $ac_lo`
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-#include <pthread.h>
-
-#ifndef offsetof
-# define offsetof(type, member) ((char *) &((type *) 0)->member - (char *) 0)
-#endif
-typedef struct { char x; pthread_mutex_t y; } ac__type_alignof_;
-int
-main ()
-{
-static int test_array [1 - 2 * !(((long int) offsetof (ac__type_alignof_, y)) <= $ac_mid)];
-test_array [0] = 0
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_hi=$ac_mid
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_lo=`expr '(' $ac_mid ')' + 1`
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-done
-case $ac_lo in
-?*) ac_cv_alignof_pthread_mutex_t=$ac_lo;;
-'') if test "$ac_cv_type_pthread_mutex_t" = yes; then
-     { { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
-$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-{ { $as_echo "$as_me:$LINENO: error: cannot compute alignment of pthread_mutex_t
-See \`config.log' for more details." >&5
-$as_echo "$as_me: error: cannot compute alignment of pthread_mutex_t
-See \`config.log' for more details." >&2;}
-   { (exit 77); exit 77; }; }; }
-   else
-     ac_cv_alignof_pthread_mutex_t=0
-   fi ;;
-esac
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-#include <pthread.h>
-
-#ifndef offsetof
-# define offsetof(type, member) ((char *) &((type *) 0)->member - (char *) 0)
-#endif
-typedef struct { char x; pthread_mutex_t y; } ac__type_alignof_;
-static long int longval () { return (long int) offsetof (ac__type_alignof_, y); }
-static unsigned long int ulongval () { return (long int) offsetof (ac__type_alignof_, y); }
-#include <stdio.h>
-#include <stdlib.h>
-int
-main ()
-{
-
-  FILE *f = fopen ("conftest.val", "w");
-  if (! f)
-    return 1;
-  if (((long int) offsetof (ac__type_alignof_, y)) < 0)
-    {
-      long int i = longval ();
-      if (i != ((long int) offsetof (ac__type_alignof_, y)))
-	return 1;
-      fprintf (f, "%ld", i);
-    }
-  else
-    {
-      unsigned long int i = ulongval ();
-      if (i != ((long int) offsetof (ac__type_alignof_, y)))
-	return 1;
-      fprintf (f, "%lu", i);
-    }
-  /* Do not output a trailing newline, as this causes \r\n confusion
-     on some platforms.  */
-  return ferror (f) || fclose (f) != 0;
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_cv_alignof_pthread_mutex_t=`cat conftest.val`
-else
-  $as_echo "$as_me: program exited with status $ac_status" >&5
-$as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-( exit $ac_status )
-if test "$ac_cv_type_pthread_mutex_t" = yes; then
-     { { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
-$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-{ { $as_echo "$as_me:$LINENO: error: cannot compute alignment of pthread_mutex_t
-See \`config.log' for more details." >&5
-$as_echo "$as_me: error: cannot compute alignment of pthread_mutex_t
-See \`config.log' for more details." >&2;}
-   { (exit 77); exit 77; }; }; }
-   else
-     ac_cv_alignof_pthread_mutex_t=0
-   fi
-fi
-rm -rf conftest.dSYM
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
-fi
-rm -f conftest.val
-fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_alignof_pthread_mutex_t" >&5
-$as_echo "$ac_cv_alignof_pthread_mutex_t" >&6; }
-
-
-
-cat >>confdefs.h <<_ACEOF
-#define ALIGNOF_PTHREAD_MUTEX_T $ac_cv_alignof_pthread_mutex_t
-_ACEOF
-
-
-  GS_ALIGNOF_MUTEX_T=$ac_cv_alignof_pthread_mutex_t
-  if test $ac_cv_alignof_pthread_mutex_t = 0 ; then
-    { { $as_echo "$as_me:$LINENO: error: Unable to find align of pthread_mutex_t (required)." >&5
-$as_echo "$as_me: error: Unable to find align of pthread_mutex_t (required)." >&2;}
-   { (exit 1); exit 1; }; }
-  fi
-
-  # The cast to long int works around a bug in the HP C Compiler,
-# see AC_CHECK_SIZEOF for more information.
-{ $as_echo "$as_me:$LINENO: checking alignment of pthread_cond_t" >&5
-$as_echo_n "checking alignment of pthread_cond_t... " >&6; }
-if test "${ac_cv_alignof_pthread_cond_t+set}" = set; then
-  $as_echo_n "(cached) " >&6
-else
-  if test "$cross_compiling" = yes; then
-  # Depending upon the size, compute the lo and hi bounds.
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-#include <pthread.h>
-
-#ifndef offsetof
-# define offsetof(type, member) ((char *) &((type *) 0)->member - (char *) 0)
-#endif
-typedef struct { char x; pthread_cond_t y; } ac__type_alignof_;
-int
-main ()
-{
-static int test_array [1 - 2 * !(((long int) offsetof (ac__type_alignof_, y)) >= 0)];
-test_array [0] = 0
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_lo=0 ac_mid=0
-  while :; do
-    cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-#include <pthread.h>
-
-#ifndef offsetof
-# define offsetof(type, member) ((char *) &((type *) 0)->member - (char *) 0)
-#endif
-typedef struct { char x; pthread_cond_t y; } ac__type_alignof_;
-int
-main ()
-{
-static int test_array [1 - 2 * !(((long int) offsetof (ac__type_alignof_, y)) <= $ac_mid)];
-test_array [0] = 0
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_hi=$ac_mid; break
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_lo=`expr $ac_mid + 1`
-			if test $ac_lo -le $ac_mid; then
-			  ac_lo= ac_hi=
-			  break
-			fi
-			ac_mid=`expr 2 '*' $ac_mid + 1`
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-  done
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-#include <pthread.h>
-
-#ifndef offsetof
-# define offsetof(type, member) ((char *) &((type *) 0)->member - (char *) 0)
-#endif
-typedef struct { char x; pthread_cond_t y; } ac__type_alignof_;
-int
-main ()
-{
-static int test_array [1 - 2 * !(((long int) offsetof (ac__type_alignof_, y)) < 0)];
-test_array [0] = 0
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_hi=-1 ac_mid=-1
-  while :; do
-    cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-#include <pthread.h>
-
-#ifndef offsetof
-# define offsetof(type, member) ((char *) &((type *) 0)->member - (char *) 0)
-#endif
-typedef struct { char x; pthread_cond_t y; } ac__type_alignof_;
-int
-main ()
-{
-static int test_array [1 - 2 * !(((long int) offsetof (ac__type_alignof_, y)) >= $ac_mid)];
-test_array [0] = 0
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_lo=$ac_mid; break
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_hi=`expr '(' $ac_mid ')' - 1`
-			if test $ac_mid -le $ac_hi; then
-			  ac_lo= ac_hi=
-			  break
-			fi
-			ac_mid=`expr 2 '*' $ac_mid`
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-  done
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_lo= ac_hi=
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-# Binary search between lo and hi bounds.
-while test "x$ac_lo" != "x$ac_hi"; do
-  ac_mid=`expr '(' $ac_hi - $ac_lo ')' / 2 + $ac_lo`
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-#include <pthread.h>
-
-#ifndef offsetof
-# define offsetof(type, member) ((char *) &((type *) 0)->member - (char *) 0)
-#endif
-typedef struct { char x; pthread_cond_t y; } ac__type_alignof_;
-int
-main ()
-{
-static int test_array [1 - 2 * !(((long int) offsetof (ac__type_alignof_, y)) <= $ac_mid)];
-test_array [0] = 0
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_hi=$ac_mid
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_lo=`expr '(' $ac_mid ')' + 1`
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-done
-case $ac_lo in
-?*) ac_cv_alignof_pthread_cond_t=$ac_lo;;
-'') if test "$ac_cv_type_pthread_cond_t" = yes; then
-     { { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
-$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-{ { $as_echo "$as_me:$LINENO: error: cannot compute alignment of pthread_cond_t
-See \`config.log' for more details." >&5
-$as_echo "$as_me: error: cannot compute alignment of pthread_cond_t
-See \`config.log' for more details." >&2;}
-   { (exit 77); exit 77; }; }; }
-   else
-     ac_cv_alignof_pthread_cond_t=0
-   fi ;;
-esac
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-#include <pthread.h>
-
-#ifndef offsetof
-# define offsetof(type, member) ((char *) &((type *) 0)->member - (char *) 0)
-#endif
-typedef struct { char x; pthread_cond_t y; } ac__type_alignof_;
-static long int longval () { return (long int) offsetof (ac__type_alignof_, y); }
-static unsigned long int ulongval () { return (long int) offsetof (ac__type_alignof_, y); }
-#include <stdio.h>
-#include <stdlib.h>
-int
-main ()
-{
-
-  FILE *f = fopen ("conftest.val", "w");
-  if (! f)
-    return 1;
-  if (((long int) offsetof (ac__type_alignof_, y)) < 0)
-    {
-      long int i = longval ();
-      if (i != ((long int) offsetof (ac__type_alignof_, y)))
-	return 1;
-      fprintf (f, "%ld", i);
-    }
-  else
-    {
-      unsigned long int i = ulongval ();
-      if (i != ((long int) offsetof (ac__type_alignof_, y)))
-	return 1;
-      fprintf (f, "%lu", i);
-    }
-  /* Do not output a trailing newline, as this causes \r\n confusion
-     on some platforms.  */
-  return ferror (f) || fclose (f) != 0;
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_cv_alignof_pthread_cond_t=`cat conftest.val`
-else
-  $as_echo "$as_me: program exited with status $ac_status" >&5
-$as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-( exit $ac_status )
-if test "$ac_cv_type_pthread_cond_t" = yes; then
-     { { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
-$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-{ { $as_echo "$as_me:$LINENO: error: cannot compute alignment of pthread_cond_t
-See \`config.log' for more details." >&5
-$as_echo "$as_me: error: cannot compute alignment of pthread_cond_t
-See \`config.log' for more details." >&2;}
-   { (exit 77); exit 77; }; }; }
-   else
-     ac_cv_alignof_pthread_cond_t=0
-   fi
-fi
-rm -rf conftest.dSYM
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
-fi
-rm -f conftest.val
-fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_alignof_pthread_cond_t" >&5
-$as_echo "$ac_cv_alignof_pthread_cond_t" >&6; }
-
-
-
-cat >>confdefs.h <<_ACEOF
-#define ALIGNOF_PTHREAD_COND_T $ac_cv_alignof_pthread_cond_t
-_ACEOF
-
-
-  if test $ac_cv_alignof_pthread_cond_t = 0 ; then
-    { { $as_echo "$as_me:$LINENO: error: Unable to find align of pthread_cond_t (required)." >&5
-$as_echo "$as_me: error: Unable to find align of pthread_cond_t (required)." >&2;}
-   { (exit 1); exit 1; }; }
-  fi
-  GS_ALIGNOF_COND_T=$ac_cv_alignof_pthread_cond_t
-
-else
-  { { $as_echo "$as_me:$LINENO: error: Unable to find pthread.h (needed for thread support)." >&5
-$as_echo "$as_me: error: Unable to find pthread.h (needed for thread support)." >&2;}
-   { (exit 1); exit 1; }; }
-fi
-{ $as_echo "$as_me:$LINENO: checking for pthread_join in -lpthread" >&5
-$as_echo_n "checking for pthread_join in -lpthread... " >&6; }
-if test "${ac_cv_lib_pthread_pthread_join+set}" = set; then
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-lpthread  $LIBS"
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char pthread_join ();
-int
-main ()
-{
-return pthread_join ();
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then
-  ac_cv_lib_pthread_pthread_join=yes
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_cv_lib_pthread_pthread_join=no
-fi
-
-rm -rf conftest.dSYM
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_lib_pthread_pthread_join" >&5
-$as_echo "$ac_cv_lib_pthread_pthread_join" >&6; }
-if test "x$ac_cv_lib_pthread_pthread_join" = x""yes; then
-  pthread_ok=yes
-else
-  pthread_ok=no
-fi
-
-ismingw=no
-checkinlibc=no
-case "$target_os" in
-  mingw*)	ismingw=yes;;
-  nto*)		checkinlibc=yes;;
-  qnx*)		checkinlibc=yes;;
-  *android*)   checkinlibc=yes;;
-esac
-if test $pthread_ok = yes ; then
-  LIBS="$LIBS -lpthread"
-else
-  if test $ismingw = yes ; then
-    { $as_echo "$as_me:$LINENO: checking for pthread_join in -lpthreadGC2" >&5
-$as_echo_n "checking for pthread_join in -lpthreadGC2... " >&6; }
-if test "${ac_cv_lib_pthreadGC2_pthread_join+set}" = set; then
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-lpthreadGC2  $LIBS"
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char pthread_join ();
-int
-main ()
-{
-return pthread_join ();
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then
-  ac_cv_lib_pthreadGC2_pthread_join=yes
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_cv_lib_pthreadGC2_pthread_join=no
-fi
-
-rm -rf conftest.dSYM
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_lib_pthreadGC2_pthread_join" >&5
-$as_echo "$ac_cv_lib_pthreadGC2_pthread_join" >&6; }
-if test "x$ac_cv_lib_pthreadGC2_pthread_join" = x""yes; then
-  pthread_ok=yes
-else
-  pthread_ok=no
-fi
-
-    if test $pthread_ok = yes ; then
-      LIBS="$LIBS -lpthreadGC2"
-    fi
-  fi
-  # Android and QNX have pthread in libc instead of libpthread
-  if test $checkinlibc = yes ; then
-    { $as_echo "$as_me:$LINENO: checking for pthread_join in -lc" >&5
-$as_echo_n "checking for pthread_join in -lc... " >&6; }
-if test "${ac_cv_lib_c_pthread_join+set}" = set; then
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-lc  $LIBS"
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char pthread_join ();
-int
-main ()
-{
-return pthread_join ();
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then
-  ac_cv_lib_c_pthread_join=yes
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_cv_lib_c_pthread_join=no
-fi
-
-rm -rf conftest.dSYM
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_lib_c_pthread_join" >&5
-$as_echo "$ac_cv_lib_c_pthread_join" >&6; }
-if test "x$ac_cv_lib_c_pthread_join" = x""yes; then
-  pthread_ok=yes
-else
-  pthread_ok=no
-fi
-
-    if test $pthread_ok = yes ; then
-       LIBS="$LIBS -lc"
-    fi
-  fi
-fi
-if test $pthread_ok = no ; then
-  { { $as_echo "$as_me:$LINENO: error: Unable to find pthread library (needed for thread support)." >&5
-$as_echo "$as_me: error: Unable to find pthread library (needed for thread support)." >&2;}
-   { (exit 1); exit 1; }; }
-fi
-
-
-# Typically need librt on Solaris for sched_yield
-
-{ $as_echo "$as_me:$LINENO: checking for sched_yield in -lrt" >&5
-$as_echo_n "checking for sched_yield in -lrt... " >&6; }
-if test "${ac_cv_lib_rt_sched_yield+set}" = set; then
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-lrt  $LIBS"
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char sched_yield ();
-int
-main ()
-{
-return sched_yield ();
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then
-  ac_cv_lib_rt_sched_yield=yes
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_cv_lib_rt_sched_yield=no
-fi
-
-rm -rf conftest.dSYM
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_lib_rt_sched_yield" >&5
-$as_echo "$ac_cv_lib_rt_sched_yield" >&6; }
-if test "x$ac_cv_lib_rt_sched_yield" = x""yes; then
-  cat >>confdefs.h <<_ACEOF
-#define HAVE_LIBRT 1
-_ACEOF
-
-  LIBS="-lrt $LIBS"
-
-fi
-
-
-
-#--------------------------------------------------------------------
-# One of these function needed by NSThread.m and objc initialize test
-#--------------------------------------------------------------------
-
-
-
-for ac_func in nanosleep usleep Sleep
-do
-as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
-{ $as_echo "$as_me:$LINENO: checking for $ac_func" >&5
-$as_echo_n "checking for $ac_func... " >&6; }
-if { as_var=$as_ac_var; eval "test \"\${$as_var+set}\" = set"; }; then
-  $as_echo_n "(cached) " >&6
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.
-   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
-#define $ac_func innocuous_$ac_func
-
-/* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char $ac_func (); below.
-    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-    <limits.h> exists even on freestanding compilers.  */
-
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
-
-#undef $ac_func
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char $ac_func ();
-/* The GNU C library defines this for functions which it implements
-    to always fail with ENOSYS.  Some functions are actually named
-    something starting with __ and the normal name is an alias.  */
-#if defined __stub_$ac_func || defined __stub___$ac_func
-choke me
-#endif
-
-int
-main ()
-{
-return $ac_func ();
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then
-  eval "$as_ac_var=yes"
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	eval "$as_ac_var=no"
-fi
+GNUSTEP_MAKEFILES=`echo $GNUSTEP_MAKEFILES|sed -e 's/\\\\/\\\\\\\\/g'`
 
-rm -rf conftest.dSYM
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
-fi
-ac_res=`eval 'as_val=${'$as_ac_var'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-as_val=`eval 'as_val=${'$as_ac_var'}
-		 $as_echo "$as_val"'`
-   if test "x$as_val" = x""yes; then
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
+cat >>confdefs.h <<_ACEOF
+#define GNUSTEP_TARGET_MAKEFILES "$GNUSTEP_MAKEFILES"
 _ACEOF
 
-fi
-done
+GNUSTEP_USER_DEFAULTS_DIR=`echo $GNUSTEP_USER_DEFAULTS_DIR|sed -e 's/\\\\/\\\\\\\\/g'`
 
+cat >>confdefs.h <<_ACEOF
+#define GNUSTEP_TARGET_USER_DEFAULTS_DIR "$GNUSTEP_USER_DEFAULTS_DIR"
+_ACEOF
 
-{ $as_echo "$as_me:$LINENO: checking for objc_root_class attribute support" >&5
-$as_echo_n "checking for objc_root_class attribute support... " >&6; }
-saved_CFLAGS="$CFLAGS"
-CFLAGS="$CFLAGS -Werror $OBJCFLAGS -x objective-c"
-cat >conftest.$ac_ext <<_ACEOF
+GNUSTEP_USER_CONFIG_FILE=`echo $GNUSTEP_USER_CONFIG_FILE|sed -e 's/\\\\/\\\\\\\\/g'`
 
-  __attribute__((objc_root_class)) @interface RootObject
-  @end
-  @implementation RootObject
-  @end
+cat >>confdefs.h <<_ACEOF
+#define GNUSTEP_TARGET_USER_CONFIG_FILE "$GNUSTEP_USER_CONFIG_FILE"
 _ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  { $as_echo "$as_me:$LINENO: result: found" >&5
-$as_echo "found" >&6; }
-  gs_objc_root_class_attr=1
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	{ $as_echo "$as_me:$LINENO: result: not present" >&5
-$as_echo "not present" >&6; }
-  gs_objc_root_class_attr=0
 
-fi
+GNUSTEP_TARGET_CONFIG_FILE=`echo $GNUSTEP_TARGET_CONFIG_FILE|sed -e 's/\\\\/\\\\\\\\/g'`
 
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+cat >>confdefs.h <<_ACEOF
+#define GNUSTEP_TARGET_CONFIG_FILE "$GNUSTEP_TARGET_CONFIG_FILE"
+_ACEOF
 
-GS_HAVE_OBJC_ROOT_CLASS_ATTR=$gs_objc_root_class_attr
 
+#
+# SYSTEM domain paths
+#
+GNUSTEP_SYSTEM_APPS=`echo $GNUSTEP_SYSTEM_APPS|sed -e 's/\\\\/\\\\\\\\/g'`
 
 cat >>confdefs.h <<_ACEOF
-#define HAVE_OBJC_ROOT_CLASS_ATTRIBUTE $gs_objc_root_class_attr
+#define GNUSTEP_TARGET_SYSTEM_APPS "$GNUSTEP_SYSTEM_APPS"
 _ACEOF
 
-CFLAGS=$saved_CFLAGS
 
-#--------------------------------------------------------------------
-# Check whether Objective-C /really/ works
-#--------------------------------------------------------------------
-{ $as_echo "$as_me:$LINENO: checking whether objc really works" >&5
-$as_echo_n "checking whether objc really works... " >&6; }
-saved_LIBS="$LIBS"
-saved_CPPFLAGS="$CPPFLAGS"
-LIBS="$LIBS $LIBOBJC"
-CPPFLAGS="$CPPFLAGS $OBJCFLAGS -x objective-c"
-if test x"$objc_threaded" != x""; then
-  LIBS="$LIBS $objc_threaded"
-fi
-LIBS="$LIBS $extra_LIBS"
-if test "${gs_cv_objc_works+set}" = set; then
-  $as_echo_n "(cached) " >&6
-else
-  if test "$cross_compiling" = yes; then
-  gs_cv_objc_works="$cross_gs_cv_objc_works"
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include "$srcdir/config/config.objc.m"
-_ACEOF
-rm -f conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  gs_cv_objc_works=yes
-else
-  $as_echo "$as_me: program exited with status $ac_status" >&5
-$as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
+GNUSTEP_SYSTEM_ADMIN_APPS=`echo $GNUSTEP_SYSTEM_ADMIN_APPS|sed -e 's/\\\\/\\\\\\\\/g'`
 
-( exit $ac_status )
-gs_cv_objc_works=no
-fi
-rm -rf conftest.dSYM
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
-fi
+cat >>confdefs.h <<_ACEOF
+#define GNUSTEP_TARGET_SYSTEM_ADMIN_APPS "$GNUSTEP_SYSTEM_ADMIN_APPS"
+_ACEOF
 
 
+GNUSTEP_SYSTEM_WEB_APPS=`echo $GNUSTEP_SYSTEM_WEB_APPS|sed -e 's/\\\\/\\\\\\\\/g'`
 
-fi
+cat >>confdefs.h <<_ACEOF
+#define GNUSTEP_TARGET_SYSTEM_WEB_APPS "$GNUSTEP_SYSTEM_WEB_APPS"
+_ACEOF
 
-if test $gs_cv_objc_works = yes; then
-  { $as_echo "$as_me:$LINENO: result: yes" >&5
-$as_echo "yes" >&6; }
-else
-  { $as_echo "$as_me:$LINENO: result: no" >&5
-$as_echo "no" >&6; }
-  echo "I don't seem to be able to use your Objective-C compiler to produce"
-  echo "working binaries!  Please check your Objective-C compiler installation."
-  echo "If you are using gcc-3.x make sure that your compiler's libgcc_s and libobjc"
-  echo "can be found by the dynamic linker - usually that requires you to play"
-  echo "with LD_LIBRARY_PATH or /etc/ld.so.conf."
-  echo "Please refer to your compiler installation instructions for more help."
-  { { $as_echo "$as_me:$LINENO: error: The Objective-C compiler does not work or is not installed properly." >&5
-$as_echo "$as_me: error: The Objective-C compiler does not work or is not installed properly." >&2;}
-   { (exit 1); exit 1; }; }
-fi
 
-# Don't revert any Objective-C flags as they are used in the next test
+GNUSTEP_SYSTEM_TOOLS=`echo $GNUSTEP_SYSTEM_TOOLS|sed -e 's/\\\\/\\\\\\\\/g'`
 
-#---------------------------------------------------------------------
-# See if we are using a compiler which allows us to change the class
-# to be used for constant strings by using the -fconstant-string-class
-# option.  If that is the case, we change it to NSConstantString.
-# Unless we are building for the apple runtime (ie only building base
-# additions library and not implementing a constant string class).
-#---------------------------------------------------------------------
-if test "$OBJC_RUNTIME_LIB" = "nx" -o "$OBJC_RUNTIME_LIB" = "apple"; then
-  NX_CONST_STRING_OBJCFLAGS=""
-  NX_CONST_STRING_CLASS=NXConstantString
-else
-  strclass_CPPFLAGS="$CPPFLAGS"
-  CPPFLAGS="$CPPFLAGS -fconstant-string-class=FooConstantString"
-  { $as_echo "$as_me:$LINENO: checking if the compiler supports -fconstant-string-class" >&5
-$as_echo_n "checking if the compiler supports -fconstant-string-class... " >&6; }
-  if test "${gs_cv_objc_compiler_supports_constant_string_class+set}" = set; then
-  $as_echo_n "(cached) " >&6
-else
-  if test "$cross_compiling" = yes; then
-  gs_cv_objc_compiler_supports_constant_string_class="$cross_gs_cv_objc_compiler_supports_constant_string_class"
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include "$srcdir/config/config.constant-string-class.m"
+cat >>confdefs.h <<_ACEOF
+#define GNUSTEP_TARGET_SYSTEM_TOOLS "$GNUSTEP_SYSTEM_TOOLS"
 _ACEOF
-rm -f conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  gs_cv_objc_compiler_supports_constant_string_class=yes
-else
-  $as_echo "$as_me: program exited with status $ac_status" >&5
-$as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
 
-( exit $ac_status )
-gs_cv_objc_compiler_supports_constant_string_class=no
-fi
-rm -rf conftest.dSYM
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
-fi
 
+GNUSTEP_SYSTEM_ADMIN_TOOLS=`echo $GNUSTEP_SYSTEM_ADMIN_TOOLS|sed -e 's/\\\\/\\\\\\\\/g'`
 
+cat >>confdefs.h <<_ACEOF
+#define GNUSTEP_TARGET_SYSTEM_ADMIN_TOOLS "$GNUSTEP_SYSTEM_ADMIN_TOOLS"
+_ACEOF
 
-fi
 
-  if test $gs_cv_objc_compiler_supports_constant_string_class = yes; then
-    NX_CONST_STRING_OBJCFLAGS="-fconstant-string-class=NSConstantString"
-    NX_CONST_STRING_CLASS=NSConstantString
-    { $as_echo "$as_me:$LINENO: result: yes" >&5
-$as_echo "yes" >&6; }
-  else
-    { $as_echo "$as_me:$LINENO: result: no" >&5
-$as_echo "no" >&6; }
-    # Check whether --enable-nxconstantstring was given.
-if test "${enable_nxconstantstring+set}" = set; then
-  enableval=$enable_nxconstantstring;
-else
-  enable_nxconstantstring=no
-fi
+GNUSTEP_SYSTEM_LIBRARY=`echo $GNUSTEP_SYSTEM_LIBRARY|sed -e 's/\\\\/\\\\\\\\/g'`
 
-    if test $enable_nxconstantstring = yes; then
-      NX_CONST_STRING_OBJCFLAGS=""
-      NX_CONST_STRING_CLASS=NXConstantString
-      { $as_echo "$as_me:$LINENO: WARNING: You have enabled the use of NXConstantString as the string class in gnustep-base.  The objective-c runtime library typically implements its own class of the same name, so you must either enforce a link order which ensures that the gnustep-base implementation is used, or (better) you must remove the class from the runtime library!" >&5
-$as_echo "$as_me: WARNING: You have enabled the use of NXConstantString as the string class in gnustep-base.  The objective-c runtime library typically implements its own class of the same name, so you must either enforce a link order which ensures that the gnustep-base implementation is used, or (better) you must remove the class from the runtime library!" >&2;}
-    else
-      { { $as_echo "$as_me:$LINENO: error: Your compiler does not appear to implement the -fconstant-string-class option needed for support of strings.  Please check for a more recent version or consider using --enable-nxconstantstring" >&5
-$as_echo "$as_me: error: Your compiler does not appear to implement the -fconstant-string-class option needed for support of strings.  Please check for a more recent version or consider using --enable-nxconstantstring" >&2;}
-   { (exit 1); exit 1; }; }
-    fi
-  fi
-  CPPFLAGS="$strclass_CPPFLAGS"
-fi
+cat >>confdefs.h <<_ACEOF
+#define GNUSTEP_TARGET_SYSTEM_LIBRARY "$GNUSTEP_SYSTEM_LIBRARY"
+_ACEOF
 
 
+GNUSTEP_SYSTEM_LIBRARIES=`echo $GNUSTEP_SYSTEM_LIBRARIES|sed -e 's/\\\\/\\\\\\\\/g'`
 
+cat >>confdefs.h <<_ACEOF
+#define GNUSTEP_TARGET_SYSTEM_LIBRARIES "$GNUSTEP_SYSTEM_LIBRARIES"
+_ACEOF
 
-# Don't revert any Objective-C flags as they are used in the next test
 
-#---------------------------------------------------------------------
-# Guess if we are using a compiler which has the (GNU extension) +load
-# method which is executed before main.
-# Defines HAVE_LOAD_METHOD if +load methods are called before main.
-# Needed by NSProcessInfo.m
-#---------------------------------------------------------------------
-{ $as_echo "$as_me:$LINENO: checking if +load method is executed before main" >&5
-$as_echo_n "checking if +load method is executed before main... " >&6; }
-if test "${gs_cv_objc_load_method_worked+set}" = set; then
-  $as_echo_n "(cached) " >&6
-else
-  if test "$cross_compiling" = yes; then
-  gs_cv_objc_load_method_worked="$cross_gs_cv_objc_load_method_worked"
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include "$srcdir/config/config.loadtest.m"
+GNUSTEP_SYSTEM_HEADERS=`echo $GNUSTEP_SYSTEM_HEADERS|sed -e 's/\\\\/\\\\\\\\/g'`
+
+cat >>confdefs.h <<_ACEOF
+#define GNUSTEP_TARGET_SYSTEM_HEADERS "$GNUSTEP_SYSTEM_HEADERS"
 _ACEOF
-rm -f conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  gs_cv_objc_load_method_worked=yes
-else
-  $as_echo "$as_me: program exited with status $ac_status" >&5
-$as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
 
-( exit $ac_status )
-gs_cv_objc_load_method_worked=no
-fi
-rm -rf conftest.dSYM
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
-fi
 
+GNUSTEP_SYSTEM_DOC=`echo $GNUSTEP_SYSTEM_DOC|sed -e 's/\\\\/\\\\\\\\/g'`
 
+cat >>confdefs.h <<_ACEOF
+#define GNUSTEP_TARGET_SYSTEM_DOC "$GNUSTEP_SYSTEM_DOC"
+_ACEOF
 
-fi
 
-if test $gs_cv_objc_load_method_worked = yes; then
+GNUSTEP_SYSTEM_DOC_MAN=`echo $GNUSTEP_SYSTEM_DOC_MAN|sed -e 's/\\\\/\\\\\\\\/g'`
 
-cat >>confdefs.h <<\_ACEOF
-#define HAVE_LOAD_METHOD 1
+cat >>confdefs.h <<_ACEOF
+#define GNUSTEP_TARGET_SYSTEM_DOC_MAN "$GNUSTEP_SYSTEM_DOC_MAN"
 _ACEOF
 
-  { $as_echo "$as_me:$LINENO: result: yes" >&5
-$as_echo "yes" >&6; }
-else
-  { $as_echo "$as_me:$LINENO: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-# Don't revert any Objective-C flags as they are used in the next test
 
-#--------------------------------------------------------------------
-# Check for thread synchronisation support in runtime
-#--------------------------------------------------------------------
+GNUSTEP_SYSTEM_DOC_INFO=`echo $GNUSTEP_SYSTEM_DOC_INFO|sed -e 's/\\\\/\\\\\\\\/g'`
 
-for ac_func in objc_sync_enter
-do
-as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
-{ $as_echo "$as_me:$LINENO: checking for $ac_func" >&5
-$as_echo_n "checking for $ac_func... " >&6; }
-if { as_var=$as_ac_var; eval "test \"\${$as_var+set}\" = set"; }; then
-  $as_echo_n "(cached) " >&6
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
+cat >>confdefs.h <<_ACEOF
+#define GNUSTEP_TARGET_SYSTEM_DOC_INFO "$GNUSTEP_SYSTEM_DOC_INFO"
 _ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.
-   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
-#define $ac_func innocuous_$ac_func
-
-/* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char $ac_func (); below.
-    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-    <limits.h> exists even on freestanding compilers.  */
 
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
 
-#undef $ac_func
+#
+# NETWORK domain paths
+#
+GNUSTEP_NETWORK_APPS=`echo $GNUSTEP_NETWORK_APPS|sed -e 's/\\\\/\\\\\\\\/g'`
 
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char $ac_func ();
-/* The GNU C library defines this for functions which it implements
-    to always fail with ENOSYS.  Some functions are actually named
-    something starting with __ and the normal name is an alias.  */
-#if defined __stub_$ac_func || defined __stub___$ac_func
-choke me
-#endif
+cat >>confdefs.h <<_ACEOF
+#define GNUSTEP_TARGET_NETWORK_APPS "$GNUSTEP_NETWORK_APPS"
+_ACEOF
 
-int
-main ()
-{
-return $ac_func ();
-  ;
-  return 0;
-}
+
+GNUSTEP_NETWORK_ADMIN_APPS=`echo $GNUSTEP_NETWORK_ADMIN_APPS|sed -e 's/\\\\/\\\\\\\\/g'`
+
+cat >>confdefs.h <<_ACEOF
+#define GNUSTEP_TARGET_NETWORK_ADMIN_APPS "$GNUSTEP_NETWORK_ADMIN_APPS"
 _ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then
-  eval "$as_ac_var=yes"
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
 
-	eval "$as_ac_var=no"
-fi
 
-rm -rf conftest.dSYM
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
-fi
-ac_res=`eval 'as_val=${'$as_ac_var'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-as_val=`eval 'as_val=${'$as_ac_var'}
-		 $as_echo "$as_val"'`
-   if test "x$as_val" = x""yes; then
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
+GNUSTEP_NETWORK_WEB_APPS=`echo $GNUSTEP_NETWORK_WEB_APPS|sed -e 's/\\\\/\\\\\\\\/g'`
+
+cat >>confdefs.h <<_ACEOF
+#define GNUSTEP_TARGET_NETWORK_WEB_APPS "$GNUSTEP_NETWORK_WEB_APPS"
 _ACEOF
 
-fi
-done
 
-if test $ac_cv_func_objc_sync_enter = yes ; then
-  OBJCSYNC=1
-else
-  OBJCSYNC=0
-fi
+GNUSTEP_NETWORK_TOOLS=`echo $GNUSTEP_NETWORK_TOOLS|sed -e 's/\\\\/\\\\\\\\/g'`
 
+cat >>confdefs.h <<_ACEOF
+#define GNUSTEP_TARGET_NETWORK_TOOLS "$GNUSTEP_NETWORK_TOOLS"
+_ACEOF
 
-# Don't revert any Objective-C flags as they are used in the next test
 
-#--------------------------------------------------------------------
-# Check for ObjC2 support in runtime
-#--------------------------------------------------------------------
+GNUSTEP_NETWORK_ADMIN_TOOLS=`echo $GNUSTEP_NETWORK_ADMIN_TOOLS|sed -e 's/\\\\/\\\\\\\\/g'`
 
-for ac_func in objc_setProperty
-do
-as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
-{ $as_echo "$as_me:$LINENO: checking for $ac_func" >&5
-$as_echo_n "checking for $ac_func... " >&6; }
-if { as_var=$as_ac_var; eval "test \"\${$as_var+set}\" = set"; }; then
-  $as_echo_n "(cached) " >&6
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
+cat >>confdefs.h <<_ACEOF
+#define GNUSTEP_TARGET_NETWORK_ADMIN_TOOLS "$GNUSTEP_NETWORK_ADMIN_TOOLS"
 _ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.
-   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
-#define $ac_func innocuous_$ac_func
 
-/* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char $ac_func (); below.
-    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-    <limits.h> exists even on freestanding compilers.  */
 
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
+GNUSTEP_NETWORK_LIBRARY=`echo $GNUSTEP_NETWORK_LIBRARY|sed -e 's/\\\\/\\\\\\\\/g'`
 
-#undef $ac_func
+cat >>confdefs.h <<_ACEOF
+#define GNUSTEP_TARGET_NETWORK_LIBRARY "$GNUSTEP_NETWORK_LIBRARY"
+_ACEOF
 
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char $ac_func ();
-/* The GNU C library defines this for functions which it implements
-    to always fail with ENOSYS.  Some functions are actually named
-    something starting with __ and the normal name is an alias.  */
-#if defined __stub_$ac_func || defined __stub___$ac_func
-choke me
-#endif
 
-int
-main ()
-{
-return $ac_func ();
-  ;
-  return 0;
-}
+GNUSTEP_NETWORK_LIBRARIES=`echo $GNUSTEP_NETWORK_LIBRARIES|sed -e 's/\\\\/\\\\\\\\/g'`
+
+cat >>confdefs.h <<_ACEOF
+#define GNUSTEP_TARGET_NETWORK_LIBRARIES "$GNUSTEP_NETWORK_LIBRARIES"
 _ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then
-  eval "$as_ac_var=yes"
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
 
-	eval "$as_ac_var=no"
-fi
 
-rm -rf conftest.dSYM
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
-fi
-ac_res=`eval 'as_val=${'$as_ac_var'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-as_val=`eval 'as_val=${'$as_ac_var'}
-		 $as_echo "$as_val"'`
-   if test "x$as_val" = x""yes; then
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
+GNUSTEP_NETWORK_HEADERS=`echo $GNUSTEP_NETWORK_HEADERS|sed -e 's/\\\\/\\\\\\\\/g'`
+
+cat >>confdefs.h <<_ACEOF
+#define GNUSTEP_TARGET_NETWORK_HEADERS "$GNUSTEP_NETWORK_HEADERS"
 _ACEOF
 
-fi
-done
 
-if test $ac_cv_func_objc_setProperty = yes ; then
-  OBJC2RUNTIME=1
-else
-  OBJC2RUNTIME=0
-fi
+GNUSTEP_NETWORK_DOC=`echo $GNUSTEP_NETWORK_DOC|sed -e 's/\\\\/\\\\\\\\/g'`
+
+cat >>confdefs.h <<_ACEOF
+#define GNUSTEP_TARGET_NETWORK_DOC "$GNUSTEP_NETWORK_DOC"
+_ACEOF
 
 
-#--------------------------------------------------------------------
-# Check for blocks support in runtime
-#--------------------------------------------------------------------
+GNUSTEP_NETWORK_DOC_MAN=`echo $GNUSTEP_NETWORK_DOC_MAN|sed -e 's/\\\\/\\\\\\\\/g'`
 
-for ac_func in _Block_copy
-do
-as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
-{ $as_echo "$as_me:$LINENO: checking for $ac_func" >&5
-$as_echo_n "checking for $ac_func... " >&6; }
-if { as_var=$as_ac_var; eval "test \"\${$as_var+set}\" = set"; }; then
-  $as_echo_n "(cached) " >&6
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
+cat >>confdefs.h <<_ACEOF
+#define GNUSTEP_TARGET_NETWORK_DOC_MAN "$GNUSTEP_NETWORK_DOC_MAN"
 _ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.
-   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
-#define $ac_func innocuous_$ac_func
 
-/* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char $ac_func (); below.
-    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-    <limits.h> exists even on freestanding compilers.  */
 
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
+GNUSTEP_NETWORK_DOC_INFO=`echo $GNUSTEP_NETWORK_DOC_INFO|sed -e 's/\\\\/\\\\\\\\/g'`
 
-#undef $ac_func
+cat >>confdefs.h <<_ACEOF
+#define GNUSTEP_TARGET_NETWORK_DOC_INFO "$GNUSTEP_NETWORK_DOC_INFO"
+_ACEOF
 
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char $ac_func ();
-/* The GNU C library defines this for functions which it implements
-    to always fail with ENOSYS.  Some functions are actually named
-    something starting with __ and the normal name is an alias.  */
-#if defined __stub_$ac_func || defined __stub___$ac_func
-choke me
-#endif
 
-int
-main ()
-{
-return $ac_func ();
-  ;
-  return 0;
-}
+#
+# LOCAL domain paths
+#
+GNUSTEP_LOCAL_APPS=`echo $GNUSTEP_LOCAL_APPS|sed -e 's/\\\\/\\\\\\\\/g'`
+
+cat >>confdefs.h <<_ACEOF
+#define GNUSTEP_TARGET_LOCAL_APPS "$GNUSTEP_LOCAL_APPS"
 _ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then
-  eval "$as_ac_var=yes"
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
 
-	eval "$as_ac_var=no"
-fi
 
-rm -rf conftest.dSYM
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
-fi
-ac_res=`eval 'as_val=${'$as_ac_var'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-as_val=`eval 'as_val=${'$as_ac_var'}
-		 $as_echo "$as_val"'`
-   if test "x$as_val" = x""yes; then
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
+GNUSTEP_LOCAL_ADMIN_APPS=`echo $GNUSTEP_LOCAL_ADMIN_APPS|sed -e 's/\\\\/\\\\\\\\/g'`
+
+cat >>confdefs.h <<_ACEOF
+#define GNUSTEP_TARGET_LOCAL_ADMIN_APPS "$GNUSTEP_LOCAL_ADMIN_APPS"
 _ACEOF
 
-fi
-done
 
-if test $ac_cv_func__Block_copy = yes ; then
-  HAVE_BLOCKS=1
-else
-  HAVE_BLOCKS=0
-fi
+GNUSTEP_LOCAL_WEB_APPS=`echo $GNUSTEP_LOCAL_WEB_APPS|sed -e 's/\\\\/\\\\\\\\/g'`
+
+cat >>confdefs.h <<_ACEOF
+#define GNUSTEP_TARGET_LOCAL_WEB_APPS "$GNUSTEP_LOCAL_WEB_APPS"
+_ACEOF
 
 
-# Don't revert any Objective-C flags as they are used in the next test
+GNUSTEP_LOCAL_TOOLS=`echo $GNUSTEP_LOCAL_TOOLS|sed -e 's/\\\\/\\\\\\\\/g'`
 
-GS_NONFRAGILE=0
-GS_MIXEDABI=0
-if test "$nonfragile" = "yes"; then
-  saved_CPPFLAGS="$CPPFLAGS"
-  CPPFLAGS="$CPPFLAGS $OBJCFLAGS -fobjc-nonfragile-abi -x objective-c"
-  { $as_echo "$as_me:$LINENO: checking for non-fragile-abi support" >&5
-$as_echo_n "checking for non-fragile-abi support... " >&6; }
-  if test "$cross_compiling" = yes; then
-  non_fragile="$cross_non_fragile"
-else
-  cat >conftest.$ac_ext <<_ACEOF
-#include "$srcdir/config/config.non-fragile-ivars.m"
+cat >>confdefs.h <<_ACEOF
+#define GNUSTEP_TARGET_LOCAL_TOOLS "$GNUSTEP_LOCAL_TOOLS"
 _ACEOF
-rm -f conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  non_fragile=yes
-else
-  $as_echo "$as_me: program exited with status $ac_status" >&5
-$as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
 
-( exit $ac_status )
-non_fragile=no
-fi
-rm -rf conftest.dSYM
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
-fi
 
+GNUSTEP_LOCAL_ADMIN_TOOLS=`echo $GNUSTEP_LOCAL_ADMIN_TOOLS|sed -e 's/\\\\/\\\\\\\\/g'`
 
-  CPPFLAGS="$saved_CPPFLAGS"
-  if test $non_fragile = yes; then
-    OBJCFLAGS="$OBJCFLAGS -fobjc-nonfragile-abi"
-    GS_NONFRAGILE=1
-    # Check whether --enable-mixedabi was given.
-if test "${enable_mixedabi+set}" = set; then
-  enableval=$enable_mixedabi;
-else
-  enable_mixedabi=yes
-fi
+cat >>confdefs.h <<_ACEOF
+#define GNUSTEP_TARGET_LOCAL_ADMIN_TOOLS "$GNUSTEP_LOCAL_ADMIN_TOOLS"
+_ACEOF
 
-    if test $enable_mixedabi = yes; then
-      GS_MIXEDABI=1
-    fi
-  fi
-  { $as_echo "$as_me:$LINENO: result: $non_fragile" >&5
-$as_echo "$non_fragile" >&6; }
-fi
 
+GNUSTEP_LOCAL_LIBRARY=`echo $GNUSTEP_LOCAL_LIBRARY|sed -e 's/\\\\/\\\\\\\\/g'`
 
+cat >>confdefs.h <<_ACEOF
+#define GNUSTEP_TARGET_LOCAL_LIBRARY "$GNUSTEP_LOCAL_LIBRARY"
+_ACEOF
 
 
-# Don't revert any Objective-C flags as they are used in the next test
+GNUSTEP_LOCAL_LIBRARIES=`echo $GNUSTEP_LOCAL_LIBRARIES|sed -e 's/\\\\/\\\\\\\\/g'`
 
-#--------------------------------------------------------------------
-# get_uninstalled_dtable used by behavior.m and objc-load.m
-#--------------------------------------------------------------------
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
+cat >>confdefs.h <<_ACEOF
+#define GNUSTEP_TARGET_LOCAL_LIBRARIES "$GNUSTEP_LOCAL_LIBRARIES"
 _ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <objc/objc-api.h>
 
+
+GNUSTEP_LOCAL_HEADERS=`echo $GNUSTEP_LOCAL_HEADERS|sed -e 's/\\\\/\\\\\\\\/g'`
+
+cat >>confdefs.h <<_ACEOF
+#define GNUSTEP_TARGET_LOCAL_HEADERS "$GNUSTEP_LOCAL_HEADERS"
 _ACEOF
-if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
-  $EGREP "objc_get_uninstalled_dtable" >/dev/null 2>&1; then
 
-cat >>confdefs.h <<\_ACEOF
-#define HAVE_OBJC_GET_UNINSTALLED_DTABLE 1
+
+GNUSTEP_LOCAL_DOC=`echo $GNUSTEP_LOCAL_DOC|sed -e 's/\\\\/\\\\\\\\/g'`
+
+cat >>confdefs.h <<_ACEOF
+#define GNUSTEP_TARGET_LOCAL_DOC "$GNUSTEP_LOCAL_DOC"
 _ACEOF
 
-fi
-rm -f conftest*
 
+GNUSTEP_LOCAL_DOC_MAN=`echo $GNUSTEP_LOCAL_DOC_MAN|sed -e 's/\\\\/\\\\\\\\/g'`
 
-# Don't revert any Objective-C flags as they are used in the next test
+cat >>confdefs.h <<_ACEOF
+#define GNUSTEP_TARGET_LOCAL_DOC_MAN "$GNUSTEP_LOCAL_DOC_MAN"
+_ACEOF
 
 
-#--------------------------------------------------------------------
-# Native Objective-C exceptions
-#--------------------------------------------------------------------
+GNUSTEP_LOCAL_DOC_INFO=`echo $GNUSTEP_LOCAL_DOC_INFO|sed -e 's/\\\\/\\\\\\\\/g'`
 
-# First of all, determine if native Objective-C exceptions are enabled
-# in gnustep-make.  They are enabled if the compiler supports it; they
-# are disabled if it doesn't.  And, of course, the user may have
-# forced one behaviour or the other.  Note that we go and look at the
-# actual config.make file to be able to know what was configured in
-# gnustep-make regardless of any gnustep-base that is currently
-# installed.  We can't use `gnustep-config --objc-flags` because that
-# may report native exceptions as disabled because the currently
-# installed gnustep-base has them disabled.
-if grep USE_OBJC_EXCEPTIONS $CURRENT_GNUSTEP_MAKEFILES/$lobj_dir/config.make | grep yes >&5 2>&5; then
-  exceptions=yes
-else
-  exceptions=no
-fi
+cat >>confdefs.h <<_ACEOF
+#define GNUSTEP_TARGET_LOCAL_DOC_INFO "$GNUSTEP_LOCAL_DOC_INFO"
+_ACEOF
 
-# At this point, if exceptions=no, then native exceptions are disabled
-# and won't be used.  If exceptions=yes, we need to check if they work
-# and if the runtime has proper support for them.  If it does, we'll
-# happily use them; if it doesn't, we'll automatically disable them
-# because they don't work. ;-)
 
-#--------------------------------------------------------------------
-# One of these is needed by for handling uncaught exceptions
-#--------------------------------------------------------------------
+#
+# USER_DIR domain paths
+#
+GNUSTEP_USER_DIR_APPS=`echo $GNUSTEP_USER_DIR_APPS|sed -e 's/\\\\/\\\\\\\\/g'`
 
-# TODO: These checks are not really needed if native exceptions are
-# disabled.  So maybe we should not run them at all in that case.  On
-# the other hand, that case is going to become more and more unusual.
+cat >>confdefs.h <<_ACEOF
+#define GNUSTEP_TARGET_USER_DIR_APPS "$GNUSTEP_USER_DIR_APPS"
+_ACEOF
 
-{ $as_echo "$as_me:$LINENO: checking for objc_setUncaughtExceptionHandler() in runtime" >&5
-$as_echo_n "checking for objc_setUncaughtExceptionHandler() in runtime... " >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-#include "$srcdir/config/config.setUncaughtExceptionHandler.m"
+
+GNUSTEP_USER_DIR_ADMIN_APPS=`echo $GNUSTEP_USER_DIR_ADMIN_APPS|sed -e 's/\\\\/\\\\\\\\/g'`
+
+cat >>confdefs.h <<_ACEOF
+#define GNUSTEP_TARGET_USER_DIR_ADMIN_APPS "$GNUSTEP_USER_DIR_ADMIN_APPS"
 _ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then
-  have_set_uncaught_exception_handler=yes
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
 
-	have_set_uncaught_exception_handler=no
-fi
 
-rm -rf conftest.dSYM
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
-if test $have_set_uncaught_exception_handler = yes; then
+GNUSTEP_USER_DIR_WEB_APPS=`echo $GNUSTEP_USER_DIR_WEB_APPS|sed -e 's/\\\\/\\\\\\\\/g'`
 
-cat >>confdefs.h <<\_ACEOF
-#define HAVE_SET_UNCAUGHT_EXCEPTION_HANDLER 1
+cat >>confdefs.h <<_ACEOF
+#define GNUSTEP_TARGET_USER_DIR_WEB_APPS "$GNUSTEP_USER_DIR_WEB_APPS"
 _ACEOF
 
-fi
-{ $as_echo "$as_me:$LINENO: result: $have_set_uncaught_exception_handler" >&5
-$as_echo "$have_set_uncaught_exception_handler" >&6; }
 
-# Don't revert any Objective-C flags as they are used in the next test
+GNUSTEP_USER_DIR_TOOLS=`echo $GNUSTEP_USER_DIR_TOOLS|sed -e 's/\\\\/\\\\\\\\/g'`
 
-{ $as_echo "$as_me:$LINENO: checking for objc_set_unexpected() in runtime" >&5
-$as_echo_n "checking for objc_set_unexpected() in runtime... " >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-#include "$srcdir/config/config.set_unexpected.m"
+cat >>confdefs.h <<_ACEOF
+#define GNUSTEP_TARGET_USER_DIR_TOOLS "$GNUSTEP_USER_DIR_TOOLS"
 _ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then
-  have_set_unexpected=yes
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
 
-	have_set_unexpected=no
-fi
 
-rm -rf conftest.dSYM
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
-if test $have_set_unexpected = yes; then
+GNUSTEP_USER_DIR_ADMIN_TOOLS=`echo $GNUSTEP_USER_DIR_ADMIN_TOOLS|sed -e 's/\\\\/\\\\\\\\/g'`
 
-cat >>confdefs.h <<\_ACEOF
-#define HAVE_SET_UNEXPECTED 1
+cat >>confdefs.h <<_ACEOF
+#define GNUSTEP_TARGET_USER_DIR_ADMIN_TOOLS "$GNUSTEP_USER_DIR_ADMIN_TOOLS"
 _ACEOF
 
-fi
-{ $as_echo "$as_me:$LINENO: result: $have_set_unexpected" >&5
-$as_echo "$have_set_unexpected" >&6; }
 
-# Don't revert any Objective-C flags as they are used in the next test
+GNUSTEP_USER_DIR_LIBRARY=`echo $GNUSTEP_USER_DIR_LIBRARY|sed -e 's/\\\\/\\\\\\\\/g'`
 
-{ $as_echo "$as_me:$LINENO: checking for _objc_unexpected_exception in runtime" >&5
-$as_echo_n "checking for _objc_unexpected_exception in runtime... " >&6; }
-if test "$cross_compiling" = yes; then
-  have_unexpected="$cross_have_unexpected"
-else
-  cat >conftest.$ac_ext <<_ACEOF
-#include "$srcdir/config/config.unexpected.m"
+cat >>confdefs.h <<_ACEOF
+#define GNUSTEP_TARGET_USER_DIR_LIBRARY "$GNUSTEP_USER_DIR_LIBRARY"
 _ACEOF
-rm -f conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  have_unexpected=yes
-else
-  $as_echo "$as_me: program exited with status $ac_status" >&5
-$as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
 
-( exit $ac_status )
-have_unexpected=no
-fi
-rm -rf conftest.dSYM
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
-fi
 
+GNUSTEP_USER_DIR_LIBRARIES=`echo $GNUSTEP_USER_DIR_LIBRARIES|sed -e 's/\\\\/\\\\\\\\/g'`
+
+cat >>confdefs.h <<_ACEOF
+#define GNUSTEP_TARGET_USER_DIR_LIBRARIES "$GNUSTEP_USER_DIR_LIBRARIES"
+_ACEOF
 
-if test $have_unexpected = yes; then
 
-cat >>confdefs.h <<\_ACEOF
-#define HAVE_UNEXPECTED 1
+GNUSTEP_USER_DIR_HEADERS=`echo $GNUSTEP_USER_DIR_HEADERS|sed -e 's/\\\\/\\\\\\\\/g'`
+
+cat >>confdefs.h <<_ACEOF
+#define GNUSTEP_TARGET_USER_DIR_HEADERS "$GNUSTEP_USER_DIR_HEADERS"
 _ACEOF
 
-fi
-{ $as_echo "$as_me:$LINENO: result: $have_unexpected" >&5
-$as_echo "$have_unexpected" >&6; }
 
-# TODO: It would also be nice to actually test that native Objective-C
-# exceptions work.
+GNUSTEP_USER_DIR_DOC=`echo $GNUSTEP_USER_DIR_DOC|sed -e 's/\\\\/\\\\\\\\/g'`
 
-if test "$exceptions" = "yes"; then
-  if test x"$have_set_uncaught_exception_handler" = x"no"; then
-    if test x"$have_set_unexpected" = x"no"; then
-      if test x"$have_unexpected" = x"no"; then
-        { $as_echo "$as_me:$LINENO: Disabling native Objective-C exceptions because the ObjC runtime" >&5
-$as_echo "$as_me: Disabling native Objective-C exceptions because the ObjC runtime" >&6;}
-        { $as_echo "$as_me:$LINENO: has no way to set an uncaught exception handler.  Please install" >&5
-$as_echo "$as_me: has no way to set an uncaught exception handler.  Please install" >&6;}
-        { $as_echo "$as_me:$LINENO: a recent Objective-C runtime if you want to use them." >&5
-$as_echo "$as_me: a recent Objective-C runtime if you want to use them." >&6;}
-        exceptions="no";
-      fi
-    fi
-  fi
-fi
+cat >>confdefs.h <<_ACEOF
+#define GNUSTEP_TARGET_USER_DIR_DOC "$GNUSTEP_USER_DIR_DOC"
+_ACEOF
 
-{ $as_echo "$as_me:$LINENO: checking whether to enable native Objective-C exceptions" >&5
-$as_echo_n "checking whether to enable native Objective-C exceptions... " >&6; }
-if test "$exceptions" = "yes"; then
-  { $as_echo "$as_me:$LINENO: result: yes" >&5
-$as_echo "yes" >&6; }
-  BASE_NATIVE_OBJC_EXCEPTIONS=1
-else
-  { $as_echo "$as_me:$LINENO: result: no" >&5
-$as_echo "no" >&6; }
-  BASE_NATIVE_OBJC_EXCEPTIONS=0
-fi
 
+GNUSTEP_USER_DIR_DOC_MAN=`echo $GNUSTEP_USER_DIR_DOC_MAN|sed -e 's/\\\\/\\\\\\\\/g'`
 
-# Don't revert any Objective-C flags as they are used in the next test
+cat >>confdefs.h <<_ACEOF
+#define GNUSTEP_TARGET_USER_DIR_DOC_MAN "$GNUSTEP_USER_DIR_DOC_MAN"
+_ACEOF
 
-#--------------------------------------------------------------------
-# Function needed by @synchronize directive
-#--------------------------------------------------------------------
 
-for ac_func in objc_sync_enter
-do
-as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
-{ $as_echo "$as_me:$LINENO: checking for $ac_func" >&5
-$as_echo_n "checking for $ac_func... " >&6; }
-if { as_var=$as_ac_var; eval "test \"\${$as_var+set}\" = set"; }; then
-  $as_echo_n "(cached) " >&6
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
+GNUSTEP_USER_DIR_DOC_INFO=`echo $GNUSTEP_USER_DIR_DOC_INFO|sed -e 's/\\\\/\\\\\\\\/g'`
+
+cat >>confdefs.h <<_ACEOF
+#define GNUSTEP_TARGET_USER_DIR_DOC_INFO "$GNUSTEP_USER_DIR_DOC_INFO"
 _ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.
-   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
-#define $ac_func innocuous_$ac_func
 
-/* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char $ac_func (); below.
-    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-    <limits.h> exists even on freestanding compilers.  */
 
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
+GNUSTEP_TARGET_SYSTEM_USERS_DIR=`echo $GNUSTEP_TARGET_SYSTEM_USERS_DIR|sed -e 's/\\\\/\\\\\\\\/g'`
 
-#undef $ac_func
+cat >>confdefs.h <<_ACEOF
+#define GNUSTEP_TARGET_SYSTEM_USERS_DIR "$GNUSTEP_TARGET_SYSTEM_USERS_DIR"
+_ACEOF
 
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char $ac_func ();
-/* The GNU C library defines this for functions which it implements
-    to always fail with ENOSYS.  Some functions are actually named
-    something starting with __ and the normal name is an alias.  */
-#if defined __stub_$ac_func || defined __stub___$ac_func
-choke me
-#endif
+GNUSTEP_TARGET_NETWORK_USERS_DIR=`echo $GNUSTEP_TARGET_NETWORK_USERS_DIR|sed -e 's/\\\\/\\\\\\\\/g'`
+
+cat >>confdefs.h <<_ACEOF
+#define GNUSTEP_TARGET_NETWORK_USERS_DIR "$GNUSTEP_TARGET_NETWORK_USERS_DIR"
+_ACEOF
+
+GNUSTEP_TARGET_LOCAL_USERS_DIR=`echo $GNUSTEP_TARGET_LOCAL_USERS_DIR|sed -e 's/\\\\/\\\\\\\\/g'`
 
-int
-main ()
-{
-return $ac_func ();
-  ;
-  return 0;
-}
+cat >>confdefs.h <<_ACEOF
+#define GNUSTEP_TARGET_LOCAL_USERS_DIR "$GNUSTEP_TARGET_LOCAL_USERS_DIR"
 _ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then
-  eval "$as_ac_var=yes"
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
 
-	eval "$as_ac_var=no"
+
+#
+# Now load the values to be used in locating libraries etc used when
+# building the base library ... as supplied by the gnustep-make package
+#
+# It looks like we ought to source the whole GNUstep.sh here, and even
+# ask it to output all variables!  That way we have access to (eg)
+# GNUSTEP_SYSTEM_HEADERS below.
+#
+# We need to unset any values that we really need, or existing settings
+# would be used by GNUstep.sh
+#
+unset GNUSTEP_SYSTEM_HEADERS
+unset GNUSTEP_SYSTEM_LIBRARIES
+unset GNUSTEP_NETWORK_HEADERS
+unset GNUSTEP_NETWORK_LIBRARIES
+unset GNUSTEP_LOCAL_HEADERS
+unset GNUSTEP_LOCAL_LIBRARIES
+GNUSTEP_MAKEFILES="$CURRENT_GNUSTEP_MAKEFILES"
+GNUSTEP_SH_EXPORT_ALL_VARIABLES=yes
+. "$CURRENT_GNUSTEP_MAKEFILES/GNUstep.sh"
+unset GNUSTEP_SH_EXPORT_ALL_VARIABLES
+
+# For backwards compatibility, define GNUSTEP_SYSTEM_HEADERS from
+# GNUSTEP_SYSTEM_ROOT if not set yet.
+if test x"$GNUSTEP_SYSTEM_HEADERS" = x""; then
+  GNUSTEP_SYSTEM_HEADERS="$GNUSTEP_SYSTEM_ROOT/Library/Headers"
 fi
 
-rm -rf conftest.dSYM
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
+if test x"$GNUSTEP_SYSTEM_LIBRARIES" = x""; then
+  GNUSTEP_SYSTEM_LIBRARIES="$GNUSTEP_SYSTEM_ROOT/Library/Libraries"
 fi
-ac_res=`eval 'as_val=${'$as_ac_var'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-as_val=`eval 'as_val=${'$as_ac_var'}
-		 $as_echo "$as_val"'`
-   if test "x$as_val" = x""yes; then
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
-_ACEOF
 
+if test x"$GNUSTEP_NETWORK_HEADERS" = x""; then
+  GNUSTEP_NETWORK_HEADERS="$GNUSTEP_NETWORK_ROOT/Library/Headers"
 fi
-done
 
+if test x"$GNUSTEP_NETWORK_LIBRARIES" = x""; then
+  GNUSTEP_NETWORK_LIBRARIES="$GNUSTEP_NETWORK_ROOT/Library/Libraries"
+fi
 
-HAVE_OBJC_SYNC_ENTER=no
-if test $ac_cv_func_objc_sync_enter = yes ; then
-  HAVE_OBJC_SYNC_ENTER=yes
+if test x"$GNUSTEP_LOCAL_HEADERS" = x""; then
+  GNUSTEP_LOCAL_HEADERS="$GNUSTEP_LOCAL_ROOT/Library/Headers"
 fi
 
+if test x"$GNUSTEP_LOCAL_LIBRARIES" = x""; then
+  GNUSTEP_LOCAL_LIBRARIES="$GNUSTEP_LOCAL_ROOT/Library/Libraries"
+fi
 
-# Don't revert any Objective-C flags as they are used in the next test
+if test x"$GNUSTEP_IS_FLATTENED" = x"no"; then
+  GNUSTEP_SYSTEM_HEADERS="$GNUSTEP_SYSTEM_HEADERS/$LIBRARY_COMBO"
+  GNUSTEP_NETWORK_HEADERS="$GNUSTEP_NETWORK_HEADERS/$LIBRARY_COMBO"
+  GNUSTEP_LOCAL_HEADERS="$GNUSTEP_LOCAL_HEADERS/$LIBRARY_COMBO"
+  # FIXME: Cross-compiling should read the target from the configure
+  # options and use it.   GNUSTEP_TARGET_* variables do not exist in
+  # this context (so "$GNUSTEP_TARGET_CPU" will always be "")
+  if test x"$GNUSTEP_TARGET_CPU" = x""; then
+    GNUSTEP_SYSTEM_LIBRARIES="$GNUSTEP_SYSTEM_LIBRARIES/$GNUSTEP_HOST_CPU/$GNUSTEP_HOST_OS/$LIBRARY_COMBO"
+    GNUSTEP_NETWORK_LIBRARIES="$GNUSTEP_NETWORK_LIBRARIES/$GNUSTEP_HOST_CPU/$GNUSTEP_HOST_OS/$LIBRARY_COMBO"
+    GNUSTEP_LOCAL_LIBRARIES="$GNUSTEP_LOCAL_LIBRARIES/$GNUSTEP_HOST_CPU/$GNUSTEP_HOST_OS/$LIBRARY_COMBO"
+  else
+    GNUSTEP_SYSTEM_LIBRARIES="$GNUSTEP_SYSTEM_LIBRARIES/$GNUSTEP_TARGET_CPU/$GNUSTEP_TARGET_OS/$LIBRARY_COMBO"
+    GNUSTEP_NETWORK_LIBRARIES="$GNUSTEP_NETWORK_LIBRARIES/$GNUSTEP_TARGET_CPU/$GNUSTEP_TARGET_OS/$LIBRARY_COMBO"
+    GNUSTEP_LOCAL_LIBRARIES="$GNUSTEP_LOCAL_LIBRARIES/$GNUSTEP_TARGET_CPU/$GNUSTEP_TARGET_OS/$LIBRARY_COMBO"
+  fi
+fi
 
-{ $as_echo "$as_me:$LINENO: checking for thread-safe +initialize in runtime" >&5
-$as_echo_n "checking for thread-safe +initialize in runtime... " >&6; }
-if test "$cross_compiling" = yes; then
-  safe_initialize="$cross_safe_initialize"
+#
+# Add standard library and header directories for configure to use to locate
+# plain C developer headers/libraries which haver been installed in the
+# GNUstep hierarchy.
+#
+CPPFLAGS="$CPPFLAGS -I$GNUSTEP_SYSTEM_HEADERS -I$GNUSTEP_NETWORK_HEADERS -I$GNUSTEP_LOCAL_HEADERS"
+LDFLAGS="$LDFLAGS -L$GNUSTEP_SYSTEM_LIBRARIES -L$GNUSTEP_NETWORK_LIBRARIES -L$GNUSTEP_LOCAL_LIBRARIES"
+
+#--------------------------------------------------------------------
+# Find the compiler
+#--------------------------------------------------------------------
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}gcc", so it can be a program name with args.
+set dummy ${ac_tool_prefix}gcc; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_prog_CC+:} false; then :
+  $as_echo_n "(cached) " >&6
 else
-  cat >conftest.$ac_ext <<_ACEOF
-#include "$srcdir/config/config.initialize.m"
-_ACEOF
-rm -f conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  safe_initialize=yes
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
 else
-  $as_echo "$as_me: program exited with status $ac_status" >&5
-$as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_CC="${ac_tool_prefix}gcc"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
 
-( exit $ac_status )
-safe_initialize=no
 fi
-rm -rf conftest.dSYM
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
 fi
-
-
-if test $safe_initialize = yes; then
-
-cat >>confdefs.h <<\_ACEOF
-#define HAVE_INITIALIZE 1
-_ACEOF
-
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
+$as_echo "$CC" >&6; }
 else
-  { $as_echo "$as_me:$LINENO: WARNING: Your ObjectiveC runtime does not support thread-safe class initialisation.  Please use a different runtime if you intend to use threads." >&5
-$as_echo "$as_me: WARNING: Your ObjectiveC runtime does not support thread-safe class initialisation.  Please use a different runtime if you intend to use threads." >&2;}
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
 fi
-{ $as_echo "$as_me:$LINENO: result: $safe_initialize" >&5
-$as_echo "$safe_initialize" >&6; }
-
-LIBS="$saved_LIBS"
-CPPFLAGS="$saved_CPPFLAGS"
 
 
-
-#--------------------------------------------------------------------
-# Generic settings needed by NSZone.m
-#--------------------------------------------------------------------
-{ $as_echo "$as_me:$LINENO: checking for size_t" >&5
-$as_echo_n "checking for size_t... " >&6; }
-if test "${ac_cv_type_size_t+set}" = set; then
+fi
+if test -z "$ac_cv_prog_CC"; then
+  ac_ct_CC=$CC
+  # Extract the first word of "gcc", so it can be a program name with args.
+set dummy gcc; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_prog_ac_ct_CC+:} false; then :
   $as_echo_n "(cached) " >&6
 else
-  ac_cv_type_size_t=no
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-int
-main ()
-{
-if (sizeof (size_t))
-       return 0;
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-int
-main ()
-{
-if (sizeof ((size_t)))
-	  return 0;
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  :
+  if test -n "$ac_ct_CC"; then
+  ac_cv_prog_ac_ct_CC="$ac_ct_CC" # Let the user override the test.
 else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_ac_ct_CC="gcc"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
 
-	ac_cv_type_size_t=yes
+fi
+fi
+ac_ct_CC=$ac_cv_prog_ac_ct_CC
+if test -n "$ac_ct_CC"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_CC" >&5
+$as_echo "$ac_ct_CC" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
 fi
 
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+  if test "x$ac_ct_CC" = x; then
+    CC=""
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    CC=$ac_ct_CC
+  fi
 else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
+  CC="$ac_cv_prog_CC"
+fi
 
+if test -z "$CC"; then
+          if test -n "$ac_tool_prefix"; then
+    # Extract the first word of "${ac_tool_prefix}cc", so it can be a program name with args.
+set dummy ${ac_tool_prefix}cc; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_prog_CC+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_CC="${ac_tool_prefix}cc"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
 
 fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
 fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_type_size_t" >&5
-$as_echo "$ac_cv_type_size_t" >&6; }
-if test "x$ac_cv_type_size_t" = x""yes; then
-  :
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
+$as_echo "$CC" >&6; }
 else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
 
-cat >>confdefs.h <<_ACEOF
-#define size_t unsigned int
-_ACEOF
 
+  fi
 fi
-
-{ $as_echo "$as_me:$LINENO: checking for inline" >&5
-$as_echo_n "checking for inline... " >&6; }
-if test "${ac_cv_c_inline+set}" = set; then
+if test -z "$CC"; then
+  # Extract the first word of "cc", so it can be a program name with args.
+set dummy cc; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_prog_CC+:} false; then :
   $as_echo_n "(cached) " >&6
 else
-  ac_cv_c_inline=no
-for ac_kw in inline __inline__ __inline; do
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#ifndef __cplusplus
-typedef int foo_t;
-static $ac_kw foo_t static_foo () {return 0; }
-$ac_kw foo_t foo () {return 0; }
-#endif
-
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_cv_c_inline=$ac_kw
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
 else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-  test "$ac_cv_c_inline" != no && break
+  ac_prog_rejected=no
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    if test "$as_dir/$ac_word$ac_exec_ext" = "/usr/ucb/cc"; then
+       ac_prog_rejected=yes
+       continue
+     fi
+    ac_cv_prog_CC="cc"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
 done
+  done
+IFS=$as_save_IFS
 
+if test $ac_prog_rejected = yes; then
+  # We found a bogon in the path, so make sure we never use it.
+  set dummy $ac_cv_prog_CC
+  shift
+  if test $# != 0; then
+    # We chose a different compiler from the bogus one.
+    # However, it has the same basename, so the bogon will be chosen
+    # first if we set CC to just the basename; use the full file name.
+    shift
+    ac_cv_prog_CC="$as_dir/$ac_word${1+' '}$@"
+  fi
+fi
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
+$as_echo "$CC" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
 fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_c_inline" >&5
-$as_echo "$ac_cv_c_inline" >&6; }
-
-
-case $ac_cv_c_inline in
-  inline | yes) ;;
-  *)
-    case $ac_cv_c_inline in
-      no) ac_val=;;
-      *) ac_val=$ac_cv_c_inline;;
-    esac
-    cat >>confdefs.h <<_ACEOF
-#ifndef __cplusplus
-#define inline $ac_val
-#endif
-_ACEOF
-    ;;
-esac
 
 
-#--------------------------------------------------------------------
-# Following header checks needed for bzero in Storage.m and other places
-#--------------------------------------------------------------------
-{ $as_echo "$as_me:$LINENO: checking for ANSI C header files" >&5
-$as_echo_n "checking for ANSI C header files... " >&6; }
-if test "${ac_cv_header_stdc+set}" = set; then
+fi
+if test -z "$CC"; then
+  if test -n "$ac_tool_prefix"; then
+  for ac_prog in cl.exe
+  do
+    # Extract the first word of "$ac_tool_prefix$ac_prog", so it can be a program name with args.
+set dummy $ac_tool_prefix$ac_prog; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_prog_CC+:} false; then :
   $as_echo_n "(cached) " >&6
 else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <stdlib.h>
-#include <stdarg.h>
-#include <string.h>
-#include <float.h>
-
-int
-main ()
-{
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_cv_header_stdc=yes
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
 else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_cv_header_stdc=no
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-
-if test $ac_cv_header_stdc = yes; then
-  # SunOS 4.x string.h does not declare mem*, contrary to ANSI.
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <string.h>
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_CC="$ac_tool_prefix$ac_prog"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
 
-_ACEOF
-if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
-  $EGREP "memchr" >/dev/null 2>&1; then
-  :
-else
-  ac_cv_header_stdc=no
 fi
-rm -f conftest*
-
 fi
-
-if test $ac_cv_header_stdc = yes; then
-  # ISC 2.0.2 stdlib.h does not declare free, contrary to ANSI.
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <stdlib.h>
-
-_ACEOF
-if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
-  $EGREP "free" >/dev/null 2>&1; then
-  :
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
+$as_echo "$CC" >&6; }
 else
-  ac_cv_header_stdc=no
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
 fi
-rm -f conftest*
 
-fi
 
-if test $ac_cv_header_stdc = yes; then
-  # /bin/cc in Irix-4.0.5 gets non-ANSI ctype macros unless using -ansi.
-  if test "$cross_compiling" = yes; then
-  :
+    test -n "$CC" && break
+  done
+fi
+if test -z "$CC"; then
+  ac_ct_CC=$CC
+  for ac_prog in cl.exe
+do
+  # Extract the first word of "$ac_prog", so it can be a program name with args.
+set dummy $ac_prog; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_prog_ac_ct_CC+:} false; then :
+  $as_echo_n "(cached) " >&6
 else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <ctype.h>
-#include <stdlib.h>
-#if ((' ' & 0x0FF) == 0x020)
-# define ISLOWER(c) ('a' <= (c) && (c) <= 'z')
-# define TOUPPER(c) (ISLOWER(c) ? 'A' + ((c) - 'a') : (c))
-#else
-# define ISLOWER(c) \
-		   (('a' <= (c) && (c) <= 'i') \
-		     || ('j' <= (c) && (c) <= 'r') \
-		     || ('s' <= (c) && (c) <= 'z'))
-# define TOUPPER(c) (ISLOWER(c) ? ((c) | 0x40) : (c))
-#endif
-
-#define XOR(e, f) (((e) && !(f)) || (!(e) && (f)))
-int
-main ()
-{
-  int i;
-  for (i = 0; i < 256; i++)
-    if (XOR (islower (i), ISLOWER (i))
-	|| toupper (i) != TOUPPER (i))
-      return 2;
-  return 0;
-}
-_ACEOF
-rm -f conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  :
+  if test -n "$ac_ct_CC"; then
+  ac_cv_prog_ac_ct_CC="$ac_ct_CC" # Let the user override the test.
 else
-  $as_echo "$as_me: program exited with status $ac_status" >&5
-$as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-( exit $ac_status )
-ac_cv_header_stdc=no
-fi
-rm -rf conftest.dSYM
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
-fi
-
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_ac_ct_CC="$ac_prog"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
 
 fi
 fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_header_stdc" >&5
-$as_echo "$ac_cv_header_stdc" >&6; }
-if test $ac_cv_header_stdc = yes; then
-
-cat >>confdefs.h <<\_ACEOF
-#define STDC_HEADERS 1
-_ACEOF
-
+ac_ct_CC=$ac_cv_prog_ac_ct_CC
+if test -n "$ac_ct_CC"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_CC" >&5
+$as_echo "$ac_ct_CC" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
 fi
 
 
+  test -n "$ac_ct_CC" && break
+done
 
-
-for ac_header in string.h memory.h alloca.h
-do
-as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  { $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
-$as_echo_n "checking for $ac_header... " >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  $as_echo_n "(cached) " >&6
-fi
-ac_res=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-else
-  # Is the header compilable?
-{ $as_echo "$as_me:$LINENO: checking $ac_header usability" >&5
-$as_echo_n "checking $ac_header usability... " >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-#include <$ac_header>
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
+  if test "x$ac_ct_CC" = x; then
+    CC=""
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
 esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_header_compiler=yes
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
+    CC=$ac_ct_CC
+  fi
+fi
 
-	ac_header_compiler=no
 fi
 
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-{ $as_echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
-$as_echo "$ac_header_compiler" >&6; }
 
-# Is the header present?
-{ $as_echo "$as_me:$LINENO: checking $ac_header presence" >&5
-$as_echo_n "checking $ac_header presence... " >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <$ac_header>
-_ACEOF
-if { (ac_try="$ac_cpp conftest.$ac_ext"
+test -z "$CC" && { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+as_fn_error $? "no acceptable C compiler found in \$PATH
+See \`config.log' for more details" "$LINENO" 5; }
+
+# Provide some information about the compiler.
+$as_echo "$as_me:${as_lineno-$LINENO}: checking for C compiler version" >&5
+set X $ac_compile
+ac_compiler=$2
+for ac_option in --version -v -V -qversion; do
+  { { ac_try="$ac_compiler $ac_option >&5"
 case "(($ac_try" in
   *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
   *) ac_try_echo=$ac_try;;
 esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_compiler $ac_option >&5") 2>conftest.err
   ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } >/dev/null && {
-	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       }; then
-  ac_header_preproc=yes
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-  ac_header_preproc=no
-fi
-
-rm -f conftest.err conftest.$ac_ext
-{ $as_echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
-$as_echo "$ac_header_preproc" >&6; }
+  if test -s conftest.err; then
+    sed '10a\
+... rest of stderr output deleted ...
+         10q' conftest.err >conftest.er1
+    cat conftest.er1 >&5
+  fi
+  rm -f conftest.er1 conftest.err
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }
+done
 
-# So?  What about this header?
-case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
-  yes:no: )
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
-$as_echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the compiler's result" >&5
-$as_echo "$as_me: WARNING: $ac_header: proceeding with the compiler's result" >&2;}
-    ac_header_preproc=yes
-    ;;
-  no:yes:* )
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
-$as_echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header:     check for missing prerequisite headers?" >&5
-$as_echo "$as_me: WARNING: $ac_header:     check for missing prerequisite headers?" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: see the Autoconf documentation" >&5
-$as_echo "$as_me: WARNING: $ac_header: see the Autoconf documentation" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&5
-$as_echo "$as_me: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
-$as_echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: in the future, the compiler will take precedence" >&5
-$as_echo "$as_me: WARNING: $ac_header: in the future, the compiler will take precedence" >&2;}
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
 
-    ;;
-esac
-{ $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
-$as_echo_n "checking for $ac_header... " >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  $as_echo_n "(cached) " >&6
-else
-  eval "$as_ac_Header=\$ac_header_preproc"
-fi
-ac_res=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
+int
+main ()
+{
 
-fi
-as_val=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-   if test "x$as_val" = x""yes; then
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
+  ;
+  return 0;
+}
 _ACEOF
+ac_clean_files_save=$ac_clean_files
+ac_clean_files="$ac_clean_files a.out a.out.dSYM a.exe b.out"
+# Try to create an executable without -o first, disregard a.out.
+# It will help us diagnose broken compilers, and finding out an intuition
+# of exeext.
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the C compiler works" >&5
+$as_echo_n "checking whether the C compiler works... " >&6; }
+ac_link_default=`$as_echo "$ac_link" | sed 's/ -o *conftest[^ ]*//'`
 
-fi
+# The possible output files:
+ac_files="a.out conftest.exe conftest a.exe a_out.exe b.out conftest.*"
 
+ac_rmfiles=
+for ac_file in $ac_files
+do
+  case $ac_file in
+    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM | *.o | *.obj ) ;;
+    * ) ac_rmfiles="$ac_rmfiles $ac_file";;
+  esac
 done
+rm -f $ac_rmfiles
 
-
-#--------------------------------------------------------------------
-# Following header check needed NSConnection.h
-#--------------------------------------------------------------------
-
-for ac_header in float.h
-do
-as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  { $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
-$as_echo_n "checking for $ac_header... " >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  $as_echo_n "(cached) " >&6
-fi
-ac_res=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-else
-  # Is the header compilable?
-{ $as_echo "$as_me:$LINENO: checking $ac_header usability" >&5
-$as_echo_n "checking $ac_header usability... " >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-#include <$ac_header>
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
+if { { ac_try="$ac_link_default"
 case "(($ac_try" in
   *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
   *) ac_try_echo=$ac_try;;
 esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_link_default") 2>&5
   ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_header_compiler=yes
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; then :
+  # Autoconf-2.13 could set the ac_cv_exeext variable to `no'.
+# So ignore a value of `no', otherwise this would lead to `EXEEXT = no'
+# in a Makefile.  We should not override ac_cv_exeext if it was cached,
+# so that the user can short-circuit this test for compilers unknown to
+# Autoconf.
+for ac_file in $ac_files ''
+do
+  test -f "$ac_file" || continue
+  case $ac_file in
+    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM | *.o | *.obj )
+	;;
+    [ab].out )
+	# We found the default executable, but exeext='' is most
+	# certainly right.
+	break;;
+    *.* )
+	if test "${ac_cv_exeext+set}" = set && test "$ac_cv_exeext" != no;
+	then :; else
+	   ac_cv_exeext=`expr "$ac_file" : '[^.]*\(\..*\)'`
+	fi
+	# We set ac_cv_exeext here because the later test for it is not
+	# safe: cross compilers may not add the suffix if given an `-o'
+	# argument, so we may need to know it at that point already.
+	# Even if this section looks crufty: it has the advantage of
+	# actually working.
+	break;;
+    * )
+	break;;
+  esac
+done
+test "$ac_cv_exeext" = no && ac_cv_exeext=
+
 else
-  $as_echo "$as_me: failed program was:" >&5
+  ac_file=''
+fi
+if test -z "$ac_file"; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+$as_echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-	ac_header_compiler=no
+{ { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+as_fn_error 77 "C compiler cannot create executables
+See \`config.log' for more details" "$LINENO" 5; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
 fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for C compiler default output file name" >&5
+$as_echo_n "checking for C compiler default output file name... " >&6; }
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_file" >&5
+$as_echo "$ac_file" >&6; }
+ac_exeext=$ac_cv_exeext
 
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-{ $as_echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
-$as_echo "$ac_header_compiler" >&6; }
-
-# Is the header present?
-{ $as_echo "$as_me:$LINENO: checking $ac_header presence" >&5
-$as_echo_n "checking $ac_header presence... " >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <$ac_header>
-_ACEOF
-if { (ac_try="$ac_cpp conftest.$ac_ext"
+rm -f -r a.out a.out.dSYM a.exe conftest$ac_cv_exeext b.out
+ac_clean_files=$ac_clean_files_save
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for suffix of executables" >&5
+$as_echo_n "checking for suffix of executables... " >&6; }
+if { { ac_try="$ac_link"
 case "(($ac_try" in
   *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
   *) ac_try_echo=$ac_try;;
 esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_link") 2>&5
   ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } >/dev/null && {
-	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       }; then
-  ac_header_preproc=yes
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-  ac_header_preproc=no
-fi
-
-rm -f conftest.err conftest.$ac_ext
-{ $as_echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
-$as_echo "$ac_header_preproc" >&6; }
-
-# So?  What about this header?
-case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
-  yes:no: )
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
-$as_echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the compiler's result" >&5
-$as_echo "$as_me: WARNING: $ac_header: proceeding with the compiler's result" >&2;}
-    ac_header_preproc=yes
-    ;;
-  no:yes:* )
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
-$as_echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header:     check for missing prerequisite headers?" >&5
-$as_echo "$as_me: WARNING: $ac_header:     check for missing prerequisite headers?" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: see the Autoconf documentation" >&5
-$as_echo "$as_me: WARNING: $ac_header: see the Autoconf documentation" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&5
-$as_echo "$as_me: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
-$as_echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: in the future, the compiler will take precedence" >&5
-$as_echo "$as_me: WARNING: $ac_header: in the future, the compiler will take precedence" >&2;}
-
-    ;;
-esac
-{ $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
-$as_echo_n "checking for $ac_header... " >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  $as_echo_n "(cached) " >&6
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; then :
+  # If both `conftest.exe' and `conftest' are `present' (well, observable)
+# catch `conftest.exe'.  For instance with Cygwin, `ls conftest' will
+# work properly (i.e., refer to `conftest.exe'), while it won't with
+# `rm'.
+for ac_file in conftest.exe conftest conftest.*; do
+  test -f "$ac_file" || continue
+  case $ac_file in
+    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM | *.o | *.obj ) ;;
+    *.* ) ac_cv_exeext=`expr "$ac_file" : '[^.]*\(\..*\)'`
+	  break;;
+    * ) break;;
+  esac
+done
 else
-  eval "$as_ac_Header=\$ac_header_preproc"
-fi
-ac_res=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-
-fi
-as_val=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-   if test "x$as_val" = x""yes; then
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
-_ACEOF
-
+  { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+as_fn_error $? "cannot compute suffix of executables: cannot compile and link
+See \`config.log' for more details" "$LINENO" 5; }
 fi
+rm -f conftest conftest$ac_cv_exeext
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_exeext" >&5
+$as_echo "$ac_cv_exeext" >&6; }
 
-done
-
-
-#--------------------------------------------------------------------
-# Header files and functions for files and filesystems
-#--------------------------------------------------------------------
-
-
-
-
-
-
-for ac_header in sys/stat.h sys/vfs.h sys/statfs.h sys/statvfs.h pwd.h grp.h
-do
-as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  { $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
-$as_echo_n "checking for $ac_header... " >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  $as_echo_n "(cached) " >&6
-fi
-ac_res=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-else
-  # Is the header compilable?
-{ $as_echo "$as_me:$LINENO: checking $ac_header usability" >&5
-$as_echo_n "checking $ac_header usability... " >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+rm -f conftest.$ac_ext
+EXEEXT=$ac_cv_exeext
+ac_exeext=$EXEEXT
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
-$ac_includes_default
-#include <$ac_header>
+#include <stdio.h>
+int
+main ()
+{
+FILE *f = fopen ("conftest.out", "w");
+ return ferror (f) || fclose (f) != 0;
+
+  ;
+  return 0;
+}
 _ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
+ac_clean_files="$ac_clean_files conftest.out"
+# Check that the compiler produces executables we can run.  If not, either
+# the compiler is broken, or we cross compile.
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether we are cross compiling" >&5
+$as_echo_n "checking whether we are cross compiling... " >&6; }
+if test "$cross_compiling" != yes; then
+  { { ac_try="$ac_link"
 case "(($ac_try" in
   *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
   *) ac_try_echo=$ac_try;;
 esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_link") 2>&5
   ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_header_compiler=yes
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_header_compiler=no
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-{ $as_echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
-$as_echo "$ac_header_compiler" >&6; }
-
-# Is the header present?
-{ $as_echo "$as_me:$LINENO: checking $ac_header presence" >&5
-$as_echo_n "checking $ac_header presence... " >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <$ac_header>
-_ACEOF
-if { (ac_try="$ac_cpp conftest.$ac_ext"
-case "(($ac_try" in
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }
+  if { ac_try='./conftest$ac_cv_exeext'
+  { { case "(($ac_try" in
   *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
   *) ac_try_echo=$ac_try;;
 esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_try") 2>&5
   ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } >/dev/null && {
-	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       }; then
-  ac_header_preproc=yes
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-  ac_header_preproc=no
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; }; then
+    cross_compiling=no
+  else
+    if test "$cross_compiling" = maybe; then
+	cross_compiling=yes
+    else
+	{ { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+as_fn_error $? "cannot run C compiled programs.
+If you meant to cross compile, use \`--host'.
+See \`config.log' for more details" "$LINENO" 5; }
+    fi
+  fi
 fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $cross_compiling" >&5
+$as_echo "$cross_compiling" >&6; }
 
-rm -f conftest.err conftest.$ac_ext
-{ $as_echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
-$as_echo "$ac_header_preproc" >&6; }
-
-# So?  What about this header?
-case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
-  yes:no: )
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
-$as_echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the compiler's result" >&5
-$as_echo "$as_me: WARNING: $ac_header: proceeding with the compiler's result" >&2;}
-    ac_header_preproc=yes
-    ;;
-  no:yes:* )
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
-$as_echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header:     check for missing prerequisite headers?" >&5
-$as_echo "$as_me: WARNING: $ac_header:     check for missing prerequisite headers?" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: see the Autoconf documentation" >&5
-$as_echo "$as_me: WARNING: $ac_header: see the Autoconf documentation" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&5
-$as_echo "$as_me: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
-$as_echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: in the future, the compiler will take precedence" >&5
-$as_echo "$as_me: WARNING: $ac_header: in the future, the compiler will take precedence" >&2;}
-
-    ;;
-esac
-{ $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
-$as_echo_n "checking for $ac_header... " >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
+rm -f conftest.$ac_ext conftest$ac_cv_exeext conftest.out
+ac_clean_files=$ac_clean_files_save
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for suffix of object files" >&5
+$as_echo_n "checking for suffix of object files... " >&6; }
+if ${ac_cv_objext+:} false; then :
   $as_echo_n "(cached) " >&6
 else
-  eval "$as_ac_Header=\$ac_header_preproc"
-fi
-ac_res=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-
-fi
-as_val=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-   if test "x$as_val" = x""yes; then
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
-_ACEOF
-
-fi
-
-done
-
-
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
 
+int
+main ()
+{
 
-for ac_header in sys/cdefs.h sys/syslimits.h sys/param.h
-do
-as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  { $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
-$as_echo_n "checking for $ac_header... " >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  $as_echo_n "(cached) " >&6
-fi
-ac_res=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-else
-  # Is the header compilable?
-{ $as_echo "$as_me:$LINENO: checking $ac_header usability" >&5
-$as_echo_n "checking $ac_header usability... " >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-#include <$ac_header>
+  ;
+  return 0;
+}
 _ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
+rm -f conftest.o conftest.obj
+if { { ac_try="$ac_compile"
 case "(($ac_try" in
   *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
   *) ac_try_echo=$ac_try;;
 esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_compile") 2>&5
   ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_header_compiler=yes
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; then :
+  for ac_file in conftest.o conftest.obj conftest.*; do
+  test -f "$ac_file" || continue;
+  case $ac_file in
+    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM ) ;;
+    *) ac_cv_objext=`expr "$ac_file" : '.*\.\(.*\)'`
+       break;;
+  esac
+done
 else
   $as_echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-	ac_header_compiler=no
+{ { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+as_fn_error $? "cannot compute suffix of object files: cannot compile
+See \`config.log' for more details" "$LINENO" 5; }
 fi
+rm -f conftest.$ac_cv_objext conftest.$ac_ext
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_objext" >&5
+$as_echo "$ac_cv_objext" >&6; }
+OBJEXT=$ac_cv_objext
+ac_objext=$OBJEXT
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether we are using the GNU C compiler" >&5
+$as_echo_n "checking whether we are using the GNU C compiler... " >&6; }
+if ${ac_cv_c_compiler_gnu+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
 
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-{ $as_echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
-$as_echo "$ac_header_compiler" >&6; }
+int
+main ()
+{
+#ifndef __GNUC__
+       choke me
+#endif
 
-# Is the header present?
-{ $as_echo "$as_me:$LINENO: checking $ac_header presence" >&5
-$as_echo_n "checking $ac_header presence... " >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <$ac_header>
+  ;
+  return 0;
+}
 _ACEOF
-if { (ac_try="$ac_cpp conftest.$ac_ext"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } >/dev/null && {
-	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       }; then
-  ac_header_preproc=yes
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_compiler_gnu=yes
 else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-  ac_header_preproc=no
+  ac_compiler_gnu=no
 fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+ac_cv_c_compiler_gnu=$ac_compiler_gnu
 
-rm -f conftest.err conftest.$ac_ext
-{ $as_echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
-$as_echo "$ac_header_preproc" >&6; }
-
-# So?  What about this header?
-case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
-  yes:no: )
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
-$as_echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the compiler's result" >&5
-$as_echo "$as_me: WARNING: $ac_header: proceeding with the compiler's result" >&2;}
-    ac_header_preproc=yes
-    ;;
-  no:yes:* )
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
-$as_echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header:     check for missing prerequisite headers?" >&5
-$as_echo "$as_me: WARNING: $ac_header:     check for missing prerequisite headers?" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: see the Autoconf documentation" >&5
-$as_echo "$as_me: WARNING: $ac_header: see the Autoconf documentation" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&5
-$as_echo "$as_me: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
-$as_echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: in the future, the compiler will take precedence" >&5
-$as_echo "$as_me: WARNING: $ac_header: in the future, the compiler will take precedence" >&2;}
-
-    ;;
-esac
-{ $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
-$as_echo_n "checking for $ac_header... " >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  $as_echo_n "(cached) " >&6
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_c_compiler_gnu" >&5
+$as_echo "$ac_cv_c_compiler_gnu" >&6; }
+if test $ac_compiler_gnu = yes; then
+  GCC=yes
 else
-  eval "$as_ac_Header=\$ac_header_preproc"
+  GCC=
 fi
-ac_res=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
+ac_test_CFLAGS=${CFLAGS+set}
+ac_save_CFLAGS=$CFLAGS
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether $CC accepts -g" >&5
+$as_echo_n "checking whether $CC accepts -g... " >&6; }
+if ${ac_cv_prog_cc_g+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_save_c_werror_flag=$ac_c_werror_flag
+   ac_c_werror_flag=yes
+   ac_cv_prog_cc_g=no
+   CFLAGS="-g"
+   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
 
-fi
-as_val=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-   if test "x$as_val" = x""yes; then
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
+int
+main ()
+{
+
+  ;
+  return 0;
+}
 _ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_cv_prog_cc_g=yes
+else
+  CFLAGS=""
+      cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
 
-fi
+int
+main ()
+{
 
-done
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
 
-# Twisted header checks for some BSDs with stupid interdependencies
+else
+  ac_c_werror_flag=$ac_save_c_werror_flag
+	 CFLAGS="-g"
+	 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
 
-for ac_header in sys/syslimits.h
-do
-as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
-{ $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
-$as_echo_n "checking for $ac_header... " >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_cv_prog_cc_g=yes
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+   ac_c_werror_flag=$ac_save_c_werror_flag
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_cc_g" >&5
+$as_echo "$ac_cv_prog_cc_g" >&6; }
+if test "$ac_test_CFLAGS" = set; then
+  CFLAGS=$ac_save_CFLAGS
+elif test $ac_cv_prog_cc_g = yes; then
+  if test "$GCC" = yes; then
+    CFLAGS="-g -O2"
+  else
+    CFLAGS="-g"
+  fi
+else
+  if test "$GCC" = yes; then
+    CFLAGS="-O2"
+  else
+    CFLAGS=
+  fi
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $CC option to accept ISO C89" >&5
+$as_echo_n "checking for $CC option to accept ISO C89... " >&6; }
+if ${ac_cv_prog_cc_c89+:} false; then :
   $as_echo_n "(cached) " >&6
 else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+  ac_cv_prog_cc_c89=no
+ac_save_CC=$CC
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
-#if HAVE_SYS_CDEFS_H
-   #include <sys/cdefs.h>
-   #endif
-   #include <sys/syslimits.h>
+#include <stdarg.h>
+#include <stdio.h>
+struct stat;
+/* Most of the following tests are stolen from RCS 5.7's src/conf.sh.  */
+struct buf { int x; };
+FILE * (*rcsopen) (struct buf *, struct stat *, int);
+static char *e (p, i)
+     char **p;
+     int i;
+{
+  return p[i];
+}
+static char *f (char * (*g) (char **, int), char **p, ...)
+{
+  char *s;
+  va_list v;
+  va_start (v,p);
+  s = g (p, va_arg (v,int));
+  va_end (v);
+  return s;
+}
+
+/* OSF 4.0 Compaq cc is some sort of almost-ANSI by default.  It has
+   function prototypes and stuff, but not '\xHH' hex character constants.
+   These don't provoke an error unfortunately, instead are silently treated
+   as 'x'.  The following induces an error, until -std is added to get
+   proper ANSI mode.  Curiously '\x00'!='x' always comes out true, for an
+   array size at least.  It's necessary to write '\x00'==0 to get something
+   that's true only with -std.  */
+int osf4_cc_array ['\x00' == 0 ? 1 : -1];
 
+/* IBM C 6 for AIX is almost-ANSI by default, but it replaces macro parameters
+   inside strings and character constants.  */
+#define FOO(x) 'x'
+int xlc6_cc_array[FOO(a) == 'x' ? 1 : -1];
 
-#include <$ac_header>
+int test (int i, double x);
+struct s1 {int (*f) (int a);};
+struct s2 {int (*f) (double a);};
+int pairnames (int, char **, FILE *(*)(struct buf *, struct stat *, int), int, int);
+int argc;
+char **argv;
+int
+main ()
+{
+return f (e, argv, 0) != argv[0]  ||  f (e, argv, 1) != argv[1];
+  ;
+  return 0;
+}
 _ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  eval "$as_ac_Header=yes"
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	eval "$as_ac_Header=no"
+for ac_arg in '' -qlanglvl=extc89 -qlanglvl=ansi -std \
+	-Ae "-Aa -D_HPUX_SOURCE" "-Xc -D__EXTENSIONS__"
+do
+  CC="$ac_save_CC $ac_arg"
+  if ac_fn_c_try_compile "$LINENO"; then :
+  ac_cv_prog_cc_c89=$ac_arg
 fi
+rm -f core conftest.err conftest.$ac_objext
+  test "x$ac_cv_prog_cc_c89" != "xno" && break
+done
+rm -f conftest.$ac_ext
+CC=$ac_save_CC
 
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
 fi
-ac_res=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-as_val=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-   if test "x$as_val" = x""yes; then
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
-_ACEOF
+# AC_CACHE_VAL
+case "x$ac_cv_prog_cc_c89" in
+  x)
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: none needed" >&5
+$as_echo "none needed" >&6; } ;;
+  xno)
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: unsupported" >&5
+$as_echo "unsupported" >&6; } ;;
+  *)
+    CC="$CC $ac_cv_prog_cc_c89"
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_cc_c89" >&5
+$as_echo "$ac_cv_prog_cc_c89" >&6; } ;;
+esac
+if test "x$ac_cv_prog_cc_c89" != xno; then :
 
 fi
 
-done
-
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
 
-for ac_header in sys/param.h
-do
-as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
-{ $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
-$as_echo_n "checking for $ac_header... " >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking how to run the C preprocessor" >&5
+$as_echo_n "checking how to run the C preprocessor... " >&6; }
+# On Suns, sometimes $CPP names a directory.
+if test -n "$CPP" && test -d "$CPP"; then
+  CPP=
+fi
+if test -z "$CPP"; then
+  if ${ac_cv_prog_CPP+:} false; then :
   $as_echo_n "(cached) " >&6
 else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+      # Double quotes because CPP needs to be expanded
+    for CPP in "$CC -E" "$CC -E -traditional-cpp" "/lib/cpp"
+    do
+      ac_preproc_ok=false
+for ac_c_preproc_warn_flag in '' yes
+do
+  # Use a header file that comes with gcc, so configuring glibc
+  # with a fresh cross-compiler works.
+  # Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+  # <limits.h> exists even on freestanding compilers.
+  # On the NeXT, cc -E runs the code through the compiler's parser,
+  # not just through cpp. "Syntax error" is here to catch this case.
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
-#if HAVE_SYS_CDEFS_H
-   #include <sys/cdefs.h>
-   #endif
-   #if HAVE_SYS_SYSLIMITS_H
-   #include <sys/syslimits.h>
-   #endif
-
-
-#include <$ac_header>
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+		     Syntax error
 _ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  eval "$as_ac_Header=yes"
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
+if ac_fn_c_try_cpp "$LINENO"; then :
 
-	eval "$as_ac_Header=no"
+else
+  # Broken: fails on valid input.
+continue
 fi
+rm -f conftest.err conftest.i conftest.$ac_ext
 
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-ac_res=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-as_val=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-   if test "x$as_val" = x""yes; then
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
+  # OK, works on sane cases.  Now check whether nonexistent headers
+  # can be detected and how.
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <ac_nonexistent.h>
 _ACEOF
-
+if ac_fn_c_try_cpp "$LINENO"; then :
+  # Broken: success on invalid input.
+continue
+else
+  # Passes both tests.
+ac_preproc_ok=:
+break
 fi
+rm -f conftest.err conftest.i conftest.$ac_ext
 
 done
+# Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
+rm -f conftest.i conftest.err conftest.$ac_ext
+if $ac_preproc_ok; then :
+  break
+fi
 
+    done
+    ac_cv_prog_CPP=$CPP
 
-for ac_header in sys/mount.h
-do
-as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
-{ $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
-$as_echo_n "checking for $ac_header... " >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  $as_echo_n "(cached) " >&6
+fi
+  CPP=$ac_cv_prog_CPP
 else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+  ac_cv_prog_CPP=$CPP
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $CPP" >&5
+$as_echo "$CPP" >&6; }
+ac_preproc_ok=false
+for ac_c_preproc_warn_flag in '' yes
+do
+  # Use a header file that comes with gcc, so configuring glibc
+  # with a fresh cross-compiler works.
+  # Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+  # <limits.h> exists even on freestanding compilers.
+  # On the NeXT, cc -E runs the code through the compiler's parser,
+  # not just through cpp. "Syntax error" is here to catch this case.
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
-#if HAVE_SYS_CDEFS_H
-   #include <sys/cdefs.h>
-   #endif
-   #if HAVE_SYS_SYSLIMITS_H
-   #include <sys/syslimits.h>
-   #endif
-   #if HAVE_SYS_PARAM_H
-   #include <sys/param.h>
-   #endif
-
-
-#include <$ac_header>
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+		     Syntax error
 _ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  eval "$as_ac_Header=yes"
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
+if ac_fn_c_try_cpp "$LINENO"; then :
 
-	eval "$as_ac_Header=no"
+else
+  # Broken: fails on valid input.
+continue
 fi
+rm -f conftest.err conftest.i conftest.$ac_ext
 
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-ac_res=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-as_val=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-   if test "x$as_val" = x""yes; then
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
+  # OK, works on sane cases.  Now check whether nonexistent headers
+  # can be detected and how.
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <ac_nonexistent.h>
 _ACEOF
-
+if ac_fn_c_try_cpp "$LINENO"; then :
+  # Broken: success on invalid input.
+continue
+else
+  # Passes both tests.
+ac_preproc_ok=:
+break
 fi
+rm -f conftest.err conftest.i conftest.$ac_ext
 
 done
+# Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
+rm -f conftest.i conftest.err conftest.$ac_ext
+if $ac_preproc_ok; then :
 
+else
+  { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+as_fn_error $? "C preprocessor \"$CPP\" fails sanity check
+See \`config.log' for more details" "$LINENO" 5; }
+fi
 
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
 
 
 
-for ac_header in sys/types.h windows.h locale.h langinfo.h
-do
-as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  { $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
-$as_echo_n "checking for $ac_header... " >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for grep that handles long lines and -e" >&5
+$as_echo_n "checking for grep that handles long lines and -e... " >&6; }
+if ${ac_cv_path_GREP+:} false; then :
   $as_echo_n "(cached) " >&6
-fi
-ac_res=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
 else
-  # Is the header compilable?
-{ $as_echo "$as_me:$LINENO: checking $ac_header usability" >&5
-$as_echo_n "checking $ac_header usability... " >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-#include <$ac_header>
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
+  if test -z "$GREP"; then
+  ac_path_GREP_found=false
+  # Loop through the user's path and test for each of PROGNAME-LIST
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH$PATH_SEPARATOR/usr/xpg4/bin
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_prog in grep ggrep; do
+    for ac_exec_ext in '' $ac_executable_extensions; do
+      ac_path_GREP="$as_dir/$ac_prog$ac_exec_ext"
+      as_fn_executable_p "$ac_path_GREP" || continue
+# Check for GNU ac_path_GREP and select it if it is found.
+  # Check for GNU $ac_path_GREP
+case `"$ac_path_GREP" --version 2>&1` in
+*GNU*)
+  ac_cv_path_GREP="$ac_path_GREP" ac_path_GREP_found=:;;
+*)
+  ac_count=0
+  $as_echo_n 0123456789 >"conftest.in"
+  while :
+  do
+    cat "conftest.in" "conftest.in" >"conftest.tmp"
+    mv "conftest.tmp" "conftest.in"
+    cp "conftest.in" "conftest.nl"
+    $as_echo 'GREP' >> "conftest.nl"
+    "$ac_path_GREP" -e 'GREP$' -e '-(cannot match)-' < "conftest.nl" >"conftest.out" 2>/dev/null || break
+    diff "conftest.out" "conftest.nl" >/dev/null 2>&1 || break
+    as_fn_arith $ac_count + 1 && ac_count=$as_val
+    if test $ac_count -gt ${ac_path_GREP_max-0}; then
+      # Best one so far, save it but keep looking for a better one
+      ac_cv_path_GREP="$ac_path_GREP"
+      ac_path_GREP_max=$ac_count
+    fi
+    # 10*(2^10) chars as input seems more than enough
+    test $ac_count -gt 10 && break
+  done
+  rm -f conftest.in conftest.tmp conftest.nl conftest.out;;
 esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_header_compiler=yes
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_header_compiler=no
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-{ $as_echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
-$as_echo "$ac_header_compiler" >&6; }
 
-# Is the header present?
-{ $as_echo "$as_me:$LINENO: checking $ac_header presence" >&5
-$as_echo_n "checking $ac_header presence... " >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <$ac_header>
-_ACEOF
-if { (ac_try="$ac_cpp conftest.$ac_ext"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } >/dev/null && {
-	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       }; then
-  ac_header_preproc=yes
+      $ac_path_GREP_found && break 3
+    done
+  done
+  done
+IFS=$as_save_IFS
+  if test -z "$ac_cv_path_GREP"; then
+    as_fn_error $? "no acceptable grep could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" "$LINENO" 5
+  fi
 else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-  ac_header_preproc=no
+  ac_cv_path_GREP=$GREP
 fi
 
-rm -f conftest.err conftest.$ac_ext
-{ $as_echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
-$as_echo "$ac_header_preproc" >&6; }
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_path_GREP" >&5
+$as_echo "$ac_cv_path_GREP" >&6; }
+ GREP="$ac_cv_path_GREP"
 
-# So?  What about this header?
-case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
-  yes:no: )
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
-$as_echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the compiler's result" >&5
-$as_echo "$as_me: WARNING: $ac_header: proceeding with the compiler's result" >&2;}
-    ac_header_preproc=yes
-    ;;
-  no:yes:* )
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
-$as_echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header:     check for missing prerequisite headers?" >&5
-$as_echo "$as_me: WARNING: $ac_header:     check for missing prerequisite headers?" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: see the Autoconf documentation" >&5
-$as_echo "$as_me: WARNING: $ac_header: see the Autoconf documentation" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&5
-$as_echo "$as_me: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
-$as_echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: in the future, the compiler will take precedence" >&5
-$as_echo "$as_me: WARNING: $ac_header: in the future, the compiler will take precedence" >&2;}
 
-    ;;
-esac
-{ $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
-$as_echo_n "checking for $ac_header... " >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for egrep" >&5
+$as_echo_n "checking for egrep... " >&6; }
+if ${ac_cv_path_EGREP+:} false; then :
   $as_echo_n "(cached) " >&6
 else
-  eval "$as_ac_Header=\$ac_header_preproc"
-fi
-ac_res=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
+  if echo a | $GREP -E '(a|b)' >/dev/null 2>&1
+   then ac_cv_path_EGREP="$GREP -E"
+   else
+     if test -z "$EGREP"; then
+  ac_path_EGREP_found=false
+  # Loop through the user's path and test for each of PROGNAME-LIST
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH$PATH_SEPARATOR/usr/xpg4/bin
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_prog in egrep; do
+    for ac_exec_ext in '' $ac_executable_extensions; do
+      ac_path_EGREP="$as_dir/$ac_prog$ac_exec_ext"
+      as_fn_executable_p "$ac_path_EGREP" || continue
+# Check for GNU ac_path_EGREP and select it if it is found.
+  # Check for GNU $ac_path_EGREP
+case `"$ac_path_EGREP" --version 2>&1` in
+*GNU*)
+  ac_cv_path_EGREP="$ac_path_EGREP" ac_path_EGREP_found=:;;
+*)
+  ac_count=0
+  $as_echo_n 0123456789 >"conftest.in"
+  while :
+  do
+    cat "conftest.in" "conftest.in" >"conftest.tmp"
+    mv "conftest.tmp" "conftest.in"
+    cp "conftest.in" "conftest.nl"
+    $as_echo 'EGREP' >> "conftest.nl"
+    "$ac_path_EGREP" 'EGREP$' < "conftest.nl" >"conftest.out" 2>/dev/null || break
+    diff "conftest.out" "conftest.nl" >/dev/null 2>&1 || break
+    as_fn_arith $ac_count + 1 && ac_count=$as_val
+    if test $ac_count -gt ${ac_path_EGREP_max-0}; then
+      # Best one so far, save it but keep looking for a better one
+      ac_cv_path_EGREP="$ac_path_EGREP"
+      ac_path_EGREP_max=$ac_count
+    fi
+    # 10*(2^10) chars as input seems more than enough
+    test $ac_count -gt 10 && break
+  done
+  rm -f conftest.in conftest.tmp conftest.nl conftest.out;;
+esac
 
+      $ac_path_EGREP_found && break 3
+    done
+  done
+  done
+IFS=$as_save_IFS
+  if test -z "$ac_cv_path_EGREP"; then
+    as_fn_error $? "no acceptable egrep could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" "$LINENO" 5
+  fi
+else
+  ac_cv_path_EGREP=$EGREP
 fi
-as_val=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-   if test "x$as_val" = x""yes; then
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
-_ACEOF
 
+   fi
 fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_path_EGREP" >&5
+$as_echo "$ac_cv_path_EGREP" >&6; }
+ EGREP="$ac_cv_path_EGREP"
 
-done
-
-saved_LIBS="$LIBS"
 
-{ $as_echo "$as_me:$LINENO: checking for main in -lm" >&5
-$as_echo_n "checking for main in -lm... " >&6; }
-if test "${ac_cv_lib_m_main+set}" = set; then
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for ANSI C header files" >&5
+$as_echo_n "checking for ANSI C header files... " >&6; }
+if ${ac_cv_header_stdc+:} false; then :
   $as_echo_n "(cached) " >&6
 else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-lm  $LIBS"
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
-
+#include <stdlib.h>
+#include <stdarg.h>
+#include <string.h>
+#include <float.h>
 
 int
 main ()
 {
-return main ();
+
   ;
   return 0;
 }
 _ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then
-  ac_cv_lib_m_main=yes
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_cv_header_stdc=yes
 else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_cv_lib_m_main=no
+  ac_cv_header_stdc=no
 fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
 
-rm -rf conftest.dSYM
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_lib_m_main" >&5
-$as_echo "$ac_cv_lib_m_main" >&6; }
-if test "x$ac_cv_lib_m_main" = x""yes; then
-  cat >>confdefs.h <<_ACEOF
-#define HAVE_LIBM 1
-_ACEOF
+if test $ac_cv_header_stdc = yes; then
+  # SunOS 4.x string.h does not declare mem*, contrary to ANSI.
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <string.h>
 
-  LIBS="-lm $LIBS"
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "memchr" >/dev/null 2>&1; then :
 
+else
+  ac_cv_header_stdc=no
 fi
+rm -f conftest*
 
+fi
 
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-for ac_func in statvfs link symlink readlink geteuid getlogin getpwnam getpwnam_r getpwuid getpwuid_r getgrgid getgrgid_r getgrnam getgrnam_r rint getopt
-do
-as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
-{ $as_echo "$as_me:$LINENO: checking for $ac_func" >&5
-$as_echo_n "checking for $ac_func... " >&6; }
-if { as_var=$as_ac_var; eval "test \"\${$as_var+set}\" = set"; }; then
-  $as_echo_n "(cached) " >&6
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+if test $ac_cv_header_stdc = yes; then
+  # ISC 2.0.2 stdlib.h does not declare free, contrary to ANSI.
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
-/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.
-   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
-#define $ac_func innocuous_$ac_func
-
-/* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char $ac_func (); below.
-    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-    <limits.h> exists even on freestanding compilers.  */
-
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
-
-#undef $ac_func
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char $ac_func ();
-/* The GNU C library defines this for functions which it implements
-    to always fail with ENOSYS.  Some functions are actually named
-    something starting with __ and the normal name is an alias.  */
-#if defined __stub_$ac_func || defined __stub___$ac_func
-choke me
-#endif
+#include <stdlib.h>
 
-int
-main ()
-{
-return $ac_func ();
-  ;
-  return 0;
-}
 _ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then
-  eval "$as_ac_var=yes"
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	eval "$as_ac_var=no"
-fi
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "free" >/dev/null 2>&1; then :
 
-rm -rf conftest.dSYM
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
+else
+  ac_cv_header_stdc=no
 fi
-ac_res=`eval 'as_val=${'$as_ac_var'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-as_val=`eval 'as_val=${'$as_ac_var'}
-		 $as_echo "$as_val"'`
-   if test "x$as_val" = x""yes; then
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
-_ACEOF
+rm -f conftest*
 
 fi
-done
 
-LIBS="$saved_LIBS"
-
-{ $as_echo "$as_me:$LINENO: checking for pw_gecos field in struct passwd" >&5
-$as_echo_n "checking for pw_gecos field in struct passwd... " >&6; }
-if test "${ac_cv_have_pw_gecos_in_struct_passwd+set}" = set; then
-  $as_echo_n "(cached) " >&6
+if test $ac_cv_header_stdc = yes; then
+  # /bin/cc in Irix-4.0.5 gets non-ANSI ctype macros unless using -ansi.
+  if test "$cross_compiling" = yes; then :
+  :
 else
-
-	cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
- #include <pwd.h>
+#include <ctype.h>
+#include <stdlib.h>
+#if ((' ' & 0x0FF) == 0x020)
+# define ISLOWER(c) ('a' <= (c) && (c) <= 'z')
+# define TOUPPER(c) (ISLOWER(c) ? 'A' + ((c) - 'a') : (c))
+#else
+# define ISLOWER(c) \
+		   (('a' <= (c) && (c) <= 'i') \
+		     || ('j' <= (c) && (c) <= 'r') \
+		     || ('s' <= (c) && (c) <= 'z'))
+# define TOUPPER(c) (ISLOWER(c) ? ((c) | 0x40) : (c))
+#endif
+
+#define XOR(e, f) (((e) && !(f)) || (!(e) && (f)))
 int
 main ()
 {
- struct passwd p; p.pw_gecos = 0;
-  ;
+  int i;
+  for (i = 0; i < 256; i++)
+    if (XOR (islower (i), ISLOWER (i))
+	|| toupper (i) != TOUPPER (i))
+      return 2;
   return 0;
 }
 _ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-   ac_cv_have_pw_gecos_in_struct_passwd="yes"
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
+if ac_fn_c_try_run "$LINENO"; then :
 
-	 ac_cv_have_pw_gecos_in_struct_passwd="no"
+else
+  ac_cv_header_stdc=no
+fi
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
+  conftest.$ac_objext conftest.beam conftest.$ac_ext
+fi
 
 fi
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_header_stdc" >&5
+$as_echo "$ac_cv_header_stdc" >&6; }
+if test $ac_cv_header_stdc = yes; then
 
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+$as_echo "#define STDC_HEADERS 1" >>confdefs.h
 
 fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_have_pw_gecos_in_struct_passwd" >&5
-$as_echo "$ac_cv_have_pw_gecos_in_struct_passwd" >&6; }
-if test "x$ac_cv_have_pw_gecos_in_struct_passwd" = "xyes" ; then
 
-cat >>confdefs.h <<\_ACEOF
-#define HAVE_PW_GECOS_IN_PASSWD 1
+# On IRIX 5.3, sys/types and inttypes.h are conflicting.
+for ac_header in sys/types.h sys/stat.h stdlib.h string.h memory.h strings.h \
+		  inttypes.h stdint.h unistd.h
+do :
+  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
+ac_fn_c_check_header_compile "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default
+"
+if eval test \"x\$"$as_ac_Header"\" = x"yes"; then :
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
 _ACEOF
 
 fi
 
-#--------------------------------------------------------------------
-# These two headers (functions) needed by Time.m
-#--------------------------------------------------------------------
-
-
-
-
-
-
-for ac_header in time.h sys/time.h tzfile.h sys/rusage.h ucbinclude/sys/resource.h
-do
-as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  { $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
-$as_echo_n "checking for $ac_header... " >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  $as_echo_n "(cached) " >&6
-fi
-ac_res=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-else
-  # Is the header compilable?
-{ $as_echo "$as_me:$LINENO: checking $ac_header usability" >&5
-$as_echo_n "checking $ac_header usability... " >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-#include <$ac_header>
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_header_compiler=yes
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
+done
 
-	ac_header_compiler=no
-fi
 
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-{ $as_echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
-$as_echo "$ac_header_compiler" >&6; }
 
-# Is the header present?
-{ $as_echo "$as_me:$LINENO: checking $ac_header presence" >&5
-$as_echo_n "checking $ac_header presence... " >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <$ac_header>
-_ACEOF
-if { (ac_try="$ac_cpp conftest.$ac_ext"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } >/dev/null && {
-	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       }; then
-  ac_header_preproc=yes
+  ac_fn_c_check_header_mongrel "$LINENO" "minix/config.h" "ac_cv_header_minix_config_h" "$ac_includes_default"
+if test "x$ac_cv_header_minix_config_h" = xyes; then :
+  MINIX=yes
 else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-  ac_header_preproc=no
+  MINIX=
 fi
 
-rm -f conftest.err conftest.$ac_ext
-{ $as_echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
-$as_echo "$ac_header_preproc" >&6; }
 
-# So?  What about this header?
-case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
-  yes:no: )
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
-$as_echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the compiler's result" >&5
-$as_echo "$as_me: WARNING: $ac_header: proceeding with the compiler's result" >&2;}
-    ac_header_preproc=yes
-    ;;
-  no:yes:* )
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
-$as_echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header:     check for missing prerequisite headers?" >&5
-$as_echo "$as_me: WARNING: $ac_header:     check for missing prerequisite headers?" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: see the Autoconf documentation" >&5
-$as_echo "$as_me: WARNING: $ac_header: see the Autoconf documentation" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&5
-$as_echo "$as_me: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
-$as_echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: in the future, the compiler will take precedence" >&5
-$as_echo "$as_me: WARNING: $ac_header: in the future, the compiler will take precedence" >&2;}
+  if test "$MINIX" = yes; then
 
-    ;;
-esac
-{ $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
-$as_echo_n "checking for $ac_header... " >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  $as_echo_n "(cached) " >&6
-else
-  eval "$as_ac_Header=\$ac_header_preproc"
-fi
-ac_res=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
+$as_echo "#define _POSIX_SOURCE 1" >>confdefs.h
 
-fi
-as_val=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-   if test "x$as_val" = x""yes; then
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
-_ACEOF
 
-fi
+$as_echo "#define _POSIX_1_SOURCE 2" >>confdefs.h
 
-done
 
+$as_echo "#define _MINIX 1" >>confdefs.h
 
+  fi
 
 
-for ac_func in time ctime tzset
-do
-as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
-{ $as_echo "$as_me:$LINENO: checking for $ac_func" >&5
-$as_echo_n "checking for $ac_func... " >&6; }
-if { as_var=$as_ac_var; eval "test \"\${$as_var+set}\" = set"; }; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether it is safe to define __EXTENSIONS__" >&5
+$as_echo_n "checking whether it is safe to define __EXTENSIONS__... " >&6; }
+if ${ac_cv_safe_to_define___extensions__+:} false; then :
   $as_echo_n "(cached) " >&6
 else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
-/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.
-   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
-#define $ac_func innocuous_$ac_func
-
-/* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char $ac_func (); below.
-    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-    <limits.h> exists even on freestanding compilers.  */
-
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
-
-#undef $ac_func
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char $ac_func ();
-/* The GNU C library defines this for functions which it implements
-    to always fail with ENOSYS.  Some functions are actually named
-    something starting with __ and the normal name is an alias.  */
-#if defined __stub_$ac_func || defined __stub___$ac_func
-choke me
-#endif
 
+#         define __EXTENSIONS__ 1
+          $ac_includes_default
 int
 main ()
 {
-return $ac_func ();
+
   ;
   return 0;
 }
 _ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then
-  eval "$as_ac_var=yes"
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_cv_safe_to_define___extensions__=yes
 else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	eval "$as_ac_var=no"
+  ac_cv_safe_to_define___extensions__=no
 fi
-
-rm -rf conftest.dSYM
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
 fi
-ac_res=`eval 'as_val=${'$as_ac_var'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-as_val=`eval 'as_val=${'$as_ac_var'}
-		 $as_echo "$as_val"'`
-   if test "x$as_val" = x""yes; then
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
-_ACEOF
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_safe_to_define___extensions__" >&5
+$as_echo "$ac_cv_safe_to_define___extensions__" >&6; }
+  test $ac_cv_safe_to_define___extensions__ = yes &&
+    $as_echo "#define __EXTENSIONS__ 1" >>confdefs.h
 
-fi
-done
+  $as_echo "#define _ALL_SOURCE 1" >>confdefs.h
 
+  $as_echo "#define _GNU_SOURCE 1" >>confdefs.h
 
-# Check if tzfile contains the proper definitions
-if test $ac_cv_header_tzfile_h = yes; then
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <tzfile.h>
+  $as_echo "#define _POSIX_PTHREAD_SEMANTICS 1" >>confdefs.h
 
-_ACEOF
-if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
-  $EGREP "tzhead" >/dev/null 2>&1; then
+  $as_echo "#define _TANDEM_SOURCE 1" >>confdefs.h
 
-cat >>confdefs.h <<\_ACEOF
-#define HAVE_TZHEAD 1
-_ACEOF
 
-fi
-rm -f conftest*
 
+MAKECC=`gnustep-config --variable=CC`
+if test "$CC" != "$MAKECC"; then
+  as_fn_error $? "You are running configure with the compiler ($CC) set to a different value from that used by gnustep-make ($MAKECC).  Please run configure again with your environment set to match your gnustep-make" "$LINENO" 5
+  exit 1
 fi
 
 #--------------------------------------------------------------------
-# These headers/functions needed by GSTcpPort.m
+# Check wether the compiler supports UTF-8 constant strings
 #--------------------------------------------------------------------
 
-
-for ac_header in sys/socket.h netinet/in.h
-do
-as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  { $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
-$as_echo_n "checking for $ac_header... " >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  $as_echo_n "(cached) " >&6
-fi
-ac_res=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-else
-  # Is the header compilable?
-{ $as_echo "$as_me:$LINENO: checking $ac_header usability" >&5
-$as_echo_n "checking $ac_header usability... " >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-#include <$ac_header>
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_header_compiler=yes
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_header_compiler=no
+GS_EXEC_CHARSET=
+GS_INPUT_CHARSET=
+# Check whether --enable-unicodeconstants was given.
+if test "${enable_unicodeconstants+set}" = set; then :
+  enableval=$enable_unicodeconstants;
 fi
 
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-{ $as_echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
-$as_echo "$ac_header_compiler" >&6; }
+if test "$enable_unicodeconstants" != "no"; then
+  ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
 
-# Is the header present?
-{ $as_echo "$as_me:$LINENO: checking $ac_header presence" >&5
-$as_echo_n "checking $ac_header presence... " >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether compiler supports UTF-8 constants in executable" >&5
+$as_echo_n "checking whether compiler supports UTF-8 constants in executable... " >&6; }
+  saved_CFLAGS="$CFLAGS"
+  saved_LANG="$LANG"
+  saved_LC_ALL="$LC_ALL"
+  export LANG="en_US.ISO-8859-1"
+  export LC_ALL="en_US.ISO-8859-1"
+  # We are working in a latin1 locale so we can build a program containing
+  # a latin1 pound character, and see if the executable has a utf-8 literal.
+  if test "$cross_compiling" = yes; then :
+  utf8literal_ok="$cross_utf8literal_ok"
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
-#include <$ac_header>
+#include "$srcdir/config/config.constant-string-encoding.c"
 _ACEOF
-if { (ac_try="$ac_cpp conftest.$ac_ext"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } >/dev/null && {
-	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       }; then
-  ac_header_preproc=yes
+if ac_fn_c_try_run "$LINENO"; then :
+  utf8literal_ok=yes
 else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-  ac_header_preproc=no
+  utf8literal_ok=no
+fi
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
+  conftest.$ac_objext conftest.beam conftest.$ac_ext
 fi
 
-rm -f conftest.err conftest.$ac_ext
-{ $as_echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
-$as_echo "$ac_header_preproc" >&6; }
-
-# So?  What about this header?
-case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
-  yes:no: )
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
-$as_echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the compiler's result" >&5
-$as_echo "$as_me: WARNING: $ac_header: proceeding with the compiler's result" >&2;}
-    ac_header_preproc=yes
-    ;;
-  no:yes:* )
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
-$as_echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header:     check for missing prerequisite headers?" >&5
-$as_echo "$as_me: WARNING: $ac_header:     check for missing prerequisite headers?" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: see the Autoconf documentation" >&5
-$as_echo "$as_me: WARNING: $ac_header: see the Autoconf documentation" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&5
-$as_echo "$as_me: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
-$as_echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: in the future, the compiler will take precedence" >&5
-$as_echo "$as_me: WARNING: $ac_header: in the future, the compiler will take precedence" >&2;}
-
-    ;;
-esac
-{ $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
-$as_echo_n "checking for $ac_header... " >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  $as_echo_n "(cached) " >&6
+  if test "$utf8literal_ok" = "yes"; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; };
+  else
+    # The compiler did not produce a utf-8 literal ... see if it does so when
+    # given the appropriate flags to tell it what charactersets to use.
+    CFLAGS="$CFLAGS -finput-charset=ISO-8859-1 -fexec-charset=UTF-8"
+    if test "$cross_compiling" = yes; then :
+  utf8literal_ok="$cross_utf8literal_ok"
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include "$srcdir/config/config.constant-string-encoding.c"
+_ACEOF
+if ac_fn_c_try_run "$LINENO"; then :
+  utf8literal_ok=yes
 else
-  eval "$as_ac_Header=\$ac_header_preproc"
+  utf8literal_ok=no
 fi
-ac_res=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
+  conftest.$ac_objext conftest.beam conftest.$ac_ext
 fi
-as_val=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-   if test "x$as_val" = x""yes; then
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
-_ACEOF
+
+    if test "$utf8literal_ok" = "yes"; then
+      { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; };
+      GS_EXEC_CHARSET=-fexec-charset=UTF-8
+      GS_INPUT_CHARSET=-finput-charset=UTF-8
+    else
+      { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; };
+      { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: Your compiler does not appear to support locales or command line options to control handling of charactersets, so we cannot be sure that the compiled code will contain the UTF-8 string literals expected by gnustep-base.  This means that using any source code code containing non US-ASCII text in string literals may give unexpected results (or crashes) at runtime.  However, as long as any such literals only use the UTF-8 characterset, this is unlikely to be a problem (since old/faulty compilers are likely to pass the UTF-8 literals through to the compiled code). Please configure using --disable-unicodeconstants to avoid seeing this warning." >&5
+$as_echo "$as_me: WARNING: Your compiler does not appear to support locales or command line options to control handling of charactersets, so we cannot be sure that the compiled code will contain the UTF-8 string literals expected by gnustep-base.  This means that using any source code code containing non US-ASCII text in string literals may give unexpected results (or crashes) at runtime.  However, as long as any such literals only use the UTF-8 characterset, this is unlikely to be a problem (since old/faulty compilers are likely to pass the UTF-8 literals through to the compiled code). Please configure using --disable-unicodeconstants to avoid seeing this warning." >&2;}
+    fi
+  fi
+  export LANG="$saved_LANG"
+  export LC_ALL="$saved_LC_ALL"
+  CFLAGS="$saved_CFLAGS"
+  ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
 
 fi
 
-done
 
-{ $as_echo "$as_me:$LINENO: checking for socklen_t" >&5
-$as_echo_n "checking for socklen_t... " >&6; }
-if test "${ac_cv_type_socklen_t+set}" = set; then
-  $as_echo_n "(cached) " >&6
-else
-  ac_cv_type_socklen_t=no
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+
+#--------------------------------------------------------------------
+# Check how to enable builtins for atomic operations
+#--------------------------------------------------------------------
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports atomic operations" >&5
+$as_echo_n "checking whether the compiler supports atomic operations... " >&6; };
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
-$ac_includes_default
+typedef int atomic;
 int
 main ()
 {
-if (sizeof (socklen_t))
-       return 0;
+atomic x; atomic y; __sync_bool_compare_and_swap(&x, y, y + 1);
   ;
   return 0;
 }
 _ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  have_atomic=yes
+else
+  have_atomic=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext;
+  if test "$have_atomic" = "yes"; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; };
+
+$as_echo "#define USE_ATOMIC_BUILTINS 1" >>confdefs.h
+
+  else
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; };
+    if test "$CC" = "gcc"; then
+      saved_CFLAGS="$CFLAGS";
+      ATOMIC_CFLAGS="";
+
+      # FIXME: Forcing -march=i568 for any i568 or later CPU is a
+      # stop gap measure to make the compiler emit native assembly
+      # for atomic operations on i586 or latter processors (GCC by
+      # default emits code compatible with the original i386 and
+      # requires library functions to emulate atomic operations).
+      # When gnustep-make takes care of this kind of target setting,
+      # the check can safely be removed.
+      case "$target_cpu" in
+        i586*|i686*|i786*)
+          ATOMIC_CFLAGS="-march=i586"
+          CFLAGS="$saved_CFLAGS $ATOMIC_CFLAGS"
+          ;;
+        x86_64)
+          ATOMIC_CFLAGS="-march=x86-64"
+          CFLAGS="$saved_CFLAGS $ATOMIC_CFLAGS"
+          ;;
+      esac
+      { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether gcc supports atomic operations with -march" >&5
+$as_echo_n "checking whether gcc supports atomic operations with -march... " >&6; };
+        cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
-$ac_includes_default
+typedef int atomic;
 int
 main ()
 {
-if (sizeof ((socklen_t)))
-	  return 0;
+atomic x; atomic y; __sync_bool_compare_and_swap(&x, y, y+1);
   ;
   return 0;
 }
 _ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  :
+if ac_fn_c_try_link "$LINENO"; then :
+  need_march=yes
 else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_cv_type_socklen_t=yes
+  need_march=no
 fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext;
 
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-
-fi
+      if test "$need_march" = "yes"; then
+        { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; };
+	OBJCFLAGS="$OBJCFLAGS $ATOMIC_CFLAGS";
 
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_type_socklen_t" >&5
-$as_echo "$ac_cv_type_socklen_t" >&6; }
-if test "x$ac_cv_type_socklen_t" = x""yes; then
+$as_echo "#define USE_ATOMIC_BUILTINS 1" >>confdefs.h
 
-cat >>confdefs.h <<_ACEOF
-#define HAVE_SOCKLEN_T 1
+      else
+        { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; };
+        saved_LDFLAGS="$LDFLAGS";
+        LDFLAGS="$saved_LDFLAGS -lgcc";
+        { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether gcc supports atomic operations using libgcc" >&5
+$as_echo_n "checking whether gcc supports atomic operations using libgcc... " >&6; };
+          cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+typedef int atomic;
+int
+main ()
+{
+atomic x; atomic y; __sync_bool_compare_and_swap(&x, y, y+1);
+  ;
+  return 0;
+}
 _ACEOF
-
-
+if ac_fn_c_try_link "$LINENO"; then :
+  atomic_in_libgcc=yes
+else
+  atomic_in_libgcc=no
 fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext;
+        if test "$atomic_in_libgcc" = "yes"; then
+          { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; };
+          LIBS="$LIBS -lgcc";
 
+$as_echo "#define USE_ATOMIC_BUILTINS 1" >>confdefs.h
 
-#--------------------------------------------------------------------
-# These headers/functions needed for stacktrace in NSException.m
-#--------------------------------------------------------------------
-PASS_ARG=no
-# Check whether --enable-bfd was given.
-if test "${enable_bfd+set}" = set; then
-  enableval=$enable_bfd;
-else
-  enable_bfd=$PASS_ARG
-fi
+        else
+          LDFLAGS="$saved_LDFLAGS";
+          { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; };
+        fi
+      fi
+    fi
+  fi
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
 
 
-if test $enable_bfd = yes; then
 
-for ac_header in bfd.h
-do
-as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  { $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
-$as_echo_n "checking for $ac_header... " >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
+# Extract the first word of "whoami", so it can be a program name with args.
+set dummy whoami; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_path_WHOAMI+:} false; then :
   $as_echo_n "(cached) " >&6
-fi
-ac_res=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
 else
-  # Is the header compilable?
-{ $as_echo "$as_me:$LINENO: checking $ac_header usability" >&5
-$as_echo_n "checking $ac_header usability... " >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-#include <$ac_header>
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
+  case $WHOAMI in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_WHOAMI="$WHOAMI" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+as_dummy="$PATH:/usr/ucb"
+for as_dir in $as_dummy
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_path_WHOAMI="$as_dir/$ac_word$ac_exec_ext"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+  test -z "$ac_cv_path_WHOAMI" && ac_cv_path_WHOAMI="echo"
+  ;;
 esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_header_compiler=yes
+fi
+WHOAMI=$ac_cv_path_WHOAMI
+if test -n "$WHOAMI"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $WHOAMI" >&5
+$as_echo "$WHOAMI" >&6; }
 else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_header_compiler=no
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
 fi
 
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-{ $as_echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
-$as_echo "$ac_header_compiler" >&6; }
 
-# Is the header present?
-{ $as_echo "$as_me:$LINENO: checking $ac_header presence" >&5
-$as_echo_n "checking $ac_header presence... " >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <$ac_header>
-_ACEOF
-if { (ac_try="$ac_cpp conftest.$ac_ext"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } >/dev/null && {
-	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       }; then
-  ac_header_preproc=yes
+# Extract the first word of "pkg-config", so it can be a program name with args.
+set dummy pkg-config; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_path_PKGCONFIG+:} false; then :
+  $as_echo_n "(cached) " >&6
 else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
+  case $PKGCONFIG in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_PKGCONFIG="$PKGCONFIG" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in no
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_path_PKGCONFIG="$as_dir/$ac_word$ac_exec_ext"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
 
-  ac_header_preproc=no
+  test -z "$ac_cv_path_PKGCONFIG" && ac_cv_path_PKGCONFIG="yes"
+  ;;
+esac
+fi
+PKGCONFIG=$ac_cv_path_PKGCONFIG
+if test -n "$PKGCONFIG"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $PKGCONFIG" >&5
+$as_echo "$PKGCONFIG" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
 fi
 
-rm -f conftest.err conftest.$ac_ext
-{ $as_echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
-$as_echo "$ac_header_preproc" >&6; }
-
-# So?  What about this header?
-case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
-  yes:no: )
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
-$as_echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the compiler's result" >&5
-$as_echo "$as_me: WARNING: $ac_header: proceeding with the compiler's result" >&2;}
-    ac_header_preproc=yes
-    ;;
-  no:yes:* )
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
-$as_echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header:     check for missing prerequisite headers?" >&5
-$as_echo "$as_me: WARNING: $ac_header:     check for missing prerequisite headers?" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: see the Autoconf documentation" >&5
-$as_echo "$as_me: WARNING: $ac_header: see the Autoconf documentation" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&5
-$as_echo "$as_me: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
-$as_echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: in the future, the compiler will take precedence" >&5
-$as_echo "$as_me: WARNING: $ac_header: in the future, the compiler will take precedence" >&2;}
-
-    ;;
+
+
+#--------------------------------------------------------------------
+# specific target_os options
+#--------------------------------------------------------------------
+INCLUDE_FLAGS="$CPPFLAGS"
+LDIR_FLAGS="$LDFLAGS"
+# This is just for configuring. Later, in config.make, INCLUDE_FLAGS
+# goes in CONFIG_SYSTEM_INCL and LIBS goes in CONFIG_SYSTEM_LIBS
+case "$target_os" in
+  freebsd* | openbsd* )
+	        CPPFLAGS="$CPPFLAGS -I/usr/local/include"
+		LDFLAGS="$LDFLAGS -L/usr/local/lib";;
+  netbsd*)	CPPFLAGS="$CPPFLAGS -I/usr/pkg/include"
+		LDFLAGS="$LDFLAGS -Wl,-R/usr/pkg/lib -L/usr/pkg/lib";;
 esac
-{ $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
-$as_echo_n "checking for $ac_header... " >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  $as_echo_n "(cached) " >&6
+
+#--------------------------------------------------------------------
+# Set Apple/Darwin/OSX/NeXT information for other tests
+#--------------------------------------------------------------------
+OBJC_WITH_GC=no
+OBJC_RUNTIME_LIB=`echo $LIBRARY_COMBO | tr '-' ' ' | awk '{print $1}'`
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking the Objective-C runtime" >&5
+$as_echo_n "checking the Objective-C runtime... " >&6; }
+if test "$OBJC_RUNTIME_LIB" = "nx" -o "$OBJC_RUNTIME_LIB" = "apple"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: NeXT" >&5
+$as_echo "NeXT" >&6; }
+  OBJCFLAGS="$OBJCFLAGS -fnext-runtime -DNeXT_RUNTIME"
+elif test "$OBJC_RUNTIME_LIB" = "gnugc"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: GNU" >&5
+$as_echo "GNU" >&6; }
+  OBJCFLAGS="$OBJCFLAGS -fgnu-runtime"
+  OBJC_WITH_GC=yes
 else
-  eval "$as_ac_Header=\$ac_header_preproc"
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: GNU" >&5
+$as_echo "GNU" >&6; }
+  OBJCFLAGS="$OBJCFLAGS -fgnu-runtime"
 fi
-ac_res=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-
+LIBOBJC=`gnustep-config --objc-libs`
+if test "$LIBOBJC" = ""; then
+  as_fn_error $? "The command 'gnustep-config --objc-libs' (provided by the gnustep-make package) returned no Objective-C library.  Unable to continue configuring without Objective-C support." "$LINENO" 5
+  exit 1
 fi
-as_val=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-   if test "x$as_val" = x""yes; then
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
-_ACEOF
 
+FOUNDATION_LIB=`echo $LIBRARY_COMBO | tr '-' ' ' | awk '{print $2}'`
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking the Foundation library" >&5
+$as_echo_n "checking the Foundation library... " >&6; }
+if test "$FOUNDATION_LIB" = "nx" -o "$FOUNDATION_LIB" = "apple"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: NeXT" >&5
+$as_echo "NeXT" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: GNU" >&5
+$as_echo "GNU" >&6; }
 fi
 
-done
-
+#--------------------------------------------------------------------
+# Miscellaneous flags
+#--------------------------------------------------------------------
 
-{ $as_echo "$as_me:$LINENO: checking for dyn_string_append in -liberty" >&5
-$as_echo_n "checking for dyn_string_append in -liberty... " >&6; }
-if test "${ac_cv_lib_iberty_dyn_string_append+set}" = set; then
+# Check to see if the libobjc library is in our GNUSTEP_SYSTEM_LIBRARIES.
+# If so, there are probably other libraries that we want there also, so
+# leave the proper includes in CPPFLAGS and LDFLAGS
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for custom shared objc library" >&5
+$as_echo_n "checking for custom shared objc library... " >&6; }
+if ${gs_cv_objc_libdir+:} false; then :
   $as_echo_n "(cached) " >&6
 else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-liberty  $LIBS"
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char dyn_string_append ();
-int
-main ()
-{
-return dyn_string_append ();
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then
-  ac_cv_lib_iberty_dyn_string_append=yes
+  gs_cv_objc_libdir=NONE
+gs_cv_objc_incdir=NONE
+# Try GNUSTEP_SYSTEM_LIBRARIES first
+if test "$GNUSTEP_IS_FLATTENED" = yes; then
+  GNUSTEP_LDIR="$GNUSTEP_SYSTEM_LIBRARIES"
+  GNUSTEP_HDIR="$GNUSTEP_SYSTEM_HEADERS"
 else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_cv_lib_iberty_dyn_string_append=no
+  GNUSTEP_LDIR="$GNUSTEP_SYSTEM_LIBRARIES/$obj_dir"
+  GNUSTEP_HDIR="$GNUSTEP_SYSTEM_HEADERS/$LIBRARY_COMBO"
 fi
 
-rm -rf conftest.dSYM
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
+if test -f "$GNUSTEP_HDIR/objc/objc.h"; then
+  if test -f "$GNUSTEP_LDIR/libobjc.a" -o -f "$GNUSTEP_LDIR/libobjc.so" -o -f "$GNUSTEP_LDIR/libobjc.dll.a" -o -f "$GNUSTEP_LDIR/libobjc-gnu.dylib" -o -f "$GNUSTEP_LDIR/libobjc_gc.a" -o -f "$GNUSTEP_LDIR/libobjc_gc.so" -o -f "$GNUSTEP_LDIR/libobjc_gc.dll.a" -o -f "$GNUSTEP_LDIR/libobjc_gc-gnu.dylib"; then
+    gs_cv_objc_libdir="$GNUSTEP_LDIR"
+    gs_cv_objc_incdir="$GNUSTEP_HDIR"
+  fi
 fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_lib_iberty_dyn_string_append" >&5
-$as_echo "$ac_cv_lib_iberty_dyn_string_append" >&6; }
-if test "x$ac_cv_lib_iberty_dyn_string_append" = x""yes; then
-  cat >>confdefs.h <<_ACEOF
-#define HAVE_LIBIBERTY 1
-_ACEOF
-
-  LIBS="-liberty $LIBS"
 
+# Try GNUSTEP_NETWORK_LIBRARIES second (override GNUSTEP_SYSTEM if
+# found)
+if test "$GNUSTEP_IS_FLATTENED" = yes; then
+  GNUSTEP_LDIR="$GNUSTEP_NETWORK_LIBRARIES"
+  GNUSTEP_HDIR="$GNUSTEP_NETWORK_HEADERS"
+else
+  GNUSTEP_LDIR="$GNUSTEP_NETWORK_LIBRARIES/$obj_dir"
+  GNUSTEP_HDIR="$GNUSTEP_NETWORK_HEADERS/$LIBRARY_COMBO"
 fi
 
+if test -f "$GNUSTEP_HDIR/objc/objc.h"; then
+  if test -f "$GNUSTEP_LDIR/libobjc.a" -o -f "$GNUSTEP_LDIR/libobjc.so" -o -f "$GNUSTEP_LDIR/libobjc.dll.a" -o -f "$GNUSTEP_LDIR/libobjc-gnu.dylib" -o -f "$GNUSTEP_LDIR/libobjc_gc.a" -o -f "$GNUSTEP_LDIR/libobjc_gc.so" -o -f "$GNUSTEP_LDIR/libobjc_gc.dll.a" -o -f "$GNUSTEP_LDIR/libobjc_gc-gnu.dylib"; then
+    gs_cv_objc_libdir="$GNUSTEP_LDIR"
+    gs_cv_objc_incdir="$GNUSTEP_HDIR"
+  fi
+fi
 
-{ $as_echo "$as_me:$LINENO: checking for bfd_openr in -lbfd" >&5
-$as_echo_n "checking for bfd_openr in -lbfd... " >&6; }
-if test "${ac_cv_lib_bfd_bfd_openr+set}" = set; then
-  $as_echo_n "(cached) " >&6
+# Try GNUSTEP_LOCAL_LIBRARIES third (override GNUSTEP_SYSTEM and
+# GNUSTEP_NETWORK if found)
+if test "$GNUSTEP_IS_FLATTENED" = yes; then
+  GNUSTEP_LDIR="$GNUSTEP_LOCAL_LIBRARIES"
+  GNUSTEP_HDIR="$GNUSTEP_LOCAL_HEADERS"
 else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-lbfd  $LIBS"
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
+  GNUSTEP_LDIR="$GNUSTEP_LOCAL_LIBRARIES/$obj_dir"
+  GNUSTEP_HDIR="$GNUSTEP_LOCAL_HEADERS/$LIBRARY_COMBO"
+fi
 
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char bfd_openr ();
-int
-main ()
-{
-return bfd_openr ();
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then
-  ac_cv_lib_bfd_bfd_openr=yes
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
+if test -f "$GNUSTEP_HDIR/objc/objc.h"; then
+  if test -f "$GNUSTEP_LDIR/libobjc.a" -o -f "$GNUSTEP_LDIR/libobjc.so" -o -f "$GNUSTEP_LDIR/libobjc.dll.a" -o -f "$GNUSTEP_LDIR/libobjc-gnu.dylib" -o -f "$GNUSTEP_LDIR/libobjc_gc.a" -o -f "$GNUSTEP_LDIR/libobjc_gc.so" -o -f "$GNUSTEP_LDIR/libobjc_gc.dll.a" -o -f "$GNUSTEP_LDIR/libobjc_gc-gnu.dylib"; then
+    gs_cv_objc_libdir="$GNUSTEP_LDIR"
+    gs_cv_objc_incdir="$GNUSTEP_HDIR"
+  fi
+fi
 
-	ac_cv_lib_bfd_bfd_openr=no
 fi
 
-rm -rf conftest.dSYM
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $gs_cv_objc_libdir" >&5
+$as_echo "$gs_cv_objc_libdir" >&6; }
+
+if test "$gs_cv_objc_libdir" != "NONE"; then
+  #
+  # The following one is so that headers of custom libraries into
+  # $GNUSTEP_HDIR are used before the standard ones
+  #
+  INCLUDE_FLAGS="$INCLUDE_FLAGS -I$gs_cv_objc_incdir"
+  LDIR_FLAGS="$LDIR_FLAGS -L$gs_cv_objc_libdir/$LIBRARY_COMBO -L$gs_cv_objc_libdir"
+  CPPFLAGS="$CPPFLAGS -I$gs_cv_objc_incdir"
+  LDFLAGS="$LDFLAGS -L$gs_cv_objc_libdir"
 fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_lib_bfd_bfd_openr" >&5
-$as_echo "$ac_cv_lib_bfd_bfd_openr" >&6; }
-if test "x$ac_cv_lib_bfd_bfd_openr" = x""yes; then
+
+#--------------------------------------------------------------------
+# Check if Objective-C is installed
+#--------------------------------------------------------------------
+for ac_header in objc/runtime.h
+do :
+  ac_fn_c_check_header_mongrel "$LINENO" "objc/runtime.h" "ac_cv_header_objc_runtime_h" "$ac_includes_default"
+if test "x$ac_cv_header_objc_runtime_h" = xyes; then :
   cat >>confdefs.h <<_ACEOF
-#define HAVE_LIBBFD 1
+#define HAVE_OBJC_RUNTIME_H 1
 _ACEOF
 
-  LIBS="-lbfd $LIBS"
-
 fi
 
-else
+done
 
-for ac_header in execinfo.h
-do
-as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  { $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
-$as_echo_n "checking for $ac_header... " >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  $as_echo_n "(cached) " >&6
-fi
-ac_res=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-else
-  # Is the header compilable?
-{ $as_echo "$as_me:$LINENO: checking $ac_header usability" >&5
-$as_echo_n "checking $ac_header usability... " >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-#include <$ac_header>
+for ac_header in objc/objc.h
+do :
+  ac_fn_c_check_header_mongrel "$LINENO" "objc/objc.h" "ac_cv_header_objc_objc_h" "$ac_includes_default"
+if test "x$ac_cv_header_objc_objc_h" = xyes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_OBJC_OBJC_H 1
 _ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_header_compiler=yes
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
 
-	ac_header_compiler=no
 fi
 
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-{ $as_echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
-$as_echo "$ac_header_compiler" >&6; }
+done
 
-# Is the header present?
-{ $as_echo "$as_me:$LINENO: checking $ac_header presence" >&5
-$as_echo_n "checking $ac_header presence... " >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <$ac_header>
+if test $ac_cv_header_objc_objc_h = no; then
+  echo "Check to make sure you have a full installation of the GCC"
+  echo "compiler that includes the Objective-C headers and libraries"
+  as_fn_error $? "Could not find Objective-C headers" "$LINENO" 5
+fi
+
+if test $OBJC_WITH_GC = yes; then
+  for ac_header in gc/gc.h
+do :
+  ac_fn_c_check_header_mongrel "$LINENO" "gc/gc.h" "ac_cv_header_gc_gc_h" "$ac_includes_default"
+if test "x$ac_cv_header_gc_gc_h" = xyes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_GC_GC_H 1
 _ACEOF
-if { (ac_try="$ac_cpp conftest.$ac_ext"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } >/dev/null && {
-	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       }; then
-  ac_header_preproc=yes
+ gc_ok=yes
 else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-  ac_header_preproc=no
+  gc_ok=no
 fi
 
-rm -f conftest.err conftest.$ac_ext
-{ $as_echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
-$as_echo "$ac_header_preproc" >&6; }
-
-# So?  What about this header?
-case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
-  yes:no: )
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
-$as_echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the compiler's result" >&5
-$as_echo "$as_me: WARNING: $ac_header: proceeding with the compiler's result" >&2;}
-    ac_header_preproc=yes
-    ;;
-  no:yes:* )
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
-$as_echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header:     check for missing prerequisite headers?" >&5
-$as_echo "$as_me: WARNING: $ac_header:     check for missing prerequisite headers?" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: see the Autoconf documentation" >&5
-$as_echo "$as_me: WARNING: $ac_header: see the Autoconf documentation" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&5
-$as_echo "$as_me: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
-$as_echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: in the future, the compiler will take precedence" >&5
-$as_echo "$as_me: WARNING: $ac_header: in the future, the compiler will take precedence" >&2;}
+done
 
-    ;;
-esac
-{ $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
-$as_echo_n "checking for $ac_header... " >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  $as_echo_n "(cached) " >&6
+  if test "$gc_ok" = no; then
+    as_fn_error $? "Garbage collection was required, but the gc/gc.h header couldn't be found." "$LINENO" 5
+  fi
+  saved_LIBS="$LIBS"
+  LIBS+=" -lgc"
+  ac_fn_c_check_func "$LINENO" "GC_malloc" "ac_cv_func_GC_malloc"
+if test "x$ac_cv_func_GC_malloc" = xyes; then :
+  gc_ok=yes
 else
-  eval "$as_ac_Header=\$ac_header_preproc"
+  gc_ok=no
 fi
-ac_res=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
+
+  if test "$gc_ok" = no; then
+    as_fn_error $? "Garbage collection was required, but the gc library couldn't be found." "$LINENO" 5
+  fi
+  ac_fn_c_check_func "$LINENO" "GC_register_my_thread" "ac_cv_func_GC_register_my_thread"
+if test "x$ac_cv_func_GC_register_my_thread" = xyes; then :
 
 fi
-as_val=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-   if test "x$as_val" = x""yes; then
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
-_ACEOF
+
+  if test "$ac_cv_func_GC_register_my_thread" = yes; then
+
+$as_echo "#define HAVE_GC_REGISTER_MY_THREAD 1" >>confdefs.h
+
+  fi
+  ac_fn_c_check_func "$LINENO" "GC_allow_register_threads" "ac_cv_func_GC_allow_register_threads"
+if test "x$ac_cv_func_GC_allow_register_threads" = xyes; then :
 
 fi
 
-done
+  if test "$ac_cv_func_GC_allow_register_threads" = yes; then
 
+$as_echo "#define HAVE_GC_ALLOW_REGISTER_THREADS 1" >>confdefs.h
 
-for ac_func in backtrace
-do
-as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
-{ $as_echo "$as_me:$LINENO: checking for $ac_func" >&5
-$as_echo_n "checking for $ac_func... " >&6; }
-if { as_var=$as_ac_var; eval "test \"\${$as_var+set}\" = set"; }; then
-  $as_echo_n "(cached) " >&6
+  fi
+  LIBS="-lobjc_gc -ldl"
+  ac_fn_c_check_func "$LINENO" "class_ivar_set_gcinvisible" "ac_cv_func_class_ivar_set_gcinvisible"
+if test "x$ac_cv_func_class_ivar_set_gcinvisible" = xyes; then :
+  gc_ok=yes
 else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.
-   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
-#define $ac_func innocuous_$ac_func
+  gc_ok=no
+fi
 
-/* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char $ac_func (); below.
-    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-    <limits.h> exists even on freestanding compilers.  */
+  if test "$gc_ok" = no; then
+    as_fn_error $? "Garbage collection was required, but the gc runtime couldn't be found." "$LINENO" 5
+  fi
+  LIBS="$saved_LIBS"
 
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
+fi
 
-#undef $ac_func
+#--------------------------------------------------------------------
+# Check for strange network stuff used by gdomap
+#--------------------------------------------------------------------
+{ $as_echo "$as_me:${as_lineno-$LINENO}: for gdomap network details" >&5
+$as_echo "$as_me: for gdomap network details" >&6;}
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for variable length socket addresses" >&5
+$as_echo_n "checking for variable length socket addresses... " >&6; }
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
 
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char $ac_func ();
-/* The GNU C library defines this for functions which it implements
-    to always fail with ENOSYS.  Some functions are actually named
-    something starting with __ and the normal name is an alias.  */
-#if defined __stub_$ac_func || defined __stub___$ac_func
-choke me
-#endif
+  #include <sys/types.h>
+  #include <sys/socket.h>
+  #include <net/if.h>
 
 int
 main ()
 {
-return $ac_func ();
+struct ifreq s; s.ifr_addr.sa_len = 0;
   ;
   return 0;
 }
 _ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then
-  eval "$as_ac_var=yes"
+if ac_fn_c_try_compile "$LINENO"; then :
+  sa_len=1
 else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	eval "$as_ac_var=no"
-fi
-
-rm -rf conftest.dSYM
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
+  sa_len=0
 fi
-ac_res=`eval 'as_val=${'$as_ac_var'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-as_val=`eval 'as_val=${'$as_ac_var'}
-		 $as_echo "$as_val"'`
-   if test "x$as_val" = x""yes; then
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
-_ACEOF
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+if test $sa_len = 1; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: found" >&5
+$as_echo "found" >&6; }
 
-fi
-done
+$as_echo "#define HAVE_SA_LEN 1" >>confdefs.h
 
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: not found" >&5
+$as_echo "not found" >&6; }
 fi
 
-for ac_func in __builtin_extract_return_address
-do
-as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
-{ $as_echo "$as_me:$LINENO: checking for $ac_func" >&5
-$as_echo_n "checking for $ac_func... " >&6; }
-if { as_var=$as_ac_var; eval "test \"\${$as_var+set}\" = set"; }; then
-  $as_echo_n "(cached) " >&6
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for gcc visibility attribute support" >&5
+$as_echo_n "checking for gcc visibility attribute support... " >&6; }
+saved_CFLAGS="$CFLAGS"
+CFLAGS="$CFLAGS -Werror"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
-/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.
-   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
-#define $ac_func innocuous_$ac_func
-
-/* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char $ac_func (); below.
-    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-    <limits.h> exists even on freestanding compilers.  */
-
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
-
-#undef $ac_func
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char $ac_func ();
-/* The GNU C library defines this for functions which it implements
-    to always fail with ENOSYS.  Some functions are actually named
-    something starting with __ and the normal name is an alias.  */
-#if defined __stub_$ac_func || defined __stub___$ac_func
-choke me
-#endif
 
-int
-main ()
-{
-return $ac_func ();
-  ;
-  return 0;
-}
+  #include <stdio.h>
+  int foo() __attribute__ ((visibility("internal")));
+  int foo(){ return 1; }
+  int main(){ return foo(); }
 _ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then
-  eval "$as_ac_var=yes"
+if ac_fn_c_try_compile "$LINENO"; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: found" >&5
+$as_echo "found" >&6; }
+  gs_visibility=1
 else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: not present" >&5
+$as_echo "not present" >&6; }
+  gs_visibility=0
 
-	eval "$as_ac_var=no"
 fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
 
-rm -rf conftest.dSYM
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
-fi
-ac_res=`eval 'as_val=${'$as_ac_var'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-as_val=`eval 'as_val=${'$as_ac_var'}
-		 $as_echo "$as_val"'`
-   if test "x$as_val" = x""yes; then
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
+cat >>confdefs.h <<_ACEOF
+#define HAVE_VISIBILITY_ATTRIBUTE $gs_visibility
 _ACEOF
 
-fi
-done
+CFLAGS="$saved_CFLAGS"
 
 
 #--------------------------------------------------------------------
-# These headers/functions needed by NSLog.m
+# Check if system has buggy SO_REUSEADDR
 #--------------------------------------------------------------------
-
-
-
-for ac_header in syslog.h sys/slog.h sys/slogcodes.h
-do
-as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  { $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
-$as_echo_n "checking for $ac_header... " >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  $as_echo_n "(cached) " >&6
-fi
-ac_res=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether SO_REUSEADDR is broken" >&5
+$as_echo_n "checking whether SO_REUSEADDR is broken... " >&6; }
+if test "$cross_compiling" = yes; then :
+  reuseaddr_ok="$cross_reuseaddr_ok"
 else
-  # Is the header compilable?
-{ $as_echo "$as_me:$LINENO: checking $ac_header usability" >&5
-$as_echo_n "checking $ac_header usability... " >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
-$ac_includes_default
-#include <$ac_header>
+#include "$srcdir/config/config.reuseaddr.c"
 _ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_header_compiler=yes
+if ac_fn_c_try_run "$LINENO"; then :
+  reuseaddr_ok=1
 else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_header_compiler=no
+  reuseaddr_ok=0
 fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-{ $as_echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
-$as_echo "$ac_header_compiler" >&6; }
-
-# Is the header present?
-{ $as_echo "$as_me:$LINENO: checking $ac_header presence" >&5
-$as_echo_n "checking $ac_header presence... " >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <$ac_header>
-_ACEOF
-if { (ac_try="$ac_cpp conftest.$ac_ext"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } >/dev/null && {
-	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       }; then
-  ac_header_preproc=yes
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-  ac_header_preproc=no
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
+  conftest.$ac_objext conftest.beam conftest.$ac_ext
 fi
 
-rm -f conftest.err conftest.$ac_ext
-{ $as_echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
-$as_echo "$ac_header_preproc" >&6; }
+if test $reuseaddr_ok = 0; then
 
-# So?  What about this header?
-case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
-  yes:no: )
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
-$as_echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the compiler's result" >&5
-$as_echo "$as_me: WARNING: $ac_header: proceeding with the compiler's result" >&2;}
-    ac_header_preproc=yes
-    ;;
-  no:yes:* )
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
-$as_echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header:     check for missing prerequisite headers?" >&5
-$as_echo "$as_me: WARNING: $ac_header:     check for missing prerequisite headers?" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: see the Autoconf documentation" >&5
-$as_echo "$as_me: WARNING: $ac_header: see the Autoconf documentation" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&5
-$as_echo "$as_me: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
-$as_echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: in the future, the compiler will take precedence" >&5
-$as_echo "$as_me: WARNING: $ac_header: in the future, the compiler will take precedence" >&2;}
+$as_echo "#define BROKEN_SO_REUSEADDR 1" >>confdefs.h
 
-    ;;
-esac
-{ $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
-$as_echo_n "checking for $ac_header... " >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  $as_echo_n "(cached) " >&6
+  echo
+  echo "The SO_REUSEADDR socket option for controlling re-use of network"
+  echo "sockets immediately after shutdown appears to be broken on this"
+  echo "machine.  Networking code will be built without using this"
+  echo "feature."
+  echo "The effect of this lack is that when a network service is shut"
+  echo "down, it cannot be re-started on the same network port until"
+  echo "an operating-system timeout has expired."
+  echo "For servers other than gdomap, GNUstep does not normally need"
+  echo "a particular network port, so the problem is unlikely to arise."
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
 else
-  eval "$as_ac_Header=\$ac_header_preproc"
-fi
-ac_res=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-
-fi
-as_val=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-   if test "x$as_val" = x""yes; then
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
-_ACEOF
-
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
 fi
 
-done
-
+#--------------------------------------------------------------------
+# Check for thread flags for libobjc.
+#--------------------------------------------------------------------
+#
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for objc threading flags" >&5
+$as_echo_n "checking for objc threading flags... " >&6; }
+#
+# Get them from gnustep-make which contains the real code to get them
+#
+objc_threaded=`grep objc_threaded: $CURRENT_GNUSTEP_MAKEFILES/$lobj_dir/config.make | sed -e 's/objc_threaded:=//'`
+#
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $objc_threaded" >&5
+$as_echo "$objc_threaded" >&6; }
 
-for ac_func in syslog
-do
-as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
-{ $as_echo "$as_me:$LINENO: checking for $ac_func" >&5
-$as_echo_n "checking for $ac_func... " >&6; }
-if { as_var=$as_ac_var; eval "test \"\${$as_var+set}\" = set"; }; then
+#--------------------------------------------------------------------
+# Byte order information needed for foundation headers.
+#--------------------------------------------------------------------
+ { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether byte ordering is bigendian" >&5
+$as_echo_n "checking whether byte ordering is bigendian... " >&6; }
+if ${ac_cv_c_bigendian+:} false; then :
   $as_echo_n "(cached) " >&6
 else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+  ac_cv_c_bigendian=unknown
+    # See if we're dealing with a universal compiler.
+    cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
-/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.
-   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
-#define $ac_func innocuous_$ac_func
+#ifndef __APPLE_CC__
+	       not a universal capable compiler
+	     #endif
+	     typedef int dummy;
 
-/* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char $ac_func (); below.
-    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-    <limits.h> exists even on freestanding compilers.  */
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
 
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
+	# Check for potential -arch flags.  It is not universal unless
+	# there are at least two -arch flags with different values.
+	ac_arch=
+	ac_prev=
+	for ac_word in $CC $CFLAGS $CPPFLAGS $LDFLAGS; do
+	 if test -n "$ac_prev"; then
+	   case $ac_word in
+	     i?86 | x86_64 | ppc | ppc64)
+	       if test -z "$ac_arch" || test "$ac_arch" = "$ac_word"; then
+		 ac_arch=$ac_word
+	       else
+		 ac_cv_c_bigendian=universal
+		 break
+	       fi
+	       ;;
+	   esac
+	   ac_prev=
+	 elif test "x$ac_word" = "x-arch"; then
+	   ac_prev=arch
+	 fi
+       done
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+    if test $ac_cv_c_bigendian = unknown; then
+      # See if sys/param.h defines the BYTE_ORDER macro.
+      cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <sys/types.h>
+	     #include <sys/param.h>
 
-#undef $ac_func
+int
+main ()
+{
+#if ! (defined BYTE_ORDER && defined BIG_ENDIAN \
+		     && defined LITTLE_ENDIAN && BYTE_ORDER && BIG_ENDIAN \
+		     && LITTLE_ENDIAN)
+	      bogus endian macros
+	     #endif
 
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char $ac_func ();
-/* The GNU C library defines this for functions which it implements
-    to always fail with ENOSYS.  Some functions are actually named
-    something starting with __ and the normal name is an alias.  */
-#if defined __stub_$ac_func || defined __stub___$ac_func
-choke me
-#endif
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  # It does; now see whether it defined to BIG_ENDIAN or not.
+	 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <sys/types.h>
+		#include <sys/param.h>
 
 int
 main ()
 {
-return $ac_func ();
+#if BYTE_ORDER != BIG_ENDIAN
+		 not big endian
+		#endif
+
   ;
   return 0;
 }
 _ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then
-  eval "$as_ac_var=yes"
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_cv_c_bigendian=yes
 else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	eval "$as_ac_var=no"
-fi
-
-rm -rf conftest.dSYM
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
+  ac_cv_c_bigendian=no
 fi
-ac_res=`eval 'as_val=${'$as_ac_var'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-as_val=`eval 'as_val=${'$as_ac_var'}
-		 $as_echo "$as_val"'`
-   if test "x$as_val" = x""yes; then
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
-_ACEOF
-
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
 fi
-done
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+    fi
+    if test $ac_cv_c_bigendian = unknown; then
+      # See if <limits.h> defines _LITTLE_ENDIAN or _BIG_ENDIAN (e.g., Solaris).
+      cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <limits.h>
 
-if test "$ac_cv_header_sys_slog_h" = "yes"; then
-  oldLibs="$LIBS";
-  LIBS="$LIBS -l:libc.a";
+int
+main ()
+{
+#if ! (defined _LITTLE_ENDIAN || defined _BIG_ENDIAN)
+	      bogus endian macros
+	     #endif
 
-for ac_func in slogf
-do
-as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
-{ $as_echo "$as_me:$LINENO: checking for $ac_func" >&5
-$as_echo_n "checking for $ac_func... " >&6; }
-if { as_var=$as_ac_var; eval "test \"\${$as_var+set}\" = set"; }; then
-  $as_echo_n "(cached) " >&6
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
+  ;
+  return 0;
+}
 _ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  # It does; now see whether it defined to _BIG_ENDIAN or not.
+	 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
-/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.
-   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
-#define $ac_func innocuous_$ac_func
-
-/* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char $ac_func (); below.
-    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-    <limits.h> exists even on freestanding compilers.  */
-
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
-
-#undef $ac_func
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char $ac_func ();
-/* The GNU C library defines this for functions which it implements
-    to always fail with ENOSYS.  Some functions are actually named
-    something starting with __ and the normal name is an alias.  */
-#if defined __stub_$ac_func || defined __stub___$ac_func
-choke me
-#endif
+#include <limits.h>
 
 int
 main ()
 {
-return $ac_func ();
+#ifndef _BIG_ENDIAN
+		 not big endian
+		#endif
+
   ;
   return 0;
 }
 _ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then
-  eval "$as_ac_var=yes"
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_cv_c_bigendian=yes
 else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	eval "$as_ac_var=no"
-fi
-
-rm -rf conftest.dSYM
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
-fi
-ac_res=`eval 'as_val=${'$as_ac_var'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-as_val=`eval 'as_val=${'$as_ac_var'}
-		 $as_echo "$as_val"'`
-   if test "x$as_val" = x""yes; then
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
-_ACEOF
-
+  ac_cv_c_bigendian=no
 fi
-done
-
-  if test "$ac_cv_func_slogf" = "no"; then
-    LIBS="$oldLibs"
-  fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
 fi
-#--------------------------------------------------------------------
-# These headers/functions needed by NSRunLoop.m
-#--------------------------------------------------------------------
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+    fi
+    if test $ac_cv_c_bigendian = unknown; then
+      # Compile a test program.
+      if test "$cross_compiling" = yes; then :
+  # Try to guess by grepping values from an object file.
+	 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+short int ascii_mm[] =
+		  { 0x4249, 0x4765, 0x6E44, 0x6961, 0x6E53, 0x7953, 0 };
+		short int ascii_ii[] =
+		  { 0x694C, 0x5454, 0x656C, 0x6E45, 0x6944, 0x6E61, 0 };
+		int use_ascii (int i) {
+		  return ascii_mm[i] + ascii_ii[i];
+		}
+		short int ebcdic_ii[] =
+		  { 0x89D3, 0xE3E3, 0x8593, 0x95C5, 0x89C4, 0x9581, 0 };
+		short int ebcdic_mm[] =
+		  { 0xC2C9, 0xC785, 0x95C4, 0x8981, 0x95E2, 0xA8E2, 0 };
+		int use_ebcdic (int i) {
+		  return ebcdic_mm[i] + ebcdic_ii[i];
+		}
+		extern int foo;
 
-for ac_header in poll.h
-do
-as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  { $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
-$as_echo_n "checking for $ac_header... " >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  $as_echo_n "(cached) " >&6
+int
+main ()
+{
+return use_ascii (foo) == use_ebcdic (foo);
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  if grep BIGenDianSyS conftest.$ac_objext >/dev/null; then
+	      ac_cv_c_bigendian=yes
+	    fi
+	    if grep LiTTleEnDian conftest.$ac_objext >/dev/null ; then
+	      if test "$ac_cv_c_bigendian" = unknown; then
+		ac_cv_c_bigendian=no
+	      else
+		# finding both strings is unlikely to happen, but who knows?
+		ac_cv_c_bigendian=unknown
+	      fi
+	    fi
 fi
-ac_res=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
 else
-  # Is the header compilable?
-{ $as_echo "$as_me:$LINENO: checking $ac_header usability" >&5
-$as_echo_n "checking $ac_header usability... " >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 $ac_includes_default
-#include <$ac_header>
+int
+main ()
+{
+
+	     /* Are we little or big endian?  From Harbison&Steele.  */
+	     union
+	     {
+	       long int l;
+	       char c[sizeof (long int)];
+	     } u;
+	     u.l = 1;
+	     return u.c[sizeof (long int) - 1] == 1;
+
+  ;
+  return 0;
+}
 _ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_header_compiler=yes
+if ac_fn_c_try_run "$LINENO"; then :
+  ac_cv_c_bigendian=no
 else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
+  ac_cv_c_bigendian=yes
+fi
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
+  conftest.$ac_objext conftest.beam conftest.$ac_ext
+fi
 
-	ac_header_compiler=no
+    fi
 fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_c_bigendian" >&5
+$as_echo "$ac_cv_c_bigendian" >&6; }
+ case $ac_cv_c_bigendian in #(
+   yes)
+     $as_echo "#define WORDS_BIGENDIAN 1" >>confdefs.h
+;; #(
+   no)
+      ;; #(
+   universal)
 
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-{ $as_echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
-$as_echo "$ac_header_compiler" >&6; }
+$as_echo "#define AC_APPLE_UNIVERSAL_BUILD 1" >>confdefs.h
 
-# Is the header present?
-{ $as_echo "$as_me:$LINENO: checking $ac_header presence" >&5
-$as_echo_n "checking $ac_header presence... " >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <$ac_header>
-_ACEOF
-if { (ac_try="$ac_cpp conftest.$ac_ext"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } >/dev/null && {
-	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       }; then
-  ac_header_preproc=yes
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
+     ;; #(
+   *)
+     as_fn_error $? "unknown endianness
+ presetting ac_cv_c_bigendian=no (or yes) will help" "$LINENO" 5 ;;
+ esac
 
-  ac_header_preproc=no
+if test $ac_cv_c_bigendian = yes; then
+  GS_WORDS_BIGENDIAN=1
+else
+  GS_WORDS_BIGENDIAN=0
 fi
 
-rm -f conftest.err conftest.$ac_ext
-{ $as_echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
-$as_echo "$ac_header_preproc" >&6; }
-
-# So?  What about this header?
-case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
-  yes:no: )
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
-$as_echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the compiler's result" >&5
-$as_echo "$as_me: WARNING: $ac_header: proceeding with the compiler's result" >&2;}
-    ac_header_preproc=yes
-    ;;
-  no:yes:* )
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
-$as_echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header:     check for missing prerequisite headers?" >&5
-$as_echo "$as_me: WARNING: $ac_header:     check for missing prerequisite headers?" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: see the Autoconf documentation" >&5
-$as_echo "$as_me: WARNING: $ac_header: see the Autoconf documentation" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&5
-$as_echo "$as_me: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
-$as_echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: in the future, the compiler will take precedence" >&5
-$as_echo "$as_me: WARNING: $ac_header: in the future, the compiler will take precedence" >&2;}
 
-    ;;
-esac
-{ $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
-$as_echo_n "checking for $ac_header... " >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
+#--------------------------------------------------------------------
+# Type size information needed for foundation headers.
+#--------------------------------------------------------------------
+# The cast to long int works around a bug in the HP C Compiler
+# version HP92453-01 B.11.11.23709.GP, which incorrectly rejects
+# declarations like `int a3[[(sizeof (unsigned char)) >= 0]];'.
+# This bug is HP SR number 8606223364.
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking size of void*" >&5
+$as_echo_n "checking size of void*... " >&6; }
+if ${ac_cv_sizeof_voidp+:} false; then :
   $as_echo_n "(cached) " >&6
 else
-  eval "$as_ac_Header=\$ac_header_preproc"
-fi
-ac_res=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
+  if ac_fn_c_compute_int "$LINENO" "(long int) (sizeof (void*))" "ac_cv_sizeof_voidp"        "$ac_includes_default"; then :
 
+else
+  if test "$ac_cv_type_voidp" = yes; then
+     { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+as_fn_error 77 "cannot compute sizeof (void*)
+See \`config.log' for more details" "$LINENO" 5; }
+   else
+     ac_cv_sizeof_voidp=0
+   fi
 fi
-as_val=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-   if test "x$as_val" = x""yes; then
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
-_ACEOF
 
 fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_sizeof_voidp" >&5
+$as_echo "$ac_cv_sizeof_voidp" >&6; }
 
-done
 
 
-for ac_func in poll
-do
-as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
-{ $as_echo "$as_me:$LINENO: checking for $ac_func" >&5
-$as_echo_n "checking for $ac_func... " >&6; }
-if { as_var=$as_ac_var; eval "test \"\${$as_var+set}\" = set"; }; then
-  $as_echo_n "(cached) " >&6
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
+cat >>confdefs.h <<_ACEOF
+#define SIZEOF_VOIDP $ac_cv_sizeof_voidp
 _ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.
-   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
-#define $ac_func innocuous_$ac_func
 
-/* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char $ac_func (); below.
-    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-    <limits.h> exists even on freestanding compilers.  */
 
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
 
-#undef $ac_func
+GS_SINT8="signed char"
+GS_UINT8="unsigned char"
 
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char $ac_func ();
-/* The GNU C library defines this for functions which it implements
-    to always fail with ENOSYS.  Some functions are actually named
-    something starting with __ and the normal name is an alias.  */
-#if defined __stub_$ac_func || defined __stub___$ac_func
-choke me
-#endif
 
-int
-main ()
-{
-return $ac_func ();
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then
-  eval "$as_ac_var=yes"
+
+# The cast to long int works around a bug in the HP C Compiler
+# version HP92453-01 B.11.11.23709.GP, which incorrectly rejects
+# declarations like `int a3[[(sizeof (unsigned char)) >= 0]];'.
+# This bug is HP SR number 8606223364.
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking size of short" >&5
+$as_echo_n "checking size of short... " >&6; }
+if ${ac_cv_sizeof_short+:} false; then :
+  $as_echo_n "(cached) " >&6
 else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
+  if ac_fn_c_compute_int "$LINENO" "(long int) (sizeof (short))" "ac_cv_sizeof_short"        "$ac_includes_default"; then :
 
-	eval "$as_ac_var=no"
+else
+  if test "$ac_cv_type_short" = yes; then
+     { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+as_fn_error 77 "cannot compute sizeof (short)
+See \`config.log' for more details" "$LINENO" 5; }
+   else
+     ac_cv_sizeof_short=0
+   fi
 fi
 
-rm -rf conftest.dSYM
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
 fi
-ac_res=`eval 'as_val=${'$as_ac_var'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-as_val=`eval 'as_val=${'$as_ac_var'}
-		 $as_echo "$as_val"'`
-   if test "x$as_val" = x""yes; then
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
-_ACEOF
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_sizeof_short" >&5
+$as_echo "$ac_cv_sizeof_short" >&6; }
 
-fi
-done
 
-have_poll=no
-if test $ac_cv_header_poll_h = yes; then
-  have_poll=yes
-  { $as_echo "$as_me:$LINENO: checking for poll emulation" >&5
-$as_echo_n "checking for poll emulation... " >&6; }
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include "config/config.poll.c"
-_ACEOF
-if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
-  $EGREP "emulating_poll" >/dev/null 2>&1; then
-  have_poll=no
-fi
-rm -f conftest*
 
-  if test $have_poll = yes; then
-    { $as_echo "$as_me:$LINENO: result: no" >&5
-$as_echo "no" >&6; }
-    { $as_echo "$as_me:$LINENO: checking if poll supports devices" >&5
-$as_echo_n "checking if poll supports devices... " >&6; }
-    if test "$cross_compiling" = yes; then
-  have_poll="$cross_have_poll"
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include "$srcdir/config/config.poll-dev.c"i
+cat >>confdefs.h <<_ACEOF
+#define SIZEOF_SHORT $ac_cv_sizeof_short
 _ACEOF
-rm -f conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  :
+
+
+
+
+# The cast to long int works around a bug in the HP C Compiler
+# version HP92453-01 B.11.11.23709.GP, which incorrectly rejects
+# declarations like `int a3[[(sizeof (unsigned char)) >= 0]];'.
+# This bug is HP SR number 8606223364.
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking size of int" >&5
+$as_echo_n "checking size of int... " >&6; }
+if ${ac_cv_sizeof_int+:} false; then :
+  $as_echo_n "(cached) " >&6
 else
-  $as_echo "$as_me: program exited with status $ac_status" >&5
-$as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
+  if ac_fn_c_compute_int "$LINENO" "(long int) (sizeof (int))" "ac_cv_sizeof_int"        "$ac_includes_default"; then :
 
-( exit $ac_status )
-have_poll=no
+else
+  if test "$ac_cv_type_int" = yes; then
+     { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+as_fn_error 77 "cannot compute sizeof (int)
+See \`config.log' for more details" "$LINENO" 5; }
+   else
+     ac_cv_sizeof_int=0
+   fi
 fi
-rm -rf conftest.dSYM
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+
 fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_sizeof_int" >&5
+$as_echo "$ac_cv_sizeof_int" >&6; }
 
 
-    if test $have_poll = yes; then
-      { $as_echo "$as_me:$LINENO: result: yes" >&5
-$as_echo "yes" >&6; }
 
-cat >>confdefs.h <<\_ACEOF
-#define HAVE_POLL_F 1
+cat >>confdefs.h <<_ACEOF
+#define SIZEOF_INT $ac_cv_sizeof_int
 _ACEOF
 
-    else
-      { $as_echo "$as_me:$LINENO: result: no" >&5
-$as_echo "no" >&6; }
-    fi
-  else
-    { $as_echo "$as_me:$LINENO: result: yes" >&5
-$as_echo "yes" >&6; }
-  fi
-fi
-
-#--------------------------------------------------------------------
-# This function needed by StdioStream.m
-#--------------------------------------------------------------------
-
 
 
 
-for ac_func in vsprintf vasprintf snprintf vsnprintf
-do
-as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
-{ $as_echo "$as_me:$LINENO: checking for $ac_func" >&5
-$as_echo_n "checking for $ac_func... " >&6; }
-if { as_var=$as_ac_var; eval "test \"\${$as_var+set}\" = set"; }; then
+# The cast to long int works around a bug in the HP C Compiler
+# version HP92453-01 B.11.11.23709.GP, which incorrectly rejects
+# declarations like `int a3[[(sizeof (unsigned char)) >= 0]];'.
+# This bug is HP SR number 8606223364.
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking size of long" >&5
+$as_echo_n "checking size of long... " >&6; }
+if ${ac_cv_sizeof_long+:} false; then :
   $as_echo_n "(cached) " >&6
 else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.
-   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
-#define $ac_func innocuous_$ac_func
+  if ac_fn_c_compute_int "$LINENO" "(long int) (sizeof (long))" "ac_cv_sizeof_long"        "$ac_includes_default"; then :
 
-/* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char $ac_func (); below.
-    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-    <limits.h> exists even on freestanding compilers.  */
+else
+  if test "$ac_cv_type_long" = yes; then
+     { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+as_fn_error 77 "cannot compute sizeof (long)
+See \`config.log' for more details" "$LINENO" 5; }
+   else
+     ac_cv_sizeof_long=0
+   fi
+fi
 
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_sizeof_long" >&5
+$as_echo "$ac_cv_sizeof_long" >&6; }
 
-#undef $ac_func
 
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char $ac_func ();
-/* The GNU C library defines this for functions which it implements
-    to always fail with ENOSYS.  Some functions are actually named
-    something starting with __ and the normal name is an alias.  */
-#if defined __stub_$ac_func || defined __stub___$ac_func
-choke me
-#endif
 
-int
-main ()
-{
-return $ac_func ();
-  ;
-  return 0;
-}
+cat >>confdefs.h <<_ACEOF
+#define SIZEOF_LONG $ac_cv_sizeof_long
 _ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then
-  eval "$as_ac_var=yes"
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
 
-	eval "$as_ac_var=no"
-fi
 
-rm -rf conftest.dSYM
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
-fi
-ac_res=`eval 'as_val=${'$as_ac_var'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-as_val=`eval 'as_val=${'$as_ac_var'}
-		 $as_echo "$as_val"'`
-   if test "x$as_val" = x""yes; then
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
-_ACEOF
 
-fi
-done
 
-if test $ac_cv_func_vsprintf = yes ; then
-    if test "$cross_compiling" = yes; then
-  VSPRINTF_RETURNS_LENGTH="$cross_VSPRINTF_RETURNS_LENGTH"
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include "$srcdir/config/config.vsprintf.c"
-_ACEOF
-rm -f conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  VSPRINTF_RETURNS_LENGTH=1
+# The cast to long int works around a bug in the HP C Compiler
+# version HP92453-01 B.11.11.23709.GP, which incorrectly rejects
+# declarations like `int a3[[(sizeof (unsigned char)) >= 0]];'.
+# This bug is HP SR number 8606223364.
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking size of long long" >&5
+$as_echo_n "checking size of long long... " >&6; }
+if ${ac_cv_sizeof_long_long+:} false; then :
+  $as_echo_n "(cached) " >&6
 else
-  $as_echo "$as_me: program exited with status $ac_status" >&5
-$as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
+  if ac_fn_c_compute_int "$LINENO" "(long int) (sizeof (long long))" "ac_cv_sizeof_long_long"        "$ac_includes_default"; then :
 
-( exit $ac_status )
-VSPRINTF_RETURNS_LENGTH=0
+else
+  if test "$ac_cv_type_long_long" = yes; then
+     { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+as_fn_error 77 "cannot compute sizeof (long long)
+See \`config.log' for more details" "$LINENO" 5; }
+   else
+     ac_cv_sizeof_long_long=0
+   fi
 fi
-rm -rf conftest.dSYM
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+
 fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_sizeof_long_long" >&5
+$as_echo "$ac_cv_sizeof_long_long" >&6; }
 
 
 
 cat >>confdefs.h <<_ACEOF
-#define VSPRINTF_RETURNS_LENGTH $VSPRINTF_RETURNS_LENGTH
+#define SIZEOF_LONG_LONG $ac_cv_sizeof_long_long
 _ACEOF
 
-fi
-if test $ac_cv_func_vasprintf = yes ; then
-    if test "$cross_compiling" = yes; then
-  VASPRINTF_RETURNS_LENGTH="$cross_VASPRINTF_RETURNS_LENGTH"
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include "$srcdir/config/config.vasprintf.c"
-_ACEOF
-rm -f conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  VASPRINTF_RETURNS_LENGTH=1
+
+
+
+# The cast to long int works around a bug in the HP C Compiler
+# version HP92453-01 B.11.11.23709.GP, which incorrectly rejects
+# declarations like `int a3[[(sizeof (unsigned char)) >= 0]];'.
+# This bug is HP SR number 8606223364.
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking size of float" >&5
+$as_echo_n "checking size of float... " >&6; }
+if ${ac_cv_sizeof_float+:} false; then :
+  $as_echo_n "(cached) " >&6
 else
-  $as_echo "$as_me: program exited with status $ac_status" >&5
-$as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
+  if ac_fn_c_compute_int "$LINENO" "(long int) (sizeof (float))" "ac_cv_sizeof_float"        "$ac_includes_default"; then :
 
-( exit $ac_status )
-VASPRINTF_RETURNS_LENGTH=0
+else
+  if test "$ac_cv_type_float" = yes; then
+     { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+as_fn_error 77 "cannot compute sizeof (float)
+See \`config.log' for more details" "$LINENO" 5; }
+   else
+     ac_cv_sizeof_float=0
+   fi
 fi
-rm -rf conftest.dSYM
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+
 fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_sizeof_float" >&5
+$as_echo "$ac_cv_sizeof_float" >&6; }
 
 
 
 cat >>confdefs.h <<_ACEOF
-#define VASPRINTF_RETURNS_LENGTH $VASPRINTF_RETURNS_LENGTH
+#define SIZEOF_FLOAT $ac_cv_sizeof_float
 _ACEOF
 
-fi
 
-#--------------------------------------------------------------------
-# This function needed by NSFileManager.m
-#--------------------------------------------------------------------
 
-for ac_func in getcwd
-do
-as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
-{ $as_echo "$as_me:$LINENO: checking for $ac_func" >&5
-$as_echo_n "checking for $ac_func... " >&6; }
-if { as_var=$as_ac_var; eval "test \"\${$as_var+set}\" = set"; }; then
+
+# The cast to long int works around a bug in the HP C Compiler
+# version HP92453-01 B.11.11.23709.GP, which incorrectly rejects
+# declarations like `int a3[[(sizeof (unsigned char)) >= 0]];'.
+# This bug is HP SR number 8606223364.
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking size of double" >&5
+$as_echo_n "checking size of double... " >&6; }
+if ${ac_cv_sizeof_double+:} false; then :
   $as_echo_n "(cached) " >&6
 else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.
-   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
-#define $ac_func innocuous_$ac_func
+  if ac_fn_c_compute_int "$LINENO" "(long int) (sizeof (double))" "ac_cv_sizeof_double"        "$ac_includes_default"; then :
 
-/* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char $ac_func (); below.
-    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-    <limits.h> exists even on freestanding compilers.  */
+else
+  if test "$ac_cv_type_double" = yes; then
+     { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+as_fn_error 77 "cannot compute sizeof (double)
+See \`config.log' for more details" "$LINENO" 5; }
+   else
+     ac_cv_sizeof_double=0
+   fi
+fi
 
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_sizeof_double" >&5
+$as_echo "$ac_cv_sizeof_double" >&6; }
 
-#undef $ac_func
 
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char $ac_func ();
-/* The GNU C library defines this for functions which it implements
-    to always fail with ENOSYS.  Some functions are actually named
-    something starting with __ and the normal name is an alias.  */
-#if defined __stub_$ac_func || defined __stub___$ac_func
-choke me
-#endif
 
-int
-main ()
-{
-return $ac_func ();
-  ;
-  return 0;
-}
+cat >>confdefs.h <<_ACEOF
+#define SIZEOF_DOUBLE $ac_cv_sizeof_double
 _ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then
-  eval "$as_ac_var=yes"
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
 
-	eval "$as_ac_var=no"
-fi
 
-rm -rf conftest.dSYM
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
-fi
-ac_res=`eval 'as_val=${'$as_ac_var'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-as_val=`eval 'as_val=${'$as_ac_var'}
-		 $as_echo "$as_val"'`
-   if test "x$as_val" = x""yes; then
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
-_ACEOF
 
+
+
+if test $ac_cv_sizeof_voidp = $ac_cv_sizeof_int; then
+  GS_SADDR="int"
+  GS_UADDR="unsigned int"
+else
+  if test $ac_cv_sizeof_voidp = $ac_cv_sizeof_long; then
+    GS_SADDR="long"
+    GS_UADDR="unsigned long"
+  else
+    if test $ac_cv_sizeof_voidp = $ac_cv_sizeof_long_long; then
+      GS_SADDR="long long"
+      GS_UADDR="unsigned long long"
+    else
+      as_fn_error $? "Unable to find integer of same size as void*" "$LINENO" 5
+    fi
+  fi
 fi
-done
 
 
 
+if test $ac_cv_sizeof_short = 2; then
+  GS_SINT16="signed short"
+  GS_UINT16="unsigned short"
+else
+  if test $ac_cv_sizeof_int = 2; then
+    GS_SINT16="signed int"
+    GS_UINT16="unsigned int"
+  else
+    as_fn_error $? "Unable to determine type for 16-bit integer" "$LINENO" 5
+  fi
+fi
 
 
 
-ac_header_dirent=no
-for ac_hdr in dirent.h sys/ndir.h sys/dir.h ndir.h; do
-  as_ac_Header=`$as_echo "ac_cv_header_dirent_$ac_hdr" | $as_tr_sh`
-{ $as_echo "$as_me:$LINENO: checking for $ac_hdr that defines DIR" >&5
-$as_echo_n "checking for $ac_hdr that defines DIR... " >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  $as_echo_n "(cached) " >&6
+if test $ac_cv_sizeof_int = 4; then
+  GS_SINT32="signed int"
+  GS_UINT32="unsigned int"
 else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <sys/types.h>
-#include <$ac_hdr>
+  if test $ac_cv_sizeof_long = 4; then
+    GS_SINT32="signed long"
+    GS_UINT32="unsigned long"
+  else
+    if test $ac_cv_sizeof_short = 4; then
+      GS_SINT32="signed short"
+      GS_UINT32="unsigned short"
+    else
+      as_fn_error $? "Unable to determine type for 32-bit integer" "$LINENO" 5
+    fi
+  fi
+fi
 
-int
-main ()
-{
-if ((DIR *) 0)
-return 0;
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  eval "$as_ac_Header=yes"
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
 
-	eval "$as_ac_Header=no"
-fi
 
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+GS_HAVE_I64=1
+if test $ac_cv_sizeof_int = 8; then
+  GS_SINT64="signed int"
+  GS_UINT64="unsigned int"
+else
+  if test $ac_cv_sizeof_long = 8; then
+    GS_SINT64="signed long"
+    GS_UINT64="unsigned long"
+  else
+    if test $ac_cv_sizeof_long_long = 8; then
+      GS_SINT64="signed long long"
+      GS_UINT64="unsigned long long"
+    else
+#     64-bit ints not supported - but we need a dummy type for byte-swapping
+#     of 64-bit values arriving from another system.
+      GS_SINT64="struct { gsu8 a8; }"
+      GS_UINT64="struct { gsu8 a8; }"
+      GS_HAVE_I64=0
+    fi
+  fi
 fi
-ac_res=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-as_val=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-   if test "x$as_val" = x""yes; then
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_hdr" | $as_tr_cpp` 1
-_ACEOF
 
-ac_header_dirent=$ac_hdr; break
-fi
 
-done
-# Two versions of opendir et al. are in -ldir and -lx on SCO Xenix.
-if test $ac_header_dirent = dirent.h; then
-  { $as_echo "$as_me:$LINENO: checking for library containing opendir" >&5
-$as_echo_n "checking for library containing opendir... " >&6; }
-if test "${ac_cv_search_opendir+set}" = set; then
-  $as_echo_n "(cached) " >&6
-else
-  ac_func_search_save_LIBS=$LIBS
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
 
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char opendir ();
-int
-main ()
-{
-return opendir ();
-  ;
-  return 0;
-}
-_ACEOF
-for ac_lib in '' dir; do
-  if test -z "$ac_lib"; then
-    ac_res="none required"
+
+GS_HAVE_I128=1
+if test $ac_cv_sizeof_long = 16; then
+  GS_SINT128="signed long"
+  GS_UINT128="unsigned long"
+else
+  if test $ac_cv_sizeof_long_long = 16; then
+    GS_SINT128="signed long long"
+    GS_UINT128="unsigned long long"
   else
-    ac_res=-l$ac_lib
-    LIBS="-l$ac_lib  $ac_func_search_save_LIBS"
+#     128-bit ints not supported - but we need a dummy type for byte-swapping
+#     of 128-bit values arriving from another system.
+    GS_SINT128="struct { gsu8 a[16]; }"
+    GS_UINT128="struct { gsu8 a[16]; }"
+    GS_HAVE_I128=0
   fi
-  rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then
-  ac_cv_search_opendir=$ac_res
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
+fi
 
 
-fi
 
-rm -rf conftest.dSYM
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext
-  if test "${ac_cv_search_opendir+set}" = set; then
-  break
-fi
-done
-if test "${ac_cv_search_opendir+set}" = set; then
-  :
+
+if test $ac_cv_sizeof_float = 4; then
+  GS_FLT32="float"
 else
-  ac_cv_search_opendir=no
+  as_fn_error $? "Unable to determine type for 32-bit float" "$LINENO" 5
 fi
-rm conftest.$ac_ext
-LIBS=$ac_func_search_save_LIBS
-fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_search_opendir" >&5
-$as_echo "$ac_cv_search_opendir" >&6; }
-ac_res=$ac_cv_search_opendir
-if test "$ac_res" != no; then
-  test "$ac_res" = "none required" || LIBS="$ac_res $LIBS"
 
-fi
 
+if test $ac_cv_sizeof_double = 8; then
+  GS_FLT64="double"
 else
-  { $as_echo "$as_me:$LINENO: checking for library containing opendir" >&5
-$as_echo_n "checking for library containing opendir... " >&6; }
-if test "${ac_cv_search_opendir+set}" = set; then
-  $as_echo_n "(cached) " >&6
-else
-  ac_func_search_save_LIBS=$LIBS
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
+  as_fn_error $? "Unable to determine type for 64-bit float" "$LINENO" 5
+fi
 
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char opendir ();
-int
-main ()
-{
-return opendir ();
-  ;
-  return 0;
-}
-_ACEOF
-for ac_lib in '' x; do
-  if test -z "$ac_lib"; then
-    ac_res="none required"
-  else
-    ac_res=-l$ac_lib
-    LIBS="-l$ac_lib  $ac_func_search_save_LIBS"
-  fi
-  rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then
-  ac_cv_search_opendir=$ac_res
+
+#--------------------------------------------------------------------
+# Type-size information for encoding into archives using NSArchiver etc.
+#--------------------------------------------------------------------
+if test $ac_cv_sizeof_short = 2; then
+  _GSC_S_SHT=_GSC_I16
 else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
+  _GSC_S_SHT=_GSC_I32
+fi
 
 
+if test $ac_cv_sizeof_int = 2; then
+  _GSC_S_INT=_GSC_I16
+else
+  if test $ac_cv_sizeof_int = 4; then
+    _GSC_S_INT=_GSC_I32
+  else
+    if test $ac_cv_sizeof_int = 8; then
+      _GSC_S_INT=_GSC_I64
+    else
+      if test $ac_cv_sizeof_int = 16; then
+	_GSC_S_INT=_GSC_I128
+      fi
+    fi
+  fi
 fi
 
-rm -rf conftest.dSYM
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext
-  if test "${ac_cv_search_opendir+set}" = set; then
-  break
-fi
-done
-if test "${ac_cv_search_opendir+set}" = set; then
-  :
+
+if test $ac_cv_sizeof_long = 4; then
+  _GSC_S_LNG=_GSC_I32
 else
-  ac_cv_search_opendir=no
-fi
-rm conftest.$ac_ext
-LIBS=$ac_func_search_save_LIBS
+  if test $ac_cv_sizeof_long = 8; then
+    _GSC_S_LNG=_GSC_I64
+  else
+    if test $ac_cv_sizeof_long = 16; then
+      _GSC_S_LNG=_GSC_I128
+    fi
+  fi
 fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_search_opendir" >&5
-$as_echo "$ac_cv_search_opendir" >&6; }
-ac_res=$ac_cv_search_opendir
-if test "$ac_res" != no; then
-  test "$ac_res" = "none required" || LIBS="$ac_res $LIBS"
 
-fi
 
+if test $ac_cv_sizeof_long_long = 4; then
+  _GSC_S_LNG_LNG=_GSC_I32
+else
+  if test $ac_cv_sizeof_long_long = 8; then
+    _GSC_S_LNG_LNG=_GSC_I64
+  else
+    if test $ac_cv_sizeof_long_long = 16; then
+      _GSC_S_LNG_LNG=_GSC_I128
+    fi
+  fi
 fi
 
 
 #--------------------------------------------------------------------
-# This function needed by gdomap.c
+# Setup dynamic linking
 #--------------------------------------------------------------------
-
-for ac_header in getopt.h
-do
-as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  { $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
-$as_echo_n "checking for $ac_header... " >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
+# Copyright (C) 2005 Free Software Foundation
+#
+# Copying and distribution of this file, with or without modification,
+# are permitted in any medium without royalty provided the copyright
+# notice and this notice are preserved.
+#--------------------------------------------------------------------
+# Guess if we are using a object file format that supports automatic
+# loading of constructor functions.
+#
+# If this system supports autoloading of constructors, that means that gcc
+# doesn't have to do it for us via collect2. This routine tests for this
+# in a very roundabout way by compiling a program with a constructor and
+# testing the file, via nm, for certain symbols that collect2 includes to
+# handle loading of constructors.
+#
+# Makes the following substitutions:
+#	Defines CON_AUTOLOAD (whether constructor functions are autoloaded)
+#--------------------------------------------------------------------
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking loading of constructor functions" >&5
+$as_echo_n "checking loading of constructor functions... " >&6; }
+if ${objc_cv_con_autoload+:} false; then :
   $as_echo_n "(cached) " >&6
-fi
-ac_res=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
 else
-  # Is the header compilable?
-{ $as_echo "$as_me:$LINENO: checking $ac_header usability" >&5
-$as_echo_n "checking $ac_header usability... " >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+  if test "$cross_compiling" = yes; then :
+  objc_cv_con_autoload=no
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
-$ac_includes_default
-#include <$ac_header>
+static int loaded = 0;
+	void cons_functions() __attribute__ ((constructor));
+	void cons_functions() { loaded = 1; }
+	int main()
+	{
+  	  return ( (loaded == 1) ? 0 : 1);
+	}
 _ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_header_compiler=yes
+if ac_fn_c_try_run "$LINENO"; then :
+  objc_cv_con_autoload=yes
 else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_header_compiler=no
+  objc_cv_con_autoload=no
+fi
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
+  conftest.$ac_objext conftest.beam conftest.$ac_ext
 fi
 
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-{ $as_echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
-$as_echo "$ac_header_compiler" >&6; }
-
-# Is the header present?
-{ $as_echo "$as_me:$LINENO: checking $ac_header presence" >&5
-$as_echo_n "checking $ac_header presence... " >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <$ac_header>
-_ACEOF
-if { (ac_try="$ac_cpp conftest.$ac_ext"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
+case "$target_os" in
+    cygwin*)	objc_cv_con_autoload=yes;;
+    mingw*)	objc_cv_con_autoload=yes;;
 esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } >/dev/null && {
-	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       }; then
-  ac_header_preproc=yes
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
 
-  ac_header_preproc=no
 fi
 
-rm -f conftest.err conftest.$ac_ext
-{ $as_echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
-$as_echo "$ac_header_preproc" >&6; }
+if test $objc_cv_con_autoload = yes; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
 
-# So?  What about this header?
-case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
-  yes:no: )
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
-$as_echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the compiler's result" >&5
-$as_echo "$as_me: WARNING: $ac_header: proceeding with the compiler's result" >&2;}
-    ac_header_preproc=yes
-    ;;
-  no:yes:* )
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
-$as_echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header:     check for missing prerequisite headers?" >&5
-$as_echo "$as_me: WARNING: $ac_header:     check for missing prerequisite headers?" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: see the Autoconf documentation" >&5
-$as_echo "$as_me: WARNING: $ac_header: see the Autoconf documentation" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&5
-$as_echo "$as_me: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
-$as_echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: in the future, the compiler will take precedence" >&5
-$as_echo "$as_me: WARNING: $ac_header: in the future, the compiler will take precedence" >&2;}
+$as_echo "#define CON_AUTOLOAD 1" >>confdefs.h
 
-    ;;
-esac
-{ $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
-$as_echo_n "checking for $ac_header... " >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  $as_echo_n "(cached) " >&6
 else
-  eval "$as_ac_Header=\$ac_header_preproc"
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
 fi
-ac_res=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
 
+# Copyright (C) 2005 Free Software Foundation
+# Copying and distribution of this file, with or without modification,
+# are permitted in any medium without royalty provided the copyright
+# notice and this notice are preserved.
+#--------------------------------------------------------------------
+# Guess the type of dynamic linker for the system
+#
+# Makes the following substitutions:
+#	DYNAMIC_LINKER	- cooresponds to the interface that is included
+#		in objc-load.c (i.e. #include "${DYNAMIC_LINKER}-load.h")
+#--------------------------------------------------------------------
+DYNAMIC_LINKER=null
+ac_fn_c_check_header_mongrel "$LINENO" "dlfcn.h" "ac_cv_header_dlfcn_h" "$ac_includes_default"
+if test "x$ac_cv_header_dlfcn_h" = xyes; then :
+  DYNAMIC_LINKER=simple
 fi
-as_val=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-   if test "x$as_val" = x""yes; then
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
-_ACEOF
 
+
+if test $DYNAMIC_LINKER = null; then
+  ac_fn_c_check_header_mongrel "$LINENO" "dl.h" "ac_cv_header_dl_h" "$ac_includes_default"
+if test "x$ac_cv_header_dl_h" = xyes; then :
+  DYNAMIC_LINKER=hpux
 fi
 
-done
+
+fi
+if test $DYNAMIC_LINKER = null; then
+  ac_fn_c_check_header_mongrel "$LINENO" "windows.h" "ac_cv_header_windows_h" "$ac_includes_default"
+if test "x$ac_cv_header_windows_h" = xyes; then :
+  DYNAMIC_LINKER=win32
+fi
+
+
+fi
+if test $DYNAMIC_LINKER = null; then
+  ac_fn_c_check_header_mongrel "$LINENO" "dld/defs.h" "ac_cv_header_dld_defs_h" "$ac_includes_default"
+if test "x$ac_cv_header_dld_defs_h" = xyes; then :
+  DYNAMIC_LINKER=dld
+fi
 
 
-#--------------------------------------------------------------------
-# This function needed by NSPage.m
-#--------------------------------------------------------------------
+fi
 
+# NB: This is used as follows: in Source/Makefile.postamble we copy
+# $(DYNAMIC_LINKER)-load.h into dynamic-load.h
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for dynamic linker type" >&5
+$as_echo_n "checking for dynamic linker type... " >&6; }
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $DYNAMIC_LINKER" >&5
+$as_echo "$DYNAMIC_LINKER" >&6; }
 
-for ac_func in posix_memalign valloc
-do
-as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
-{ $as_echo "$as_me:$LINENO: checking for $ac_func" >&5
-$as_echo_n "checking for $ac_func... " >&6; }
-if { as_var=$as_ac_var; eval "test \"\${$as_var+set}\" = set"; }; then
+if test $DYNAMIC_LINKER = simple; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for dladdr in -ldl" >&5
+$as_echo_n "checking for dladdr in -ldl... " >&6; }
+if ${ac_cv_lib_dl_dladdr+:} false; then :
   $as_echo_n "(cached) " >&6
 else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-ldl  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
-/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.
-   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
-#define $ac_func innocuous_$ac_func
-
-/* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char $ac_func (); below.
-    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-    <limits.h> exists even on freestanding compilers.  */
-
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
-
-#undef $ac_func
 
 /* Override any GCC internal prototype to avoid an error.
    Use char because int might match the return type of a GCC
@@ -18475,104 +6666,73 @@ cat >>conftest.$ac_ext <<_ACEOF
 #ifdef __cplusplus
 extern "C"
 #endif
-char $ac_func ();
-/* The GNU C library defines this for functions which it implements
-    to always fail with ENOSYS.  Some functions are actually named
-    something starting with __ and the normal name is an alias.  */
-#if defined __stub_$ac_func || defined __stub___$ac_func
-choke me
-#endif
-
+char dladdr ();
 int
 main ()
 {
-return $ac_func ();
+return dladdr ();
   ;
   return 0;
 }
 _ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then
-  eval "$as_ac_var=yes"
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_dl_dladdr=yes
 else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
+  ac_cv_lib_dl_dladdr=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_dl_dladdr" >&5
+$as_echo "$ac_cv_lib_dl_dladdr" >&6; }
+if test "x$ac_cv_lib_dl_dladdr" = xyes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_LIBDL 1
+_ACEOF
+
+  LIBS="-ldl $LIBS"
 
-	eval "$as_ac_var=no"
 fi
 
-rm -rf conftest.dSYM
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
 fi
-ac_res=`eval 'as_val=${'$as_ac_var'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-as_val=`eval 'as_val=${'$as_ac_var'}
-		 $as_echo "$as_val"'`
-   if test "x$as_val" = x""yes; then
+
+
+# NOTE: libdl should be in LIBS now if it's available.
+for ac_func in dladdr
+do :
+  ac_fn_c_check_func "$LINENO" "dladdr" "ac_cv_func_dladdr"
+if test "x$ac_cv_func_dladdr" = xyes; then :
   cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
+#define HAVE_DLADDR 1
 _ACEOF
 
 fi
 done
 
 
-#--------------------------------------------------------------------
-# This function needed by Time.m
-#--------------------------------------------------------------------
+for ac_func in gethostbyname
+do :
+  ac_fn_c_check_func "$LINENO" "gethostbyname" "ac_cv_func_gethostbyname"
+if test "x$ac_cv_func_gethostbyname" = xyes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_GETHOSTBYNAME 1
+_ACEOF
 
-for ac_func in times
-do
-as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
-{ $as_echo "$as_me:$LINENO: checking for $ac_func" >&5
-$as_echo_n "checking for $ac_func... " >&6; }
-if { as_var=$as_ac_var; eval "test \"\${$as_var+set}\" = set"; }; then
+fi
+done
+
+if test "$ac_cv_func_gethostbyname" = "no"; then
+  # QNX has gethostbyname and friends in libsocket
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for gethostbyname in -lsocket" >&5
+$as_echo_n "checking for gethostbyname in -lsocket... " >&6; }
+if ${ac_cv_lib_socket_gethostbyname+:} false; then :
   $as_echo_n "(cached) " >&6
 else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lsocket  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
-/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.
-   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
-#define $ac_func innocuous_$ac_func
-
-/* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char $ac_func (); below.
-    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-    <limits.h> exists even on freestanding compilers.  */
-
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
-
-#undef $ac_func
 
 /* Override any GCC internal prototype to avoid an error.
    Use char because int might match the return type of a GCC
@@ -18580,104 +6740,229 @@ cat >>conftest.$ac_ext <<_ACEOF
 #ifdef __cplusplus
 extern "C"
 #endif
-char $ac_func ();
-/* The GNU C library defines this for functions which it implements
-    to always fail with ENOSYS.  Some functions are actually named
-    something starting with __ and the normal name is an alias.  */
-#if defined __stub_$ac_func || defined __stub___$ac_func
-choke me
-#endif
-
+char gethostbyname ();
 int
 main ()
 {
-return $ac_func ();
+return gethostbyname ();
   ;
   return 0;
 }
 _ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then
-  eval "$as_ac_var=yes"
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_socket_gethostbyname=yes
 else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
+  ac_cv_lib_socket_gethostbyname=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_socket_gethostbyname" >&5
+$as_echo "$ac_cv_lib_socket_gethostbyname" >&6; }
+if test "x$ac_cv_lib_socket_gethostbyname" = xyes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_LIBSOCKET 1
+_ACEOF
+
+  LIBS="-lsocket $LIBS"
 
-	eval "$as_ac_var=no"
 fi
 
-rm -rf conftest.dSYM
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
 fi
-ac_res=`eval 'as_val=${'$as_ac_var'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-as_val=`eval 'as_val=${'$as_ac_var'}
-		 $as_echo "$as_val"'`
-   if test "x$as_val" = x""yes; then
+
+#--------------------------------------------------------------------
+# Check for pthread.h
+#--------------------------------------------------------------------
+for ac_header in pthread.h
+do :
+  ac_fn_c_check_header_mongrel "$LINENO" "pthread.h" "ac_cv_header_pthread_h" "$ac_includes_default"
+if test "x$ac_cv_header_pthread_h" = xyes; then :
   cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
+#define HAVE_PTHREAD_H 1
 _ACEOF
 
 fi
+
 done
 
+if test $ac_cv_header_pthread_h = yes ; then
+  # The cast to long int works around a bug in the HP C Compiler
+# version HP92453-01 B.11.11.23709.GP, which incorrectly rejects
+# declarations like `int a3[[(sizeof (unsigned char)) >= 0]];'.
+# This bug is HP SR number 8606223364.
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking size of pthread_mutex_t" >&5
+$as_echo_n "checking size of pthread_mutex_t... " >&6; }
+if ${ac_cv_sizeof_pthread_mutex_t+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if ac_fn_c_compute_int "$LINENO" "(long int) (sizeof (pthread_mutex_t))" "ac_cv_sizeof_pthread_mutex_t"        "$ac_includes_default
+#include <pthread.h>
+"; then :
 
-#--------------------------------------------------------------------
-# These functions needed by NSData.m and GSFFIInvocation.m
-#--------------------------------------------------------------------
+else
+  if test "$ac_cv_type_pthread_mutex_t" = yes; then
+     { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+as_fn_error 77 "cannot compute sizeof (pthread_mutex_t)
+See \`config.log' for more details" "$LINENO" 5; }
+   else
+     ac_cv_sizeof_pthread_mutex_t=0
+   fi
+fi
 
-for ac_func in mkstemp
-do
-as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
-{ $as_echo "$as_me:$LINENO: checking for $ac_func" >&5
-$as_echo_n "checking for $ac_func... " >&6; }
-if { as_var=$as_ac_var; eval "test \"\${$as_var+set}\" = set"; }; then
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_sizeof_pthread_mutex_t" >&5
+$as_echo "$ac_cv_sizeof_pthread_mutex_t" >&6; }
+
+
+
+cat >>confdefs.h <<_ACEOF
+#define SIZEOF_PTHREAD_MUTEX_T $ac_cv_sizeof_pthread_mutex_t
+_ACEOF
+
+
+  GS_SIZEOF_MUTEX_T=$ac_cv_sizeof_pthread_mutex_t
+  if test $ac_cv_sizeof_pthread_mutex_t = 0 ; then
+    as_fn_error $? "Unable to find size of pthread_mutex_t (required)." "$LINENO" 5
+  fi
+
+  # The cast to long int works around a bug in the HP C Compiler
+# version HP92453-01 B.11.11.23709.GP, which incorrectly rejects
+# declarations like `int a3[[(sizeof (unsigned char)) >= 0]];'.
+# This bug is HP SR number 8606223364.
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking size of pthread_cond_t" >&5
+$as_echo_n "checking size of pthread_cond_t... " >&6; }
+if ${ac_cv_sizeof_pthread_cond_t+:} false; then :
   $as_echo_n "(cached) " >&6
 else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
+  if ac_fn_c_compute_int "$LINENO" "(long int) (sizeof (pthread_cond_t))" "ac_cv_sizeof_pthread_cond_t"        "$ac_includes_default
+#include <pthread.h>
+"; then :
+
+else
+  if test "$ac_cv_type_pthread_cond_t" = yes; then
+     { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+as_fn_error 77 "cannot compute sizeof (pthread_cond_t)
+See \`config.log' for more details" "$LINENO" 5; }
+   else
+     ac_cv_sizeof_pthread_cond_t=0
+   fi
+fi
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_sizeof_pthread_cond_t" >&5
+$as_echo "$ac_cv_sizeof_pthread_cond_t" >&6; }
+
+
+
+cat >>confdefs.h <<_ACEOF
+#define SIZEOF_PTHREAD_COND_T $ac_cv_sizeof_pthread_cond_t
 _ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.
-   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
-#define $ac_func innocuous_$ac_func
 
-/* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char $ac_func (); below.
-    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-    <limits.h> exists even on freestanding compilers.  */
 
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
+  if test $ac_cv_sizeof_pthread_cond_t = 0 ; then
+    as_fn_error $? "Unable to find size of pthread_cond_t (required)." "$LINENO" 5
+  fi
+  GS_SIZEOF_COND_T=$ac_cv_sizeof_pthread_cond_t
+
+  # The cast to long int works around a bug in the HP C Compiler,
+# see AC_CHECK_SIZEOF for more information.
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking alignment of pthread_mutex_t" >&5
+$as_echo_n "checking alignment of pthread_mutex_t... " >&6; }
+if ${ac_cv_alignof_pthread_mutex_t+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if ac_fn_c_compute_int "$LINENO" "(long int) offsetof (ac__type_alignof_, y)" "ac_cv_alignof_pthread_mutex_t"        "$ac_includes_default
+#include <pthread.h>
+
+#ifndef offsetof
+# define offsetof(type, member) ((char *) &((type *) 0)->member - (char *) 0)
+#endif
+typedef struct { char x; pthread_mutex_t y; } ac__type_alignof_;"; then :
+
+else
+  if test "$ac_cv_type_pthread_mutex_t" = yes; then
+     { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+as_fn_error 77 "cannot compute alignment of pthread_mutex_t
+See \`config.log' for more details" "$LINENO" 5; }
+   else
+     ac_cv_alignof_pthread_mutex_t=0
+   fi
+fi
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_alignof_pthread_mutex_t" >&5
+$as_echo "$ac_cv_alignof_pthread_mutex_t" >&6; }
+
+
+
+cat >>confdefs.h <<_ACEOF
+#define ALIGNOF_PTHREAD_MUTEX_T $ac_cv_alignof_pthread_mutex_t
+_ACEOF
+
+
+  GS_ALIGNOF_MUTEX_T=$ac_cv_alignof_pthread_mutex_t
+  if test $ac_cv_alignof_pthread_mutex_t = 0 ; then
+    as_fn_error $? "Unable to find align of pthread_mutex_t (required)." "$LINENO" 5
+  fi
+
+  # The cast to long int works around a bug in the HP C Compiler,
+# see AC_CHECK_SIZEOF for more information.
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking alignment of pthread_cond_t" >&5
+$as_echo_n "checking alignment of pthread_cond_t... " >&6; }
+if ${ac_cv_alignof_pthread_cond_t+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if ac_fn_c_compute_int "$LINENO" "(long int) offsetof (ac__type_alignof_, y)" "ac_cv_alignof_pthread_cond_t"        "$ac_includes_default
+#include <pthread.h>
+
+#ifndef offsetof
+# define offsetof(type, member) ((char *) &((type *) 0)->member - (char *) 0)
 #endif
+typedef struct { char x; pthread_cond_t y; } ac__type_alignof_;"; then :
+
+else
+  if test "$ac_cv_type_pthread_cond_t" = yes; then
+     { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+as_fn_error 77 "cannot compute alignment of pthread_cond_t
+See \`config.log' for more details" "$LINENO" 5; }
+   else
+     ac_cv_alignof_pthread_cond_t=0
+   fi
+fi
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_alignof_pthread_cond_t" >&5
+$as_echo "$ac_cv_alignof_pthread_cond_t" >&6; }
+
+
+
+cat >>confdefs.h <<_ACEOF
+#define ALIGNOF_PTHREAD_COND_T $ac_cv_alignof_pthread_cond_t
+_ACEOF
+
+
+  if test $ac_cv_alignof_pthread_cond_t = 0 ; then
+    as_fn_error $? "Unable to find align of pthread_cond_t (required)." "$LINENO" 5
+  fi
+  GS_ALIGNOF_COND_T=$ac_cv_alignof_pthread_cond_t
 
-#undef $ac_func
+else
+  as_fn_error $? "Unable to find pthread.h (needed for thread support)." "$LINENO" 5
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for pthread_join in -lpthread" >&5
+$as_echo_n "checking for pthread_join in -lpthread... " >&6; }
+if ${ac_cv_lib_pthread_pthread_join+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lpthread  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
 
 /* Override any GCC internal prototype to avoid an error.
    Use char because int might match the return type of a GCC
@@ -18685,100 +6970,53 @@ cat >>conftest.$ac_ext <<_ACEOF
 #ifdef __cplusplus
 extern "C"
 #endif
-char $ac_func ();
-/* The GNU C library defines this for functions which it implements
-    to always fail with ENOSYS.  Some functions are actually named
-    something starting with __ and the normal name is an alias.  */
-#if defined __stub_$ac_func || defined __stub___$ac_func
-choke me
-#endif
-
+char pthread_join ();
 int
 main ()
 {
-return $ac_func ();
+return pthread_join ();
   ;
   return 0;
 }
 _ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then
-  eval "$as_ac_var=yes"
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_pthread_pthread_join=yes
 else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	eval "$as_ac_var=no"
+  ac_cv_lib_pthread_pthread_join=no
 fi
-
-rm -rf conftest.dSYM
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
 fi
-ac_res=`eval 'as_val=${'$as_ac_var'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-as_val=`eval 'as_val=${'$as_ac_var'}
-		 $as_echo "$as_val"'`
-   if test "x$as_val" = x""yes; then
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
-_ACEOF
-
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_pthread_pthread_join" >&5
+$as_echo "$ac_cv_lib_pthread_pthread_join" >&6; }
+if test "x$ac_cv_lib_pthread_pthread_join" = xyes; then :
+  pthread_ok=yes
+else
+  pthread_ok=no
 fi
-done
 
-
-for ac_func in shmctl
-do
-as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
-{ $as_echo "$as_me:$LINENO: checking for $ac_func" >&5
-$as_echo_n "checking for $ac_func... " >&6; }
-if { as_var=$as_ac_var; eval "test \"\${$as_var+set}\" = set"; }; then
+ismingw=no
+checkinlibc=no
+case "$target_os" in
+  mingw*)	ismingw=yes;;
+  nto*)		checkinlibc=yes;;
+  qnx*)		checkinlibc=yes;;
+  *android*)   checkinlibc=yes;;
+esac
+if test $pthread_ok = yes ; then
+  LIBS="$LIBS -lpthread"
+else
+  if test $ismingw = yes ; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for pthread_join in -lpthreadGC2" >&5
+$as_echo_n "checking for pthread_join in -lpthreadGC2... " >&6; }
+if ${ac_cv_lib_pthreadGC2_pthread_join+:} false; then :
   $as_echo_n "(cached) " >&6
 else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lpthreadGC2  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
-/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.
-   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
-#define $ac_func innocuous_$ac_func
-
-/* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char $ac_func (); below.
-    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-    <limits.h> exists even on freestanding compilers.  */
-
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
-
-#undef $ac_func
 
 /* Override any GCC internal prototype to avoid an error.
    Use char because int might match the return type of a GCC
@@ -18786,100 +7024,47 @@ cat >>conftest.$ac_ext <<_ACEOF
 #ifdef __cplusplus
 extern "C"
 #endif
-char $ac_func ();
-/* The GNU C library defines this for functions which it implements
-    to always fail with ENOSYS.  Some functions are actually named
-    something starting with __ and the normal name is an alias.  */
-#if defined __stub_$ac_func || defined __stub___$ac_func
-choke me
-#endif
-
+char pthread_join ();
 int
 main ()
 {
-return $ac_func ();
+return pthread_join ();
   ;
   return 0;
 }
 _ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then
-  eval "$as_ac_var=yes"
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_pthreadGC2_pthread_join=yes
 else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	eval "$as_ac_var=no"
+  ac_cv_lib_pthreadGC2_pthread_join=no
 fi
-
-rm -rf conftest.dSYM
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
 fi
-ac_res=`eval 'as_val=${'$as_ac_var'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-as_val=`eval 'as_val=${'$as_ac_var'}
-		 $as_echo "$as_val"'`
-   if test "x$as_val" = x""yes; then
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
-_ACEOF
-
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_pthreadGC2_pthread_join" >&5
+$as_echo "$ac_cv_lib_pthreadGC2_pthread_join" >&6; }
+if test "x$ac_cv_lib_pthreadGC2_pthread_join" = xyes; then :
+  pthread_ok=yes
+else
+  pthread_ok=no
 fi
-done
 
-
-for ac_func in mmap
-do
-as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
-{ $as_echo "$as_me:$LINENO: checking for $ac_func" >&5
-$as_echo_n "checking for $ac_func... " >&6; }
-if { as_var=$as_ac_var; eval "test \"\${$as_var+set}\" = set"; }; then
+    if test $pthread_ok = yes ; then
+      LIBS="$LIBS -lpthreadGC2"
+    fi
+  fi
+  # Android and QNX have pthread in libc instead of libpthread
+  if test $checkinlibc = yes ; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for pthread_join in -lc" >&5
+$as_echo_n "checking for pthread_join in -lc... " >&6; }
+if ${ac_cv_lib_c_pthread_join+:} false; then :
   $as_echo_n "(cached) " >&6
 else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lc  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
-/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.
-   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
-#define $ac_func innocuous_$ac_func
-
-/* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char $ac_func (); below.
-    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-    <limits.h> exists even on freestanding compilers.  */
-
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
-
-#undef $ac_func
 
 /* Override any GCC internal prototype to avoid an error.
    Use char because int might match the return type of a GCC
@@ -18887,100 +7072,52 @@ cat >>conftest.$ac_ext <<_ACEOF
 #ifdef __cplusplus
 extern "C"
 #endif
-char $ac_func ();
-/* The GNU C library defines this for functions which it implements
-    to always fail with ENOSYS.  Some functions are actually named
-    something starting with __ and the normal name is an alias.  */
-#if defined __stub_$ac_func || defined __stub___$ac_func
-choke me
-#endif
-
+char pthread_join ();
 int
 main ()
 {
-return $ac_func ();
+return pthread_join ();
   ;
   return 0;
 }
 _ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then
-  eval "$as_ac_var=yes"
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_c_pthread_join=yes
 else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	eval "$as_ac_var=no"
+  ac_cv_lib_c_pthread_join=no
 fi
-
-rm -rf conftest.dSYM
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_c_pthread_join" >&5
+$as_echo "$ac_cv_lib_c_pthread_join" >&6; }
+if test "x$ac_cv_lib_c_pthread_join" = xyes; then :
+  pthread_ok=yes
+else
+  pthread_ok=no
 fi
-ac_res=`eval 'as_val=${'$as_ac_var'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-as_val=`eval 'as_val=${'$as_ac_var'}
-		 $as_echo "$as_val"'`
-   if test "x$as_val" = x""yes; then
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
-_ACEOF
 
+    if test $pthread_ok = yes ; then
+       LIBS="$LIBS -lc"
+    fi
+  fi
+fi
+if test $pthread_ok = no ; then
+  as_fn_error $? "Unable to find pthread library (needed for thread support)." "$LINENO" 5
 fi
-done
 
 
-for ac_func in mprotect
-do
-as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
-{ $as_echo "$as_me:$LINENO: checking for $ac_func" >&5
-$as_echo_n "checking for $ac_func... " >&6; }
-if { as_var=$as_ac_var; eval "test \"\${$as_var+set}\" = set"; }; then
+# Typically need librt on Solaris for sched_yield
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for sched_yield in -lrt" >&5
+$as_echo_n "checking for sched_yield in -lrt... " >&6; }
+if ${ac_cv_lib_rt_sched_yield+:} false; then :
   $as_echo_n "(cached) " >&6
 else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lrt  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
-/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.
-   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
-#define $ac_func innocuous_$ac_func
-
-/* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char $ac_func (); below.
-    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-    <limits.h> exists even on freestanding compilers.  */
-
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
-
-#undef $ac_func
 
 /* Override any GCC internal prototype to avoid an error.
    Use char because int might match the return type of a GCC
@@ -18988,950 +7125,884 @@ cat >>conftest.$ac_ext <<_ACEOF
 #ifdef __cplusplus
 extern "C"
 #endif
-char $ac_func ();
-/* The GNU C library defines this for functions which it implements
-    to always fail with ENOSYS.  Some functions are actually named
-    something starting with __ and the normal name is an alias.  */
-#if defined __stub_$ac_func || defined __stub___$ac_func
-choke me
-#endif
-
+char sched_yield ();
 int
 main ()
 {
-return $ac_func ();
+return sched_yield ();
   ;
   return 0;
 }
 _ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then
-  eval "$as_ac_var=yes"
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_rt_sched_yield=yes
 else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
+  ac_cv_lib_rt_sched_yield=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_rt_sched_yield" >&5
+$as_echo "$ac_cv_lib_rt_sched_yield" >&6; }
+if test "x$ac_cv_lib_rt_sched_yield" = xyes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_LIBRT 1
+_ACEOF
+
+  LIBS="-lrt $LIBS"
+
+fi
+
+
+
+#--------------------------------------------------------------------
+# One of these function needed by NSThread.m and objc initialize test
+#--------------------------------------------------------------------
+for ac_func in nanosleep usleep Sleep
+do :
+  as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
+ac_fn_c_check_func "$LINENO" "$ac_func" "$as_ac_var"
+if eval test \"x\$"$as_ac_var"\" = x"yes"; then :
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+done
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for objc_root_class attribute support" >&5
+$as_echo_n "checking for objc_root_class attribute support... " >&6; }
+saved_CFLAGS="$CFLAGS"
+CFLAGS="$CFLAGS -Werror $OBJCFLAGS -x objective-c"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+  __attribute__((objc_root_class)) @interface RootObject
+  @end
+  @implementation RootObject
+  @end
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: found" >&5
+$as_echo "found" >&6; }
+  gs_objc_root_class_attr=1
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: not present" >&5
+$as_echo "not present" >&6; }
+  gs_objc_root_class_attr=0
+
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+
+GS_HAVE_OBJC_ROOT_CLASS_ATTR=$gs_objc_root_class_attr
 
-	eval "$as_ac_var=no"
-fi
 
-rm -rf conftest.dSYM
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
-fi
-ac_res=`eval 'as_val=${'$as_ac_var'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-as_val=`eval 'as_val=${'$as_ac_var'}
-		 $as_echo "$as_val"'`
-   if test "x$as_val" = x""yes; then
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
+cat >>confdefs.h <<_ACEOF
+#define HAVE_OBJC_ROOT_CLASS_ATTRIBUTE $gs_objc_root_class_attr
 _ACEOF
 
-fi
-done
-
+CFLAGS=$saved_CFLAGS
 
-for ac_header in sys/mman.h
-do
-as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  { $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
-$as_echo_n "checking for $ac_header... " >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  $as_echo_n "(cached) " >&6
+#--------------------------------------------------------------------
+# Check whether Objective-C /really/ works
+#--------------------------------------------------------------------
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether objc really works" >&5
+$as_echo_n "checking whether objc really works... " >&6; }
+saved_LIBS="$LIBS"
+saved_CPPFLAGS="$CPPFLAGS"
+LIBS="$LIBS $LIBOBJC"
+CPPFLAGS="$CPPFLAGS $OBJCFLAGS -x objective-c"
+if test x"$objc_threaded" != x""; then
+  LIBS="$LIBS $objc_threaded"
 fi
-ac_res=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
+LIBS="$LIBS $extra_LIBS"
+if ${gs_cv_objc_works+:} false; then :
+  $as_echo_n "(cached) " >&6
 else
-  # Is the header compilable?
-{ $as_echo "$as_me:$LINENO: checking $ac_header usability" >&5
-$as_echo_n "checking $ac_header usability... " >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+  if test "$cross_compiling" = yes; then :
+  gs_cv_objc_works="$cross_gs_cv_objc_works"
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
-$ac_includes_default
-#include <$ac_header>
+#include "$srcdir/config/config.objc.m"
 _ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_header_compiler=yes
+if ac_fn_c_try_run "$LINENO"; then :
+  gs_cv_objc_works=yes
 else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_header_compiler=no
+  gs_cv_objc_works=no
+fi
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
+  conftest.$ac_objext conftest.beam conftest.$ac_ext
 fi
 
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-{ $as_echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
-$as_echo "$ac_header_compiler" >&6; }
-
-# Is the header present?
-{ $as_echo "$as_me:$LINENO: checking $ac_header presence" >&5
-$as_echo_n "checking $ac_header presence... " >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <$ac_header>
-_ACEOF
-if { (ac_try="$ac_cpp conftest.$ac_ext"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } >/dev/null && {
-	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       }; then
-  ac_header_preproc=yes
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
 
-  ac_header_preproc=no
 fi
 
-rm -f conftest.err conftest.$ac_ext
-{ $as_echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
-$as_echo "$ac_header_preproc" >&6; }
+if test $gs_cv_objc_works = yes; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+  echo "I don't seem to be able to use your Objective-C compiler to produce"
+  echo "working binaries!  Please check your Objective-C compiler installation."
+  echo "If you are using gcc-3.x make sure that your compiler's libgcc_s and libobjc"
+  echo "can be found by the dynamic linker - usually that requires you to play"
+  echo "with LD_LIBRARY_PATH or /etc/ld.so.conf."
+  echo "Please refer to your compiler installation instructions for more help."
+  as_fn_error $? "The Objective-C compiler does not work or is not installed properly." "$LINENO" 5
+fi
 
-# So?  What about this header?
-case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
-  yes:no: )
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
-$as_echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the compiler's result" >&5
-$as_echo "$as_me: WARNING: $ac_header: proceeding with the compiler's result" >&2;}
-    ac_header_preproc=yes
-    ;;
-  no:yes:* )
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
-$as_echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header:     check for missing prerequisite headers?" >&5
-$as_echo "$as_me: WARNING: $ac_header:     check for missing prerequisite headers?" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: see the Autoconf documentation" >&5
-$as_echo "$as_me: WARNING: $ac_header: see the Autoconf documentation" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&5
-$as_echo "$as_me: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
-$as_echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: in the future, the compiler will take precedence" >&5
-$as_echo "$as_me: WARNING: $ac_header: in the future, the compiler will take precedence" >&2;}
+# Don't revert any Objective-C flags as they are used in the next test
 
-    ;;
+#---------------------------------------------------------------------
+# See if we are using a compiler which allows us to change the class
+# to be used for constant strings by using the -fconstant-string-class
+# option.  If that is the case, we change it to NSConstantString.
+# Unless we are building for the apple runtime (ie only building base
+# additions library and not implementing a constant string class).
+#---------------------------------------------------------------------
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking if the compiler generates constant CFStrings" >&5
+$as_echo_n "checking if the compiler generates constant CFStrings... " >&6; }
+case "$target_os" in
+    darwin*)    IS_DARWIN="yes";;
+    *)          IS_DARWIN="no";;
 esac
-{ $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
-$as_echo_n "checking for $ac_header... " >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $IS_DARWIN" >&5
+$as_echo "$IS_DARWIN" >&6; }
+
+if test "$IS_DARWIN" = "yes"; then
+  NX_CONST_STRING_OBJCFLAGS=""
+  NX_CONST_STRING_CLASS=NSCFConstantString
+else
+  strclass_CPPFLAGS="$CPPFLAGS"
+  CPPFLAGS="$CPPFLAGS -fconstant-string-class=FooConstantString"
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if the compiler supports -fconstant-string-class" >&5
+$as_echo_n "checking if the compiler supports -fconstant-string-class... " >&6; }
+  if ${gs_cv_objc_compiler_supports_constant_string_class+:} false; then :
   $as_echo_n "(cached) " >&6
 else
-  eval "$as_ac_Header=\$ac_header_preproc"
+  if test "$cross_compiling" = yes; then :
+  gs_cv_objc_compiler_supports_constant_string_class="$cross_gs_cv_objc_compiler_supports_constant_string_class"
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include "$srcdir/config/config.constant-string-class.m"
+_ACEOF
+if ac_fn_c_try_run "$LINENO"; then :
+  gs_cv_objc_compiler_supports_constant_string_class=yes
+else
+  gs_cv_objc_compiler_supports_constant_string_class=no
 fi
-ac_res=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
+  conftest.$ac_objext conftest.beam conftest.$ac_ext
 fi
-as_val=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-   if test "x$as_val" = x""yes; then
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
-_ACEOF
+
 
 fi
 
-done
+  if test $gs_cv_objc_compiler_supports_constant_string_class = yes; then
+    NX_CONST_STRING_OBJCFLAGS="-fconstant-string-class=NSConstantString"
+    NX_CONST_STRING_CLASS=NSConstantString
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+  else
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+    # Check whether --enable-nxconstantstring was given.
+if test "${enable_nxconstantstring+set}" = set; then :
+  enableval=$enable_nxconstantstring;
+else
+  enable_nxconstantstring=no
+fi
 
+    if test $enable_nxconstantstring = yes; then
+      NX_CONST_STRING_OBJCFLAGS=""
+      NX_CONST_STRING_CLASS=NXConstantString
+      { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: You have enabled the use of NXConstantString as the string class in gnustep-base.  The objective-c runtime library typically implements its own class of the same name, so you must either enforce a link order which ensures that the gnustep-base implementation is used, or (better) you must remove the class from the runtime library!" >&5
+$as_echo "$as_me: WARNING: You have enabled the use of NXConstantString as the string class in gnustep-base.  The objective-c runtime library typically implements its own class of the same name, so you must either enforce a link order which ensures that the gnustep-base implementation is used, or (better) you must remove the class from the runtime library!" >&2;}
+    else
+      as_fn_error $? "Your compiler does not appear to implement the -fconstant-string-class option needed for support of strings.  Please check for a more recent version or consider using --enable-nxconstantstring" "$LINENO" 5
+    fi
+  fi
+  CPPFLAGS="$strclass_CPPFLAGS"
+fi
 
-#--------------------------------------------------------------------
-# These functions needed by NSTask.m
-#--------------------------------------------------------------------
 
 
 
+# Don't revert any Objective-C flags as they are used in the next test
 
-for ac_func in killpg setpgrp setpgid setsid
-do
-as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
-{ $as_echo "$as_me:$LINENO: checking for $ac_func" >&5
-$as_echo_n "checking for $ac_func... " >&6; }
-if { as_var=$as_ac_var; eval "test \"\${$as_var+set}\" = set"; }; then
+#---------------------------------------------------------------------
+# Guess if we are using a compiler which has the (GNU extension) +load
+# method which is executed before main.
+# Defines HAVE_LOAD_METHOD if +load methods are called before main.
+# Needed by NSProcessInfo.m
+#---------------------------------------------------------------------
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking if +load method is executed before main" >&5
+$as_echo_n "checking if +load method is executed before main... " >&6; }
+if ${gs_cv_objc_load_method_worked+:} false; then :
   $as_echo_n "(cached) " >&6
 else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+  if test "$cross_compiling" = yes; then :
+  gs_cv_objc_load_method_worked="$cross_gs_cv_objc_load_method_worked"
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
-/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.
-   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
-#define $ac_func innocuous_$ac_func
+#include "$srcdir/config/config.loadtest.m"
+_ACEOF
+if ac_fn_c_try_run "$LINENO"; then :
+  gs_cv_objc_load_method_worked=yes
+else
+  gs_cv_objc_load_method_worked=no
+fi
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
+  conftest.$ac_objext conftest.beam conftest.$ac_ext
+fi
 
-/* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char $ac_func (); below.
-    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-    <limits.h> exists even on freestanding compilers.  */
 
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
+fi
 
-#undef $ac_func
+if test $gs_cv_objc_load_method_worked = yes; then
 
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char $ac_func ();
-/* The GNU C library defines this for functions which it implements
-    to always fail with ENOSYS.  Some functions are actually named
-    something starting with __ and the normal name is an alias.  */
-#if defined __stub_$ac_func || defined __stub___$ac_func
-choke me
-#endif
+$as_echo "#define HAVE_LOAD_METHOD 1" >>confdefs.h
 
-int
-main ()
-{
-return $ac_func ();
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then
-  eval "$as_ac_var=yes"
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
 else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	eval "$as_ac_var=no"
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
 fi
 
-rm -rf conftest.dSYM
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
-fi
-ac_res=`eval 'as_val=${'$as_ac_var'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-as_val=`eval 'as_val=${'$as_ac_var'}
-		 $as_echo "$as_val"'`
-   if test "x$as_val" = x""yes; then
+# Don't revert any Objective-C flags as they are used in the next test
+
+#--------------------------------------------------------------------
+# Check for thread synchronisation support in runtime
+#--------------------------------------------------------------------
+for ac_func in objc_sync_enter
+do :
+  ac_fn_c_check_func "$LINENO" "objc_sync_enter" "ac_cv_func_objc_sync_enter"
+if test "x$ac_cv_func_objc_sync_enter" = xyes; then :
   cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
+#define HAVE_OBJC_SYNC_ENTER 1
 _ACEOF
 
 fi
 done
 
-if test "x$ac_cv_func_setpgrp" = xyes; then
-  { $as_echo "$as_me:$LINENO: checking whether setpgrp takes no argument" >&5
-$as_echo_n "checking whether setpgrp takes no argument... " >&6; }
-if test "${ac_cv_func_setpgrp_void+set}" = set; then
-  $as_echo_n "(cached) " >&6
-else
-  if test "$cross_compiling" = yes; then
-  { { $as_echo "$as_me:$LINENO: error: cannot check setpgrp when cross compiling" >&5
-$as_echo "$as_me: error: cannot check setpgrp when cross compiling" >&2;}
-   { (exit 1); exit 1; }; }
+if test $ac_cv_func_objc_sync_enter = yes ; then
+  OBJCSYNC=1
 else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-int
-main ()
-{
-/* If this system has a BSD-style setpgrp which takes arguments,
-  setpgrp(1, 1) will fail with ESRCH and return -1, in that case
-  exit successfully. */
-  return setpgrp (1,1) != -1;
-  ;
-  return 0;
-}
+  OBJCSYNC=0
+fi
+
+
+# Don't revert any Objective-C flags as they are used in the next test
+
+#--------------------------------------------------------------------
+# Check for ObjC2 support in runtime
+#--------------------------------------------------------------------
+for ac_func in objc_setProperty
+do :
+  ac_fn_c_check_func "$LINENO" "objc_setProperty" "ac_cv_func_objc_setProperty"
+if test "x$ac_cv_func_objc_setProperty" = xyes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_OBJC_SETPROPERTY 1
 _ACEOF
-rm -f conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_cv_func_setpgrp_void=no
-else
-  $as_echo "$as_me: program exited with status $ac_status" >&5
-$as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
 
-( exit $ac_status )
-ac_cv_func_setpgrp_void=yes
-fi
-rm -rf conftest.dSYM
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
 fi
+done
 
-
+if test $ac_cv_func_objc_setProperty = yes ; then
+  OBJC2RUNTIME=1
+else
+  OBJC2RUNTIME=0
 fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_func_setpgrp_void" >&5
-$as_echo "$ac_cv_func_setpgrp_void" >&6; }
-if test $ac_cv_func_setpgrp_void = yes; then
 
-cat >>confdefs.h <<\_ACEOF
-#define SETPGRP_VOID 1
+
+#--------------------------------------------------------------------
+# Check for blocks support in runtime
+#--------------------------------------------------------------------
+for ac_func in _Block_copy
+do :
+  ac_fn_c_check_func "$LINENO" "_Block_copy" "ac_cv_func__Block_copy"
+if test "x$ac_cv_func__Block_copy" = xyes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE__BLOCK_COPY 1
 _ACEOF
 
 fi
+done
 
+if test $ac_cv_func__Block_copy = yes ; then
+  HAVE_BLOCKS=1
+else
+  HAVE_BLOCKS=0
 fi
 
-HAVE_PTS_STREAM_MODULES=0
-case "${target}" in
-  *-sysv-*)
-    HAVE_PTS_STREAM_MODULES=1
-    ;;
-esac
 
-cat >>confdefs.h <<_ACEOF
-#define HAVE_PTS_STREAM_MODULES $HAVE_PTS_STREAM_MODULES
+# Don't revert any Objective-C flags as they are used in the next test
+
+GS_NONFRAGILE=0
+GS_MIXEDABI=0
+if test "$nonfragile" = "yes"; then
+  saved_CPPFLAGS="$CPPFLAGS"
+  CPPFLAGS="$CPPFLAGS $OBJCFLAGS -fobjc-nonfragile-abi -x objective-c"
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for non-fragile-abi support" >&5
+$as_echo_n "checking for non-fragile-abi support... " >&6; }
+  if test "$cross_compiling" = yes; then :
+  non_fragile="$cross_non_fragile"
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include "$srcdir/config/config.non-fragile-ivars.m"
 _ACEOF
+if ac_fn_c_try_run "$LINENO"; then :
+  non_fragile=yes
+else
+  non_fragile=no
+fi
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
+  conftest.$ac_objext conftest.beam conftest.$ac_ext
+fi
 
+  CPPFLAGS="$saved_CPPFLAGS"
+  if test $non_fragile = yes; then
+    OBJCFLAGS="$OBJCFLAGS -fobjc-nonfragile-abi"
+    GS_NONFRAGILE=1
+    # Check whether --enable-mixedabi was given.
+if test "${enable_mixedabi+set}" = set; then :
+  enableval=$enable_mixedabi;
+else
+  enable_mixedabi=yes
+fi
 
+    if test $enable_mixedabi = yes; then
+      GS_MIXEDABI=1
+    fi
+  fi
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $non_fragile" >&5
+$as_echo "$non_fragile" >&6; }
+fi
 
 
 
 
+# Don't revert any Objective-C flags as they are used in the next test
 
+#--------------------------------------------------------------------
+# get_uninstalled_dtable used by behavior.m and objc-load.m
+#--------------------------------------------------------------------
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <objc/objc-api.h>
 
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "objc_get_uninstalled_dtable" >/dev/null 2>&1; then :
 
+$as_echo "#define HAVE_OBJC_GET_UNINSTALLED_DTABLE 1" >>confdefs.h
 
+fi
+rm -f conftest*
 
 
+# Don't revert any Objective-C flags as they are used in the next test
 
 
+#--------------------------------------------------------------------
+# Native Objective-C exceptions
+#--------------------------------------------------------------------
 
+# First of all, determine if native Objective-C exceptions are enabled
+# in gnustep-make.  They are enabled if the compiler supports it; they
+# are disabled if it doesn't.  And, of course, the user may have
+# forced one behaviour or the other.  Note that we go and look at the
+# actual config.make file to be able to know what was configured in
+# gnustep-make regardless of any gnustep-base that is currently
+# installed.  We can't use `gnustep-config --objc-flags` because that
+# may report native exceptions as disabled because the currently
+# installed gnustep-base has them disabled.
+if grep USE_OBJC_EXCEPTIONS $CURRENT_GNUSTEP_MAKEFILES/$lobj_dir/config.make | grep yes >&5 2>&5; then
+  exceptions=yes
+else
+  exceptions=no
+fi
 
+# At this point, if exceptions=no, then native exceptions are disabled
+# and won't be used.  If exceptions=yes, we need to check if they work
+# and if the runtime has proper support for them.  If it does, we'll
+# happily use them; if it doesn't, we'll automatically disable them
+# because they don't work. ;-)
 
+#--------------------------------------------------------------------
+# One of these is needed by for handling uncaught exceptions
+#--------------------------------------------------------------------
 
+# TODO: These checks are not really needed if native exceptions are
+# disabled.  So maybe we should not run them at all in that case.  On
+# the other hand, that case is going to become more and more unusual.
 
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for objc_setUncaughtExceptionHandler() in runtime" >&5
+$as_echo_n "checking for objc_setUncaughtExceptionHandler() in runtime... " >&6; }
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include "$srcdir/config/config.setUncaughtExceptionHandler.m"
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  have_set_uncaught_exception_handler=yes
+else
+  have_set_uncaught_exception_handler=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+if test $have_set_uncaught_exception_handler = yes; then
 
+$as_echo "#define HAVE_SET_UNCAUGHT_EXCEPTION_HANDLER 1" >>confdefs.h
 
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $have_set_uncaught_exception_handler" >&5
+$as_echo "$have_set_uncaught_exception_handler" >&6; }
 
+# Don't revert any Objective-C flags as they are used in the next test
 
-for ac_header in 	fcntl.h 	inttypes.h 	libc.h 	limits.h 	malloc.h 	memory.h 	signal.h 	stdint.h 	string.h 	sys/fcntl.h 	sys/file.h 	sys/filio.h 	sys/inttypes.h 	sys/ioctl.h 	sys/signal.h 	sys/stropts.h 	sys/wait.h 	unistd.h 	utime.h         stdlib.h
-do
-as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  { $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
-$as_echo_n "checking for $ac_header... " >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  $as_echo_n "(cached) " >&6
-fi
-ac_res=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-else
-  # Is the header compilable?
-{ $as_echo "$as_me:$LINENO: checking $ac_header usability" >&5
-$as_echo_n "checking $ac_header usability... " >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for objc_set_unexpected() in runtime" >&5
+$as_echo_n "checking for objc_set_unexpected() in runtime... " >&6; }
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
-$ac_includes_default
-#include <$ac_header>
+#include "$srcdir/config/config.set_unexpected.m"
 _ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_header_compiler=yes
+if ac_fn_c_try_link "$LINENO"; then :
+  have_set_unexpected=yes
 else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
+  have_set_unexpected=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+if test $have_set_unexpected = yes; then
+
+$as_echo "#define HAVE_SET_UNEXPECTED 1" >>confdefs.h
 
-	ac_header_compiler=no
 fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $have_set_unexpected" >&5
+$as_echo "$have_set_unexpected" >&6; }
 
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-{ $as_echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
-$as_echo "$ac_header_compiler" >&6; }
+# Don't revert any Objective-C flags as they are used in the next test
 
-# Is the header present?
-{ $as_echo "$as_me:$LINENO: checking $ac_header presence" >&5
-$as_echo_n "checking $ac_header presence... " >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for _objc_unexpected_exception in runtime" >&5
+$as_echo_n "checking for _objc_unexpected_exception in runtime... " >&6; }
+if test "$cross_compiling" = yes; then :
+  have_unexpected="$cross_have_unexpected"
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
-#include <$ac_header>
+#include "$srcdir/config/config.unexpected.m"
 _ACEOF
-if { (ac_try="$ac_cpp conftest.$ac_ext"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } >/dev/null && {
-	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       }; then
-  ac_header_preproc=yes
+if ac_fn_c_try_run "$LINENO"; then :
+  have_unexpected=yes
 else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
+  have_unexpected=no
+fi
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
+  conftest.$ac_objext conftest.beam conftest.$ac_ext
+fi
+
+if test $have_unexpected = yes; then
+
+$as_echo "#define HAVE_UNEXPECTED 1" >>confdefs.h
 
-  ac_header_preproc=no
 fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $have_unexpected" >&5
+$as_echo "$have_unexpected" >&6; }
 
-rm -f conftest.err conftest.$ac_ext
-{ $as_echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
-$as_echo "$ac_header_preproc" >&6; }
+# TODO: It would also be nice to actually test that native Objective-C
+# exceptions work.
 
-# So?  What about this header?
-case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
-  yes:no: )
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
-$as_echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the compiler's result" >&5
-$as_echo "$as_me: WARNING: $ac_header: proceeding with the compiler's result" >&2;}
-    ac_header_preproc=yes
-    ;;
-  no:yes:* )
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
-$as_echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header:     check for missing prerequisite headers?" >&5
-$as_echo "$as_me: WARNING: $ac_header:     check for missing prerequisite headers?" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: see the Autoconf documentation" >&5
-$as_echo "$as_me: WARNING: $ac_header: see the Autoconf documentation" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&5
-$as_echo "$as_me: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
-$as_echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: in the future, the compiler will take precedence" >&5
-$as_echo "$as_me: WARNING: $ac_header: in the future, the compiler will take precedence" >&2;}
+if test "$exceptions" = "yes"; then
+  if test x"$have_set_uncaught_exception_handler" = x"no"; then
+    if test x"$have_set_unexpected" = x"no"; then
+      if test x"$have_unexpected" = x"no"; then
+        { $as_echo "$as_me:${as_lineno-$LINENO}: Disabling native Objective-C exceptions because the ObjC runtime" >&5
+$as_echo "$as_me: Disabling native Objective-C exceptions because the ObjC runtime" >&6;}
+        { $as_echo "$as_me:${as_lineno-$LINENO}: has no way to set an uncaught exception handler.  Please install" >&5
+$as_echo "$as_me: has no way to set an uncaught exception handler.  Please install" >&6;}
+        { $as_echo "$as_me:${as_lineno-$LINENO}: a recent Objective-C runtime if you want to use them." >&5
+$as_echo "$as_me: a recent Objective-C runtime if you want to use them." >&6;}
+        exceptions="no";
+      fi
+    fi
+  fi
+fi
 
-    ;;
-esac
-{ $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
-$as_echo_n "checking for $ac_header... " >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  $as_echo_n "(cached) " >&6
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether to enable native Objective-C exceptions" >&5
+$as_echo_n "checking whether to enable native Objective-C exceptions... " >&6; }
+if test "$exceptions" = "yes"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+  BASE_NATIVE_OBJC_EXCEPTIONS=1
 else
-  eval "$as_ac_Header=\$ac_header_preproc"
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+  BASE_NATIVE_OBJC_EXCEPTIONS=0
 fi
-ac_res=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
 
-fi
-as_val=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-   if test "x$as_val" = x""yes; then
+
+# Don't revert any Objective-C flags as they are used in the next test
+
+#--------------------------------------------------------------------
+# Function needed by @synchronize directive
+#--------------------------------------------------------------------
+for ac_func in objc_sync_enter
+do :
+  ac_fn_c_check_func "$LINENO" "objc_sync_enter" "ac_cv_func_objc_sync_enter"
+if test "x$ac_cv_func_objc_sync_enter" = xyes; then :
   cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
+#define HAVE_OBJC_SYNC_ENTER 1
 _ACEOF
 
 fi
-
 done
 
 
-if test $ac_cv_header_stdint_h = yes; then
-INCLUDE_STDINT="#include <stdint.h>"
-elif test $ac_cv_header_inttypes_h = yes; then
-INCLUDE_STDINT="#include <inttypes.h>"
-elif test $ac_cv_header_sys_inttypes_h = yes; then
-INCLUDE_STDINT="#include <sys/inttypes.h>"
+HAVE_OBJC_SYNC_ENTER=no
+if test $ac_cv_func_objc_sync_enter = yes ; then
+  HAVE_OBJC_SYNC_ENTER=yes
+fi
+
+
+# Don't revert any Objective-C flags as they are used in the next test
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for thread-safe +initialize in runtime" >&5
+$as_echo_n "checking for thread-safe +initialize in runtime... " >&6; }
+if test "$cross_compiling" = yes; then :
+  safe_initialize="$cross_safe_initialize"
 else
-INCLUDE_STDINT="no"
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include "$srcdir/config/config.initialize.m"
+_ACEOF
+if ac_fn_c_try_run "$LINENO"; then :
+  safe_initialize=yes
+else
+  safe_initialize=no
+fi
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
+  conftest.$ac_objext conftest.beam conftest.$ac_ext
 fi
 
-if test "$INCLUDE_STDINT" = "no"; then
-INCLUDE_STDINT=""
-DEFINE_INT8_T="#define int8_t gss8"
-DEFINE_UINT8_T="#define uint8_t gsu8"
-DEFINE_INT16_T="#define int16_t gss16"
-DEFINE_UINT16_T="#define uint16_t gsu16"
-DEFINE_INT32_T="#define int32_t gss32"
-DEFINE_UINT32_T="#define uint32_t gsu32"
-DEFINE_INT64_T="#define int64_t gss64"
-DEFINE_UINT64_T="#define uint64_t gsu64"
-DEFINE_INTPTR_T="#define intptr_t gssaddr"
-DEFINE_UINTPTR_T="#define uintptr_t gsuaddr"
+if test $safe_initialize = yes; then
+
+$as_echo "#define HAVE_INITIALIZE 1" >>confdefs.h
+
 else
-DEFINE_INT8_T=""
-DEFINE_UINT8_T=""
-DEFINE_INT16_T=""
-DEFINE_UINT16_T=""
-DEFINE_INT32_T=""
-DEFINE_UINT32_T=""
-DEFINE_INT64_T=""
-DEFINE_UINT64_T=""
-DEFINE_INTPTR_T=""
-DEFINE_UINTPTR_T=""
+  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: Your ObjectiveC runtime does not support thread-safe class initialisation.  Please use a different runtime if you intend to use threads." >&5
+$as_echo "$as_me: WARNING: Your ObjectiveC runtime does not support thread-safe class initialisation.  Please use a different runtime if you intend to use threads." >&2;}
 fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $safe_initialize" >&5
+$as_echo "$safe_initialize" >&6; }
 
+LIBS="$saved_LIBS"
+CPPFLAGS="$saved_CPPFLAGS"
 
 
 
+#--------------------------------------------------------------------
+# Generic settings needed by NSZone.m
+#--------------------------------------------------------------------
+ac_fn_c_check_type "$LINENO" "size_t" "ac_cv_type_size_t" "$ac_includes_default"
+if test "x$ac_cv_type_size_t" = xyes; then :
 
+else
 
+cat >>confdefs.h <<_ACEOF
+#define size_t unsigned int
+_ACEOF
 
+fi
 
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for inline" >&5
+$as_echo_n "checking for inline... " >&6; }
+if ${ac_cv_c_inline+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_cv_c_inline=no
+for ac_kw in inline __inline__ __inline; do
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#ifndef __cplusplus
+typedef int foo_t;
+static $ac_kw foo_t static_foo () {return 0; }
+$ac_kw foo_t foo () {return 0; }
+#endif
 
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_cv_c_inline=$ac_kw
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+  test "$ac_cv_c_inline" != no && break
+done
 
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_c_inline" >&5
+$as_echo "$ac_cv_c_inline" >&6; }
 
+case $ac_cv_c_inline in
+  inline | yes) ;;
+  *)
+    case $ac_cv_c_inline in
+      no) ac_val=;;
+      *) ac_val=$ac_cv_c_inline;;
+    esac
+    cat >>confdefs.h <<_ACEOF
+#ifndef __cplusplus
+#define inline $ac_val
+#endif
+_ACEOF
+    ;;
+esac
 
 
 #--------------------------------------------------------------------
-# These used by GSFileHandle.m and distributed objects
-# On some systems we need -lnsl ... so check for that first.
+# Following header checks needed for bzero in Storage.m and other places
 #--------------------------------------------------------------------
-
-{ $as_echo "$as_me:$LINENO: checking for inet_ntop in -lnsl" >&5
-$as_echo_n "checking for inet_ntop in -lnsl... " >&6; }
-if test "${ac_cv_lib_nsl_inet_ntop+set}" = set; then
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for ANSI C header files" >&5
+$as_echo_n "checking for ANSI C header files... " >&6; }
+if ${ac_cv_header_stdc+:} false; then :
   $as_echo_n "(cached) " >&6
 else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-lnsl  $LIBS"
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
+#include <stdlib.h>
+#include <stdarg.h>
+#include <string.h>
+#include <float.h>
 
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char inet_ntop ();
 int
 main ()
 {
-return inet_ntop ();
+
   ;
   return 0;
 }
 _ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then
-  ac_cv_lib_nsl_inet_ntop=yes
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_cv_header_stdc=yes
 else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_cv_lib_nsl_inet_ntop=no
+  ac_cv_header_stdc=no
 fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
 
-rm -rf conftest.dSYM
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_lib_nsl_inet_ntop" >&5
-$as_echo "$ac_cv_lib_nsl_inet_ntop" >&6; }
-if test "x$ac_cv_lib_nsl_inet_ntop" = x""yes; then
-  cat >>confdefs.h <<_ACEOF
-#define HAVE_LIBNSL 1
-_ACEOF
+if test $ac_cv_header_stdc = yes; then
+  # SunOS 4.x string.h does not declare mem*, contrary to ANSI.
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <string.h>
 
-  LIBS="-lnsl $LIBS"
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "memchr" >/dev/null 2>&1; then :
 
+else
+  ac_cv_header_stdc=no
 fi
+rm -f conftest*
 
+fi
 
+if test $ac_cv_header_stdc = yes; then
+  # ISC 2.0.2 stdlib.h does not declare free, contrary to ANSI.
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <stdlib.h>
 
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "free" >/dev/null 2>&1; then :
 
+else
+  ac_cv_header_stdc=no
+fi
+rm -f conftest*
 
+fi
 
-for ac_func in gethostbyaddr_r inet_aton inet_pton inet_ntop sigaction
-do
-as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
-{ $as_echo "$as_me:$LINENO: checking for $ac_func" >&5
-$as_echo_n "checking for $ac_func... " >&6; }
-if { as_var=$as_ac_var; eval "test \"\${$as_var+set}\" = set"; }; then
-  $as_echo_n "(cached) " >&6
+if test $ac_cv_header_stdc = yes; then
+  # /bin/cc in Irix-4.0.5 gets non-ANSI ctype macros unless using -ansi.
+  if test "$cross_compiling" = yes; then :
+  :
 else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
-/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.
-   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
-#define $ac_func innocuous_$ac_func
-
-/* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char $ac_func (); below.
-    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-    <limits.h> exists even on freestanding compilers.  */
-
-#ifdef __STDC__
-# include <limits.h>
+#include <ctype.h>
+#include <stdlib.h>
+#if ((' ' & 0x0FF) == 0x020)
+# define ISLOWER(c) ('a' <= (c) && (c) <= 'z')
+# define TOUPPER(c) (ISLOWER(c) ? 'A' + ((c) - 'a') : (c))
 #else
-# include <assert.h>
-#endif
-
-#undef $ac_func
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char $ac_func ();
-/* The GNU C library defines this for functions which it implements
-    to always fail with ENOSYS.  Some functions are actually named
-    something starting with __ and the normal name is an alias.  */
-#if defined __stub_$ac_func || defined __stub___$ac_func
-choke me
+# define ISLOWER(c) \
+		   (('a' <= (c) && (c) <= 'i') \
+		     || ('j' <= (c) && (c) <= 'r') \
+		     || ('s' <= (c) && (c) <= 'z'))
+# define TOUPPER(c) (ISLOWER(c) ? ((c) | 0x40) : (c))
 #endif
 
+#define XOR(e, f) (((e) && !(f)) || (!(e) && (f)))
 int
 main ()
 {
-return $ac_func ();
-  ;
+  int i;
+  for (i = 0; i < 256; i++)
+    if (XOR (islower (i), ISLOWER (i))
+	|| toupper (i) != TOUPPER (i))
+      return 2;
   return 0;
 }
 _ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then
-  eval "$as_ac_var=yes"
+if ac_fn_c_try_run "$LINENO"; then :
+
 else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
+  ac_cv_header_stdc=no
+fi
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
+  conftest.$ac_objext conftest.beam conftest.$ac_ext
+fi
 
-	eval "$as_ac_var=no"
 fi
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_header_stdc" >&5
+$as_echo "$ac_cv_header_stdc" >&6; }
+if test $ac_cv_header_stdc = yes; then
+
+$as_echo "#define STDC_HEADERS 1" >>confdefs.h
 
-rm -rf conftest.dSYM
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
 fi
-ac_res=`eval 'as_val=${'$as_ac_var'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-as_val=`eval 'as_val=${'$as_ac_var'}
-		 $as_echo "$as_val"'`
-   if test "x$as_val" = x""yes; then
+
+for ac_header in string.h memory.h alloca.h
+do :
+  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
+ac_fn_c_check_header_mongrel "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default"
+if eval test \"x\$"$as_ac_Header"\" = x"yes"; then :
   cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
+#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
 _ACEOF
 
 fi
+
 done
 
-USE_ZLIB=0
 
-for ac_header in zlib.h
-do
-as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  { $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
-$as_echo_n "checking for $ac_header... " >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  $as_echo_n "(cached) " >&6
-fi
-ac_res=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-else
-  # Is the header compilable?
-{ $as_echo "$as_me:$LINENO: checking $ac_header usability" >&5
-$as_echo_n "checking $ac_header usability... " >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
+#--------------------------------------------------------------------
+# Following header check needed NSConnection.h
+#--------------------------------------------------------------------
+for ac_header in float.h
+do :
+  ac_fn_c_check_header_mongrel "$LINENO" "float.h" "ac_cv_header_float_h" "$ac_includes_default"
+if test "x$ac_cv_header_float_h" = xyes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_FLOAT_H 1
 _ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-#include <$ac_header>
+
+fi
+
+done
+
+
+#--------------------------------------------------------------------
+# Header files and functions for files and filesystems
+#--------------------------------------------------------------------
+for ac_header in sys/stat.h sys/vfs.h sys/statfs.h sys/statvfs.h pwd.h grp.h
+do :
+  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
+ac_fn_c_check_header_mongrel "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default"
+if eval test \"x\$"$as_ac_Header"\" = x"yes"; then :
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
 _ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_header_compiler=yes
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
 
-	ac_header_compiler=no
 fi
 
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-{ $as_echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
-$as_echo "$ac_header_compiler" >&6; }
+done
 
-# Is the header present?
-{ $as_echo "$as_me:$LINENO: checking $ac_header presence" >&5
-$as_echo_n "checking $ac_header presence... " >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
+for ac_header in sys/cdefs.h sys/syslimits.h sys/param.h
+do :
+  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
+ac_fn_c_check_header_mongrel "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default"
+if eval test \"x\$"$as_ac_Header"\" = x"yes"; then :
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
 _ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <$ac_header>
+
+fi
+
+done
+
+# Twisted header checks for some BSDs with stupid interdependencies
+for ac_header in sys/syslimits.h
+do :
+  ac_fn_c_check_header_compile "$LINENO" "sys/syslimits.h" "ac_cv_header_sys_syslimits_h" "#if HAVE_SYS_CDEFS_H
+   #include <sys/cdefs.h>
+   #endif
+   #include <sys/syslimits.h>
+
+"
+if test "x$ac_cv_header_sys_syslimits_h" = xyes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_SYS_SYSLIMITS_H 1
+_ACEOF
+
+fi
+
+done
+
+for ac_header in sys/param.h
+do :
+  ac_fn_c_check_header_compile "$LINENO" "sys/param.h" "ac_cv_header_sys_param_h" "#if HAVE_SYS_CDEFS_H
+   #include <sys/cdefs.h>
+   #endif
+   #if HAVE_SYS_SYSLIMITS_H
+   #include <sys/syslimits.h>
+   #endif
+
+"
+if test "x$ac_cv_header_sys_param_h" = xyes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_SYS_PARAM_H 1
 _ACEOF
-if { (ac_try="$ac_cpp conftest.$ac_ext"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } >/dev/null && {
-	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       }; then
-  ac_header_preproc=yes
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
 
-  ac_header_preproc=no
 fi
 
-rm -f conftest.err conftest.$ac_ext
-{ $as_echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
-$as_echo "$ac_header_preproc" >&6; }
+done
 
-# So?  What about this header?
-case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
-  yes:no: )
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
-$as_echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the compiler's result" >&5
-$as_echo "$as_me: WARNING: $ac_header: proceeding with the compiler's result" >&2;}
-    ac_header_preproc=yes
-    ;;
-  no:yes:* )
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
-$as_echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header:     check for missing prerequisite headers?" >&5
-$as_echo "$as_me: WARNING: $ac_header:     check for missing prerequisite headers?" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: see the Autoconf documentation" >&5
-$as_echo "$as_me: WARNING: $ac_header: see the Autoconf documentation" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&5
-$as_echo "$as_me: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
-$as_echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: in the future, the compiler will take precedence" >&5
-$as_echo "$as_me: WARNING: $ac_header: in the future, the compiler will take precedence" >&2;}
+for ac_header in sys/mount.h
+do :
+  ac_fn_c_check_header_compile "$LINENO" "sys/mount.h" "ac_cv_header_sys_mount_h" "#if HAVE_SYS_CDEFS_H
+   #include <sys/cdefs.h>
+   #endif
+   #if HAVE_SYS_SYSLIMITS_H
+   #include <sys/syslimits.h>
+   #endif
+   #if HAVE_SYS_PARAM_H
+   #include <sys/param.h>
+   #endif
 
-    ;;
-esac
-{ $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
-$as_echo_n "checking for $ac_header... " >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  $as_echo_n "(cached) " >&6
-else
-  eval "$as_ac_Header=\$ac_header_preproc"
-fi
-ac_res=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
+"
+if test "x$ac_cv_header_sys_mount_h" = xyes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_SYS_MOUNT_H 1
+_ACEOF
 
 fi
-as_val=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-   if test "x$as_val" = x""yes; then
+
+done
+
+for ac_header in sys/types.h windows.h locale.h langinfo.h
+do :
+  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
+ac_fn_c_check_header_mongrel "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default"
+if eval test \"x\$"$as_ac_Header"\" = x"yes"; then :
   cat >>confdefs.h <<_ACEOF
 #define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
 _ACEOF
@@ -19940,277 +8011,247 @@ fi
 
 done
 
-if test $ac_cv_header_zlib_h = yes; then
-  { $as_echo "$as_me:$LINENO: checking for gzseek in -lz" >&5
-$as_echo_n "checking for gzseek in -lz... " >&6; }
-if test "${ac_cv_lib_z_gzseek+set}" = set; then
+saved_LIBS="$LIBS"
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for main in -lm" >&5
+$as_echo_n "checking for main in -lm... " >&6; }
+if ${ac_cv_lib_m_main+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
-LIBS="-lz  $LIBS"
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+LIBS="-lm  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char gzseek ();
+
 int
 main ()
 {
-return gzseek ();
+return main ();
   ;
   return 0;
 }
 _ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then
-  ac_cv_lib_z_gzseek=yes
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_m_main=yes
 else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_cv_lib_z_gzseek=no
+  ac_cv_lib_m_main=no
 fi
-
-rm -rf conftest.dSYM
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_lib_z_gzseek" >&5
-$as_echo "$ac_cv_lib_z_gzseek" >&6; }
-if test "x$ac_cv_lib_z_gzseek" = x""yes; then
-  zlib_ok=yes
-else
-  zlib_ok=no
-fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_m_main" >&5
+$as_echo "$ac_cv_lib_m_main" >&6; }
+if test "x$ac_cv_lib_m_main" = xyes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_LIBM 1
+_ACEOF
+
+  LIBS="-lm $LIBS"
 
-  if test "$zlib_ok" = yes; then
-    LIBS="$LIBS -lz"
-    USE_ZLIB=1
-  fi
 fi
 
+for ac_func in statvfs link symlink readlink geteuid getlogin getpwnam getpwnam_r getpwuid getpwuid_r getgrgid getgrgid_r getgrnam getgrnam_r rint getopt
+do :
+  as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
+ac_fn_c_check_func "$LINENO" "$ac_func" "$as_ac_var"
+if eval test \"x\$"$as_ac_var"\" = x"yes"; then :
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
 
-HAVE_INET_PTON=no
-if test $ac_cv_func_inet_pton = yes ; then
-  HAVE_INET_PTON=yes
 fi
+done
 
+LIBS="$saved_LIBS"
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for pw_gecos field in struct passwd" >&5
+$as_echo_n "checking for pw_gecos field in struct passwd... " >&6; }
+if ${ac_cv_have_pw_gecos_in_struct_passwd+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+
+	cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+ #include <pwd.h>
+int
+main ()
+{
+ struct passwd p; p.pw_gecos = 0;
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+   ac_cv_have_pw_gecos_in_struct_passwd="yes"
+else
+   ac_cv_have_pw_gecos_in_struct_passwd="no"
+
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
 
-HAVE_INET_NTOP=no
-if test $ac_cv_func_inet_ntop = yes ; then
-  HAVE_INET_NTOP=yes
 fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_have_pw_gecos_in_struct_passwd" >&5
+$as_echo "$ac_cv_have_pw_gecos_in_struct_passwd" >&6; }
+if test "x$ac_cv_have_pw_gecos_in_struct_passwd" = "xyes" ; then
+
+$as_echo "#define HAVE_PW_GECOS_IN_PASSWD 1" >>confdefs.h
 
+fi
 
 #--------------------------------------------------------------------
-# For setting thread stack size
+# These two headers (functions) needed by Time.m
 #--------------------------------------------------------------------
 
-for ac_header in sys/resource.h
-do
-as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  { $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
-$as_echo_n "checking for $ac_header... " >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  $as_echo_n "(cached) " >&6
+for ac_header in time.h sys/time.h tzfile.h sys/rusage.h ucbinclude/sys/resource.h
+do :
+  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
+ac_fn_c_check_header_mongrel "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default"
+if eval test \"x\$"$as_ac_Header"\" = x"yes"; then :
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
 fi
-ac_res=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-else
-  # Is the header compilable?
-{ $as_echo "$as_me:$LINENO: checking $ac_header usability" >&5
-$as_echo_n "checking $ac_header usability... " >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
+
+done
+
+for ac_func in time ctime tzset
+do :
+  as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
+ac_fn_c_check_func "$LINENO" "$ac_func" "$as_ac_var"
+if eval test \"x\$"$as_ac_var"\" = x"yes"; then :
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
 _ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+
+fi
+done
+
+
+# Check if tzfile contains the proper definitions
+if test $ac_cv_header_tzfile_h = yes; then
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
-$ac_includes_default
-#include <$ac_header>
+#include <tzfile.h>
+
 _ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_header_compiler=yes
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "tzhead" >/dev/null 2>&1; then :
+
+$as_echo "#define HAVE_TZHEAD 1" >>confdefs.h
 
-	ac_header_compiler=no
 fi
+rm -f conftest*
 
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-{ $as_echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
-$as_echo "$ac_header_compiler" >&6; }
+fi
 
-# Is the header present?
-{ $as_echo "$as_me:$LINENO: checking $ac_header presence" >&5
-$as_echo_n "checking $ac_header presence... " >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <$ac_header>
+#--------------------------------------------------------------------
+# These headers/functions needed by GSTcpPort.m
+#--------------------------------------------------------------------
+for ac_header in sys/socket.h netinet/in.h
+do :
+  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
+ac_fn_c_check_header_mongrel "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default"
+if eval test \"x\$"$as_ac_Header"\" = x"yes"; then :
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
 _ACEOF
-if { (ac_try="$ac_cpp conftest.$ac_ext"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } >/dev/null && {
-	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       }; then
-  ac_header_preproc=yes
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
 
-  ac_header_preproc=no
 fi
 
-rm -f conftest.err conftest.$ac_ext
-{ $as_echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
-$as_echo "$ac_header_preproc" >&6; }
+done
+
+ac_fn_c_check_type "$LINENO" "socklen_t" "ac_cv_type_socklen_t" "$ac_includes_default"
+if test "x$ac_cv_type_socklen_t" = xyes; then :
+
+cat >>confdefs.h <<_ACEOF
+#define HAVE_SOCKLEN_T 1
+_ACEOF
 
-# So?  What about this header?
-case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
-  yes:no: )
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
-$as_echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the compiler's result" >&5
-$as_echo "$as_me: WARNING: $ac_header: proceeding with the compiler's result" >&2;}
-    ac_header_preproc=yes
-    ;;
-  no:yes:* )
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
-$as_echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header:     check for missing prerequisite headers?" >&5
-$as_echo "$as_me: WARNING: $ac_header:     check for missing prerequisite headers?" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: see the Autoconf documentation" >&5
-$as_echo "$as_me: WARNING: $ac_header: see the Autoconf documentation" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&5
-$as_echo "$as_me: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
-$as_echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: in the future, the compiler will take precedence" >&5
-$as_echo "$as_me: WARNING: $ac_header: in the future, the compiler will take precedence" >&2;}
 
-    ;;
-esac
-{ $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
-$as_echo_n "checking for $ac_header... " >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  $as_echo_n "(cached) " >&6
-else
-  eval "$as_ac_Header=\$ac_header_preproc"
 fi
-ac_res=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
 
+
+#--------------------------------------------------------------------
+# These headers/functions needed for stacktrace in NSException.m
+#--------------------------------------------------------------------
+PASS_ARG=no
+# Check whether --enable-bfd was given.
+if test "${enable_bfd+set}" = set; then :
+  enableval=$enable_bfd;
+else
+  enable_bfd=$PASS_ARG
 fi
-as_val=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-   if test "x$as_val" = x""yes; then
+
+
+if test $enable_bfd = yes; then
+  for ac_header in bfd.h
+do :
+  ac_fn_c_check_header_mongrel "$LINENO" "bfd.h" "ac_cv_header_bfd_h" "$ac_includes_default"
+if test "x$ac_cv_header_bfd_h" = xyes; then :
   cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
+#define HAVE_BFD_H 1
 _ACEOF
 
 fi
 
 done
 
-
-for ac_func in setrlimit
-do
-as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
-{ $as_echo "$as_me:$LINENO: checking for $ac_func" >&5
-$as_echo_n "checking for $ac_func... " >&6; }
-if { as_var=$as_ac_var; eval "test \"\${$as_var+set}\" = set"; }; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for dyn_string_append in -liberty" >&5
+$as_echo_n "checking for dyn_string_append in -liberty... " >&6; }
+if ${ac_cv_lib_iberty_dyn_string_append+:} false; then :
   $as_echo_n "(cached) " >&6
 else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-liberty  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
-/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.
-   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
-#define $ac_func innocuous_$ac_func
-
-/* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char $ac_func (); below.
-    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-    <limits.h> exists even on freestanding compilers.  */
 
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
 #endif
+char dyn_string_append ();
+int
+main ()
+{
+return dyn_string_append ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_iberty_dyn_string_append=yes
+else
+  ac_cv_lib_iberty_dyn_string_append=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_iberty_dyn_string_append" >&5
+$as_echo "$ac_cv_lib_iberty_dyn_string_append" >&6; }
+if test "x$ac_cv_lib_iberty_dyn_string_append" = xyes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_LIBIBERTY 1
+_ACEOF
 
-#undef $ac_func
+  LIBS="-liberty $LIBS"
+
+fi
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for bfd_openr in -lbfd" >&5
+$as_echo_n "checking for bfd_openr in -lbfd... " >&6; }
+if ${ac_cv_lib_bfd_bfd_openr+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lbfd  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
 
 /* Override any GCC internal prototype to avoid an error.
    Use char because int might match the return type of a GCC
@@ -20218,64 +8259,66 @@ cat >>conftest.$ac_ext <<_ACEOF
 #ifdef __cplusplus
 extern "C"
 #endif
-char $ac_func ();
-/* The GNU C library defines this for functions which it implements
-    to always fail with ENOSYS.  Some functions are actually named
-    something starting with __ and the normal name is an alias.  */
-#if defined __stub_$ac_func || defined __stub___$ac_func
-choke me
-#endif
-
+char bfd_openr ();
 int
 main ()
 {
-return $ac_func ();
+return bfd_openr ();
   ;
   return 0;
 }
 _ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then
-  eval "$as_ac_var=yes"
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_bfd_bfd_openr=yes
 else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
+  ac_cv_lib_bfd_bfd_openr=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_bfd_bfd_openr" >&5
+$as_echo "$ac_cv_lib_bfd_bfd_openr" >&6; }
+if test "x$ac_cv_lib_bfd_bfd_openr" = xyes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_LIBBFD 1
+_ACEOF
+
+  LIBS="-lbfd $LIBS"
+
+fi
+
+else
+  for ac_header in execinfo.h
+do :
+  ac_fn_c_check_header_mongrel "$LINENO" "execinfo.h" "ac_cv_header_execinfo_h" "$ac_includes_default"
+if test "x$ac_cv_header_execinfo_h" = xyes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_EXECINFO_H 1
+_ACEOF
+
+fi
+
+done
+
+  for ac_func in backtrace
+do :
+  ac_fn_c_check_func "$LINENO" "backtrace" "ac_cv_func_backtrace"
+if test "x$ac_cv_func_backtrace" = xyes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_BACKTRACE 1
+_ACEOF
 
-	eval "$as_ac_var=no"
 fi
+done
 
-rm -rf conftest.dSYM
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
 fi
-ac_res=`eval 'as_val=${'$as_ac_var'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-as_val=`eval 'as_val=${'$as_ac_var'}
-		 $as_echo "$as_val"'`
-   if test "x$as_val" = x""yes; then
+for ac_func in __builtin_extract_return_address
+do :
+  ac_fn_c_check_func "$LINENO" "__builtin_extract_return_address" "ac_cv_func___builtin_extract_return_address"
+if test "x$ac_cv_func___builtin_extract_return_address" = xyes; then :
   cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
+#define HAVE___BUILTIN_EXTRACT_RETURN_ADDRESS 1
 _ACEOF
 
 fi
@@ -20283,444 +8326,312 @@ done
 
 
 #--------------------------------------------------------------------
-# One of these functions needed by NSDebug.m and NSProcessInfo.m
+# These headers/functions needed by NSLog.m
 #--------------------------------------------------------------------
-
-for ac_func in strerror
-do
-as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
-{ $as_echo "$as_me:$LINENO: checking for $ac_func" >&5
-$as_echo_n "checking for $ac_func... " >&6; }
-if { as_var=$as_ac_var; eval "test \"\${$as_var+set}\" = set"; }; then
-  $as_echo_n "(cached) " >&6
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
+for ac_header in syslog.h sys/slog.h sys/slogcodes.h
+do :
+  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
+ac_fn_c_check_header_mongrel "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default"
+if eval test \"x\$"$as_ac_Header"\" = x"yes"; then :
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
 _ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.
-   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
-#define $ac_func innocuous_$ac_func
 
-/* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char $ac_func (); below.
-    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-    <limits.h> exists even on freestanding compilers.  */
+fi
 
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
+done
 
-#undef $ac_func
+for ac_func in syslog
+do :
+  ac_fn_c_check_func "$LINENO" "syslog" "ac_cv_func_syslog"
+if test "x$ac_cv_func_syslog" = xyes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_SYSLOG 1
+_ACEOF
 
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char $ac_func ();
-/* The GNU C library defines this for functions which it implements
-    to always fail with ENOSYS.  Some functions are actually named
-    something starting with __ and the normal name is an alias.  */
-#if defined __stub_$ac_func || defined __stub___$ac_func
-choke me
-#endif
+fi
+done
 
-int
-main ()
-{
-return $ac_func ();
-  ;
-  return 0;
-}
+if test "$ac_cv_header_sys_slog_h" = "yes"; then
+  oldLibs="$LIBS";
+  LIBS="$LIBS -l:libc.a";
+  for ac_func in slogf
+do :
+  ac_fn_c_check_func "$LINENO" "slogf" "ac_cv_func_slogf"
+if test "x$ac_cv_func_slogf" = xyes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_SLOGF 1
 _ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then
-  eval "$as_ac_var=yes"
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
 
-	eval "$as_ac_var=no"
 fi
+done
 
-rm -rf conftest.dSYM
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
+  if test "$ac_cv_func_slogf" = "no"; then
+    LIBS="$oldLibs"
+  fi
 fi
-ac_res=`eval 'as_val=${'$as_ac_var'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-as_val=`eval 'as_val=${'$as_ac_var'}
-		 $as_echo "$as_val"'`
-   if test "x$as_val" = x""yes; then
+#--------------------------------------------------------------------
+# These headers/functions needed by NSRunLoop.m
+#--------------------------------------------------------------------
+for ac_header in poll.h
+do :
+  ac_fn_c_check_header_mongrel "$LINENO" "poll.h" "ac_cv_header_poll_h" "$ac_includes_default"
+if test "x$ac_cv_header_poll_h" = xyes; then :
   cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
+#define HAVE_POLL_H 1
 _ACEOF
 
 fi
-done
 
-{ $as_echo "$as_me:$LINENO: checking whether strerror_r is declared" >&5
-$as_echo_n "checking whether strerror_r is declared... " >&6; }
-if test "${ac_cv_have_decl_strerror_r+set}" = set; then
-  $as_echo_n "(cached) " >&6
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-int
-main ()
-{
-#ifndef strerror_r
-  (void) strerror_r;
-#endif
+done
 
-  ;
-  return 0;
-}
+for ac_func in poll
+do :
+  ac_fn_c_check_func "$LINENO" "poll" "ac_cv_func_poll"
+if test "x$ac_cv_func_poll" = xyes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_POLL 1
 _ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_cv_have_decl_strerror_r=yes
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
 
-	ac_cv_have_decl_strerror_r=no
 fi
+done
 
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+have_poll=no
+if test $ac_cv_header_poll_h = yes; then
+  have_poll=yes
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for poll emulation" >&5
+$as_echo_n "checking for poll emulation... " >&6; }
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include "config/config.poll.c"
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "emulating_poll" >/dev/null 2>&1; then :
+  have_poll=no
 fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_have_decl_strerror_r" >&5
-$as_echo "$ac_cv_have_decl_strerror_r" >&6; }
-if test "x$ac_cv_have_decl_strerror_r" = x""yes; then
+rm -f conftest*
 
-cat >>confdefs.h <<_ACEOF
-#define HAVE_DECL_STRERROR_R 1
+  if test $have_poll = yes; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking if poll supports devices" >&5
+$as_echo_n "checking if poll supports devices... " >&6; }
+    if test "$cross_compiling" = yes; then :
+  have_poll="$cross_have_poll"
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include "$srcdir/config/config.poll-dev.c"i
 _ACEOF
-
+if ac_fn_c_try_run "$LINENO"; then :
 
 else
-  cat >>confdefs.h <<_ACEOF
-#define HAVE_DECL_STRERROR_R 0
-_ACEOF
+  have_poll=no
+fi
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
+  conftest.$ac_objext conftest.beam conftest.$ac_ext
+fi
+
+    if test $have_poll = yes; then
+      { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
 
+$as_echo "#define HAVE_POLL_F 1" >>confdefs.h
 
+    else
+      { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+    fi
+  else
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+  fi
 fi
 
+#--------------------------------------------------------------------
+# This function needed by StdioStream.m
+#--------------------------------------------------------------------
+for ac_func in vsprintf vasprintf snprintf vsnprintf
+do :
+  as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
+ac_fn_c_check_func "$LINENO" "$ac_func" "$as_ac_var"
+if eval test \"x\$"$as_ac_var"\" = x"yes"; then :
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
 
+fi
+done
 
-for ac_func in strerror_r
-do
-as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
-{ $as_echo "$as_me:$LINENO: checking for $ac_func" >&5
-$as_echo_n "checking for $ac_func... " >&6; }
-if { as_var=$as_ac_var; eval "test \"\${$as_var+set}\" = set"; }; then
-  $as_echo_n "(cached) " >&6
+if test $ac_cv_func_vsprintf = yes ; then
+    if test "$cross_compiling" = yes; then :
+  VSPRINTF_RETURNS_LENGTH="$cross_VSPRINTF_RETURNS_LENGTH"
 else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
-/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.
-   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
-#define $ac_func innocuous_$ac_func
+#include "$srcdir/config/config.vsprintf.c"
+_ACEOF
+if ac_fn_c_try_run "$LINENO"; then :
+  VSPRINTF_RETURNS_LENGTH=1
+else
+  VSPRINTF_RETURNS_LENGTH=0
+fi
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
+  conftest.$ac_objext conftest.beam conftest.$ac_ext
+fi
 
-/* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char $ac_func (); below.
-    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-    <limits.h> exists even on freestanding compilers.  */
 
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
+cat >>confdefs.h <<_ACEOF
+#define VSPRINTF_RETURNS_LENGTH $VSPRINTF_RETURNS_LENGTH
+_ACEOF
 
-#undef $ac_func
+fi
+if test $ac_cv_func_vasprintf = yes ; then
+    if test "$cross_compiling" = yes; then :
+  VASPRINTF_RETURNS_LENGTH="$cross_VASPRINTF_RETURNS_LENGTH"
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include "$srcdir/config/config.vasprintf.c"
+_ACEOF
+if ac_fn_c_try_run "$LINENO"; then :
+  VASPRINTF_RETURNS_LENGTH=1
+else
+  VASPRINTF_RETURNS_LENGTH=0
+fi
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
+  conftest.$ac_objext conftest.beam conftest.$ac_ext
+fi
 
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char $ac_func ();
-/* The GNU C library defines this for functions which it implements
-    to always fail with ENOSYS.  Some functions are actually named
-    something starting with __ and the normal name is an alias.  */
-#if defined __stub_$ac_func || defined __stub___$ac_func
-choke me
-#endif
 
-int
-main ()
-{
-return $ac_func ();
-  ;
-  return 0;
-}
+cat >>confdefs.h <<_ACEOF
+#define VASPRINTF_RETURNS_LENGTH $VASPRINTF_RETURNS_LENGTH
 _ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then
-  eval "$as_ac_var=yes"
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
 
-	eval "$as_ac_var=no"
 fi
 
-rm -rf conftest.dSYM
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
-fi
-ac_res=`eval 'as_val=${'$as_ac_var'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-as_val=`eval 'as_val=${'$as_ac_var'}
-		 $as_echo "$as_val"'`
-   if test "x$as_val" = x""yes; then
+#--------------------------------------------------------------------
+# This function needed by NSFileManager.m
+#--------------------------------------------------------------------
+for ac_func in getcwd
+do :
+  ac_fn_c_check_func "$LINENO" "getcwd" "ac_cv_func_getcwd"
+if test "x$ac_cv_func_getcwd" = xyes; then :
   cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
+#define HAVE_GETCWD 1
 _ACEOF
 
 fi
 done
 
-{ $as_echo "$as_me:$LINENO: checking whether strerror_r returns char *" >&5
-$as_echo_n "checking whether strerror_r returns char *... " >&6; }
-if test "${ac_cv_func_strerror_r_char_p+set}" = set; then
+ac_header_dirent=no
+for ac_hdr in dirent.h sys/ndir.h sys/dir.h ndir.h; do
+  as_ac_Header=`$as_echo "ac_cv_header_dirent_$ac_hdr" | $as_tr_sh`
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_hdr that defines DIR" >&5
+$as_echo_n "checking for $ac_hdr that defines DIR... " >&6; }
+if eval \${$as_ac_Header+:} false; then :
   $as_echo_n "(cached) " >&6
 else
-
-    ac_cv_func_strerror_r_char_p=no
-    if test $ac_cv_have_decl_strerror_r = yes; then
-      cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
-$ac_includes_default
+#include <sys/types.h>
+#include <$ac_hdr>
+
 int
 main ()
 {
-
-	  char buf[100];
-	  char x = *strerror_r (0, buf, sizeof buf);
-	  char *p = strerror_r (0, buf, sizeof buf);
-	  return !p || x;
-
+if ((DIR *) 0)
+return 0;
   ;
   return 0;
 }
 _ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_cv_func_strerror_r_char_p=yes
+if ac_fn_c_try_compile "$LINENO"; then :
+  eval "$as_ac_Header=yes"
 else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
+  eval "$as_ac_Header=no"
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+eval ac_res=\$$as_ac_Header
+	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+$as_echo "$ac_res" >&6; }
+if eval test \"x\$"$as_ac_Header"\" = x"yes"; then :
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_hdr" | $as_tr_cpp` 1
+_ACEOF
 
+ac_header_dirent=$ac_hdr; break
 fi
 
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-    else
-      # strerror_r is not declared.  Choose between
-      # systems that have relatively inaccessible declarations for the
-      # function.  BeOS and DEC UNIX 4.0 fall in this category, but the
-      # former has a strerror_r that returns char*, while the latter
-      # has a strerror_r that returns `int'.
-      # This test should segfault on the DEC system.
-      if test "$cross_compiling" = yes; then
-  :
+done
+# Two versions of opendir et al. are in -ldir and -lx on SCO Xenix.
+if test $ac_header_dirent = dirent.h; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for library containing opendir" >&5
+$as_echo_n "checking for library containing opendir... " >&6; }
+if ${ac_cv_search_opendir+:} false; then :
+  $as_echo_n "(cached) " >&6
 else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+  ac_func_search_save_LIBS=$LIBS
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
-$ac_includes_default
-	extern char *strerror_r ();
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char opendir ();
 int
 main ()
 {
-char buf[100];
-	  char x = *strerror_r (0, buf, sizeof buf);
-	  return ! isalpha (x);
+return opendir ();
   ;
   return 0;
 }
 _ACEOF
-rm -f conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_cv_func_strerror_r_char_p=yes
-else
-  $as_echo "$as_me: program exited with status $ac_status" >&5
-$as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
+for ac_lib in '' dir; do
+  if test -z "$ac_lib"; then
+    ac_res="none required"
+  else
+    ac_res=-l$ac_lib
+    LIBS="-l$ac_lib  $ac_func_search_save_LIBS"
+  fi
+  if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_search_opendir=$ac_res
 fi
-rm -rf conftest.dSYM
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext
+  if ${ac_cv_search_opendir+:} false; then :
+  break
 fi
+done
+if ${ac_cv_search_opendir+:} false; then :
 
-
-    fi
-
+else
+  ac_cv_search_opendir=no
 fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_func_strerror_r_char_p" >&5
-$as_echo "$ac_cv_func_strerror_r_char_p" >&6; }
-if test $ac_cv_func_strerror_r_char_p = yes; then
-
-cat >>confdefs.h <<\_ACEOF
-#define STRERROR_R_CHAR_P 1
-_ACEOF
-
+rm conftest.$ac_ext
+LIBS=$ac_func_search_save_LIBS
 fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_search_opendir" >&5
+$as_echo "$ac_cv_search_opendir" >&6; }
+ac_res=$ac_cv_search_opendir
+if test "$ac_res" != no; then :
+  test "$ac_res" = "none required" || LIBS="$ac_res $LIBS"
 
+fi
 
-#--------------------------------------------------------------------
-# Needed by NSDebug.m
-#--------------------------------------------------------------------
-
-for ac_func in sigsetjmp
-do
-as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
-{ $as_echo "$as_me:$LINENO: checking for $ac_func" >&5
-$as_echo_n "checking for $ac_func... " >&6; }
-if { as_var=$as_ac_var; eval "test \"\${$as_var+set}\" = set"; }; then
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for library containing opendir" >&5
+$as_echo_n "checking for library containing opendir... " >&6; }
+if ${ac_cv_search_opendir+:} false; then :
   $as_echo_n "(cached) " >&6
 else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+  ac_func_search_save_LIBS=$LIBS
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
-/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.
-   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
-#define $ac_func innocuous_$ac_func
-
-/* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char $ac_func (); below.
-    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-    <limits.h> exists even on freestanding compilers.  */
-
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
-
-#undef $ac_func
 
 /* Override any GCC internal prototype to avoid an error.
    Use char because int might match the return type of a GCC
@@ -20728,314 +8639,233 @@ cat >>conftest.$ac_ext <<_ACEOF
 #ifdef __cplusplus
 extern "C"
 #endif
-char $ac_func ();
-/* The GNU C library defines this for functions which it implements
-    to always fail with ENOSYS.  Some functions are actually named
-    something starting with __ and the normal name is an alias.  */
-#if defined __stub_$ac_func || defined __stub___$ac_func
-choke me
-#endif
-
+char opendir ();
 int
 main ()
 {
-return $ac_func ();
+return opendir ();
   ;
   return 0;
 }
 _ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then
-  eval "$as_ac_var=yes"
+for ac_lib in '' x; do
+  if test -z "$ac_lib"; then
+    ac_res="none required"
+  else
+    ac_res=-l$ac_lib
+    LIBS="-l$ac_lib  $ac_func_search_save_LIBS"
+  fi
+  if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_search_opendir=$ac_res
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext
+  if ${ac_cv_search_opendir+:} false; then :
+  break
+fi
+done
+if ${ac_cv_search_opendir+:} false; then :
+
 else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
+  ac_cv_search_opendir=no
+fi
+rm conftest.$ac_ext
+LIBS=$ac_func_search_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_search_opendir" >&5
+$as_echo "$ac_cv_search_opendir" >&6; }
+ac_res=$ac_cv_search_opendir
+if test "$ac_res" != no; then :
+  test "$ac_res" = "none required" || LIBS="$ac_res $LIBS"
 
-	eval "$as_ac_var=no"
 fi
 
-rm -rf conftest.dSYM
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
 fi
-ac_res=`eval 'as_val=${'$as_ac_var'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-as_val=`eval 'as_val=${'$as_ac_var'}
-		 $as_echo "$as_val"'`
-   if test "x$as_val" = x""yes; then
+
+
+#--------------------------------------------------------------------
+# This function needed by gdomap.c
+#--------------------------------------------------------------------
+for ac_header in getopt.h
+do :
+  ac_fn_c_check_header_mongrel "$LINENO" "getopt.h" "ac_cv_header_getopt_h" "$ac_includes_default"
+if test "x$ac_cv_header_getopt_h" = xyes; then :
   cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
+#define HAVE_GETOPT_H 1
 _ACEOF
 
 fi
+
 done
 
 
 #--------------------------------------------------------------------
-# This type needed by GSFormat
+# This function needed by NSPage.m
 #--------------------------------------------------------------------
-{ $as_echo "$as_me:$LINENO: checking for uintmax_t" >&5
-$as_echo_n "checking for uintmax_t... " >&6; }
-if test "${ac_cv_type_uintmax_t+set}" = set; then
-  $as_echo_n "(cached) " >&6
-else
-  ac_cv_type_uintmax_t=no
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-int
-main ()
-{
-if (sizeof (uintmax_t))
-       return 0;
-  ;
-  return 0;
-}
+for ac_func in posix_memalign valloc
+do :
+  as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
+ac_fn_c_check_func "$LINENO" "$ac_func" "$as_ac_var"
+if eval test \"x\$"$as_ac_var"\" = x"yes"; then :
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
 _ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
+
+fi
+done
+
+
+#--------------------------------------------------------------------
+# This function needed by Time.m
+#--------------------------------------------------------------------
+for ac_func in times
+do :
+  ac_fn_c_check_func "$LINENO" "times" "ac_cv_func_times"
+if test "x$ac_cv_func_times" = xyes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_TIMES 1
 _ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-int
-main ()
-{
-if (sizeof ((uintmax_t)))
-	  return 0;
-  ;
-  return 0;
-}
+
+fi
+done
+
+
+#--------------------------------------------------------------------
+# These functions needed by NSData.m and GSFFIInvocation.m
+#--------------------------------------------------------------------
+for ac_func in mkstemp
+do :
+  ac_fn_c_check_func "$LINENO" "mkstemp" "ac_cv_func_mkstemp"
+if test "x$ac_cv_func_mkstemp" = xyes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_MKSTEMP 1
+_ACEOF
+
+fi
+done
+
+for ac_func in shmctl
+do :
+  ac_fn_c_check_func "$LINENO" "shmctl" "ac_cv_func_shmctl"
+if test "x$ac_cv_func_shmctl" = xyes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_SHMCTL 1
 _ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  :
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
 
-	ac_cv_type_uintmax_t=yes
 fi
+done
 
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
+for ac_func in mmap
+do :
+  ac_fn_c_check_func "$LINENO" "mmap" "ac_cv_func_mmap"
+if test "x$ac_cv_func_mmap" = xyes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_MMAP 1
+_ACEOF
 
 fi
+done
+
+for ac_func in mprotect
+do :
+  ac_fn_c_check_func "$LINENO" "mprotect" "ac_cv_func_mprotect"
+if test "x$ac_cv_func_mprotect" = xyes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_MPROTECT 1
+_ACEOF
 
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
 fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_type_uintmax_t" >&5
-$as_echo "$ac_cv_type_uintmax_t" >&6; }
-if test "x$ac_cv_type_uintmax_t" = x""yes; then
+done
 
-cat >>confdefs.h <<_ACEOF
-#define HAVE_UINTMAX_T 1
+for ac_header in sys/mman.h
+do :
+  ac_fn_c_check_header_mongrel "$LINENO" "sys/mman.h" "ac_cv_header_sys_mman_h" "$ac_includes_default"
+if test "x$ac_cv_header_sys_mman_h" = xyes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_SYS_MMAN_H 1
 _ACEOF
 
-
 fi
 
+done
+
+
+#--------------------------------------------------------------------
+# These functions needed by NSTask.m
+#--------------------------------------------------------------------
+for ac_func in killpg setpgrp setpgid setsid
+do :
+  as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
+ac_fn_c_check_func "$LINENO" "$ac_func" "$as_ac_var"
+if eval test \"x\$"$as_ac_var"\" = x"yes"; then :
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
 
-for ac_header in wchar.h
-do
-as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  { $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
-$as_echo_n "checking for $ac_header... " >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  $as_echo_n "(cached) " >&6
 fi
-ac_res=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
+done
+
+if test "x$ac_cv_func_setpgrp" = xyes; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether setpgrp takes no argument" >&5
+$as_echo_n "checking whether setpgrp takes no argument... " >&6; }
+if ${ac_cv_func_setpgrp_void+:} false; then :
+  $as_echo_n "(cached) " >&6
 else
-  # Is the header compilable?
-{ $as_echo "$as_me:$LINENO: checking $ac_header usability" >&5
-$as_echo_n "checking $ac_header usability... " >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+  if test "$cross_compiling" = yes; then :
+  as_fn_error $? "cannot check setpgrp when cross compiling" "$LINENO" 5
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 $ac_includes_default
-#include <$ac_header>
+int
+main ()
+{
+/* If this system has a BSD-style setpgrp which takes arguments,
+  setpgrp(1, 1) will fail with ESRCH and return -1, in that case
+  exit successfully. */
+  return setpgrp (1,1) != -1;
+  ;
+  return 0;
+}
 _ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_header_compiler=yes
+if ac_fn_c_try_run "$LINENO"; then :
+  ac_cv_func_setpgrp_void=no
 else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_header_compiler=no
+  ac_cv_func_setpgrp_void=yes
+fi
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
+  conftest.$ac_objext conftest.beam conftest.$ac_ext
 fi
 
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-{ $as_echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
-$as_echo "$ac_header_compiler" >&6; }
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_func_setpgrp_void" >&5
+$as_echo "$ac_cv_func_setpgrp_void" >&6; }
+if test $ac_cv_func_setpgrp_void = yes; then
 
-# Is the header present?
-{ $as_echo "$as_me:$LINENO: checking $ac_header presence" >&5
-$as_echo_n "checking $ac_header presence... " >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <$ac_header>
-_ACEOF
-if { (ac_try="$ac_cpp conftest.$ac_ext"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } >/dev/null && {
-	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       }; then
-  ac_header_preproc=yes
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
+$as_echo "#define SETPGRP_VOID 1" >>confdefs.h
 
-  ac_header_preproc=no
 fi
 
-rm -f conftest.err conftest.$ac_ext
-{ $as_echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
-$as_echo "$ac_header_preproc" >&6; }
-
-# So?  What about this header?
-case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
-  yes:no: )
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
-$as_echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the compiler's result" >&5
-$as_echo "$as_me: WARNING: $ac_header: proceeding with the compiler's result" >&2;}
-    ac_header_preproc=yes
-    ;;
-  no:yes:* )
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
-$as_echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header:     check for missing prerequisite headers?" >&5
-$as_echo "$as_me: WARNING: $ac_header:     check for missing prerequisite headers?" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: see the Autoconf documentation" >&5
-$as_echo "$as_me: WARNING: $ac_header: see the Autoconf documentation" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&5
-$as_echo "$as_me: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
-$as_echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: in the future, the compiler will take precedence" >&5
-$as_echo "$as_me: WARNING: $ac_header: in the future, the compiler will take precedence" >&2;}
+fi
 
+HAVE_PTS_STREAM_MODULES=0
+case "${target}" in
+  *-sysv-*)
+    HAVE_PTS_STREAM_MODULES=1
     ;;
 esac
-{ $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
-$as_echo_n "checking for $ac_header... " >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  $as_echo_n "(cached) " >&6
-else
-  eval "$as_ac_Header=\$ac_header_preproc"
-fi
-ac_res=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
 
-fi
-as_val=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-   if test "x$as_val" = x""yes; then
+cat >>confdefs.h <<_ACEOF
+#define HAVE_PTS_STREAM_MODULES $HAVE_PTS_STREAM_MODULES
+_ACEOF
+
+
+
+for ac_header in 	fcntl.h 	inttypes.h 	libc.h 	limits.h 	malloc.h 	memory.h 	signal.h 	stdint.h 	string.h 	sys/fcntl.h 	sys/file.h 	sys/filio.h 	sys/inttypes.h 	sys/ioctl.h 	sys/signal.h 	sys/stropts.h 	sys/wait.h 	unistd.h 	utime.h         stdlib.h
+do :
+  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
+ac_fn_c_check_header_mongrel "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default"
+if eval test \"x\$"$as_ac_Header"\" = x"yes"; then :
   cat >>confdefs.h <<_ACEOF
 #define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
 _ACEOF
@@ -21045,105 +8875,66 @@ fi
 done
 
 
-#--------------------------------------------------------------------
-# Check if short and int values need to be word aligned
-#--------------------------------------------------------------------
-{ $as_echo "$as_me:$LINENO: checking short/int needs to be word aligned" >&5
-$as_echo_n "checking short/int needs to be word aligned... " >&6; }
-if test "$cross_compiling" = yes; then
-  NEED_WORD_ALIGNMENT="$cross_NEED_WORD_ALIGNMENT"
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include "$srcdir/config/config.align.c"
-_ACEOF
-rm -f conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  NEED_WORD_ALIGNMENT=0
+if test $ac_cv_header_stdint_h = yes; then
+INCLUDE_STDINT="#include <stdint.h>"
+elif test $ac_cv_header_inttypes_h = yes; then
+INCLUDE_STDINT="#include <inttypes.h>"
+elif test $ac_cv_header_sys_inttypes_h = yes; then
+INCLUDE_STDINT="#include <sys/inttypes.h>"
 else
-  $as_echo "$as_me: program exited with status $ac_status" >&5
-$as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-( exit $ac_status )
-NEED_WORD_ALIGNMENT=1
+INCLUDE_STDINT="no"
 fi
-rm -rf conftest.dSYM
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+
+if test "$INCLUDE_STDINT" = "no"; then
+INCLUDE_STDINT=""
+DEFINE_INT8_T="#define int8_t gss8"
+DEFINE_UINT8_T="#define uint8_t gsu8"
+DEFINE_INT16_T="#define int16_t gss16"
+DEFINE_UINT16_T="#define uint16_t gsu16"
+DEFINE_INT32_T="#define int32_t gss32"
+DEFINE_UINT32_T="#define uint32_t gsu32"
+DEFINE_INT64_T="#define int64_t gss64"
+DEFINE_UINT64_T="#define uint64_t gsu64"
+DEFINE_INTPTR_T="#define intptr_t gssaddr"
+DEFINE_UINTPTR_T="#define uintptr_t gsuaddr"
+else
+DEFINE_INT8_T=""
+DEFINE_UINT8_T=""
+DEFINE_INT16_T=""
+DEFINE_UINT16_T=""
+DEFINE_INT32_T=""
+DEFINE_UINT32_T=""
+DEFINE_INT64_T=""
+DEFINE_UINT64_T=""
+DEFINE_INTPTR_T=""
+DEFINE_UINTPTR_T=""
 fi
 
 
 
-cat >>confdefs.h <<_ACEOF
-#define NEED_WORD_ALIGNMENT $NEED_WORD_ALIGNMENT
-_ACEOF
 
-if test $NEED_WORD_ALIGNMENT = 1; then
-  { $as_echo "$as_me:$LINENO: result: yes" >&5
-$as_echo "yes" >&6; }
-else
-  { $as_echo "$as_me:$LINENO: result: no" >&5
-$as_echo "no" >&6; }
-fi
+
+
+
+
+
+
+
+
 
 #--------------------------------------------------------------------
-# This needed by NSString for handling of %@ printf directive.
+# These used by GSFileHandle.m and distributed objects
+# On some systems we need -lnsl ... so check for that first.
 #--------------------------------------------------------------------
-
-for ac_func in register_printf_specifier
-do
-as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
-{ $as_echo "$as_me:$LINENO: checking for $ac_func" >&5
-$as_echo_n "checking for $ac_func... " >&6; }
-if { as_var=$as_ac_var; eval "test \"\${$as_var+set}\" = set"; }; then
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for inet_ntop in -lnsl" >&5
+$as_echo_n "checking for inet_ntop in -lnsl... " >&6; }
+if ${ac_cv_lib_nsl_inet_ntop+:} false; then :
   $as_echo_n "(cached) " >&6
 else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lnsl  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
-/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.
-   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
-#define $ac_func innocuous_$ac_func
-
-/* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char $ac_func (); below.
-    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-    <limits.h> exists even on freestanding compilers.  */
-
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
-
-#undef $ac_func
 
 /* Override any GCC internal prototype to avoid an error.
    Use char because int might match the return type of a GCC
@@ -21151,62 +8942,40 @@ cat >>conftest.$ac_ext <<_ACEOF
 #ifdef __cplusplus
 extern "C"
 #endif
-char $ac_func ();
-/* The GNU C library defines this for functions which it implements
-    to always fail with ENOSYS.  Some functions are actually named
-    something starting with __ and the normal name is an alias.  */
-#if defined __stub_$ac_func || defined __stub___$ac_func
-choke me
-#endif
-
+char inet_ntop ();
 int
 main ()
 {
-return $ac_func ();
+return inet_ntop ();
   ;
   return 0;
 }
 _ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then
-  eval "$as_ac_var=yes"
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_nsl_inet_ntop=yes
 else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	eval "$as_ac_var=no"
+  ac_cv_lib_nsl_inet_ntop=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
 fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_nsl_inet_ntop" >&5
+$as_echo "$ac_cv_lib_nsl_inet_ntop" >&6; }
+if test "x$ac_cv_lib_nsl_inet_ntop" = xyes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_LIBNSL 1
+_ACEOF
+
+  LIBS="-lnsl $LIBS"
 
-rm -rf conftest.dSYM
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
 fi
-ac_res=`eval 'as_val=${'$as_ac_var'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-as_val=`eval 'as_val=${'$as_ac_var'}
-		 $as_echo "$as_val"'`
-   if test "x$as_val" = x""yes; then
+
+for ac_func in gethostbyaddr_r inet_aton inet_pton inet_ntop sigaction
+do :
+  as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
+ac_fn_c_check_func "$LINENO" "$ac_func" "$as_ac_var"
+if eval test \"x\$"$as_ac_var"\" = x"yes"; then :
   cat >>confdefs.h <<_ACEOF
 #define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
 _ACEOF
@@ -21214,33 +8983,29 @@ _ACEOF
 fi
 done
 
-{ $as_echo "$as_me:$LINENO: checking for register_printf_function" >&5
-$as_echo_n "checking for register_printf_function... " >&6; }
-if test "${ac_cv_func_register_printf_function+set}" = set; then
-  $as_echo_n "(cached) " >&6
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
+USE_ZLIB=0
+for ac_header in zlib.h
+do :
+  ac_fn_c_check_header_mongrel "$LINENO" "zlib.h" "ac_cv_header_zlib_h" "$ac_includes_default"
+if test "x$ac_cv_header_zlib_h" = xyes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_ZLIB_H 1
 _ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-/* Define register_printf_function to an innocuous variant, in case <limits.h> declares register_printf_function.
-   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
-#define register_printf_function innocuous_register_printf_function
 
-/* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char register_printf_function (); below.
-    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-    <limits.h> exists even on freestanding compilers.  */
+fi
 
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
+done
 
-#undef register_printf_function
+if test $ac_cv_header_zlib_h = yes; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for gzseek in -lz" >&5
+$as_echo_n "checking for gzseek in -lz... " >&6; }
+if ${ac_cv_lib_z_gzseek+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lz  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
 
 /* Override any GCC internal prototype to avoid an error.
    Use char because int might match the return type of a GCC
@@ -21248,274 +9013,194 @@ cat >>conftest.$ac_ext <<_ACEOF
 #ifdef __cplusplus
 extern "C"
 #endif
-char register_printf_function ();
-/* The GNU C library defines this for functions which it implements
-    to always fail with ENOSYS.  Some functions are actually named
-    something starting with __ and the normal name is an alias.  */
-#if defined __stub_register_printf_function || defined __stub___register_printf_function
-choke me
-#endif
-
+char gzseek ();
 int
 main ()
 {
-return register_printf_function ();
+return gzseek ();
   ;
   return 0;
 }
 _ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then
-  ac_cv_func_register_printf_function=yes
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_z_gzseek=yes
 else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_cv_func_register_printf_function=no
+  ac_cv_lib_z_gzseek=no
 fi
-
-rm -rf conftest.dSYM
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
 fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_func_register_printf_function" >&5
-$as_echo "$ac_cv_func_register_printf_function" >&6; }
-if test "x$ac_cv_func_register_printf_function" = x""yes; then
-  register_printf=1
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_z_gzseek" >&5
+$as_echo "$ac_cv_lib_z_gzseek" >&6; }
+if test "x$ac_cv_lib_z_gzseek" = xyes; then :
+  zlib_ok=yes
 else
-  register_printf=0
+  zlib_ok=no
 fi
 
-if test $register_printf = 1; then
-  if test "$cross_compiling" = yes; then
-  working_register_printf="$cross_working_register_printf"
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include "$srcdir/config/config.printf.c"
-_ACEOF
-rm -f conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  working_register_printf=1
-else
-  $as_echo "$as_me: program exited with status $ac_status" >&5
-$as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-( exit $ac_status )
-working_register_printf=0
+  if test "$zlib_ok" = yes; then
+    LIBS="$LIBS -lz"
+    USE_ZLIB=1
+  fi
 fi
-rm -rf conftest.dSYM
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+
+
+HAVE_INET_PTON=no
+if test $ac_cv_func_inet_pton = yes ; then
+  HAVE_INET_PTON=yes
 fi
 
 
-  if test $working_register_printf = 1; then
+HAVE_INET_NTOP=no
+if test $ac_cv_func_inet_ntop = yes ; then
+  HAVE_INET_NTOP=yes
+fi
 
-cat >>confdefs.h <<\_ACEOF
-#define HAVE_REGISTER_PRINTF_FUNCTION 1
-_ACEOF
 
-    if test "$cross_compiling" = yes; then
-  wide_register_printf="$cross_wide_register_printf"
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include "$srcdir/config/config.wprintf.c"
+#--------------------------------------------------------------------
+# For setting thread stack size
+#--------------------------------------------------------------------
+for ac_header in sys/resource.h
+do :
+  ac_fn_c_check_header_mongrel "$LINENO" "sys/resource.h" "ac_cv_header_sys_resource_h" "$ac_includes_default"
+if test "x$ac_cv_header_sys_resource_h" = xyes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_SYS_RESOURCE_H 1
 _ACEOF
-rm -f conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  wide_register_printf=1
-else
-  $as_echo "$as_me: program exited with status $ac_status" >&5
-$as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
 
-( exit $ac_status )
-wide_register_printf=0
 fi
-rm -rf conftest.dSYM
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
-fi
-
 
-    if test $wide_register_printf = 1; then
+done
 
-cat >>confdefs.h <<\_ACEOF
-#define HAVE_WIDE_PRINTF_FUNCTION 1
+for ac_func in setrlimit
+do :
+  ac_fn_c_check_func "$LINENO" "setrlimit" "ac_cv_func_setrlimit"
+if test "x$ac_cv_func_setrlimit" = xyes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_SETRLIMIT 1
 _ACEOF
 
-    fi
-  fi
 fi
+done
 
 
 #--------------------------------------------------------------------
-# This function needed by NSString.
+# One of these functions needed by NSDebug.m and NSProcessInfo.m
 #--------------------------------------------------------------------
+for ac_func in strerror
+do :
+  ac_fn_c_check_func "$LINENO" "strerror" "ac_cv_func_strerror"
+if test "x$ac_cv_func_strerror" = xyes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_STRERROR 1
+_ACEOF
 
-for ac_func in realpath
-do
-as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
-{ $as_echo "$as_me:$LINENO: checking for $ac_func" >&5
-$as_echo_n "checking for $ac_func... " >&6; }
-if { as_var=$as_ac_var; eval "test \"\${$as_var+set}\" = set"; }; then
-  $as_echo_n "(cached) " >&6
+fi
+done
+
+ac_fn_c_check_decl "$LINENO" "strerror_r" "ac_cv_have_decl_strerror_r" "$ac_includes_default"
+if test "x$ac_cv_have_decl_strerror_r" = xyes; then :
+  ac_have_decl=1
 else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.
-   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
-#define $ac_func innocuous_$ac_func
+  ac_have_decl=0
+fi
 
-/* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char $ac_func (); below.
-    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-    <limits.h> exists even on freestanding compilers.  */
+cat >>confdefs.h <<_ACEOF
+#define HAVE_DECL_STRERROR_R $ac_have_decl
+_ACEOF
 
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
+for ac_func in strerror_r
+do :
+  ac_fn_c_check_func "$LINENO" "strerror_r" "ac_cv_func_strerror_r"
+if test "x$ac_cv_func_strerror_r" = xyes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_STRERROR_R 1
+_ACEOF
 
-#undef $ac_func
+fi
+done
 
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char $ac_func ();
-/* The GNU C library defines this for functions which it implements
-    to always fail with ENOSYS.  Some functions are actually named
-    something starting with __ and the normal name is an alias.  */
-#if defined __stub_$ac_func || defined __stub___$ac_func
-choke me
-#endif
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether strerror_r returns char *" >&5
+$as_echo_n "checking whether strerror_r returns char *... " >&6; }
+if ${ac_cv_func_strerror_r_char_p+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
 
+    ac_cv_func_strerror_r_char_p=no
+    if test $ac_cv_have_decl_strerror_r = yes; then
+      cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+$ac_includes_default
 int
 main ()
 {
-return $ac_func ();
+
+	  char buf[100];
+	  char x = *strerror_r (0, buf, sizeof buf);
+	  char *p = strerror_r (0, buf, sizeof buf);
+	  return !p || x;
+
   ;
   return 0;
 }
 _ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then
-  eval "$as_ac_var=yes"
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_cv_func_strerror_r_char_p=yes
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+    else
+      # strerror_r is not declared.  Choose between
+      # systems that have relatively inaccessible declarations for the
+      # function.  BeOS and DEC UNIX 4.0 fall in this category, but the
+      # former has a strerror_r that returns char*, while the latter
+      # has a strerror_r that returns `int'.
+      # This test should segfault on the DEC system.
+      if test "$cross_compiling" = yes; then :
+  :
 else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+$ac_includes_default
+	extern char *strerror_r ();
+int
+main ()
+{
+char buf[100];
+	  char x = *strerror_r (0, buf, sizeof buf);
+	  return ! isalpha (x);
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_run "$LINENO"; then :
+  ac_cv_func_strerror_r_char_p=yes
+fi
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
+  conftest.$ac_objext conftest.beam conftest.$ac_ext
+fi
+
+    fi
 
-	eval "$as_ac_var=no"
 fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_func_strerror_r_char_p" >&5
+$as_echo "$ac_cv_func_strerror_r_char_p" >&6; }
+if test $ac_cv_func_strerror_r_char_p = yes; then
+
+$as_echo "#define STRERROR_R_CHAR_P 1" >>confdefs.h
 
-rm -rf conftest.dSYM
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
 fi
-ac_res=`eval 'as_val=${'$as_ac_var'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-as_val=`eval 'as_val=${'$as_ac_var'}
-		 $as_echo "$as_val"'`
-   if test "x$as_val" = x""yes; then
+
+
+#--------------------------------------------------------------------
+# Needed by NSDebug.m
+#--------------------------------------------------------------------
+for ac_func in sigsetjmp
+do :
+  ac_fn_c_check_func "$LINENO" "sigsetjmp" "ac_cv_func_sigsetjmp"
+if test "x$ac_cv_func_sigsetjmp" = xyes; then :
   cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
+#define HAVE_SIGSETJMP 1
 _ACEOF
 
 fi
@@ -21523,629 +9208,246 @@ done
 
 
 #--------------------------------------------------------------------
-# Check if the C Library defines extern char *program_invocation_name
-# Used in critical cases by NSProcessInfo.m
+# This type needed by GSFormat
 #--------------------------------------------------------------------
-{ $as_echo "$as_me:$LINENO: checking program_invocation_name in C Library" >&5
-$as_echo_n "checking program_invocation_name in C Library... " >&6; }
-if test "${gs_cv_program_invocation_name_worked+set}" = set; then
-  $as_echo_n "(cached) " >&6
-else
-  if test "$cross_compiling" = yes; then
-  gs_cv_program_invocation_name_worked="$cross_gs_cv_program_invocation_name_worked"
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-
-#include <string.h>
-int
-main (int argc, char *argv[])
-{
-  extern char *program_invocation_name;
-  return (strcmp (program_invocation_name, argv[0]));
-}
-
-_ACEOF
-rm -f conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  gs_cv_program_invocation_name_worked=yes
-else
-  $as_echo "$as_me: program exited with status $ac_status" >&5
-$as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
+ac_fn_c_check_type "$LINENO" "uintmax_t" "ac_cv_type_uintmax_t" "$ac_includes_default"
+if test "x$ac_cv_type_uintmax_t" = xyes; then :
 
-( exit $ac_status )
-gs_cv_program_invocation_name_worked=no
-fi
-rm -rf conftest.dSYM
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
-fi
+cat >>confdefs.h <<_ACEOF
+#define HAVE_UINTMAX_T 1
+_ACEOF
 
 
 fi
 
-if test $gs_cv_program_invocation_name_worked = yes; then
-
-cat >>confdefs.h <<\_ACEOF
-#define HAVE_PROGRAM_INVOCATION_NAME 1
+for ac_header in wchar.h
+do :
+  ac_fn_c_check_header_mongrel "$LINENO" "wchar.h" "ac_cv_header_wchar_h" "$ac_includes_default"
+if test "x$ac_cv_header_wchar_h" = xyes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_WCHAR_H 1
 _ACEOF
 
-  { $as_echo "$as_me:$LINENO: result: yes" >&5
-$as_echo "yes" >&6; }
-else
-  { $as_echo "$as_me:$LINENO: result: no" >&5
-$as_echo "no" >&6; }
 fi
 
+done
+
+
 #--------------------------------------------------------------------
-# Check for uname header used by NSProcessInfo.m
+# Check if short and int values need to be word aligned
 #--------------------------------------------------------------------
-
-for ac_header in sys/utsname.h
-do
-as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  { $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
-$as_echo_n "checking for $ac_header... " >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  $as_echo_n "(cached) " >&6
-fi
-ac_res=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking short/int needs to be word aligned" >&5
+$as_echo_n "checking short/int needs to be word aligned... " >&6; }
+if test "$cross_compiling" = yes; then :
+  NEED_WORD_ALIGNMENT="$cross_NEED_WORD_ALIGNMENT"
 else
-  # Is the header compilable?
-{ $as_echo "$as_me:$LINENO: checking $ac_header usability" >&5
-$as_echo_n "checking $ac_header usability... " >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
-$ac_includes_default
-#include <$ac_header>
+#include "$srcdir/config/config.align.c"
 _ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_header_compiler=yes
+if ac_fn_c_try_run "$LINENO"; then :
+  NEED_WORD_ALIGNMENT=0
 else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_header_compiler=no
+  NEED_WORD_ALIGNMENT=1
 fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-{ $as_echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
-$as_echo "$ac_header_compiler" >&6; }
-
-# Is the header present?
-{ $as_echo "$as_me:$LINENO: checking $ac_header presence" >&5
-$as_echo_n "checking $ac_header presence... " >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <$ac_header>
-_ACEOF
-if { (ac_try="$ac_cpp conftest.$ac_ext"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } >/dev/null && {
-	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       }; then
-  ac_header_preproc=yes
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-  ac_header_preproc=no
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
+  conftest.$ac_objext conftest.beam conftest.$ac_ext
 fi
 
-rm -f conftest.err conftest.$ac_ext
-{ $as_echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
-$as_echo "$ac_header_preproc" >&6; }
 
-# So?  What about this header?
-case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
-  yes:no: )
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
-$as_echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the compiler's result" >&5
-$as_echo "$as_me: WARNING: $ac_header: proceeding with the compiler's result" >&2;}
-    ac_header_preproc=yes
-    ;;
-  no:yes:* )
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
-$as_echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header:     check for missing prerequisite headers?" >&5
-$as_echo "$as_me: WARNING: $ac_header:     check for missing prerequisite headers?" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: see the Autoconf documentation" >&5
-$as_echo "$as_me: WARNING: $ac_header: see the Autoconf documentation" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&5
-$as_echo "$as_me: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
-$as_echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: in the future, the compiler will take precedence" >&5
-$as_echo "$as_me: WARNING: $ac_header: in the future, the compiler will take precedence" >&2;}
+cat >>confdefs.h <<_ACEOF
+#define NEED_WORD_ALIGNMENT $NEED_WORD_ALIGNMENT
+_ACEOF
 
-    ;;
-esac
-{ $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
-$as_echo_n "checking for $ac_header... " >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  $as_echo_n "(cached) " >&6
+if test $NEED_WORD_ALIGNMENT = 1; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
 else
-  eval "$as_ac_Header=\$ac_header_preproc"
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
 fi
-ac_res=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
 
-fi
-as_val=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-   if test "x$as_val" = x""yes; then
+#--------------------------------------------------------------------
+# This needed by NSString for handling of %@ printf directive.
+#--------------------------------------------------------------------
+for ac_func in register_printf_specifier
+do :
+  ac_fn_c_check_func "$LINENO" "register_printf_specifier" "ac_cv_func_register_printf_specifier"
+if test "x$ac_cv_func_register_printf_specifier" = xyes; then :
   cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
+#define HAVE_REGISTER_PRINTF_SPECIFIER 1
 _ACEOF
 
 fi
-
 done
 
-
-#--------------------------------------------------------------------
-# Check for sysctlbyname used by NSProcessInfo.m
-#--------------------------------------------------------------------
-
-for ac_header in sys/sysctl.h
-do
-as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  { $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
-$as_echo_n "checking for $ac_header... " >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  $as_echo_n "(cached) " >&6
+ac_fn_c_check_func "$LINENO" "register_printf_function" "ac_cv_func_register_printf_function"
+if test "x$ac_cv_func_register_printf_function" = xyes; then :
+  register_printf=1
+else
+  register_printf=0
 fi
-ac_res=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
+
+if test $register_printf = 1; then
+  if test "$cross_compiling" = yes; then :
+  working_register_printf="$cross_working_register_printf"
 else
-  # Is the header compilable?
-{ $as_echo "$as_me:$LINENO: checking $ac_header usability" >&5
-$as_echo_n "checking $ac_header usability... " >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
-$ac_includes_default
-#include <$ac_header>
+#include "$srcdir/config/config.printf.c"
 _ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_header_compiler=yes
+if ac_fn_c_try_run "$LINENO"; then :
+  working_register_printf=1
 else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_header_compiler=no
+  working_register_printf=0
+fi
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
+  conftest.$ac_objext conftest.beam conftest.$ac_ext
 fi
 
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-{ $as_echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
-$as_echo "$ac_header_compiler" >&6; }
+  if test $working_register_printf = 1; then
 
-# Is the header present?
-{ $as_echo "$as_me:$LINENO: checking $ac_header presence" >&5
-$as_echo_n "checking $ac_header presence... " >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+$as_echo "#define HAVE_REGISTER_PRINTF_FUNCTION 1" >>confdefs.h
+
+    if test "$cross_compiling" = yes; then :
+  wide_register_printf="$cross_wide_register_printf"
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
-#include <$ac_header>
+#include "$srcdir/config/config.wprintf.c"
 _ACEOF
-if { (ac_try="$ac_cpp conftest.$ac_ext"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } >/dev/null && {
-	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       }; then
-  ac_header_preproc=yes
+if ac_fn_c_try_run "$LINENO"; then :
+  wide_register_printf=1
 else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-  ac_header_preproc=no
+  wide_register_printf=0
+fi
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
+  conftest.$ac_objext conftest.beam conftest.$ac_ext
 fi
 
-rm -f conftest.err conftest.$ac_ext
-{ $as_echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
-$as_echo "$ac_header_preproc" >&6; }
+    if test $wide_register_printf = 1; then
 
-# So?  What about this header?
-case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
-  yes:no: )
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
-$as_echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the compiler's result" >&5
-$as_echo "$as_me: WARNING: $ac_header: proceeding with the compiler's result" >&2;}
-    ac_header_preproc=yes
-    ;;
-  no:yes:* )
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
-$as_echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header:     check for missing prerequisite headers?" >&5
-$as_echo "$as_me: WARNING: $ac_header:     check for missing prerequisite headers?" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: see the Autoconf documentation" >&5
-$as_echo "$as_me: WARNING: $ac_header: see the Autoconf documentation" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&5
-$as_echo "$as_me: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
-$as_echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: in the future, the compiler will take precedence" >&5
-$as_echo "$as_me: WARNING: $ac_header: in the future, the compiler will take precedence" >&2;}
+$as_echo "#define HAVE_WIDE_PRINTF_FUNCTION 1" >>confdefs.h
 
-    ;;
-esac
-{ $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
-$as_echo_n "checking for $ac_header... " >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  $as_echo_n "(cached) " >&6
-else
-  eval "$as_ac_Header=\$ac_header_preproc"
+    fi
+  fi
 fi
-ac_res=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
 
-fi
-as_val=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-   if test "x$as_val" = x""yes; then
+
+#--------------------------------------------------------------------
+# This function needed by NSString.
+#--------------------------------------------------------------------
+for ac_func in realpath
+do :
+  ac_fn_c_check_func "$LINENO" "realpath" "ac_cv_func_realpath"
+if test "x$ac_cv_func_realpath" = xyes; then :
   cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
+#define HAVE_REALPATH 1
 _ACEOF
 
 fi
-
 done
 
 
-for ac_func in sysctlbyname
-do
-as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
-{ $as_echo "$as_me:$LINENO: checking for $ac_func" >&5
-$as_echo_n "checking for $ac_func... " >&6; }
-if { as_var=$as_ac_var; eval "test \"\${$as_var+set}\" = set"; }; then
+#--------------------------------------------------------------------
+# Check if the C Library defines extern char *program_invocation_name
+# Used in critical cases by NSProcessInfo.m
+#--------------------------------------------------------------------
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking program_invocation_name in C Library" >&5
+$as_echo_n "checking program_invocation_name in C Library... " >&6; }
+if ${gs_cv_program_invocation_name_worked+:} false; then :
   $as_echo_n "(cached) " >&6
 else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+  if test "$cross_compiling" = yes; then :
+  gs_cv_program_invocation_name_worked="$cross_gs_cv_program_invocation_name_worked"
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
-/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.
-   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
-#define $ac_func innocuous_$ac_func
-
-/* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char $ac_func (); below.
-    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-    <limits.h> exists even on freestanding compilers.  */
-
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
-
-#undef $ac_func
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char $ac_func ();
-/* The GNU C library defines this for functions which it implements
-    to always fail with ENOSYS.  Some functions are actually named
-    something starting with __ and the normal name is an alias.  */
-#if defined __stub_$ac_func || defined __stub___$ac_func
-choke me
-#endif
 
+#include <string.h>
 int
-main ()
+main (int argc, char *argv[])
 {
-return $ac_func ();
-  ;
-  return 0;
+  extern char *program_invocation_name;
+  return (strcmp (program_invocation_name, argv[0]));
 }
+
 _ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then
-  eval "$as_ac_var=yes"
+if ac_fn_c_try_run "$LINENO"; then :
+  gs_cv_program_invocation_name_worked=yes
 else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	eval "$as_ac_var=no"
+  gs_cv_program_invocation_name_worked=no
 fi
-
-rm -rf conftest.dSYM
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
+  conftest.$ac_objext conftest.beam conftest.$ac_ext
 fi
-ac_res=`eval 'as_val=${'$as_ac_var'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-as_val=`eval 'as_val=${'$as_ac_var'}
-		 $as_echo "$as_val"'`
-   if test "x$as_val" = x""yes; then
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
-_ACEOF
 
 fi
-done
 
+if test $gs_cv_program_invocation_name_worked = yes; then
 
-#--------------------------------------------------------------------
-# Defines HAVE_PROCFS if the kernel supports the /proc filesystem.
-# Needed by NSProcessInfo.m
-#--------------------------------------------------------------------
+$as_echo "#define HAVE_PROGRAM_INVOCATION_NAME 1" >>confdefs.h
 
-for ac_header in procfs.h
-do
-as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  { $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
-$as_echo_n "checking for $ac_header... " >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  $as_echo_n "(cached) " >&6
-fi
-ac_res=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
 else
-  # Is the header compilable?
-{ $as_echo "$as_me:$LINENO: checking $ac_header usability" >&5
-$as_echo_n "checking $ac_header usability... " >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-#include <$ac_header>
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+#--------------------------------------------------------------------
+# Check for uname header used by NSProcessInfo.m
+#--------------------------------------------------------------------
+for ac_header in sys/utsname.h
+do :
+  ac_fn_c_check_header_mongrel "$LINENO" "sys/utsname.h" "ac_cv_header_sys_utsname_h" "$ac_includes_default"
+if test "x$ac_cv_header_sys_utsname_h" = xyes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_SYS_UTSNAME_H 1
 _ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_header_compiler=yes
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
 
-	ac_header_compiler=no
 fi
 
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-{ $as_echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
-$as_echo "$ac_header_compiler" >&6; }
+done
+
 
-# Is the header present?
-{ $as_echo "$as_me:$LINENO: checking $ac_header presence" >&5
-$as_echo_n "checking $ac_header presence... " >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <$ac_header>
+#--------------------------------------------------------------------
+# Check for sysctlbyname used by NSProcessInfo.m
+#--------------------------------------------------------------------
+for ac_header in sys/sysctl.h
+do :
+  ac_fn_c_check_header_mongrel "$LINENO" "sys/sysctl.h" "ac_cv_header_sys_sysctl_h" "$ac_includes_default"
+if test "x$ac_cv_header_sys_sysctl_h" = xyes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_SYS_SYSCTL_H 1
 _ACEOF
-if { (ac_try="$ac_cpp conftest.$ac_ext"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } >/dev/null && {
-	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       }; then
-  ac_header_preproc=yes
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
 
-  ac_header_preproc=no
 fi
 
-rm -f conftest.err conftest.$ac_ext
-{ $as_echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
-$as_echo "$ac_header_preproc" >&6; }
+done
 
-# So?  What about this header?
-case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
-  yes:no: )
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
-$as_echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the compiler's result" >&5
-$as_echo "$as_me: WARNING: $ac_header: proceeding with the compiler's result" >&2;}
-    ac_header_preproc=yes
-    ;;
-  no:yes:* )
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
-$as_echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header:     check for missing prerequisite headers?" >&5
-$as_echo "$as_me: WARNING: $ac_header:     check for missing prerequisite headers?" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: see the Autoconf documentation" >&5
-$as_echo "$as_me: WARNING: $ac_header: see the Autoconf documentation" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&5
-$as_echo "$as_me: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
-$as_echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: in the future, the compiler will take precedence" >&5
-$as_echo "$as_me: WARNING: $ac_header: in the future, the compiler will take precedence" >&2;}
+for ac_func in sysctlbyname
+do :
+  ac_fn_c_check_func "$LINENO" "sysctlbyname" "ac_cv_func_sysctlbyname"
+if test "x$ac_cv_func_sysctlbyname" = xyes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_SYSCTLBYNAME 1
+_ACEOF
 
-    ;;
-esac
-{ $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
-$as_echo_n "checking for $ac_header... " >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  $as_echo_n "(cached) " >&6
-else
-  eval "$as_ac_Header=\$ac_header_preproc"
 fi
-ac_res=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
+done
 
-fi
-as_val=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-   if test "x$as_val" = x""yes; then
+
+#--------------------------------------------------------------------
+# Defines HAVE_PROCFS if the kernel supports the /proc filesystem.
+# Needed by NSProcessInfo.m
+#--------------------------------------------------------------------
+for ac_header in procfs.h
+do :
+  ac_fn_c_check_header_mongrel "$LINENO" "procfs.h" "ac_cv_header_procfs_h" "$ac_includes_default"
+if test "x$ac_cv_header_procfs_h" = xyes; then :
   cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
+#define HAVE_PROCFS_H 1
 _ACEOF
 
 fi
@@ -22153,16 +9455,16 @@ fi
 done
 
  # Check whether --enable-procfs was given.
-if test "${enable_procfs+set}" = set; then
+if test "${enable_procfs+set}" = set; then :
   enableval=$enable_procfs; enable_procfs="$enableval"
 else
   if test "$cross_compiling" = yes; then enable_procfs=cross; else enable_procfs=yes; fi;
 fi
 
 
-  { $as_echo "$as_me:$LINENO: checking kernel support for /proc filesystem" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking kernel support for /proc filesystem" >&5
 $as_echo_n "checking kernel support for /proc filesystem... " >&6; }
-if test "${ac_cv_sys_procfs+set}" = set; then
+if ${ac_cv_sys_procfs+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   if test "$enable_procfs" = yes; then
@@ -22188,110 +9490,75 @@ else
     ac_cv_sys_procfs=no
   fi
 fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_sys_procfs" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_sys_procfs" >&5
 $as_echo "$ac_cv_sys_procfs" >&6; }
 
   if test "$enable_procfs" = cross; then
-    { $as_echo "$as_me:$LINENO: WARNING: Cross-compiling: Pass --enable-procfs argument to enable use of /proc filesystem." >&5
+    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: Cross-compiling: Pass --enable-procfs argument to enable use of /proc filesystem." >&5
 $as_echo "$as_me: WARNING: Cross-compiling: Pass --enable-procfs argument to enable use of /proc filesystem." >&2;}
   fi
   if test $ac_cv_sys_procfs = yes; then
 
-cat >>confdefs.h <<\_ACEOF
-#define HAVE_PROCFS 1
-_ACEOF
+$as_echo "#define HAVE_PROCFS 1" >>confdefs.h
 
   fi
 
 
  # Check whether --enable-procfs-psinfo was given.
-if test "${enable_procfs_psinfo+set}" = set; then
+if test "${enable_procfs_psinfo+set}" = set; then :
   enableval=$enable_procfs_psinfo; enable_procfs_psinfo="$enableval"
 else
   if test "$cross_compiling" = yes; then enable_procfs_psinfo=cross; else enable_procfs_psinfo=yes; fi;
 fi
 
 
-  { $as_echo "$as_me:$LINENO: checking support for /proc psinfo struct" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking support for /proc psinfo struct" >&5
 $as_echo_n "checking support for /proc psinfo struct... " >&6; }
-if test "${ac_cv_sys_procfs_psinfo+set}" = set; then
+if ${ac_cv_sys_procfs_psinfo+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   if test "$enable_procfs_psinfo" = yes; then
-    if test "$cross_compiling" = yes; then
+    if test "$cross_compiling" = yes; then :
   ac_cv_sys_procfs_psinfo=yes
 else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #include "$srcdir/config/config.psinfo.c"
 _ACEOF
-rm -f conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
+if ac_fn_c_try_run "$LINENO"; then :
   ac_cv_sys_procfs_psinfo=yes
 else
-  $as_echo "$as_me: program exited with status $ac_status" >&5
-$as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-( exit $ac_status )
-ac_cv_sys_procfs_psinfo=no
+  ac_cv_sys_procfs_psinfo=no
 fi
-rm -rf conftest.dSYM
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
+  conftest.$ac_objext conftest.beam conftest.$ac_ext
 fi
 
-
   elif test "$enable_procfs" = cross; then
     ac_cv_sys_procfs_psinfo=no
   else
     ac_cv_sys_procfs_psinfo=no
   fi
 fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_sys_procfs_psinfo" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_sys_procfs_psinfo" >&5
 $as_echo "$ac_cv_sys_procfs_psinfo" >&6; }
 
   if test "$enable_procfs" = cross; then
-    { $as_echo "$as_me:$LINENO: WARNING: Cross-compiling: Pass --enable-procfs-psinfo argument to enable use of /proc psinfo information." >&5
+    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: Cross-compiling: Pass --enable-procfs-psinfo argument to enable use of /proc psinfo information." >&5
 $as_echo "$as_me: WARNING: Cross-compiling: Pass --enable-procfs-psinfo argument to enable use of /proc psinfo information." >&2;}
   fi
   if test $ac_cv_sys_procfs_psinfo = yes; then
 
-cat >>confdefs.h <<\_ACEOF
-#define HAVE_PROCFS_PSINFO 1
-_ACEOF
+$as_echo "#define HAVE_PROCFS_PSINFO 1" >>confdefs.h
 
   fi
 
 
 
 
-  { $as_echo "$as_me:$LINENO: checking link to exe of process in /proc" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking link to exe of process in /proc" >&5
 $as_echo_n "checking link to exe of process in /proc... " >&6; }
-if test "${ac_cv_sys_procfs_exe_link+set}" = set; then
+if ${ac_cv_sys_procfs_exe_link+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   if test "$ac_cv_sys_procfs" = yes; then
@@ -22308,7 +9575,7 @@ else
       ac_cv_sys_procfs_exe_link=no
     fi
 fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_sys_procfs_exe_link" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_sys_procfs_exe_link" >&5
 $as_echo "$ac_cv_sys_procfs_exe_link" >&6; }
 
   if test "$ac_cv_sys_procfs_exe_link" != no; then
@@ -22323,65 +9590,34 @@ _ACEOF
 #--------------------------------------------------------------------
 # Check if /proc/$$/cmdline terminates the last argument with a nul
 #--------------------------------------------------------------------
-{ $as_echo "$as_me:$LINENO: checking /proc/$$/cmdline terminated by nul" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking /proc/$$/cmdline terminated by nul" >&5
 $as_echo_n "checking /proc/$$/cmdline terminated by nul... " >&6; }
-if test "$cross_compiling" = yes; then
+if test "$cross_compiling" = yes; then :
   CMDLINE_TERMINATED="$cross_CMDLINE_TERMINATED"
 else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #include "$srcdir/config/config.proccmd.c"
 _ACEOF
-rm -f conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
+if ac_fn_c_try_run "$LINENO"; then :
   CMDLINE_TERMINATED=1
 else
-  $as_echo "$as_me: program exited with status $ac_status" >&5
-$as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-( exit $ac_status )
-CMDLINE_TERMINATED=0
+  CMDLINE_TERMINATED=0
 fi
-rm -rf conftest.dSYM
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
+  conftest.$ac_objext conftest.beam conftest.$ac_ext
 fi
 
 
-
 cat >>confdefs.h <<_ACEOF
 #define CMDLINE_TERMINATED $CMDLINE_TERMINATED
 _ACEOF
 
 if test $CMDLINE_TERMINATED = 1; then
-  { $as_echo "$as_me:$LINENO: result: yes" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
 $as_echo "yes" >&6; }
 else
-  { $as_echo "$as_me:$LINENO: result: no" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
 fi
 
@@ -22390,19 +9626,14 @@ fi
 #--------------------------------------------------------------------
 have_kvm_env=0
 save_LIBS="$LIBS"
-
-{ $as_echo "$as_me:$LINENO: checking for kvm_getenvv in -lkvm" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for kvm_getenvv in -lkvm" >&5
 $as_echo_n "checking for kvm_getenvv in -lkvm... " >&6; }
-if test "${ac_cv_lib_kvm_kvm_getenvv+set}" = set; then
+if ${ac_cv_lib_kvm_kvm_getenvv+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
 LIBS="-lkvm  $LIBS"
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
 /* Override any GCC internal prototype to avoid an error.
@@ -22420,43 +9651,18 @@ return kvm_getenvv ();
   return 0;
 }
 _ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then
+if ac_fn_c_try_link "$LINENO"; then :
   ac_cv_lib_kvm_kvm_getenvv=yes
 else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_cv_lib_kvm_kvm_getenvv=no
+  ac_cv_lib_kvm_kvm_getenvv=no
 fi
-
-rm -rf conftest.dSYM
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_lib_kvm_kvm_getenvv" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_kvm_kvm_getenvv" >&5
 $as_echo "$ac_cv_lib_kvm_kvm_getenvv" >&6; }
-if test "x$ac_cv_lib_kvm_kvm_getenvv" = x""yes; then
+if test "x$ac_cv_lib_kvm_kvm_getenvv" = xyes; then :
   cat >>confdefs.h <<_ACEOF
 #define HAVE_LIBKVM 1
 _ACEOF
@@ -22466,65 +9672,32 @@ _ACEOF
 fi
 
 if test "$ac_cv_lib_kvm_kvm_getenvv" = yes; then
-  { $as_echo "$as_me:$LINENO: checking if we can access kernel memory" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if we can access kernel memory" >&5
 $as_echo_n "checking if we can access kernel memory... " >&6; }
-  if test "$cross_compiling" = yes; then
+  if test "$cross_compiling" = yes; then :
   have_kvm_env="$cross_have_kvm_env"
 else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #include "$srcdir/config/config.kvmopen.c"
 _ACEOF
-rm -f conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
+if ac_fn_c_try_run "$LINENO"; then :
   have_kvm_env=1
 else
-  $as_echo "$as_me: program exited with status $ac_status" >&5
-$as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-( exit $ac_status )
-have_kvm_env=0
+  have_kvm_env=0
 fi
-rm -rf conftest.dSYM
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
+  conftest.$ac_objext conftest.beam conftest.$ac_ext
 fi
 
-
   if test $have_kvm_env = 1; then
-    { $as_echo "$as_me:$LINENO: result: yes" >&5
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
 $as_echo "yes" >&6; }
 
-cat >>confdefs.h <<\_ACEOF
-#define HAVE_KVM_ENV 1
-_ACEOF
+$as_echo "#define HAVE_KVM_ENV 1" >>confdefs.h
 
   else
-    { $as_echo "$as_me:$LINENO: result: no" >&5
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
     # Reset LIBS since we don't need kvm
     LIBS="$save_LIBS"
@@ -22541,10 +9714,10 @@ case "$target_os" in
   cygwin*)	PASS_ARG=yes;;
 esac
 
-{ $as_echo "$as_me:$LINENO: checking use of pass-through arguments" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking use of pass-through arguments" >&5
 $as_echo_n "checking use of pass-through arguments... " >&6; }
 # Check whether --enable-pass-arguments was given.
-if test "${enable_pass_arguments+set}" = set; then
+if test "${enable_pass_arguments+set}" = set; then :
   enableval=$enable_pass_arguments;
 else
   enable_pass_arguments=$PASS_ARG
@@ -22557,13 +9730,13 @@ else
   GS_PASS_ARGUMENTS=0
 fi
 
-{ $as_echo "$as_me:$LINENO: result: $enable_pass_arguments" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $enable_pass_arguments" >&5
 $as_echo "$enable_pass_arguments" >&6; }
 
-{ $as_echo "$as_me:$LINENO: checking use of fake-main definition" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking use of fake-main definition" >&5
 $as_echo_n "checking use of fake-main definition... " >&6; }
 # Check whether --enable-fake-main was given.
-if test "${enable_fake_main+set}" = set; then
+if test "${enable_fake_main+set}" = set; then :
   enableval=$enable_fake_main;
 else
   enable_fake_main=no
@@ -22587,7 +9760,7 @@ elif test "$enable_pass_arguments" = "no"; then
   if test "$gs_cv_objc_load_method_worked" = yes -a \( "$ac_cv_sys_procfs" = yes -o "$have_kvm_env" = 1 -o "$ac_cv_sys_procfs_psinfo" = yes \); then
     GS_FAKE_MAIN=0
     if test "$have_kvm_env" = "1"; then
-      { $as_echo "$as_me:$LINENO: WARNING: Using libkvm which is known to be buggy on some systems consider configuring with --enable-fake-main instead." >&5
+      { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: Using libkvm which is known to be buggy on some systems consider configuring with --enable-fake-main instead." >&5
 $as_echo "$as_me: WARNING: Using libkvm which is known to be buggy on some systems consider configuring with --enable-fake-main instead." >&2;}
     fi
   else
@@ -22603,7 +9776,7 @@ case "$target_os" in
     mingw*)	enable_fake_main=no; GS_FAKE_MAIN=0;;
 esac
 
-{ $as_echo "$as_me:$LINENO: result: $enable_fake_main" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $enable_fake_main" >&5
 $as_echo "$enable_fake_main" >&6; }
 
 #--------------------------------------------------------------------
@@ -22611,7 +9784,7 @@ $as_echo "$enable_fake_main" >&6; }
 #--------------------------------------------------------------------
 
 # Check whether --with-include-flags was given.
-if test "${with_include_flags+set}" = set; then
+if test "${with_include_flags+set}" = set; then :
   withval=$with_include_flags; include_flags="$withval"
 else
   include_flags="no"
@@ -22624,7 +9797,7 @@ fi
 
 
 # Check whether --with-library-flags was given.
-if test "${with_library_flags+set}" = set; then
+if test "${with_library_flags+set}" = set; then :
   withval=$with_library_flags; library_flags="$withval"
 else
   library_flags="no"
@@ -22663,18 +9836,22 @@ if test "$exceptions" = "yes"; then
   do_broken_libffcall=yes
   do_enable_libffcall=no
 
-  if test "$have_unexpected" = "no"; then
-    echo
-    echo "Your gnustep-make is configured to use native objc exceptions, but"
-    echo "the objc runtime does not appear to support setting an uncaught"
-    echo "exception handler.  This means that any uncaught exception will"
-    echo "cause a program to abort immediately."
-    echo "Consider reconfiguring gnustep-make or updating libobjc to fix this."
+  if test "$have_set_uncaught_exception_handler" = "no"; then
+    if test "$have_set_unexpected" = "no"; then
+      if test "$have_unexpected" = "no"; then
+        echo
+        echo "Your gnustep-make is configured to use native objc exceptions, but"
+        echo "the objc runtime does not appear to support setting an uncaught"
+        echo "exception handler.  This means that any uncaught exception will"
+        echo "cause a program to abort immediately."
+        echo "Consider reconfiguring gnustep-make or updating libobjc to fix this."
+      fi
+    fi
   fi
 fi
 
 # Check whether --enable-libffi was given.
-if test "${enable_libffi+set}" = set; then
+if test "${enable_libffi+set}" = set; then :
   enableval=$enable_libffi;
 else
   enable_libffi=$do_enable_libffi
@@ -22682,7 +9859,7 @@ fi
 
 
 # Check whether --enable-ffcall was given.
-if test "${enable_ffcall+set}" = set; then
+if test "${enable_ffcall+set}" = set; then :
   enableval=$enable_ffcall;
 else
   enable_ffcall=$do_enable_libffcall
@@ -22690,12 +9867,12 @@ fi
 
 
 if test $enable_ffcall = yes; then
-  { $as_echo "$as_me:$LINENO: WARNING: ffcall has been enabled ... this is deprecated ... please install and use a recent libffi if possible" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: ffcall has been enabled ... this is deprecated ... please install and use a recent libffi if possible" >&5
 $as_echo "$as_me: WARNING: ffcall has been enabled ... this is deprecated ... please install and use a recent libffi if possible" >&2;}
 fi
 
 # Check whether --enable-invocations was given.
-if test "${enable_invocations+set}" = set; then
+if test "${enable_invocations+set}" = set; then :
   enableval=$enable_invocations;
 else
   enable_invocations=yes
@@ -22709,7 +9886,7 @@ fi
 
 
 # Check whether --with-ffi-include was given.
-if test "${with_ffi_include+set}" = set; then
+if test "${with_ffi_include+set}" = set; then :
   withval=$with_ffi_include; ffi_incdir="$withval"
 else
   ffi_incdir="no"
@@ -22722,312 +9899,52 @@ fi
 
 
 # Check whether --with-ffi-library was given.
-if test "${with_ffi_library+set}" = set; then
+if test "${with_ffi_library+set}" = set; then :
   withval=$with_ffi_library; ffi_libdir="$withval"
 else
   ffi_libdir="no"
 fi
 
-if test ${ffi_libdir} != "no"; then
-
-case "$target_os" in
-	netbsd*)
-		LDFLAGS="$LDFLAGS -L${ffi_libdir} -Wl,-R${ffi_libdir}"
-		LDIR_FLAGS="$LDIR_FLAGS -Wl,-R${ffi_libdir} -L${ffi_libdir}";;
-	*)
-		LDFLAGS="$LDFLAGS -L${ffi_libdir}"
-		LDIR_FLAGS="$LDIR_FLAGS -L${ffi_libdir}";;
-esac
-
-fi
-
-if test "$do_broken_libffi" = "no"; then
-  if test "$PKGCONFIG" = "yes"; then
-    if pkg-config --exists libffi; then
-      pkg_config_libffi=yes
-      ffi_CFLAGS=`pkg-config --cflags libffi`;
-      CPPFLAGS="$CPPFLAGS $ffi_CFLAGS"
-      INCLUDE_FLAGS="$INCLUDE_FLAGS $ffi_CFLAGS"
-    fi
-  fi
-  if test "${ac_cv_header_ffi_h+set}" = set; then
-  { $as_echo "$as_me:$LINENO: checking for ffi.h" >&5
-$as_echo_n "checking for ffi.h... " >&6; }
-if test "${ac_cv_header_ffi_h+set}" = set; then
-  $as_echo_n "(cached) " >&6
-fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_header_ffi_h" >&5
-$as_echo "$ac_cv_header_ffi_h" >&6; }
-else
-  # Is the header compilable?
-{ $as_echo "$as_me:$LINENO: checking ffi.h usability" >&5
-$as_echo_n "checking ffi.h usability... " >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-#include <ffi.h>
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_header_compiler=yes
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_header_compiler=no
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-{ $as_echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
-$as_echo "$ac_header_compiler" >&6; }
-
-# Is the header present?
-{ $as_echo "$as_me:$LINENO: checking ffi.h presence" >&5
-$as_echo_n "checking ffi.h presence... " >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <ffi.h>
-_ACEOF
-if { (ac_try="$ac_cpp conftest.$ac_ext"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } >/dev/null && {
-	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       }; then
-  ac_header_preproc=yes
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-  ac_header_preproc=no
-fi
-
-rm -f conftest.err conftest.$ac_ext
-{ $as_echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
-$as_echo "$ac_header_preproc" >&6; }
-
-# So?  What about this header?
-case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
-  yes:no: )
-    { $as_echo "$as_me:$LINENO: WARNING: ffi.h: accepted by the compiler, rejected by the preprocessor!" >&5
-$as_echo "$as_me: WARNING: ffi.h: accepted by the compiler, rejected by the preprocessor!" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: ffi.h: proceeding with the compiler's result" >&5
-$as_echo "$as_me: WARNING: ffi.h: proceeding with the compiler's result" >&2;}
-    ac_header_preproc=yes
-    ;;
-  no:yes:* )
-    { $as_echo "$as_me:$LINENO: WARNING: ffi.h: present but cannot be compiled" >&5
-$as_echo "$as_me: WARNING: ffi.h: present but cannot be compiled" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: ffi.h:     check for missing prerequisite headers?" >&5
-$as_echo "$as_me: WARNING: ffi.h:     check for missing prerequisite headers?" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: ffi.h: see the Autoconf documentation" >&5
-$as_echo "$as_me: WARNING: ffi.h: see the Autoconf documentation" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: ffi.h:     section \"Present But Cannot Be Compiled\"" >&5
-$as_echo "$as_me: WARNING: ffi.h:     section \"Present But Cannot Be Compiled\"" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: ffi.h: proceeding with the preprocessor's result" >&5
-$as_echo "$as_me: WARNING: ffi.h: proceeding with the preprocessor's result" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: ffi.h: in the future, the compiler will take precedence" >&5
-$as_echo "$as_me: WARNING: ffi.h: in the future, the compiler will take precedence" >&2;}
-
-    ;;
-esac
-{ $as_echo "$as_me:$LINENO: checking for ffi.h" >&5
-$as_echo_n "checking for ffi.h... " >&6; }
-if test "${ac_cv_header_ffi_h+set}" = set; then
-  $as_echo_n "(cached) " >&6
-else
-  ac_cv_header_ffi_h=$ac_header_preproc
-fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_header_ffi_h" >&5
-$as_echo "$ac_cv_header_ffi_h" >&6; }
-
-fi
-if test "x$ac_cv_header_ffi_h" = x""yes; then
-  have_libffi=yes
-else
-  have_libffi=no
-fi
-
-
-else
-  have_libffi=no
-fi
-if test "$do_broken_libffcall" = "no"; then
-
-for ac_header in callback.h
-do
-as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  { $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
-$as_echo_n "checking for $ac_header... " >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  $as_echo_n "(cached) " >&6
-fi
-ac_res=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-else
-  # Is the header compilable?
-{ $as_echo "$as_me:$LINENO: checking $ac_header usability" >&5
-$as_echo_n "checking $ac_header usability... " >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-#include <$ac_header>
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_header_compiler=yes
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_header_compiler=no
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-{ $as_echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
-$as_echo "$ac_header_compiler" >&6; }
-
-# Is the header present?
-{ $as_echo "$as_me:$LINENO: checking $ac_header presence" >&5
-$as_echo_n "checking $ac_header presence... " >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <$ac_header>
-_ACEOF
-if { (ac_try="$ac_cpp conftest.$ac_ext"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } >/dev/null && {
-	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       }; then
-  ac_header_preproc=yes
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-  ac_header_preproc=no
-fi
-
-rm -f conftest.err conftest.$ac_ext
-{ $as_echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
-$as_echo "$ac_header_preproc" >&6; }
-
-# So?  What about this header?
-case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
-  yes:no: )
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
-$as_echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the compiler's result" >&5
-$as_echo "$as_me: WARNING: $ac_header: proceeding with the compiler's result" >&2;}
-    ac_header_preproc=yes
-    ;;
-  no:yes:* )
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
-$as_echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header:     check for missing prerequisite headers?" >&5
-$as_echo "$as_me: WARNING: $ac_header:     check for missing prerequisite headers?" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: see the Autoconf documentation" >&5
-$as_echo "$as_me: WARNING: $ac_header: see the Autoconf documentation" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&5
-$as_echo "$as_me: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
-$as_echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: in the future, the compiler will take precedence" >&5
-$as_echo "$as_me: WARNING: $ac_header: in the future, the compiler will take precedence" >&2;}
+if test ${ffi_libdir} != "no"; then
 
-    ;;
+case "$target_os" in
+	netbsd*)
+		LDFLAGS="$LDFLAGS -L${ffi_libdir} -Wl,-R${ffi_libdir}"
+		LDIR_FLAGS="$LDIR_FLAGS -Wl,-R${ffi_libdir} -L${ffi_libdir}";;
+	*)
+		LDFLAGS="$LDFLAGS -L${ffi_libdir}"
+		LDIR_FLAGS="$LDIR_FLAGS -L${ffi_libdir}";;
 esac
-{ $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
-$as_echo_n "checking for $ac_header... " >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  $as_echo_n "(cached) " >&6
+
+fi
+
+if test "$do_broken_libffi" = "no"; then
+  if test "$PKGCONFIG" = "yes"; then
+    if pkg-config --exists libffi; then
+      pkg_config_libffi=yes
+      ffi_CFLAGS=`pkg-config --cflags libffi`;
+      CPPFLAGS="$CPPFLAGS $ffi_CFLAGS"
+      INCLUDE_FLAGS="$INCLUDE_FLAGS $ffi_CFLAGS"
+    fi
+  fi
+  ac_fn_c_check_header_mongrel "$LINENO" "ffi.h" "ac_cv_header_ffi_h" "$ac_includes_default"
+if test "x$ac_cv_header_ffi_h" = xyes; then :
+  have_libffi=yes
 else
-  eval "$as_ac_Header=\$ac_header_preproc"
+  have_libffi=no
 fi
-ac_res=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
 
+
+else
+  have_libffi=no
 fi
-as_val=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-   if test "x$as_val" = x""yes; then
+if test "$do_broken_libffcall" = "no"; then
+  for ac_header in callback.h
+do :
+  ac_fn_c_check_header_mongrel "$LINENO" "callback.h" "ac_cv_header_callback_h" "$ac_includes_default"
+if test "x$ac_cv_header_callback_h" = xyes; then :
   cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
+#define HAVE_CALLBACK_H 1
 _ACEOF
  have_ffcall=yes
 else
@@ -23051,7 +9968,7 @@ if test $have_libffi = no; then
   # If we don't have libffi but do have ffcall, use ffcall
   if test $have_ffcall = yes; then
     if test $enable_ffcall = no; then
-      { $as_echo "$as_me:$LINENO: WARNING: ffi support seems to be missing on this system ... please install a recent libffi" >&5
+      { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: ffi support seems to be missing on this system ... please install a recent libffi" >&5
 $as_echo "$as_me: WARNING: ffi support seems to be missing on this system ... please install a recent libffi" >&2;}
     fi
   fi
@@ -23060,77 +9977,35 @@ fi
 have_forward_hook=yes
 saved_CPPFLAGS="$CPPFLAGS"
 CPPFLAGS="$CPPFLAGS $OBJCFLAGS -x objective-c"
-{ $as_echo "$as_me:$LINENO: checking for forwarding callback in runtime" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for forwarding callback in runtime" >&5
 $as_echo_n "checking for forwarding callback in runtime... " >&6; }
-cat >conftest.$ac_ext <<_ACEOF
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
 #include "$srcdir/config/config.forward2.m"
 _ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
+if ac_fn_c_try_compile "$LINENO"; then :
   have_forward_hook=yes
 else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	have_forward_hook=no
+  have_forward_hook=no
 fi
-
 rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
 if test $have_forward_hook = yes; then
 
-cat >>confdefs.h <<\_ACEOF
-#define HAVE_FORWARD2 1
-_ACEOF
+$as_echo "#define HAVE_FORWARD2 1" >>confdefs.h
 
 else
-  cat >conftest.$ac_ext <<_ACEOF
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
 #include "$srcdir/config/config.forward.m"
 _ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
+if ac_fn_c_try_compile "$LINENO"; then :
   have_forward_hook=yes
 else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	have_forward_hook=no
+  have_forward_hook=no
 fi
-
 rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
 fi
-{ $as_echo "$as_me:$LINENO: result: $have_forward_hook" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $have_forward_hook" >&5
 $as_echo "$have_forward_hook" >&6; }
 if test $have_forward_hook = no; then
   enable_libffi=no
@@ -23138,14 +10013,12 @@ if test $have_forward_hook = no; then
 fi
 CPPFLAGS="$saved_CPPFLAGS"
 
-{ $as_echo "$as_me:$LINENO: checking FFI library usage" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking FFI library usage" >&5
 $as_echo_n "checking FFI library usage... " >&6; }
 WITH_FFI=none
 if test $enable_libffi = yes; then
 
-cat >>confdefs.h <<\_ACEOF
-#define USE_LIBFFI 1
-_ACEOF
+$as_echo "#define USE_LIBFFI 1" >>confdefs.h
 
   WITH_FFI=libffi
   if test "$pkg_config_libffi" = "yes"; then
@@ -23154,179 +10027,50 @@ _ACEOF
     ffi_LIBS=-lffi
   fi
   LIBS="$ffi_LIBS $LIBS"
-  if test "$cross_compiling" = yes; then
+  if test "$cross_compiling" = yes; then :
   ffi_ok="$cross_ffi_ok"
 else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #include "$srcdir/config/config.ffi.c"
 _ACEOF
-rm -f conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
+if ac_fn_c_try_run "$LINENO"; then :
   ffi_ok="yes"
 else
-  $as_echo "$as_me: program exited with status $ac_status" >&5
-$as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-( exit $ac_status )
-ffi_ok="no"
+  ffi_ok="no"
 fi
-rm -rf conftest.dSYM
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
+  conftest.$ac_objext conftest.beam conftest.$ac_ext
 fi
 
-
   if test $ffi_ok = yes; then
-    { $as_echo "$as_me:$LINENO: result: libffi" >&5
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: libffi" >&5
 $as_echo "libffi" >&6; }
     if test $do_broken_libffi = yes; then
-      { $as_echo "$as_me:$LINENO: WARNING: ffi may be broken on this system ... try enabling ffcall" >&5
+      { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: ffi may be broken on this system ... try enabling ffcall" >&5
 $as_echo "$as_me: WARNING: ffi may be broken on this system ... try enabling ffcall" >&2;}
     fi
-
-for ac_func in ffi_prep_closure_loc
-do
-as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
-{ $as_echo "$as_me:$LINENO: checking for $ac_func" >&5
-$as_echo_n "checking for $ac_func... " >&6; }
-if { as_var=$as_ac_var; eval "test \"\${$as_var+set}\" = set"; }; then
-  $as_echo_n "(cached) " >&6
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.
-   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
-#define $ac_func innocuous_$ac_func
-
-/* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char $ac_func (); below.
-    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-    <limits.h> exists even on freestanding compilers.  */
-
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
-
-#undef $ac_func
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char $ac_func ();
-/* The GNU C library defines this for functions which it implements
-    to always fail with ENOSYS.  Some functions are actually named
-    something starting with __ and the normal name is an alias.  */
-#if defined __stub_$ac_func || defined __stub___$ac_func
-choke me
-#endif
-
-int
-main ()
-{
-return $ac_func ();
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then
-  eval "$as_ac_var=yes"
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	eval "$as_ac_var=no"
-fi
-
-rm -rf conftest.dSYM
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
-fi
-ac_res=`eval 'as_val=${'$as_ac_var'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-as_val=`eval 'as_val=${'$as_ac_var'}
-		 $as_echo "$as_val"'`
-   if test "x$as_val" = x""yes; then
+    for ac_func in ffi_prep_closure_loc
+do :
+  ac_fn_c_check_func "$LINENO" "ffi_prep_closure_loc" "ac_cv_func_ffi_prep_closure_loc"
+if test "x$ac_cv_func_ffi_prep_closure_loc" = xyes; then :
   cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
+#define HAVE_FFI_PREP_CLOSURE_LOC 1
 _ACEOF
 
 fi
 done
 
   else
-    { { $as_echo "$as_me:$LINENO: error: The ffi library (libffi) does not appear to be working.  Perhaps it's missing or you need a more recent version.  Version 3.0.9 or later should work, and you can find a link to it n the list of packages for download at http://www.gnustep.org/resources/sources.html" >&5
-$as_echo "$as_me: error: The ffi library (libffi) does not appear to be working.  Perhaps it's missing or you need a more recent version.  Version 3.0.9 or later should work, and you can find a link to it n the list of packages for download at http://www.gnustep.org/resources/sources.html" >&2;}
-   { (exit 1); exit 1; }; }
+    as_fn_error $? "The ffi library (libffi) does not appear to be working.  Perhaps it's missing or you need a more recent version.  Version 3.0.9 or later should work, and you can find a link to it n the list of packages for download at http://www.gnustep.org/resources/sources.html" "$LINENO" 5
   fi
 elif test $enable_ffcall = yes; then
 
-cat >>confdefs.h <<\_ACEOF
-#define USE_FFCALL 1
-_ACEOF
+$as_echo "#define USE_FFCALL 1" >>confdefs.h
 
   WITH_FFI=ffcall
   LIBS="-lcallback -lavcall $LIBS"
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #include <callback.h>
 int
@@ -23337,132 +10081,81 @@ main ()
   return 0;
 }
 _ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then
+if ac_fn_c_try_link "$LINENO"; then :
   ffi_ok="yes"
 else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ffi_ok="no"
+  ffi_ok="no"
 fi
-
-rm -rf conftest.dSYM
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
   if test $ffi_ok = yes; then
-    { $as_echo "$as_me:$LINENO: result: ffcall" >&5
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: ffcall" >&5
 $as_echo "ffcall" >&6; }
   fi
-  { $as_echo "$as_me:$LINENO: WARNING: ffcall is broken on some systems and is deprecated ... try enabling ffi" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: ffcall is broken on some systems and is deprecated ... try enabling ffi" >&5
 $as_echo "$as_me: WARNING: ffcall is broken on some systems and is deprecated ... try enabling ffi" >&2;}
 else
   ffi_ok=no
 fi
 
 if test $enable_ffcall = yes -a $ffi_ok = yes; then
-  { $as_echo "$as_me:$LINENO: checking if ffcall trampolines work" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if ffcall trampolines work" >&5
 $as_echo_n "checking if ffcall trampolines work... " >&6; }
-  if test "$cross_compiling" = yes; then
+  if test "$cross_compiling" = yes; then :
   have_working_trampoline=yes
 else
-  cat >conftest.$ac_ext <<_ACEOF
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
 #include "$srcdir/config/config.trampoline.c"
 _ACEOF
-rm -f conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
+if ac_fn_c_try_run "$LINENO"; then :
   have_working_trampoline=yes
 else
-  $as_echo "$as_me: program exited with status $ac_status" >&5
-$as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-( exit $ac_status )
-have_working_trampoline=no
+  have_working_trampoline=no
 fi
-rm -rf conftest.dSYM
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
+  conftest.$ac_objext conftest.beam conftest.$ac_ext
 fi
 
-
-  { $as_echo "$as_me:$LINENO: result: $have_working_trampoline" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $have_working_trampoline" >&5
 $as_echo "$have_working_trampoline" >&6; }
 fi
 
-if test $ffi_ok = no; then
-  { $as_echo "$as_me:$LINENO: result: none" >&5
-$as_echo "none" >&6; }
-  echo
-  if test $have_forward_hook = no; then
-    echo "You do not have an up-to-date libobjc library installed"
-  elif test "$have_working_trampoline" = no; then
-    echo "You have ffcall, but it does not work properly. Most likely because"
-    echo "your system's security policy is blocking some parts of ffcall"
-    echo "we recommend installing libffi instead."
-  else
-    echo "You do not have either ffcall or libffi installed/enabled, or configure needs"
-    echo "--with-ffi-include and/or --with-ffi-library flags so GNUstep can find them,"
-    echo "or you have ffcall but gnustep-make is configured to use native exceptions"
-    echo "(native exceptions are not compatible with ffcall)."
-  fi
-  echo "GNUstep requires libffi (or ffcall) and proper libobjc hooks to do"
-  echo "invocations and DO."
-  echo "(This does not apply on apple-apple-apple systems where DO is"
-  echo "not compatible with other GNUstep systems.)"
-  if test $enable_invocations = yes; then
-    echo
-    echo "You most likely do not want to build base without invocation support."
-    echo "Many things (including Distributed Objects and undo/redo), won't work"
-    echo "at all without invocations."
-    echo "If you really want to build -base without invocation support,"
-    echo "add --disable-invocations to the configure arguments."
-    echo "For more information, read the GNUstep build guide, ffcall section:"
-    echo "http://gnustep.made-it.com/BuildGuide/index.html"
-    { { $as_echo "$as_me:$LINENO: error: Incomplete support for ffi functionality." >&5
-$as_echo "$as_me: error: Incomplete support for ffi functionality." >&2;}
-   { (exit 1); exit 1; }; }
-  fi
-  { $as_echo "$as_me:$LINENO: WARNING: Incomplete support for ffi funtionality." >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ffi_ok" >&5
+$as_echo "$ffi_ok" >&6; }
+if test "$OBJC_RUNTIME_LIB" != "nx" -a "$OBJC_RUNTIME_LIB" != "apple"; then
+    if test $ffi_ok = no; then
+      echo
+      if test $have_forward_hook = no; then
+        echo "You do not have an up-to-date libobjc library installed"
+      elif test "$have_working_trampoline" = no; then
+        echo "You have ffcall, but it does not work properly. Most likely because"
+        echo "your system's security policy is blocking some parts of ffcall"
+        echo "we recommend installing libffi instead."
+      else
+        echo "You do not have either ffcall or libffi installed/enabled, or configure needs"
+        echo "--with-ffi-include and/or --with-ffi-library flags so GNUstep can find them,"
+        echo "or you have ffcall but gnustep-make is configured to use native exceptions"
+        echo "(native exceptions are not compatible with ffcall)."
+      fi
+      echo "GNUstep requires libffi (or ffcall) and proper libobjc hooks to do"
+      echo "invocations and DO."
+      echo "(This does not apply on apple-apple-apple systems where DO is"
+      echo "not compatible with other GNUstep systems.)"
+      if test $enable_invocations = yes; then
+        echo
+        echo "You most likely do not want to build base without invocation support."
+        echo "Many things (including Distributed Objects and undo/redo), won't work"
+        echo "at all without invocations."
+        echo "If you really want to build -base without invocation support,"
+        echo "add --disable-invocations to the configure arguments."
+        echo "For more information, read the GNUstep build guide, ffcall section:"
+        echo "http://gnustep.made-it.com/BuildGuide/index.html"
+        as_fn_error $? "Incomplete support for ffi functionality." "$LINENO" 5
+      fi
+      { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: Incomplete support for ffi funtionality." >&5
 $as_echo "$as_me: WARNING: Incomplete support for ffi funtionality." >&2;}
+    fi
 fi
 
 
@@ -23487,7 +10180,7 @@ fi
 # First, check if there's a working iconv in libc (ie. if the test program
 # runs without any extra flags).
 # Check whether --enable-iconv was given.
-if test "${enable_iconv+set}" = set; then
+if test "${enable_iconv+set}" = set; then :
   enableval=$enable_iconv;
 else
   enable_iconv=yes
@@ -23495,70 +10188,42 @@ fi
 
 
 if test $enable_iconv = yes; then
-{ $as_echo "$as_me:$LINENO: checking iconv support" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking iconv support" >&5
 $as_echo_n "checking iconv support... " >&6; }
-if test "$cross_compiling" = yes; then
+if test "$cross_compiling" = yes; then :
   found_iconv="$cross_found_iconv_libc"
 else
-  cat >conftest.$ac_ext <<_ACEOF
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
 #include <iconv.h>
 int main(int argc,char **argv)
 { return iconv_open("UTF-8//TRANSLIT","ASCII") == -1 ? 1 : 0; }
 
 _ACEOF
-rm -f conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
+if ac_fn_c_try_run "$LINENO"; then :
   # libc has a working iconv.
 
-cat >>confdefs.h <<\_ACEOF
-#define HAVE_ICONV 1
-_ACEOF
+$as_echo "#define HAVE_ICONV 1" >>confdefs.h
 
-  { $as_echo "$as_me:$LINENO: result: yes, in libc" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes, in libc" >&5
 $as_echo "yes, in libc" >&6; }
   found_iconv=yes
 
 else
-  $as_echo "$as_me: program exited with status $ac_status" >&5
-$as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-( exit $ac_status )
-found_iconv=no
+  found_iconv=no
 
 fi
-rm -rf conftest.dSYM
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
+  conftest.$ac_objext conftest.beam conftest.$ac_ext
 fi
 
 
-
 if test $found_iconv = no ; then
   # libc doesn't have a working iconv with translit.
   # Try adding -liconv and any user supplied directory.
 
 # Check whether --with-libiconv-library was given.
-if test "${with_libiconv_library+set}" = set; then
+if test "${with_libiconv_library+set}" = set; then :
   withval=$with_libiconv_library; libiconv_libdir="$withval"
 else
   libiconv_libdir="no"
@@ -23580,66 +10245,38 @@ esac
 
   old_LIBS="$LIBS"
   LIBS="-liconv $LIBS"
-  if test "$cross_compiling" = yes; then
+  if test "$cross_compiling" = yes; then :
   found_iconv="$cross_found_iconv_liconv";
     if test "$found_iconv" = "no"; then
       LIBS="$old_LIBS"
     fi
 
 else
-  cat >conftest.$ac_ext <<_ACEOF
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
 #include <iconv.h>
   int main(int argc,char **argv)
   { return iconv_open("UTF-8//TRANSLIT","ASCII") == -1 ? 1 : 0; }
 
 _ACEOF
-rm -f conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
+if ac_fn_c_try_run "$LINENO"; then :
   # -liconv works.
 
-cat >>confdefs.h <<\_ACEOF
-#define HAVE_ICONV 1
-_ACEOF
+$as_echo "#define HAVE_ICONV 1" >>confdefs.h
 
-    { $as_echo "$as_me:$LINENO: result: yes, -liconv" >&5
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes, -liconv" >&5
 $as_echo "yes, -liconv" >&6; }
     found_iconv=yes
 
 else
-  $as_echo "$as_me: program exited with status $ac_status" >&5
-$as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-( exit $ac_status )
-found_iconv=no
+  found_iconv=no
     LIBS="$old_LIBS"
 
 fi
-rm -rf conftest.dSYM
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
+  conftest.$ac_objext conftest.beam conftest.$ac_ext
 fi
 
-
 fi
 
 if test $found_iconv = no ; then
@@ -23647,150 +10284,89 @@ if test $found_iconv = no ; then
   # BSDs install this lib as libgiconv.
   old_LIBS="$LIBS"
   LIBS="-lgiconv $LIBS"
-  if test "$cross_compiling" = yes; then
+  if test "$cross_compiling" = yes; then :
   found_iconv="$cross_found_iconv_lgiconv";
     if test "$found_iconv" = "no"; then
       LIBS="$old_LIBS"
     fi
 
 else
-  cat >conftest.$ac_ext <<_ACEOF
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
 #include <giconv.h>
   int main(int argc,char **argv)
   { return iconv_open("UTF-8//TRANSLIT","ASCII") == -1 ? 1 : 0; }
 
 _ACEOF
-rm -f conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
+if ac_fn_c_try_run "$LINENO"; then :
 
-cat >>confdefs.h <<\_ACEOF
-#define HAVE_ICONV 1
-_ACEOF
+$as_echo "#define HAVE_ICONV 1" >>confdefs.h
 
 
-cat >>confdefs.h <<\_ACEOF
-#define HAVE_GICONV 1
-_ACEOF
+$as_echo "#define HAVE_GICONV 1" >>confdefs.h
 
-    { $as_echo "$as_me:$LINENO: result: yes, -lgiconv" >&5
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes, -lgiconv" >&5
 $as_echo "yes, -lgiconv" >&6; }
     found_iconv=yes
 
 else
-  $as_echo "$as_me: program exited with status $ac_status" >&5
-$as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-( exit $ac_status )
-found_iconv=no
+  found_iconv=no
     LIBS="$old_LIBS"
 
 fi
-rm -rf conftest.dSYM
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
+  conftest.$ac_objext conftest.beam conftest.$ac_ext
 fi
 
-
 fi
 
 # Check whether --enable-stricticonv was given.
-if test "${enable_stricticonv+set}" = set; then
+if test "${enable_stricticonv+set}" = set; then :
   enableval=$enable_stricticonv;
 else
   enable_stricticonv=no
 fi
 
-if test $enable_stricticonv = yes; then
-{ $as_echo "$as_me:$LINENO: checking non-lossy iconv support" >&5
-$as_echo_n "checking non-lossy iconv support... " >&6; }
-if test "$cross_compiling" = yes; then
-  { { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
-$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-{ { $as_echo "$as_me:$LINENO: error: cannot run test program while cross compiling
-See \`config.log' for more details." >&5
-$as_echo "$as_me: error: cannot run test program while cross compiling
-See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; }; }
-else
-  cat >conftest.$ac_ext <<_ACEOF
-#include <iconv.h>
-int main(int argc,char **argv)
-{ return iconv_open("UTF-8","ASCII") == -1 ? 1 : 0; }
-
-_ACEOF
-rm -f conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  # libc has a working iconv.
-
-cat >>confdefs.h <<\_ACEOF
-#define HAVE_ICONV 1
+if test $enable_stricticonv = yes; then
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking non-lossy iconv support" >&5
+$as_echo_n "checking non-lossy iconv support... " >&6; }
+if test "$cross_compiling" = yes; then :
+  { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+as_fn_error $? "cannot run test program while cross compiling
+See \`config.log' for more details" "$LINENO" 5; }
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <iconv.h>
+int main(int argc,char **argv)
+{ return iconv_open("UTF-8","ASCII") == -1 ? 1 : 0; }
+
 _ACEOF
+if ac_fn_c_try_run "$LINENO"; then :
+  # libc has a working iconv.
 
-  { $as_echo "$as_me:$LINENO: result: yes, in libc" >&5
+$as_echo "#define HAVE_ICONV 1" >>confdefs.h
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes, in libc" >&5
 $as_echo "yes, in libc" >&6; }
   found_iconv=yes
 
 else
-  $as_echo "$as_me: program exited with status $ac_status" >&5
-$as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-( exit $ac_status )
-found_iconv=no
+  found_iconv=no
 
 fi
-rm -rf conftest.dSYM
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
+  conftest.$ac_objext conftest.beam conftest.$ac_ext
 fi
 
 
-
 if test $found_iconv = no ; then
   # libc doesn't have a working iconv. Try adding -liconv and any user
   # supplied directory.
 
 # Check whether --with-libiconv-library was given.
-if test "${with_libiconv_library+set}" = set; then
+if test "${with_libiconv_library+set}" = set; then :
   withval=$with_libiconv_library; libiconv_libdir="$withval"
 else
   libiconv_libdir="no"
@@ -23812,68 +10388,37 @@ esac
 
   old_LIBS="$LIBS"
   LIBS="-liconv $LIBS"
-  if test "$cross_compiling" = yes; then
-  { { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+  if test "$cross_compiling" = yes; then :
+  { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
 $as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-{ { $as_echo "$as_me:$LINENO: error: cannot run test program while cross compiling
-See \`config.log' for more details." >&5
-$as_echo "$as_me: error: cannot run test program while cross compiling
-See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; }; }
+as_fn_error $? "cannot run test program while cross compiling
+See \`config.log' for more details" "$LINENO" 5; }
 else
-  cat >conftest.$ac_ext <<_ACEOF
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
 #include <iconv.h>
   int main(int argc,char **argv)
   { return iconv_open("UTF-8","ASCII") == -1 ? 1 : 0; }
 
 _ACEOF
-rm -f conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
+if ac_fn_c_try_run "$LINENO"; then :
   # -liconv works.
 
-cat >>confdefs.h <<\_ACEOF
-#define HAVE_ICONV 1
-_ACEOF
+$as_echo "#define HAVE_ICONV 1" >>confdefs.h
 
-    { $as_echo "$as_me:$LINENO: result: yes, -liconv" >&5
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes, -liconv" >&5
 $as_echo "yes, -liconv" >&6; }
     found_iconv=yes
 
 else
-  $as_echo "$as_me: program exited with status $ac_status" >&5
-$as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-( exit $ac_status )
-found_iconv=no
+  found_iconv=no
     LIBS="$old_LIBS"
 
 fi
-rm -rf conftest.dSYM
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
+  conftest.$ac_objext conftest.beam conftest.$ac_ext
 fi
 
-
 fi
 
 if test $found_iconv = no ; then
@@ -23881,86 +10426,51 @@ if test $found_iconv = no ; then
   # BSDs install this lib as libgiconv.
   old_LIBS="$LIBS"
   LIBS="-lgiconv $LIBS"
-  if test "$cross_compiling" = yes; then
-  { { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+  if test "$cross_compiling" = yes; then :
+  { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
 $as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-{ { $as_echo "$as_me:$LINENO: error: cannot run test program while cross compiling
-See \`config.log' for more details." >&5
-$as_echo "$as_me: error: cannot run test program while cross compiling
-See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; }; }
+as_fn_error $? "cannot run test program while cross compiling
+See \`config.log' for more details" "$LINENO" 5; }
 else
-  cat >conftest.$ac_ext <<_ACEOF
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
 #include <giconv.h>
   int main(int argc,char **argv)
   { return iconv_open("UTF-8","ASCII") == -1 ? 1 : 0; }
 
 _ACEOF
-rm -f conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
+if ac_fn_c_try_run "$LINENO"; then :
 
-cat >>confdefs.h <<\_ACEOF
-#define HAVE_ICONV 1
-_ACEOF
+$as_echo "#define HAVE_ICONV 1" >>confdefs.h
 
 
-cat >>confdefs.h <<\_ACEOF
-#define HAVE_GICONV 1
-_ACEOF
+$as_echo "#define HAVE_GICONV 1" >>confdefs.h
 
-    { $as_echo "$as_me:$LINENO: result: yes, -lgiconv" >&5
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes, -lgiconv" >&5
 $as_echo "yes, -lgiconv" >&6; }
     found_iconv=yes
 
 else
-  $as_echo "$as_me: program exited with status $ac_status" >&5
-$as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-( exit $ac_status )
-found_iconv=no
+  found_iconv=no
     LIBS="$old_LIBS"
 
 fi
-rm -rf conftest.dSYM
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
+  conftest.$ac_objext conftest.beam conftest.$ac_ext
 fi
 
-
 fi
 fi
 
 if test $found_iconv = no ; then
-  { $as_echo "$as_me:$LINENO: result: no" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
   echo
   echo "You do not appear to have usable iconv header/library."
   echo "Building without them will disable much characterset support."
   echo "If you really want to build gnustep-base without character conversion"
   echo " support, please add --disable-iconv to the configure arguments."
-  { { $as_echo "$as_me:$LINENO: error: Missing support for character conversion functionality." >&5
-$as_echo "$as_me: error: Missing support for character conversion functionality." >&2;}
-   { (exit 1); exit 1; }; }
+  as_fn_error $? "Missing support for character conversion functionality." "$LINENO" 5
 fi
 fi
 
@@ -23969,7 +10479,7 @@ fi
 # See DEPENDENCIES POLICY at the start of this file.
 #--------------------------------------------------------------------
 # Check whether --enable-xml was given.
-if test "${enable_xml+set}" = set; then
+if test "${enable_xml+set}" = set; then :
   enableval=$enable_xml;
 else
   enable_xml=yes
@@ -23985,14 +10495,14 @@ if test $enable_xml = yes; then
 
 
 # Check whether --with-xml-prefix was given.
-if test "${with_xml_prefix+set}" = set; then
+if test "${with_xml_prefix+set}" = set; then :
   withval=$with_xml_prefix; xml_config_prefix="$withval"
 else
   xml_config_prefix=""
 fi
 
 # Check whether --enable-xmltest was given.
-if test "${enable_xmltest+set}" = set; then
+if test "${enable_xmltest+set}" = set; then :
   enableval=$enable_xmltest;
 else
   enable_xmltest=yes
@@ -24011,9 +10521,9 @@ fi
 
   # Extract the first word of "xml2-config", so it can be a program name with args.
 set dummy xml2-config; ac_word=$2
-{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_path_XML2_CONFIG+set}" = set; then
+if ${ac_cv_path_XML2_CONFIG+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   case $XML2_CONFIG in
@@ -24026,14 +10536,14 @@ for as_dir in $PATH
 do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
-  for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_path_XML2_CONFIG="$as_dir/$ac_word$ac_exec_ext"
-    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
-done
+  done
 IFS=$as_save_IFS
 
   test -z "$ac_cv_path_XML2_CONFIG" && ac_cv_path_XML2_CONFIG="no"
@@ -24042,10 +10552,10 @@ esac
 fi
 XML2_CONFIG=$ac_cv_path_XML2_CONFIG
 if test -n "$XML2_CONFIG"; then
-  { $as_echo "$as_me:$LINENO: result: $XML2_CONFIG" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $XML2_CONFIG" >&5
 $as_echo "$XML2_CONFIG" >&6; }
 else
-  { $as_echo "$as_me:$LINENO: result: no" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
 fi
 
@@ -24053,9 +10563,9 @@ fi
   if test "$XML2_CONFIG" = "no" ; then
     # Extract the first word of "xml-config", so it can be a program name with args.
 set dummy xml-config; ac_word=$2
-{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_path_XML_CONFIG+set}" = set; then
+if ${ac_cv_path_XML_CONFIG+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   case $XML_CONFIG in
@@ -24068,14 +10578,14 @@ for as_dir in $PATH
 do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
-  for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_path_XML_CONFIG="$as_dir/$ac_word$ac_exec_ext"
-    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
-done
+  done
 IFS=$as_save_IFS
 
   test -z "$ac_cv_path_XML_CONFIG" && ac_cv_path_XML_CONFIG="no"
@@ -24084,10 +10594,10 @@ esac
 fi
 XML_CONFIG=$ac_cv_path_XML_CONFIG
 if test -n "$XML_CONFIG"; then
-  { $as_echo "$as_me:$LINENO: result: $XML_CONFIG" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $XML_CONFIG" >&5
 $as_echo "$XML_CONFIG" >&6; }
 else
-  { $as_echo "$as_me:$LINENO: result: no" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
 fi
 
@@ -24096,7 +10606,7 @@ fi
     XML_CONFIG=$XML2_CONFIG
   fi
   min_xml_version=2.3.0
-  { $as_echo "$as_me:$LINENO: checking for libxml - version >= $min_xml_version" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for libxml - version >= $min_xml_version" >&5
 $as_echo_n "checking for libxml - version >= $min_xml_version... " >&6; }
   no_xml=""
   if test "$XML_CONFIG" = "no" ; then
@@ -24108,14 +10618,10 @@ $as_echo_n "checking for libxml - version >= $min_xml_version... " >&6; }
     CFLAGS="$CFLAGS $XML_CFLAGS"
     LIBS="$XML_LIBS $LIBS"
     rm -f conf.xmltest
-    if test "$cross_compiling" = yes; then
+    if test "$cross_compiling" = yes; then :
   echo $ac_n "cross compiling; assumed OK... $ac_c"
 else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
 #include <stdlib.h>
@@ -24171,43 +10677,16 @@ main()
 }
 
 _ACEOF
-rm -f conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  :
-else
-  $as_echo "$as_me: program exited with status $ac_status" >&5
-$as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
+if ac_fn_c_try_run "$LINENO"; then :
 
-( exit $ac_status )
-no_xml=yes
+else
+  no_xml=yes
 fi
-rm -rf conftest.dSYM
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
+  conftest.$ac_objext conftest.beam conftest.$ac_ext
 fi
 
 
-
     CFLAGS="$ac_save_CFLAGS"
     LIBS="$ac_save_LIBS"
   else
@@ -24226,14 +10705,10 @@ fi
       CFLAGS="$CFLAGS $XML_CFLAGS"
       LIBS="$XML_LIBS $LIBS"
       rm -f conf.xmltest
-      if test "$cross_compiling" = yes; then
+      if test "$cross_compiling" = yes; then :
   echo $ac_n "cross compiling; assumed OK... $ac_c"
 else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
 #include <stdlib.h>
@@ -24308,54 +10783,27 @@ main()
 }
 
 _ACEOF
-rm -f conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  :
-else
-  $as_echo "$as_me: program exited with status $ac_status" >&5
-$as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
+if ac_fn_c_try_run "$LINENO"; then :
 
-( exit $ac_status )
-no_xml=yes
+else
+  no_xml=yes
 fi
-rm -rf conftest.dSYM
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
+  conftest.$ac_objext conftest.beam conftest.$ac_ext
 fi
 
 
-
       CFLAGS="$ac_save_CFLAGS"
       LIBS="$ac_save_LIBS"
     fi
   fi
 
   if test "x$no_xml" = x ; then
-    { $as_echo "$as_me:$LINENO: result: yes" >&5
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
 $as_echo "yes" >&6; }
     enable_libxml=yes
   else
-    { $as_echo "$as_me:$LINENO: result: no" >&5
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
     if test "$XML_CONFIG" = "no" ; then
       echo "*** The xml-config script installed by libxml could not be found"
@@ -24386,150 +10834,14 @@ $as_echo "no" >&6; }
     LIBS="$XML_LIBS $LIBS"
     HAVE_LIBXML=1
 
-cat >>confdefs.h <<\_ACEOF
-#define HAVE_LIBXML 1
-_ACEOF
-
-
-for ac_header in libxml/SAX2.h
-do
-as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  { $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
-$as_echo_n "checking for $ac_header... " >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  $as_echo_n "(cached) " >&6
-fi
-ac_res=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-else
-  # Is the header compilable?
-{ $as_echo "$as_me:$LINENO: checking $ac_header usability" >&5
-$as_echo_n "checking $ac_header usability... " >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-#include <$ac_header>
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_header_compiler=yes
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_header_compiler=no
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-{ $as_echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
-$as_echo "$ac_header_compiler" >&6; }
-
-# Is the header present?
-{ $as_echo "$as_me:$LINENO: checking $ac_header presence" >&5
-$as_echo_n "checking $ac_header presence... " >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <$ac_header>
-_ACEOF
-if { (ac_try="$ac_cpp conftest.$ac_ext"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } >/dev/null && {
-	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       }; then
-  ac_header_preproc=yes
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-  ac_header_preproc=no
-fi
-
-rm -f conftest.err conftest.$ac_ext
-{ $as_echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
-$as_echo "$ac_header_preproc" >&6; }
-
-# So?  What about this header?
-case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
-  yes:no: )
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
-$as_echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the compiler's result" >&5
-$as_echo "$as_me: WARNING: $ac_header: proceeding with the compiler's result" >&2;}
-    ac_header_preproc=yes
-    ;;
-  no:yes:* )
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
-$as_echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header:     check for missing prerequisite headers?" >&5
-$as_echo "$as_me: WARNING: $ac_header:     check for missing prerequisite headers?" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: see the Autoconf documentation" >&5
-$as_echo "$as_me: WARNING: $ac_header: see the Autoconf documentation" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&5
-$as_echo "$as_me: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
-$as_echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: in the future, the compiler will take precedence" >&5
-$as_echo "$as_me: WARNING: $ac_header: in the future, the compiler will take precedence" >&2;}
-
-    ;;
-esac
-{ $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
-$as_echo_n "checking for $ac_header... " >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  $as_echo_n "(cached) " >&6
-else
-  eval "$as_ac_Header=\$ac_header_preproc"
-fi
-ac_res=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
+$as_echo "#define HAVE_LIBXML 1" >>confdefs.h
 
-fi
-as_val=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-   if test "x$as_val" = x""yes; then
+    for ac_header in libxml/SAX2.h
+do :
+  ac_fn_c_check_header_mongrel "$LINENO" "libxml/SAX2.h" "ac_cv_header_libxml_SAX2_h" "$ac_includes_default"
+if test "x$ac_cv_header_libxml_SAX2_h" = xyes; then :
   cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
+#define HAVE_LIBXML_SAX2_H 1
 _ACEOF
 
 fi
@@ -24539,215 +10851,60 @@ done
     #--------------------------------------------------------------------
     # Check for (optional) libxslt
     #--------------------------------------------------------------------
-    # Check whether --enable-xslt was given.
-if test "${enable_xslt+set}" = set; then
-  enableval=$enable_xslt;
-else
-  enable_xslt=yes
-fi
-
-
-    if test $enable_xslt = yes; then
-      { $as_echo "$as_me:$LINENO: checking for xsltApplyStylesheet in -lxslt" >&5
-$as_echo_n "checking for xsltApplyStylesheet in -lxslt... " >&6; }
-if test "${ac_cv_lib_xslt_xsltApplyStylesheet+set}" = set; then
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-lxslt  $LIBS"
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char xsltApplyStylesheet ();
-int
-main ()
-{
-return xsltApplyStylesheet ();
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then
-  ac_cv_lib_xslt_xsltApplyStylesheet=yes
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_cv_lib_xslt_xsltApplyStylesheet=no
-fi
-
-rm -rf conftest.dSYM
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_lib_xslt_xsltApplyStylesheet" >&5
-$as_echo "$ac_cv_lib_xslt_xsltApplyStylesheet" >&6; }
-if test "x$ac_cv_lib_xslt_xsltApplyStylesheet" = x""yes; then
-  xslt_ok=yes
-else
-  xslt_ok=no
-fi
-
-      if test "$xslt_ok" = "yes"; then
-	if test "${ac_cv_header_libxslt_xslt_h+set}" = set; then
-  { $as_echo "$as_me:$LINENO: checking for libxslt/xslt.h" >&5
-$as_echo_n "checking for libxslt/xslt.h... " >&6; }
-if test "${ac_cv_header_libxslt_xslt_h+set}" = set; then
-  $as_echo_n "(cached) " >&6
-fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_header_libxslt_xslt_h" >&5
-$as_echo "$ac_cv_header_libxslt_xslt_h" >&6; }
-else
-  # Is the header compilable?
-{ $as_echo "$as_me:$LINENO: checking libxslt/xslt.h usability" >&5
-$as_echo_n "checking libxslt/xslt.h usability... " >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-#include <libxslt/xslt.h>
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_header_compiler=yes
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_header_compiler=no
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-{ $as_echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
-$as_echo "$ac_header_compiler" >&6; }
-
-# Is the header present?
-{ $as_echo "$as_me:$LINENO: checking libxslt/xslt.h presence" >&5
-$as_echo_n "checking libxslt/xslt.h presence... " >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <libxslt/xslt.h>
-_ACEOF
-if { (ac_try="$ac_cpp conftest.$ac_ext"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } >/dev/null && {
-	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       }; then
-  ac_header_preproc=yes
+    # Check whether --enable-xslt was given.
+if test "${enable_xslt+set}" = set; then :
+  enableval=$enable_xslt;
 else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-  ac_header_preproc=no
+  enable_xslt=yes
 fi
 
-rm -f conftest.err conftest.$ac_ext
-{ $as_echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
-$as_echo "$ac_header_preproc" >&6; }
-
-# So?  What about this header?
-case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
-  yes:no: )
-    { $as_echo "$as_me:$LINENO: WARNING: libxslt/xslt.h: accepted by the compiler, rejected by the preprocessor!" >&5
-$as_echo "$as_me: WARNING: libxslt/xslt.h: accepted by the compiler, rejected by the preprocessor!" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: libxslt/xslt.h: proceeding with the compiler's result" >&5
-$as_echo "$as_me: WARNING: libxslt/xslt.h: proceeding with the compiler's result" >&2;}
-    ac_header_preproc=yes
-    ;;
-  no:yes:* )
-    { $as_echo "$as_me:$LINENO: WARNING: libxslt/xslt.h: present but cannot be compiled" >&5
-$as_echo "$as_me: WARNING: libxslt/xslt.h: present but cannot be compiled" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: libxslt/xslt.h:     check for missing prerequisite headers?" >&5
-$as_echo "$as_me: WARNING: libxslt/xslt.h:     check for missing prerequisite headers?" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: libxslt/xslt.h: see the Autoconf documentation" >&5
-$as_echo "$as_me: WARNING: libxslt/xslt.h: see the Autoconf documentation" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: libxslt/xslt.h:     section \"Present But Cannot Be Compiled\"" >&5
-$as_echo "$as_me: WARNING: libxslt/xslt.h:     section \"Present But Cannot Be Compiled\"" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: libxslt/xslt.h: proceeding with the preprocessor's result" >&5
-$as_echo "$as_me: WARNING: libxslt/xslt.h: proceeding with the preprocessor's result" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: libxslt/xslt.h: in the future, the compiler will take precedence" >&5
-$as_echo "$as_me: WARNING: libxslt/xslt.h: in the future, the compiler will take precedence" >&2;}
 
-    ;;
-esac
-{ $as_echo "$as_me:$LINENO: checking for libxslt/xslt.h" >&5
-$as_echo_n "checking for libxslt/xslt.h... " >&6; }
-if test "${ac_cv_header_libxslt_xslt_h+set}" = set; then
+    if test $enable_xslt = yes; then
+      { $as_echo "$as_me:${as_lineno-$LINENO}: checking for xsltApplyStylesheet in -lxslt" >&5
+$as_echo_n "checking for xsltApplyStylesheet in -lxslt... " >&6; }
+if ${ac_cv_lib_xslt_xsltApplyStylesheet+:} false; then :
   $as_echo_n "(cached) " >&6
 else
-  ac_cv_header_libxslt_xslt_h=$ac_header_preproc
-fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_header_libxslt_xslt_h" >&5
-$as_echo "$ac_cv_header_libxslt_xslt_h" >&6; }
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lxslt  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
 
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char xsltApplyStylesheet ();
+int
+main ()
+{
+return xsltApplyStylesheet ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_xslt_xsltApplyStylesheet=yes
+else
+  ac_cv_lib_xslt_xsltApplyStylesheet=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
 fi
-if test "x$ac_cv_header_libxslt_xslt_h" = x""yes; then
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_xslt_xsltApplyStylesheet" >&5
+$as_echo "$ac_cv_lib_xslt_xsltApplyStylesheet" >&6; }
+if test "x$ac_cv_lib_xslt_xsltApplyStylesheet" = xyes; then :
+  xslt_ok=yes
+else
+  xslt_ok=no
+fi
+
+      if test "$xslt_ok" = "yes"; then
+	ac_fn_c_check_header_mongrel "$LINENO" "libxslt/xslt.h" "ac_cv_header_libxslt_xslt_h" "$ac_includes_default"
+if test "x$ac_cv_header_libxslt_xslt_h" = xyes; then :
   xslthdr_ok=yes
 else
   xslthdr_ok=no
@@ -24761,9 +10918,7 @@ fi
       if test "$xslt_ok" = "yes"; then
 	HAVE_LIBXSLT=1
 
-cat >>confdefs.h <<\_ACEOF
-#define HAVE_LIBXSLT 1
-_ACEOF
+$as_echo "#define HAVE_LIBXSLT 1" >>confdefs.h
 
 	LIBS="-lxslt $LIBS"
       else
@@ -24772,12 +10927,12 @@ _ACEOF
 	echo "Building without them will disable the XSLT extensions."
 	echo "If you really want to build gnustep-base without XSLT support,"
 	echo "add --disable-xslt to the configure arguments to avoid warning."
-	{ $as_echo "$as_me:$LINENO: WARNING: Missing support for XSLT functionality." >&5
+	{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: Missing support for XSLT functionality." >&5
 $as_echo "$as_me: WARNING: Missing support for XSLT functionality." >&2;}
       fi
     else
       HAVE_LIBXSLT=0
-      { $as_echo "$as_me:$LINENO: WARNING: Disabled support for XSLT funtionality." >&5
+      { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: Disabled support for XSLT funtionality." >&5
 $as_echo "$as_me: WARNING: Disabled support for XSLT funtionality." >&2;}
     fi
 
@@ -24792,12 +10947,10 @@ $as_echo "$as_me: WARNING: Disabled support for XSLT funtionality." >&2;}
     echo "If you really want to build gnustep-base without XML DOM support"
     echo " (though NSXMLParser is unaffected),  please"
     echo "add --disable-xml to the configure arguments."
-    { { $as_echo "$as_me:$LINENO: error: Missing support for XML DOM functionality." >&5
-$as_echo "$as_me: error: Missing support for XML DOM functionality." >&2;}
-   { (exit 1); exit 1; }; }
+    as_fn_error $? "Missing support for XML DOM functionality." "$LINENO" 5
   fi
 else
-  { $as_echo "$as_me:$LINENO: WARNING: Disabled support for XML funtionality." >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: Disabled support for XML funtionality." >&5
 $as_echo "$as_me: WARNING: Disabled support for XML funtionality." >&2;}
   HAVE_LIBXML=0
 fi
@@ -24807,15 +10960,30 @@ fi
 # Check recent libgnutls for SSL streams.
 # See DEPENDENCIES POLICY at the start of this file.
 #--------------------------------------------------------------------
-# Check whether --enable-tls was given.
-if test "${enable_tls+set}" = set; then
-  enableval=$enable_tls;
+
+# GNUTLS is linked to Apple's CoreFoundation on OSX, which renders it unusable there
+case "$target_os" in
+    darwin*) # Check whether --enable-gnutls was given.
+if test "${enable_gnutls+set}" = set; then :
+  enableval=$enable_gnutls; enable_gnutls="$enableval"
 else
-  enable_tls=yes
+  enable_gnutls=no
 fi
+   ;;
+    *)       # Check whether --enable-gnutls was given.
+if test "${enable_gnutls+set}" = set; then :
+  enableval=$enable_gnutls; enable_gnutls="$enableval"
+else
+  enable_gnutls=yes
+fi
+ ;;
+esac
 
-
-if test $enable_tls = yes; then
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether we should try to use GNUTLS for SSL/TLS support" >&5
+$as_echo_n "checking whether we should try to use GNUTLS for SSL/TLS support... " >&6; }
+if test "$enable_gnutls" = yes; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
   HAVE_GNUTLS=0
   # Save CFLAGS and LIBS as AM_PATH_TLS clobbers these variables regardless
   # of the success of the macro.
@@ -24824,7 +10992,7 @@ if test $enable_tls = yes; then
 
   if test $PKGCONFIG = yes; then
     if pkg-config --exists gnutls; then
-      { $as_echo "$as_me:$LINENO: checking gnutls support" >&5
+      { $as_echo "$as_me:${as_lineno-$LINENO}: checking gnutls support" >&5
 $as_echo_n "checking gnutls support... " >&6; }
       HAVE_GNUTLS=1
       TLS_CFLAGS=`pkg-config --cflags gnutls`
@@ -24837,14 +11005,14 @@ $as_echo_n "checking gnutls support... " >&6; }
 
 
 # Check whether --with-tls-prefix was given.
-if test "${with_tls_prefix+set}" = set; then
+if test "${with_tls_prefix+set}" = set; then :
   withval=$with_tls_prefix; tls_config_prefix="$withval"
 else
   tls_config_prefix=""
 fi
 
 # Check whether --enable-tlstest was given.
-if test "${enable_tlstest+set}" = set; then
+if test "${enable_tlstest+set}" = set; then :
   enableval=$enable_tlstest;
 else
   enable_tlstest=yes
@@ -24863,9 +11031,9 @@ fi
 
   # Extract the first word of "libgnutls-config", so it can be a program name with args.
 set dummy libgnutls-config; ac_word=$2
-{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_path_TLS_CONFIG+set}" = set; then
+if ${ac_cv_path_TLS_CONFIG+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   case $TLS_CONFIG in
@@ -24878,14 +11046,14 @@ for as_dir in $PATH
 do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
-  for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_path_TLS_CONFIG="$as_dir/$ac_word$ac_exec_ext"
-    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
-done
+  done
 IFS=$as_save_IFS
 
   test -z "$ac_cv_path_TLS_CONFIG" && ac_cv_path_TLS_CONFIG="no"
@@ -24894,16 +11062,16 @@ esac
 fi
 TLS_CONFIG=$ac_cv_path_TLS_CONFIG
 if test -n "$TLS_CONFIG"; then
-  { $as_echo "$as_me:$LINENO: result: $TLS_CONFIG" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $TLS_CONFIG" >&5
 $as_echo "$TLS_CONFIG" >&6; }
 else
-  { $as_echo "$as_me:$LINENO: result: no" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
 fi
 
 
   min_tls_version=1.4.0
-  { $as_echo "$as_me:$LINENO: checking for libgnutls - version >= $min_tls_version" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for libgnutls - version >= $min_tls_version" >&5
 $as_echo_n "checking for libgnutls - version >= $min_tls_version... " >&6; }
   no_tls=""
   if test "$TLS_CONFIG" = "no" ; then
@@ -24920,14 +11088,10 @@ $as_echo_n "checking for libgnutls - version >= $min_tls_version... " >&6; }
     CFLAGS="$CFLAGS $TLS_CFLAGS"
     LIBS="$TLS_LIBS $LIBS"
     rm -f conf.tlstest
-    if test "$cross_compiling" = yes; then
+    if test "$cross_compiling" = yes; then :
   echo $ac_n "cross compiling; assumed OK... $ac_c"
 else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
 #include <stdlib.h>
@@ -24954,43 +11118,16 @@ main()
 }
 
 _ACEOF
-rm -f conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  :
-else
-  $as_echo "$as_me: program exited with status $ac_status" >&5
-$as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
+if ac_fn_c_try_run "$LINENO"; then :
 
-( exit $ac_status )
-no_tls=yes
+else
+  no_tls=yes
 fi
-rm -rf conftest.dSYM
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
+  conftest.$ac_objext conftest.beam conftest.$ac_ext
 fi
 
 
-
     CFLAGS="$ac_save_CFLAGS"
     LIBS="$ac_save_LIBS"
   else
@@ -25009,14 +11146,10 @@ fi
       CFLAGS="$CFLAGS $TLS_CFLAGS"
       LIBS="$TLS_LIBS $LIBS"
       rm -f conf.tlstest
-      if test "$cross_compiling" = yes; then
+      if test "$cross_compiling" = yes; then :
   echo $ac_n "cross compiling; assumed OK... $ac_c"
 else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
 #include <stdlib.h>
@@ -25043,54 +11176,27 @@ main()
 }
 
 _ACEOF
-rm -f conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  :
-else
-  $as_echo "$as_me: program exited with status $ac_status" >&5
-$as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
+if ac_fn_c_try_run "$LINENO"; then :
 
-( exit $ac_status )
-no_tls=yes
+else
+  no_tls=yes
 fi
-rm -rf conftest.dSYM
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
+  conftest.$ac_objext conftest.beam conftest.$ac_ext
 fi
 
 
-
       CFLAGS="$ac_save_CFLAGS"
       LIBS="$ac_save_LIBS"
     fi
   fi
 
   if test "x$no_tls" = x ; then
-    { $as_echo "$as_me:$LINENO: result: yes" >&5
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
 $as_echo "yes" >&6; }
     enable_libgnutls=yes
   else
-    { $as_echo "$as_me:$LINENO: result: no" >&5
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
     if test "$TLS_CONFIG" = "no" ; then
       echo "*** The libgnutls-config script installed by libgnutls could not be found"
@@ -25121,18 +11227,14 @@ $as_echo "no" >&6; }
     fi
   fi
   if test $HAVE_GNUTLS = 1; then
-    { $as_echo "$as_me:$LINENO: checking for gcry_control in -lgcrypt" >&5
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for gcry_control in -lgcrypt" >&5
 $as_echo_n "checking for gcry_control in -lgcrypt... " >&6; }
-if test "${ac_cv_lib_gcrypt_gcry_control+set}" = set; then
+if ${ac_cv_lib_gcrypt_gcry_control+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
 LIBS="-lgcrypt  $LIBS"
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
 /* Override any GCC internal prototype to avoid an error.
@@ -25150,50 +11252,25 @@ return gcry_control ();
   return 0;
 }
 _ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then
+if ac_fn_c_try_link "$LINENO"; then :
   ac_cv_lib_gcrypt_gcry_control=yes
 else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_cv_lib_gcrypt_gcry_control=no
+  ac_cv_lib_gcrypt_gcry_control=no
 fi
-
-rm -rf conftest.dSYM
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_lib_gcrypt_gcry_control" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_gcrypt_gcry_control" >&5
 $as_echo "$ac_cv_lib_gcrypt_gcry_control" >&6; }
-if test "x$ac_cv_lib_gcrypt_gcry_control" = x""yes; then
+if test "x$ac_cv_lib_gcrypt_gcry_control" = xyes; then :
   have_gcrypt=yes
 else
   have_gcrypt=no
 fi
 
     if test "$have_gcrypt" = "no"; then
-      { $as_echo "$as_me:$LINENO: WARNING: Missing support for thread-safe operation in GNUTLS.  Disabling TLS support)." >&5
+      { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: Missing support for thread-safe operation in GNUTLS.  Disabling TLS support)." >&5
 $as_echo "$as_me: WARNING: Missing support for thread-safe operation in GNUTLS.  Disabling TLS support)." >&2;}
       HAVE_GNUTLS=0
     else
@@ -25204,7 +11281,7 @@ $as_echo "$as_me: WARNING: Missing support for thread-safe operation in GNUTLS.
     # Restore the CFLAGS and LIBS because AM_PATH_TLS messes them
     LIBS="$saved_LIBS"
     CFLAGS="$saved_CFLAGS"
-    { $as_echo "$as_me:$LINENO: result: no" >&5
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
     echo
     echo "You do not appear to have usable libgnutls headers/library."
@@ -25212,124 +11289,32 @@ $as_echo "no" >&6; }
     echo "NSFileHandle, NSURLHandle and NSURLConnection."
     echo "If you really want to build gnustep-base without TLS support,"
     echo "add --disable-tls to the configure arguments."
-    { { $as_echo "$as_me:$LINENO: error: Missing support for TLS functionality." >&5
-$as_echo "$as_me: error: Missing support for TLS functionality." >&2;}
-   { (exit 1); exit 1; }; }
+    as_fn_error $? "Missing support for TLS functionality." "$LINENO" 5
   else
-    { $as_echo "$as_me:$LINENO: result: yes" >&5
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
 $as_echo "yes" >&6; }
     CPPFLAGS="$CPPFLAGS $TLS_CFLAGS"
     INCLUDE_FLAGS="$INCLUDE_FLAGS $TLS_CFLAGS"
     LIBS="$TLS_LIBS $LIBS"
-
-for ac_func in gnutls_transport_set_errno
-do
-as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
-{ $as_echo "$as_me:$LINENO: checking for $ac_func" >&5
-$as_echo_n "checking for $ac_func... " >&6; }
-if { as_var=$as_ac_var; eval "test \"\${$as_var+set}\" = set"; }; then
-  $as_echo_n "(cached) " >&6
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.
-   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
-#define $ac_func innocuous_$ac_func
-
-/* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char $ac_func (); below.
-    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-    <limits.h> exists even on freestanding compilers.  */
-
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
-
-#undef $ac_func
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char $ac_func ();
-/* The GNU C library defines this for functions which it implements
-    to always fail with ENOSYS.  Some functions are actually named
-    something starting with __ and the normal name is an alias.  */
-#if defined __stub_$ac_func || defined __stub___$ac_func
-choke me
-#endif
-
-int
-main ()
-{
-return $ac_func ();
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then
-  eval "$as_ac_var=yes"
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	eval "$as_ac_var=no"
-fi
-
-rm -rf conftest.dSYM
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
-fi
-ac_res=`eval 'as_val=${'$as_ac_var'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-as_val=`eval 'as_val=${'$as_ac_var'}
-		 $as_echo "$as_val"'`
-   if test "x$as_val" = x""yes; then
+    for ac_func in gnutls_transport_set_errno
+do :
+  ac_fn_c_check_func "$LINENO" "gnutls_transport_set_errno" "ac_cv_func_gnutls_transport_set_errno"
+if test "x$ac_cv_func_gnutls_transport_set_errno" = xyes; then :
   cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
+#define HAVE_GNUTLS_TRANSPORT_SET_ERRNO 1
 _ACEOF
 
 fi
 done
 
     if test "$ac_cv_func_gnutls_transport_set_errno" = "no"; then
-      { $as_echo "$as_me:$LINENO: WARNING: Missing support for thread-safe error handling in GNUTLS.  Please check that you have the most recent version installed (2.0 or later chould be fine)." >&5
+      { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: Missing support for thread-safe error handling in GNUTLS.  Please check that you have the most recent version installed (2.0 or later chould be fine)." >&5
 $as_echo "$as_me: WARNING: Missing support for thread-safe error handling in GNUTLS.  Please check that you have the most recent version installed (2.0 or later chould be fine)." >&2;}
     fi
   fi
 else
-  { $as_echo "$as_me:$LINENO: WARNING: Disabled support for TLS funtionality." >&5
-$as_echo "$as_me: WARNING: Disabled support for TLS funtionality." >&2;}
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
   HAVE_GNUTLS=0
 fi
 if test $HAVE_GNUTLS = 1; then
@@ -25342,168 +11327,79 @@ fi
 
 
 #--------------------------------------------------------------------
-# Check for NSNetServices
-# See DEPENDENCIES POLICY at the start of this file.
+# If there's no GNUTLS support, try using OpenSSL instead.
 #--------------------------------------------------------------------
-HAVE_MDNS=0
-HAVE_AVAHI=0
-# Check whether --enable-zeroconf was given.
-if test "${enable_zeroconf+set}" = set; then
-  enableval=$enable_zeroconf;
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether we should try to use OpenSSL instead of GNUTLS" >&5
+$as_echo_n "checking whether we should try to use OpenSSL instead of GNUTLS... " >&6; }
+if test $HAVE_GNUTLS = 0; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+
+  # Configure flags from sub-configure runs, so they show up in our help file.
+  # Check whether --enable-openssl was given.
+if test "${enable_openssl+set}" = set; then :
+  enableval=$enable_openssl;
 else
-  enable_zeroconf=yes
+  enable_openssl=yes
 fi
 
+  HAVE_GNUTLS=0
 
-# Check whether --with-zeroconf-api was given.
-if test "${with_zeroconf_api+set}" = set; then
-  withval=$with_zeroconf_api; zeroconf_api="$withval"
+# Check whether --with-openssl-include was given.
+if test "${with_openssl_include+set}" = set; then :
+  withval=$with_openssl_include; openssl_incdir="$withval"
 else
-  zeroconf_api="any"
+  openssl_incdir="no"
 fi
 
-if test $enable_zeroconf = yes; then
-  if test "$zeroconf_api" = "any" || test "$zeroconf_api" = "mdns"; then
 
-for ac_header in dns_sd.h
-do
-as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  { $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
-$as_echo_n "checking for $ac_header... " >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  $as_echo_n "(cached) " >&6
-fi
-ac_res=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-else
-  # Is the header compilable?
-{ $as_echo "$as_me:$LINENO: checking $ac_header usability" >&5
-$as_echo_n "checking $ac_header usability... " >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-#include <$ac_header>
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_header_compiler=yes
+# Check whether --with-openssl-library was given.
+if test "${with_openssl_library+set}" = set; then :
+  withval=$with_openssl_library; openssl_libdir="$withval"
 else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_header_compiler=no
+  openssl_libdir="no"
 fi
 
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-{ $as_echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
-$as_echo "$ac_header_compiler" >&6; }
 
-# Is the header present?
-{ $as_echo "$as_me:$LINENO: checking $ac_header presence" >&5
-$as_echo_n "checking $ac_header presence... " >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <$ac_header>
-_ACEOF
-if { (ac_try="$ac_cpp conftest.$ac_ext"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } >/dev/null && {
-	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       }; then
-  ac_header_preproc=yes
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
 
-  ac_header_preproc=no
+
+subdirs="$subdirs SSL"
+
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
 fi
 
-rm -f conftest.err conftest.$ac_ext
-{ $as_echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
-$as_echo "$ac_header_preproc" >&6; }
+#--------------------------------------------------------------------
+# Check for NSNetServices
+# See DEPENDENCIES POLICY at the start of this file.
+#--------------------------------------------------------------------
+HAVE_MDNS=0
+HAVE_AVAHI=0
+# Check whether --enable-zeroconf was given.
+if test "${enable_zeroconf+set}" = set; then :
+  enableval=$enable_zeroconf;
+else
+  enable_zeroconf=yes
+fi
 
-# So?  What about this header?
-case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
-  yes:no: )
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
-$as_echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the compiler's result" >&5
-$as_echo "$as_me: WARNING: $ac_header: proceeding with the compiler's result" >&2;}
-    ac_header_preproc=yes
-    ;;
-  no:yes:* )
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
-$as_echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header:     check for missing prerequisite headers?" >&5
-$as_echo "$as_me: WARNING: $ac_header:     check for missing prerequisite headers?" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: see the Autoconf documentation" >&5
-$as_echo "$as_me: WARNING: $ac_header: see the Autoconf documentation" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&5
-$as_echo "$as_me: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
-$as_echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: in the future, the compiler will take precedence" >&5
-$as_echo "$as_me: WARNING: $ac_header: in the future, the compiler will take precedence" >&2;}
 
-    ;;
-esac
-{ $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
-$as_echo_n "checking for $ac_header... " >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  $as_echo_n "(cached) " >&6
+# Check whether --with-zeroconf-api was given.
+if test "${with_zeroconf_api+set}" = set; then :
+  withval=$with_zeroconf_api; zeroconf_api="$withval"
 else
-  eval "$as_ac_Header=\$ac_header_preproc"
+  zeroconf_api="any"
 fi
-ac_res=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
 
-fi
-as_val=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-   if test "x$as_val" = x""yes; then
+if test $enable_zeroconf = yes; then
+  if test "$zeroconf_api" = "any" || test "$zeroconf_api" = "mdns"; then
+    for ac_header in dns_sd.h
+do :
+  ac_fn_c_check_header_mongrel "$LINENO" "dns_sd.h" "ac_cv_header_dns_sd_h" "$ac_includes_default"
+if test "x$ac_cv_header_dns_sd_h" = xyes; then :
   cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
+#define HAVE_DNS_SD_H 1
 _ACEOF
  have_mdns=yes
 else
@@ -25513,18 +11409,14 @@ fi
 done
 
     if test "$have_mdns" = "yes"; then
-      { $as_echo "$as_me:$LINENO: checking for DNSServiceBrowse in -ldns_sd" >&5
+      { $as_echo "$as_me:${as_lineno-$LINENO}: checking for DNSServiceBrowse in -ldns_sd" >&5
 $as_echo_n "checking for DNSServiceBrowse in -ldns_sd... " >&6; }
-if test "${ac_cv_lib_dns_sd_DNSServiceBrowse+set}" = set; then
+if ${ac_cv_lib_dns_sd_DNSServiceBrowse+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
 LIBS="-ldns_sd  $LIBS"
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
 /* Override any GCC internal prototype to avoid an error.
@@ -25542,43 +11434,18 @@ return DNSServiceBrowse ();
   return 0;
 }
 _ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then
+if ac_fn_c_try_link "$LINENO"; then :
   ac_cv_lib_dns_sd_DNSServiceBrowse=yes
 else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_cv_lib_dns_sd_DNSServiceBrowse=no
+  ac_cv_lib_dns_sd_DNSServiceBrowse=no
 fi
-
-rm -rf conftest.dSYM
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_lib_dns_sd_DNSServiceBrowse" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_dns_sd_DNSServiceBrowse" >&5
 $as_echo "$ac_cv_lib_dns_sd_DNSServiceBrowse" >&6; }
-if test "x$ac_cv_lib_dns_sd_DNSServiceBrowse" = x""yes; then
+if test "x$ac_cv_lib_dns_sd_DNSServiceBrowse" = xyes; then :
   have_mdns=yes
 else
   have_mdns=no
@@ -25587,150 +11454,27 @@ fi
       if test "$have_mdns" = "yes"; then
         MDNS_LIBS="-ldns_sd"
         HAVE_MDNS=1
+      else
+        ac_fn_c_check_func "$LINENO" "DNSServiceBrowse" "ac_cv_func_DNSServiceBrowse"
+if test "x$ac_cv_func_DNSServiceBrowse" = xyes; then :
+  have_mdns=yes
+else
+  have_mdns=no
+fi
+
+        if test "$have_mdns" = "yes"; then
+          HAVE_MDNS=1
+        fi
       fi
     fi
   fi
   if test "$zeroconf_api" = "any" || test "$zeroconf_api" = "avahi"; then
-
-for ac_header in avahi-client/client.h
-do
-as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  { $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
-$as_echo_n "checking for $ac_header... " >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  $as_echo_n "(cached) " >&6
-fi
-ac_res=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-else
-  # Is the header compilable?
-{ $as_echo "$as_me:$LINENO: checking $ac_header usability" >&5
-$as_echo_n "checking $ac_header usability... " >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-#include <$ac_header>
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_header_compiler=yes
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_header_compiler=no
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-{ $as_echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
-$as_echo "$ac_header_compiler" >&6; }
-
-# Is the header present?
-{ $as_echo "$as_me:$LINENO: checking $ac_header presence" >&5
-$as_echo_n "checking $ac_header presence... " >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <$ac_header>
-_ACEOF
-if { (ac_try="$ac_cpp conftest.$ac_ext"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } >/dev/null && {
-	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       }; then
-  ac_header_preproc=yes
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-  ac_header_preproc=no
-fi
-
-rm -f conftest.err conftest.$ac_ext
-{ $as_echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
-$as_echo "$ac_header_preproc" >&6; }
-
-# So?  What about this header?
-case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
-  yes:no: )
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
-$as_echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the compiler's result" >&5
-$as_echo "$as_me: WARNING: $ac_header: proceeding with the compiler's result" >&2;}
-    ac_header_preproc=yes
-    ;;
-  no:yes:* )
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
-$as_echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header:     check for missing prerequisite headers?" >&5
-$as_echo "$as_me: WARNING: $ac_header:     check for missing prerequisite headers?" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: see the Autoconf documentation" >&5
-$as_echo "$as_me: WARNING: $ac_header: see the Autoconf documentation" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&5
-$as_echo "$as_me: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
-$as_echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: in the future, the compiler will take precedence" >&5
-$as_echo "$as_me: WARNING: $ac_header: in the future, the compiler will take precedence" >&2;}
-
-    ;;
-esac
-{ $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
-$as_echo_n "checking for $ac_header... " >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  $as_echo_n "(cached) " >&6
-else
-  eval "$as_ac_Header=\$ac_header_preproc"
-fi
-ac_res=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-
-fi
-as_val=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-   if test "x$as_val" = x""yes; then
+    for ac_header in avahi-client/client.h
+do :
+  ac_fn_c_check_header_mongrel "$LINENO" "avahi-client/client.h" "ac_cv_header_avahi_client_client_h" "$ac_includes_default"
+if test "x$ac_cv_header_avahi_client_client_h" = xyes; then :
   cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
+#define HAVE_AVAHI_CLIENT_CLIENT_H 1
 _ACEOF
  have_avahi=yes
 else
@@ -25740,18 +11484,14 @@ fi
 done
 
     if test "$have_avahi" = "yes"; then
-      { $as_echo "$as_me:$LINENO: checking for avahi_client_new in -lavahi-client" >&5
+      { $as_echo "$as_me:${as_lineno-$LINENO}: checking for avahi_client_new in -lavahi-client" >&5
 $as_echo_n "checking for avahi_client_new in -lavahi-client... " >&6; }
-if test "${ac_cv_lib_avahi_client_avahi_client_new+set}" = set; then
+if ${ac_cv_lib_avahi_client_avahi_client_new+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
 LIBS="-lavahi-client  $LIBS"
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
 /* Override any GCC internal prototype to avoid an error.
@@ -25769,43 +11509,18 @@ return avahi_client_new ();
   return 0;
 }
 _ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then
+if ac_fn_c_try_link "$LINENO"; then :
   ac_cv_lib_avahi_client_avahi_client_new=yes
 else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_cv_lib_avahi_client_avahi_client_new=no
+  ac_cv_lib_avahi_client_avahi_client_new=no
 fi
-
-rm -rf conftest.dSYM
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_lib_avahi_client_avahi_client_new" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_avahi_client_avahi_client_new" >&5
 $as_echo "$ac_cv_lib_avahi_client_avahi_client_new" >&6; }
-if test "x$ac_cv_lib_avahi_client_avahi_client_new" = x""yes; then
+if test "x$ac_cv_lib_avahi_client_avahi_client_new" = xyes; then :
   have_avahi=yes
 else
   have_avahi=no
@@ -25835,7 +11550,7 @@ fi
 #--------------------------------------------------------------------
 HAVE_ICU=0
 # Check whether --enable-icu was given.
-if test "${enable_icu+set}" = set; then
+if test "${enable_icu+set}" = set; then :
   enableval=$enable_icu;
 else
   enable_icu=yes
@@ -25843,7 +11558,7 @@ fi
 
 
 # Check whether --enable-icu-config was given.
-if test "${enable_icu_config+set}" = set; then
+if test "${enable_icu_config+set}" = set; then :
   enableval=$enable_icu_config;
 else
   enable_icu_config=yes
@@ -25852,7 +11567,7 @@ fi
 
 
 # Check whether --with-icu-library was given.
-if test "${with_icu_library+set}" = set; then
+if test "${with_icu_library+set}" = set; then :
   withval=$with_icu_library; icu_libdir="$withval"
 else
   icu_libdir="no"
@@ -25867,9 +11582,9 @@ if test $enable_icu = yes; then
   if test -z "$ICU_CONFIG"; then
     # Extract the first word of "icu-config", so it can be a program name with args.
 set dummy icu-config; ac_word=$2
-{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_path_ICU_CONFIG+set}" = set; then
+if ${ac_cv_path_ICU_CONFIG+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   case $ICU_CONFIG in
@@ -25882,14 +11597,14 @@ for as_dir in $PATH
 do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
-  for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_path_ICU_CONFIG="$as_dir/$ac_word$ac_exec_ext"
-    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
-done
+  done
 IFS=$as_save_IFS
 
   test -z "$ac_cv_path_ICU_CONFIG" && ac_cv_path_ICU_CONFIG="no"
@@ -25898,10 +11613,10 @@ esac
 fi
 ICU_CONFIG=$ac_cv_path_ICU_CONFIG
 if test -n "$ICU_CONFIG"; then
-  { $as_echo "$as_me:$LINENO: result: $ICU_CONFIG" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ICU_CONFIG" >&5
 $as_echo "$ICU_CONFIG" >&6; }
 else
-  { $as_echo "$as_me:$LINENO: result: no" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
 fi
 
@@ -25914,23 +11629,23 @@ fi
     echo "See http://site.icu-project.org/ for help."
   else
     ICU_VERSION=`$ICU_CONFIG --version`
-    { $as_echo "$as_me:$LINENO: checking for ICU >= 4.0" >&5
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for ICU >= 4.0" >&5
 $as_echo_n "checking for ICU >= 4.0... " >&6; }
       found=`expr $ICU_VERSION \>= 4.0`
       if test "$found" = "1" ; then
-	{ $as_echo "$as_me:$LINENO: result: yes" >&5
+	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
 $as_echo "yes" >&6; }
 	ok=yes
 
-	{ $as_echo "$as_me:$LINENO: checking ICU_LIBS" >&5
+	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking ICU_LIBS" >&5
 $as_echo_n "checking ICU_LIBS... " >&6; }
 	ICU_LIBS=`$ICU_CONFIG --ldflags-libsonly`
-	{ $as_echo "$as_me:$LINENO: result: $ICU_LIBS" >&5
+	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ICU_LIBS" >&5
 $as_echo "$ICU_LIBS" >&6; }
-	{ $as_echo "$as_me:$LINENO: checking ICU_LDFLAGS" >&5
+	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking ICU_LDFLAGS" >&5
 $as_echo_n "checking ICU_LDFLAGS... " >&6; }
 	ICU_LDFLAGS=`$ICU_CONFIG --ldflags-searchpath`
-	{ $as_echo "$as_me:$LINENO: result: $ICU_LDFLAGS" >&5
+	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ICU_LDFLAGS" >&5
 $as_echo "$ICU_LDFLAGS" >&6; }
       else
 	ICU_LIBS=""
@@ -25950,18 +11665,14 @@ $as_echo "$ICU_LDFLAGS" >&6; }
 
   else
     have_icu=no;
-    { $as_echo "$as_me:$LINENO: checking for libicu (icu-config disabled)..." >&5
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for libicu (icu-config disabled)..." >&5
 $as_echo "$as_me: checking for libicu (icu-config disabled)..." >&6;}
     if test "$icu_libdir" != "no"; then
       ICU_LDFLAGS="-I$icu_libdir";
     fi
     saved_LDFLAGS="$LDFLAGS";
     LDFLAGS="$LDFLAGS $LIBS $ICU_LDFLAGS -licui18n -licuuc -licudata -lm"
-    cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+    cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
 int
@@ -25972,193 +11683,25 @@ main ()
   return 0;
 }
 _ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then
+if ac_fn_c_try_link "$LINENO"; then :
   have_icu="yes"
 else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	have_icu="no"
+  have_icu="no"
 fi
-
-rm -rf conftest.dSYM
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext;
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext;
     LDFLAGS="$saved_LDFLAGS";
     ICU_LIBS="-licui18n -licuuc -licudata -lm"
   fi
 
   if test "$have_icu" = "yes"; then
-    { $as_echo "$as_me:$LINENO: result: yes" >&5
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
 $as_echo "yes" >&6; }
-
-
-
-
-
-
-
-
-
-
-
-for ac_header in unicode/uloc.h unicode/ulocdata.h unicode/ucol.h unicode/ucurr.h unicode/uregex.h unicode/ucal.h unicode/unum.h unicode/udat.h unicode/udatpg.h unicode/ustring.h unicode/usearch.h
-do
-as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  { $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
-$as_echo_n "checking for $ac_header... " >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  $as_echo_n "(cached) " >&6
-fi
-ac_res=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-else
-  # Is the header compilable?
-{ $as_echo "$as_me:$LINENO: checking $ac_header usability" >&5
-$as_echo_n "checking $ac_header usability... " >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-#include <$ac_header>
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_header_compiler=yes
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_header_compiler=no
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-{ $as_echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
-$as_echo "$ac_header_compiler" >&6; }
-
-# Is the header present?
-{ $as_echo "$as_me:$LINENO: checking $ac_header presence" >&5
-$as_echo_n "checking $ac_header presence... " >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <$ac_header>
-_ACEOF
-if { (ac_try="$ac_cpp conftest.$ac_ext"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } >/dev/null && {
-	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       }; then
-  ac_header_preproc=yes
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-  ac_header_preproc=no
-fi
-
-rm -f conftest.err conftest.$ac_ext
-{ $as_echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
-$as_echo "$ac_header_preproc" >&6; }
-
-# So?  What about this header?
-case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
-  yes:no: )
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
-$as_echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the compiler's result" >&5
-$as_echo "$as_me: WARNING: $ac_header: proceeding with the compiler's result" >&2;}
-    ac_header_preproc=yes
-    ;;
-  no:yes:* )
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
-$as_echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header:     check for missing prerequisite headers?" >&5
-$as_echo "$as_me: WARNING: $ac_header:     check for missing prerequisite headers?" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: see the Autoconf documentation" >&5
-$as_echo "$as_me: WARNING: $ac_header: see the Autoconf documentation" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&5
-$as_echo "$as_me: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
-$as_echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: in the future, the compiler will take precedence" >&5
-$as_echo "$as_me: WARNING: $ac_header: in the future, the compiler will take precedence" >&2;}
-
-    ;;
-esac
-{ $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
-$as_echo_n "checking for $ac_header... " >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  $as_echo_n "(cached) " >&6
-else
-  eval "$as_ac_Header=\$ac_header_preproc"
-fi
-ac_res=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-
-fi
-as_val=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-   if test "x$as_val" = x""yes; then
+    for ac_header in unicode/uloc.h unicode/ulocdata.h unicode/ucol.h unicode/ucurr.h unicode/uregex.h unicode/ucal.h unicode/unum.h unicode/udat.h unicode/udatpg.h unicode/ustring.h unicode/usearch.h
+do :
+  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
+ac_fn_c_check_header_mongrel "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default"
+if eval test \"x\$"$as_ac_Header"\" = x"yes"; then :
   cat >>confdefs.h <<_ACEOF
 #define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
 _ACEOF
@@ -26172,16 +11715,14 @@ done
     LDIR_FLAGS="$LDIR_FLAGS $ICU_LDFLAGS"
     HAVE_ICU=1
   else
-    { $as_echo "$as_me:$LINENO: result: no" >&5
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
     echo
     echo "You do not appear to have usable ICU headers/libraries."
     echo "Building without them will disable major functionality."
     echo "If you really want to build gnustep-base without ICU,"
     echo "add --disable-icu to the configure arguments."
-    { { $as_echo "$as_me:$LINENO: error: Missing support for International Components for Unicode (ICU)." >&5
-$as_echo "$as_me: error: Missing support for International Components for Unicode (ICU)." >&2;}
-   { (exit 1); exit 1; }; }
+    as_fn_error $? "Missing support for International Components for Unicode (ICU)." "$LINENO" 5
   fi
 fi
 
@@ -26192,154 +11733,20 @@ fi
 #--------------------------------------------------------------------
 HAVE_LIBDISPATCH=0
 # Check whether --enable-libdispatch was given.
-if test "${enable_libdispatch+set}" = set; then
+if test "${enable_libdispatch+set}" = set; then :
   enableval=$enable_libdispatch; enable_libdispatch=no
 else
   enable_libdispatch=yes
 fi
 
-
-if test $enable_libdispatch = yes; then
-
-for ac_header in dispatch.h
-do
-as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  { $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
-$as_echo_n "checking for $ac_header... " >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  $as_echo_n "(cached) " >&6
-fi
-ac_res=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-else
-  # Is the header compilable?
-{ $as_echo "$as_me:$LINENO: checking $ac_header usability" >&5
-$as_echo_n "checking $ac_header usability... " >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-#include <$ac_header>
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_header_compiler=yes
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_header_compiler=no
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-{ $as_echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
-$as_echo "$ac_header_compiler" >&6; }
-
-# Is the header present?
-{ $as_echo "$as_me:$LINENO: checking $ac_header presence" >&5
-$as_echo_n "checking $ac_header presence... " >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <$ac_header>
-_ACEOF
-if { (ac_try="$ac_cpp conftest.$ac_ext"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } >/dev/null && {
-	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       }; then
-  ac_header_preproc=yes
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-  ac_header_preproc=no
-fi
-
-rm -f conftest.err conftest.$ac_ext
-{ $as_echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
-$as_echo "$ac_header_preproc" >&6; }
-
-# So?  What about this header?
-case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
-  yes:no: )
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
-$as_echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the compiler's result" >&5
-$as_echo "$as_me: WARNING: $ac_header: proceeding with the compiler's result" >&2;}
-    ac_header_preproc=yes
-    ;;
-  no:yes:* )
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
-$as_echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header:     check for missing prerequisite headers?" >&5
-$as_echo "$as_me: WARNING: $ac_header:     check for missing prerequisite headers?" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: see the Autoconf documentation" >&5
-$as_echo "$as_me: WARNING: $ac_header: see the Autoconf documentation" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&5
-$as_echo "$as_me: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
-$as_echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: in the future, the compiler will take precedence" >&5
-$as_echo "$as_me: WARNING: $ac_header: in the future, the compiler will take precedence" >&2;}
-
-    ;;
-esac
-{ $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
-$as_echo_n "checking for $ac_header... " >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  $as_echo_n "(cached) " >&6
-else
-  eval "$as_ac_Header=\$ac_header_preproc"
-fi
-ac_res=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-
-fi
-as_val=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-   if test "x$as_val" = x""yes; then
+
+if test $enable_libdispatch = yes; then
+  for ac_header in dispatch.h
+do :
+  ac_fn_c_check_header_mongrel "$LINENO" "dispatch.h" "ac_cv_header_dispatch_h" "$ac_includes_default"
+if test "x$ac_cv_header_dispatch_h" = xyes; then :
   cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
+#define HAVE_DISPATCH_H 1
 _ACEOF
  have_dispatch=yes
 else
@@ -26349,146 +11756,12 @@ fi
 done
 
   if test "$have_dispatch" = "no"; then
-
-for ac_header in dispatch/dispatch.h
-do
-as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  { $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
-$as_echo_n "checking for $ac_header... " >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  $as_echo_n "(cached) " >&6
-fi
-ac_res=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-else
-  # Is the header compilable?
-{ $as_echo "$as_me:$LINENO: checking $ac_header usability" >&5
-$as_echo_n "checking $ac_header usability... " >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-#include <$ac_header>
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_header_compiler=yes
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_header_compiler=no
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-{ $as_echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
-$as_echo "$ac_header_compiler" >&6; }
-
-# Is the header present?
-{ $as_echo "$as_me:$LINENO: checking $ac_header presence" >&5
-$as_echo_n "checking $ac_header presence... " >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <$ac_header>
-_ACEOF
-if { (ac_try="$ac_cpp conftest.$ac_ext"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } >/dev/null && {
-	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       }; then
-  ac_header_preproc=yes
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-  ac_header_preproc=no
-fi
-
-rm -f conftest.err conftest.$ac_ext
-{ $as_echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
-$as_echo "$ac_header_preproc" >&6; }
-
-# So?  What about this header?
-case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
-  yes:no: )
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
-$as_echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the compiler's result" >&5
-$as_echo "$as_me: WARNING: $ac_header: proceeding with the compiler's result" >&2;}
-    ac_header_preproc=yes
-    ;;
-  no:yes:* )
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
-$as_echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header:     check for missing prerequisite headers?" >&5
-$as_echo "$as_me: WARNING: $ac_header:     check for missing prerequisite headers?" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: see the Autoconf documentation" >&5
-$as_echo "$as_me: WARNING: $ac_header: see the Autoconf documentation" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&5
-$as_echo "$as_me: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
-$as_echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: in the future, the compiler will take precedence" >&5
-$as_echo "$as_me: WARNING: $ac_header: in the future, the compiler will take precedence" >&2;}
-
-    ;;
-esac
-{ $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
-$as_echo_n "checking for $ac_header... " >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  $as_echo_n "(cached) " >&6
-else
-  eval "$as_ac_Header=\$ac_header_preproc"
-fi
-ac_res=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-
-fi
-as_val=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-   if test "x$as_val" = x""yes; then
+    for ac_header in dispatch/dispatch.h
+do :
+  ac_fn_c_check_header_mongrel "$LINENO" "dispatch/dispatch.h" "ac_cv_header_dispatch_dispatch_h" "$ac_includes_default"
+if test "x$ac_cv_header_dispatch_dispatch_h" = xyes; then :
   cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
+#define HAVE_DISPATCH_DISPATCH_H 1
 _ACEOF
  have_dispatch=yes
 else
@@ -26499,18 +11772,14 @@ done
 
   fi
   if test "$have_dispatch" = "yes"; then
-    { $as_echo "$as_me:$LINENO: checking for dispatch_queue_create in -ldispatch" >&5
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for dispatch_queue_create in -ldispatch" >&5
 $as_echo_n "checking for dispatch_queue_create in -ldispatch... " >&6; }
-if test "${ac_cv_lib_dispatch_dispatch_queue_create+set}" = set; then
+if ${ac_cv_lib_dispatch_dispatch_queue_create+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
 LIBS="-ldispatch  $LIBS"
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
 /* Override any GCC internal prototype to avoid an error.
@@ -26528,43 +11797,18 @@ return dispatch_queue_create ();
   return 0;
 }
 _ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then
+if ac_fn_c_try_link "$LINENO"; then :
   ac_cv_lib_dispatch_dispatch_queue_create=yes
 else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_cv_lib_dispatch_dispatch_queue_create=no
+  ac_cv_lib_dispatch_dispatch_queue_create=no
 fi
-
-rm -rf conftest.dSYM
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_lib_dispatch_dispatch_queue_create" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_dispatch_dispatch_queue_create" >&5
 $as_echo "$ac_cv_lib_dispatch_dispatch_queue_create" >&6; }
-if test "x$ac_cv_lib_dispatch_dispatch_queue_create" = x""yes; then
+if test "x$ac_cv_lib_dispatch_dispatch_queue_create" = xyes; then :
   have_dispatch=yes
 else
   have_dispatch=no
@@ -26575,13 +11819,9 @@ fi
       LIBS="-lobjc -ldispatch";
       # This check is needed because libdispatch might be linked against a
       # version of libBlocksRuntime that defines symbols conflicting with libobjc
-      { $as_echo "$as_me:$LINENO: checking whether we can link libdispatch and libobjc at the same time" >&5
+      { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether we can link libdispatch and libobjc at the same time" >&5
 $as_echo_n "checking whether we can link libdispatch and libobjc at the same time... " >&6; }
-      cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+      cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
 int
@@ -26592,46 +11832,21 @@ main ()
   return 0;
 }
 _ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then
+if ac_fn_c_try_link "$LINENO"; then :
   have_dispatch=yes
 else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	have_dispatch=no
+  have_dispatch=no
 fi
-
-rm -rf conftest.dSYM
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
       if test "$have_dispatch" = "yes"; then
 	LIBS="$saveLIBS -ldispatch";
-	{ $as_echo "$as_me:$LINENO: result: yes" >&5
+	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
 $as_echo "yes" >&6; };
 	HAVE_LIBDISPATCH=1;
       else
 	LIBS="$saveLIBS";
-	{ $as_echo "$as_me:$LINENO: result: no" >&5
+	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; };
       fi
     fi
@@ -26648,7 +11863,7 @@ fi
 #--------------------------------------------------------------------
 
 # Check whether --with-gmp-include was given.
-if test "${with_gmp_include+set}" = set; then
+if test "${with_gmp_include+set}" = set; then :
   withval=$with_gmp_include; gmp_incdir="$withval"
 else
   gmp_incdir="no"
@@ -26657,7 +11872,7 @@ fi
 
 
 # Check whether --with-gmp-library was given.
-if test "${with_gmp_library+set}" = set; then
+if test "${with_gmp_library+set}" = set; then :
   withval=$with_gmp_library; gmp_libdir="$withval"
 else
   gmp_libdir="no"
@@ -26684,146 +11899,12 @@ esac
 fi
 
 USE_GMP=0
-
 for ac_header in gmp.h
-do
-as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  { $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
-$as_echo_n "checking for $ac_header... " >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  $as_echo_n "(cached) " >&6
-fi
-ac_res=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-else
-  # Is the header compilable?
-{ $as_echo "$as_me:$LINENO: checking $ac_header usability" >&5
-$as_echo_n "checking $ac_header usability... " >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-#include <$ac_header>
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_header_compiler=yes
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_header_compiler=no
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-{ $as_echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
-$as_echo "$ac_header_compiler" >&6; }
-
-# Is the header present?
-{ $as_echo "$as_me:$LINENO: checking $ac_header presence" >&5
-$as_echo_n "checking $ac_header presence... " >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <$ac_header>
-_ACEOF
-if { (ac_try="$ac_cpp conftest.$ac_ext"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } >/dev/null && {
-	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       }; then
-  ac_header_preproc=yes
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-  ac_header_preproc=no
-fi
-
-rm -f conftest.err conftest.$ac_ext
-{ $as_echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
-$as_echo "$ac_header_preproc" >&6; }
-
-# So?  What about this header?
-case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
-  yes:no: )
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
-$as_echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the compiler's result" >&5
-$as_echo "$as_me: WARNING: $ac_header: proceeding with the compiler's result" >&2;}
-    ac_header_preproc=yes
-    ;;
-  no:yes:* )
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
-$as_echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header:     check for missing prerequisite headers?" >&5
-$as_echo "$as_me: WARNING: $ac_header:     check for missing prerequisite headers?" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: see the Autoconf documentation" >&5
-$as_echo "$as_me: WARNING: $ac_header: see the Autoconf documentation" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&5
-$as_echo "$as_me: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
-$as_echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: in the future, the compiler will take precedence" >&5
-$as_echo "$as_me: WARNING: $ac_header: in the future, the compiler will take precedence" >&2;}
-
-    ;;
-esac
-{ $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
-$as_echo_n "checking for $ac_header... " >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  $as_echo_n "(cached) " >&6
-else
-  eval "$as_ac_Header=\$ac_header_preproc"
-fi
-ac_res=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-
-fi
-as_val=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-   if test "x$as_val" = x""yes; then
+do :
+  ac_fn_c_check_header_mongrel "$LINENO" "gmp.h" "ac_cv_header_gmp_h" "$ac_includes_default"
+if test "x$ac_cv_header_gmp_h" = xyes; then :
   cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
+#define HAVE_GMP_H 1
 _ACEOF
 
 fi
@@ -26831,18 +11912,14 @@ fi
 done
 
 if test $ac_cv_header_gmp_h = yes; then
-  { $as_echo "$as_me:$LINENO: checking for mpf_abs in -lgmp" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for mpf_abs in -lgmp" >&5
 $as_echo_n "checking for mpf_abs in -lgmp... " >&6; }
-if test "${ac_cv_lib_gmp_mpf_abs+set}" = set; then
+if ${ac_cv_lib_gmp_mpf_abs+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
 LIBS="-lgmp  $LIBS"
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
 /* Override any GCC internal prototype to avoid an error.
@@ -26860,61 +11937,32 @@ return mpf_abs ();
   return 0;
 }
 _ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then
+if ac_fn_c_try_link "$LINENO"; then :
   ac_cv_lib_gmp_mpf_abs=yes
 else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_cv_lib_gmp_mpf_abs=no
+  ac_cv_lib_gmp_mpf_abs=no
 fi
-
-rm -rf conftest.dSYM
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_lib_gmp_mpf_abs" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_gmp_mpf_abs" >&5
 $as_echo "$ac_cv_lib_gmp_mpf_abs" >&6; }
-if test "x$ac_cv_lib_gmp_mpf_abs" = x""yes; then
+if test "x$ac_cv_lib_gmp_mpf_abs" = xyes; then :
   gmp_ok=yes
 else
   gmp_ok=no
 fi
 
   if test "$gmp_ok" = no; then
-    { $as_echo "$as_me:$LINENO: checking for __gmpf_abs in -lgmp" >&5
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for __gmpf_abs in -lgmp" >&5
 $as_echo_n "checking for __gmpf_abs in -lgmp... " >&6; }
-if test "${ac_cv_lib_gmp___gmpf_abs+set}" = set; then
+if ${ac_cv_lib_gmp___gmpf_abs+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
 LIBS="-lgmp  $LIBS"
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
 /* Override any GCC internal prototype to avoid an error.
@@ -26932,43 +11980,18 @@ return __gmpf_abs ();
   return 0;
 }
 _ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then
+if ac_fn_c_try_link "$LINENO"; then :
   ac_cv_lib_gmp___gmpf_abs=yes
 else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_cv_lib_gmp___gmpf_abs=no
+  ac_cv_lib_gmp___gmpf_abs=no
 fi
-
-rm -rf conftest.dSYM
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_lib_gmp___gmpf_abs" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_gmp___gmpf_abs" >&5
 $as_echo "$ac_cv_lib_gmp___gmpf_abs" >&6; }
-if test "x$ac_cv_lib_gmp___gmpf_abs" = x""yes; then
+if test "x$ac_cv_lib_gmp___gmpf_abs" = xyes; then :
   gmp_ok=yes
 else
   gmp_ok=no
@@ -26989,7 +12012,7 @@ fi
 #--------------------------------------------------------------------
 
 # Check whether --with-sort-algorithm was given.
-if test "${with_sort_algorithm+set}" = set; then
+if test "${with_sort_algorithm+set}" = set; then :
   withval=$with_sort_algorithm; sort_algorithm="$withval"
 else
   sort_algorithm="shellsort"
@@ -26998,28 +12021,20 @@ fi
 
 if test "$sort_algorithm" = "timsort"; then
 
-cat >>confdefs.h <<\_ACEOF
-#define GS_USE_TIMSORT 1
-_ACEOF
+$as_echo "#define GS_USE_TIMSORT 1" >>confdefs.h
 
 else
   if test "$sort_algorithm" = "quicksort"; then
 
-cat >>confdefs.h <<\_ACEOF
-#define GS_USE_QUICKSORT 1
-_ACEOF
+$as_echo "#define GS_USE_QUICKSORT 1" >>confdefs.h
 
   else
     if test "$sort_algorithm" = "shellsort"; then
 
-cat >>confdefs.h <<\_ACEOF
-#define GS_USE_SHELLSORT 1
-_ACEOF
+$as_echo "#define GS_USE_SHELLSORT 1" >>confdefs.h
 
     else
-      { { $as_echo "$as_me:$LINENO: error: Unknown sort_algorithm defined!" >&5
-$as_echo "$as_me: error: Unknown sort_algorithm defined!" >&2;}
-   { (exit 1); exit 1; }; }
+      as_fn_error $? "Unknown sort_algorithm defined!" "$LINENO" 5
     fi
   fi
 fi
@@ -27028,16 +12043,12 @@ fi
 # Check whether nl_langinfo(CODESET) is supported, needed by Unicode.m.
 #--------------------------------------------------------------------
 
-  { $as_echo "$as_me:$LINENO: checking for nl_langinfo and CODESET" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for nl_langinfo and CODESET" >&5
 $as_echo_n "checking for nl_langinfo and CODESET... " >&6; }
-if test "${am_cv_langinfo_codeset+set}" = set; then
+if ${am_cv_langinfo_codeset+:} false; then :
   $as_echo_n "(cached) " >&6
 else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #include <langinfo.h>
 int
@@ -27048,47 +12059,20 @@ char* cs = nl_langinfo(CODESET);
   return 0;
 }
 _ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then
+if ac_fn_c_try_link "$LINENO"; then :
   am_cv_langinfo_codeset=yes
 else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	am_cv_langinfo_codeset=no
+  am_cv_langinfo_codeset=no
 fi
-
-rm -rf conftest.dSYM
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
 
 fi
-{ $as_echo "$as_me:$LINENO: result: $am_cv_langinfo_codeset" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $am_cv_langinfo_codeset" >&5
 $as_echo "$am_cv_langinfo_codeset" >&6; }
   if test $am_cv_langinfo_codeset = yes; then
 
-cat >>confdefs.h <<\_ACEOF
-#define HAVE_LANGINFO_CODESET 1
-_ACEOF
+$as_echo "#define HAVE_LANGINFO_CODESET 1" >>confdefs.h
 
   fi
 
@@ -27100,16 +12084,12 @@ _ACEOF
 #--------------------------------------------------------------------
 # Check for -Wdeclaration-after-statement
 #--------------------------------------------------------------------
-{ $as_echo "$as_me:$LINENO: checking whether the compiler supports -Wdeclaration-after-statement" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -Wdeclaration-after-statement" >&5
 $as_echo_n "checking whether the compiler supports -Wdeclaration-after-statement... " >&6; }
 
 saved_CFLAGS="$CFLAGS"
 CFLAGS="$CFLAGS -Wdeclaration-after-statement"
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
 int
@@ -27120,36 +12100,15 @@ main ()
   return 0;
 }
 _ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
+if ac_fn_c_try_compile "$LINENO"; then :
   HAS_W_DECL_AFTER_STATEMENT=yes
 else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	HAS_W_DECL_AFTER_STATEMENT=no
+  HAS_W_DECL_AFTER_STATEMENT=no
 fi
-
 rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
 CFLAGS="$saved_CFLAGS"
 
-{ $as_echo "$as_me:$LINENO: result: $HAS_W_DECL_AFTER_STATEMENT" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $HAS_W_DECL_AFTER_STATEMENT" >&5
 $as_echo "$HAS_W_DECL_AFTER_STATEMENT" >&6; }
 
 if test x"$HAS_W_DECL_AFTER_STATEMENT" = x"yes"; then
@@ -27165,94 +12124,54 @@ fi
 #--------------------------------------------------------------------
 
 # Check whether --with-gdomap-port was given.
-if test "${with_gdomap_port+set}" = set; then
+if test "${with_gdomap_port+set}" = set; then :
   withval=$with_gdomap_port; gdomap_port="$withval"
 else
-  gdomap_port="no"
-fi
-
-
-if test "$gdomap_port" = "no"; then
-  GNUSTEP_GDOMAP_PORT_OVERRIDE="$gdomap_port"
-else
-  GNUSTEP_GDOMAP_PORT_OVERRIDE="$gdomap_port"
-fi
-
-
-#--------------------------------------------------------------------
-# Check if we should install gdomap as setuid
-#--------------------------------------------------------------------
-{ $as_echo "$as_me:$LINENO: checking if we should install gdomap as setuid" >&5
-$as_echo_n "checking if we should install gdomap as setuid... " >&6; }
-# Check whether --enable-setuid-gdomap was given.
-if test "${enable_setuid_gdomap+set}" = set; then
-  enableval=$enable_setuid_gdomap; ac_cv_setuid_gdomap=$enableval
-else
-  ac_cv_setuid_gdomap="no"
-fi
-
-
-if test "$ac_cv_setuid_gdomap" = "yes"; then
-  { $as_echo "$as_me:$LINENO: result: yes" >&5
-$as_echo "yes" >&6; };
-  GNUSTEP_INSTALL_GDOMAP_AS_SETUID="yes"
-else
-  { $as_echo "$as_me:$LINENO: result: no" >&5
-$as_echo "no" >&6; };
-  GNUSTEP_INSTALL_GDOMAP_AS_SETUID="no"
-fi
-
-
-
-# If there's no TLS support ... try to get some limited functionality
-# by using OpenSSL instead.
-
-if test "$HAVE_TLS" = "0"; then
-
-#--------------------------------------------------------------------
-# Configure flags from sub-configure runs, so they show up in our
-# help file.
-#--------------------------------------------------------------------
-# Check whether --enable-openssl was given.
-if test "${enable_openssl+set}" = set; then
-  enableval=$enable_openssl;
-else
-  enable_openssl=yes
+  gdomap_port="no"
 fi
 
-  HAVE_GNUTLS=0
 
-# Check whether --with-openssl-include was given.
-if test "${with_openssl_include+set}" = set; then
-  withval=$with_openssl_include; openssl_incdir="$withval"
+if test "$gdomap_port" = "no"; then
+  GNUSTEP_GDOMAP_PORT_OVERRIDE="$gdomap_port"
 else
-  openssl_incdir="no"
+  GNUSTEP_GDOMAP_PORT_OVERRIDE="$gdomap_port"
 fi
 
 
-# Check whether --with-openssl-library was given.
-if test "${with_openssl_library+set}" = set; then
-  withval=$with_openssl_library; openssl_libdir="$withval"
+#--------------------------------------------------------------------
+# Check if we should install gdomap as setuid
+#--------------------------------------------------------------------
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking if we should install gdomap as setuid" >&5
+$as_echo_n "checking if we should install gdomap as setuid... " >&6; }
+# Check whether --enable-setuid-gdomap was given.
+if test "${enable_setuid_gdomap+set}" = set; then :
+  enableval=$enable_setuid_gdomap; ac_cv_setuid_gdomap=$enableval
 else
-  openssl_libdir="no"
+  ac_cv_setuid_gdomap="no"
 fi
 
 
+if test "$ac_cv_setuid_gdomap" = "yes"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; };
+  GNUSTEP_INSTALL_GDOMAP_AS_SETUID="yes"
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; };
+  GNUSTEP_INSTALL_GDOMAP_AS_SETUID="no"
+fi
 
 
-subdirs="$subdirs SSL"
-
-fi
 
 #--------------------------------------------------------------------
 # Record the version
 #--------------------------------------------------------------------
-{ $as_echo "$as_me:$LINENO: checking for the version of gnustep-base we are compiling" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for the version of gnustep-base we are compiling" >&5
 $as_echo_n "checking for the version of gnustep-base we are compiling... " >&6; }
 if test -f "Version"; then
   . ./Version
 fi
-{ $as_echo "$as_me:$LINENO: result: $VERSION" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $VERSION" >&5
 $as_echo "$VERSION" >&6; }
 
 
@@ -27292,13 +12211,13 @@ _ACEOF
     case $ac_val in #(
     *${as_nl}*)
       case $ac_var in #(
-      *_cv_*) { $as_echo "$as_me:$LINENO: WARNING: cache variable $ac_var contains a newline" >&5
+      *_cv_*) { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: cache variable $ac_var contains a newline" >&5
 $as_echo "$as_me: WARNING: cache variable $ac_var contains a newline" >&2;} ;;
       esac
       case $ac_var in #(
       _ | IFS | as_nl) ;; #(
       BASH_ARGV | BASH_SOURCE) eval $ac_var= ;; #(
-      *) $as_unset $ac_var ;;
+      *) { eval $ac_var=; unset $ac_var;} ;;
       esac ;;
     esac
   done
@@ -27306,8 +12225,8 @@ $as_echo "$as_me: WARNING: cache variable $ac_var contains a newline" >&2;} ;;
   (set) 2>&1 |
     case $as_nl`(ac_space=' '; set) 2>&1` in #(
     *${as_nl}ac_space=\ *)
-      # `set' does not quote correctly, so add quotes (double-quote
-      # substitution turns \\\\ into \\, and sed turns \\ into \).
+      # `set' does not quote correctly, so add quotes: double-quote
+      # substitution turns \\\\ into \\, and sed turns \\ into \.
       sed -n \
 	"s/'/'\\\\''/g;
 	  s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1='\\2'/p"
@@ -27329,12 +12248,23 @@ $as_echo "$as_me: WARNING: cache variable $ac_var contains a newline" >&2;} ;;
      :end' >>confcache
 if diff "$cache_file" confcache >/dev/null 2>&1; then :; else
   if test -w "$cache_file"; then
-    test "x$cache_file" != "x/dev/null" &&
-      { $as_echo "$as_me:$LINENO: updating cache $cache_file" >&5
+    if test "x$cache_file" != "x/dev/null"; then
+      { $as_echo "$as_me:${as_lineno-$LINENO}: updating cache $cache_file" >&5
 $as_echo "$as_me: updating cache $cache_file" >&6;}
-    cat confcache >$cache_file
+      if test ! -f "$cache_file" || test -h "$cache_file"; then
+	cat confcache >"$cache_file"
+      else
+        case $cache_file in #(
+        */* | ?:*)
+	  mv -f confcache "$cache_file"$$ &&
+	  mv -f "$cache_file"$$ "$cache_file" ;; #(
+        *)
+	  mv -f confcache "$cache_file" ;;
+	esac
+      fi
+    fi
   else
-    { $as_echo "$as_me:$LINENO: not updating unwritable cache $cache_file" >&5
+    { $as_echo "$as_me:${as_lineno-$LINENO}: not updating unwritable cache $cache_file" >&5
 $as_echo "$as_me: not updating unwritable cache $cache_file" >&6;}
   fi
 fi
@@ -27348,14 +12278,15 @@ DEFS=-DHAVE_CONFIG_H
 
 ac_libobjs=
 ac_ltlibobjs=
+U=
 for ac_i in : $LIBOBJS; do test "x$ac_i" = x: && continue
   # 1. Remove the extension, and $U if already installed.
   ac_script='s/\$U\././;s/\.o$//;s/\.obj$//'
   ac_i=`$as_echo "$ac_i" | sed "$ac_script"`
   # 2. Prepend LIBOBJDIR.  When used with automake>=1.10 LIBOBJDIR
   #    will be set to the directory where LIBOBJS objects are built.
-  ac_libobjs="$ac_libobjs \${LIBOBJDIR}$ac_i\$U.$ac_objext"
-  ac_ltlibobjs="$ac_ltlibobjs \${LIBOBJDIR}$ac_i"'$U.lo'
+  as_fn_append ac_libobjs " \${LIBOBJDIR}$ac_i\$U.$ac_objext"
+  as_fn_append ac_ltlibobjs " \${LIBOBJDIR}$ac_i"'$U.lo'
 done
 LIBOBJS=$ac_libobjs
 
@@ -27364,13 +12295,14 @@ LTLIBOBJS=$ac_ltlibobjs
 
 
 
-: ${CONFIG_STATUS=./config.status}
+: "${CONFIG_STATUS=./config.status}"
 ac_write_fail=0
 ac_clean_files_save=$ac_clean_files
 ac_clean_files="$ac_clean_files $CONFIG_STATUS"
-{ $as_echo "$as_me:$LINENO: creating $CONFIG_STATUS" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: creating $CONFIG_STATUS" >&5
 $as_echo "$as_me: creating $CONFIG_STATUS" >&6;}
-cat >$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+as_write_fail=0
+cat >$CONFIG_STATUS <<_ASEOF || as_write_fail=1
 #! $SHELL
 # Generated by $as_me.
 # Run this file to recreate the current configuration.
@@ -27380,17 +12312,18 @@ cat >$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
 debug=false
 ac_cs_recheck=false
 ac_cs_silent=false
-SHELL=\${CONFIG_SHELL-$SHELL}
-_ACEOF
 
-cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
-## --------------------- ##
-## M4sh Initialization.  ##
-## --------------------- ##
+SHELL=\${CONFIG_SHELL-$SHELL}
+export SHELL
+_ASEOF
+cat >>$CONFIG_STATUS <<\_ASEOF || as_write_fail=1
+## -------------------- ##
+## M4sh Initialization. ##
+## -------------------- ##
 
 # Be more Bourne compatible
 DUALCASE=1; export DUALCASE # for MKS sh
-if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
+if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then :
   emulate sh
   NULLCMD=:
   # Pre-4.2 versions of Zsh do word splitting on ${1+"$@"}, which
@@ -27398,23 +12331,15 @@ if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
   alias -g '${1+"$@"}'='"$@"'
   setopt NO_GLOB_SUBST
 else
-  case `(set -o) 2>/dev/null` in
-  *posix*) set -o posix ;;
+  case `(set -o) 2>/dev/null` in #(
+  *posix*) :
+    set -o posix ;; #(
+  *) :
+     ;;
 esac
-
 fi
 
 
-
-
-# PATH needs CR
-# Avoid depending upon Character Ranges.
-as_cr_letters='abcdefghijklmnopqrstuvwxyz'
-as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
-as_cr_Letters=$as_cr_letters$as_cr_LETTERS
-as_cr_digits='0123456789'
-as_cr_alnum=$as_cr_Letters$as_cr_digits
-
 as_nl='
 '
 export as_nl
@@ -27422,7 +12347,13 @@ export as_nl
 as_echo='\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'
 as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo
 as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo$as_echo
-if (test "X`printf %s $as_echo`" = "X$as_echo") 2>/dev/null; then
+# Prefer a ksh shell builtin over an external printf program on Solaris,
+# but without wasting forks for bash or zsh.
+if test -z "$BASH_VERSION$ZSH_VERSION" \
+    && (test "X`print -r -- $as_echo`" = "X$as_echo") 2>/dev/null; then
+  as_echo='print -r --'
+  as_echo_n='print -rn --'
+elif (test "X`printf %s $as_echo`" = "X$as_echo") 2>/dev/null; then
   as_echo='printf %s\n'
   as_echo_n='printf %s'
 else
@@ -27433,7 +12364,7 @@ else
     as_echo_body='eval expr "X$1" : "X\\(.*\\)"'
     as_echo_n_body='eval
       arg=$1;
-      case $arg in
+      case $arg in #(
       *"$as_nl"*)
 	expr "X$arg" : "X\\(.*\\)$as_nl";
 	arg=`expr "X$arg" : ".*$as_nl\\(.*\\)"`;;
@@ -27456,13 +12387,6 @@ if test "${PATH_SEPARATOR+set}" != set; then
   }
 fi
 
-# Support unset when possible.
-if ( (MAIL=60; unset MAIL) || exit) >/dev/null 2>&1; then
-  as_unset=unset
-else
-  as_unset=false
-fi
-
 
 # IFS
 # We need space, tab and new line, in precisely that order.  Quoting is
@@ -27472,15 +12396,16 @@ fi
 IFS=" ""	$as_nl"
 
 # Find who we are.  Look in the path if we contain no directory separator.
-case $0 in
+as_myself=
+case $0 in #((
   *[\\/]* ) as_myself=$0 ;;
   *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
 for as_dir in $PATH
 do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
-  test -r "$as_dir/$0" && as_myself=$as_dir/$0 && break
-done
+    test -r "$as_dir/$0" && as_myself=$as_dir/$0 && break
+  done
 IFS=$as_save_IFS
 
      ;;
@@ -27492,12 +12417,16 @@ if test "x$as_myself" = x; then
 fi
 if test ! -f "$as_myself"; then
   $as_echo "$as_myself: error: cannot find myself; rerun with an absolute file name" >&2
-  { (exit 1); exit 1; }
+  exit 1
 fi
 
-# Work around bugs in pre-3.0 UWIN ksh.
-for as_var in ENV MAIL MAILPATH
-do ($as_unset $as_var) >/dev/null 2>&1 && $as_unset $as_var
+# Unset variables that we do not need and which cause bugs (e.g. in
+# pre-3.0 UWIN ksh).  But do not cause bugs in bash 2.01; the "|| exit 1"
+# suppresses any "Segmentation fault" message there.  '((' could
+# trigger a bug in pdksh 5.2.14.
+for as_var in BASH_ENV ENV MAIL MAILPATH
+do eval test x\${$as_var+set} = xset \
+  && ( (unset $as_var) || exit 1) >/dev/null 2>&1 && unset $as_var || :
 done
 PS1='$ '
 PS2='> '
@@ -27509,7 +12438,89 @@ export LC_ALL
 LANGUAGE=C
 export LANGUAGE
 
-# Required to use basename.
+# CDPATH.
+(unset CDPATH) >/dev/null 2>&1 && unset CDPATH
+
+
+# as_fn_error STATUS ERROR [LINENO LOG_FD]
+# ----------------------------------------
+# Output "`basename $0`: error: ERROR" to stderr. If LINENO and LOG_FD are
+# provided, also output the error to LOG_FD, referencing LINENO. Then exit the
+# script with STATUS, using 1 if that was 0.
+as_fn_error ()
+{
+  as_status=$1; test $as_status -eq 0 && as_status=1
+  if test "$4"; then
+    as_lineno=${as_lineno-"$3"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+    $as_echo "$as_me:${as_lineno-$LINENO}: error: $2" >&$4
+  fi
+  $as_echo "$as_me: error: $2" >&2
+  as_fn_exit $as_status
+} # as_fn_error
+
+
+# as_fn_set_status STATUS
+# -----------------------
+# Set $? to STATUS, without forking.
+as_fn_set_status ()
+{
+  return $1
+} # as_fn_set_status
+
+# as_fn_exit STATUS
+# -----------------
+# Exit the shell with STATUS, even in a "trap 0" or "set -e" context.
+as_fn_exit ()
+{
+  set +e
+  as_fn_set_status $1
+  exit $1
+} # as_fn_exit
+
+# as_fn_unset VAR
+# ---------------
+# Portably unset VAR.
+as_fn_unset ()
+{
+  { eval $1=; unset $1;}
+}
+as_unset=as_fn_unset
+# as_fn_append VAR VALUE
+# ----------------------
+# Append the text in VALUE to the end of the definition contained in VAR. Take
+# advantage of any shell optimizations that allow amortized linear growth over
+# repeated appends, instead of the typical quadratic growth present in naive
+# implementations.
+if (eval "as_var=1; as_var+=2; test x\$as_var = x12") 2>/dev/null; then :
+  eval 'as_fn_append ()
+  {
+    eval $1+=\$2
+  }'
+else
+  as_fn_append ()
+  {
+    eval $1=\$$1\$2
+  }
+fi # as_fn_append
+
+# as_fn_arith ARG...
+# ------------------
+# Perform arithmetic evaluation on the ARGs, and store the result in the
+# global $as_val. Take advantage of shells that can avoid forks. The arguments
+# must be portable across $(()) and expr.
+if (eval "test \$(( 1 + 1 )) = 2") 2>/dev/null; then :
+  eval 'as_fn_arith ()
+  {
+    as_val=$(( $* ))
+  }'
+else
+  as_fn_arith ()
+  {
+    as_val=`expr "$@" || test $? -eq 1`
+  }
+fi # as_fn_arith
+
+
 if expr a : '\(a\)' >/dev/null 2>&1 &&
    test "X`expr 00001 : '.*\(...\)'`" = X001; then
   as_expr=expr
@@ -27523,8 +12534,12 @@ else
   as_basename=false
 fi
 
+if (as_dir=`dirname -- /` && test "X$as_dir" = X/) >/dev/null 2>&1; then
+  as_dirname=dirname
+else
+  as_dirname=false
+fi
 
-# Name of the executable.
 as_me=`$as_basename -- "$0" ||
 $as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
 	 X"$0" : 'X\(//\)$' \| \
@@ -27544,76 +12559,25 @@ $as_echo X/"$0" |
 	  }
 	  s/.*/./; q'`
 
-# CDPATH.
-$as_unset CDPATH
-
-
-
-  as_lineno_1=$LINENO
-  as_lineno_2=$LINENO
-  test "x$as_lineno_1" != "x$as_lineno_2" &&
-  test "x`expr $as_lineno_1 + 1`" = "x$as_lineno_2" || {
-
-  # Create $as_me.lineno as a copy of $as_myself, but with $LINENO
-  # uniformly replaced by the line number.  The first 'sed' inserts a
-  # line-number line after each line using $LINENO; the second 'sed'
-  # does the real work.  The second script uses 'N' to pair each
-  # line-number line with the line containing $LINENO, and appends
-  # trailing '-' during substitution so that $LINENO is not a special
-  # case at line end.
-  # (Raja R Harinath suggested sed '=', and Paul Eggert wrote the
-  # scripts with optimization help from Paolo Bonzini.  Blame Lee
-  # E. McMahon (1931-1989) for sed's syntax.  :-)
-  sed -n '
-    p
-    /[$]LINENO/=
-  ' <$as_myself |
-    sed '
-      s/[$]LINENO.*/&-/
-      t lineno
-      b
-      :lineno
-      N
-      :loop
-      s/[$]LINENO\([^'$as_cr_alnum'_].*\n\)\(.*\)/\2\1\2/
-      t loop
-      s/-\n.*//
-    ' >$as_me.lineno &&
-  chmod +x "$as_me.lineno" ||
-    { $as_echo "$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&2
-   { (exit 1); exit 1; }; }
-
-  # Don't try to exec as it changes $[0], causing all sort of problems
-  # (the dirname of $[0] is not the place where we might find the
-  # original and so on.  Autoconf is especially sensitive to this).
-  . "./$as_me.lineno"
-  # Exit status is that of the last command.
-  exit
-}
-
-
-if (as_dir=`dirname -- /` && test "X$as_dir" = X/) >/dev/null 2>&1; then
-  as_dirname=dirname
-else
-  as_dirname=false
-fi
+# Avoid depending upon Character Ranges.
+as_cr_letters='abcdefghijklmnopqrstuvwxyz'
+as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
+as_cr_Letters=$as_cr_letters$as_cr_LETTERS
+as_cr_digits='0123456789'
+as_cr_alnum=$as_cr_Letters$as_cr_digits
 
 ECHO_C= ECHO_N= ECHO_T=
-case `echo -n x` in
+case `echo -n x` in #(((((
 -n*)
-  case `echo 'x\c'` in
+  case `echo 'xy\c'` in
   *c*) ECHO_T='	';;	# ECHO_T is single tab character.
-  *)   ECHO_C='\c';;
+  xy)  ECHO_C='\c';;
+  *)   echo `echo ksh88 bug on AIX 6.1` > /dev/null
+       ECHO_T='	';;
   esac;;
 *)
   ECHO_N='-n';;
 esac
-if expr a : '\(a\)' >/dev/null 2>&1 &&
-   test "X`expr 00001 : '.*\(...\)'`" = X001; then
-  as_expr=expr
-else
-  as_expr=false
-fi
 
 rm -f conf$$ conf$$.exe conf$$.file
 if test -d conf$$.dir; then
@@ -27628,49 +12592,85 @@ if (echo >conf$$.file) 2>/dev/null; then
     # ... but there are two gotchas:
     # 1) On MSYS, both `ln -s file dir' and `ln file dir' fail.
     # 2) DJGPP < 2.04 has no symlinks; `ln -s' creates a wrapper executable.
-    # In both cases, we have to default to `cp -p'.
+    # In both cases, we have to default to `cp -pR'.
     ln -s conf$$.file conf$$.dir 2>/dev/null && test ! -f conf$$.exe ||
-      as_ln_s='cp -p'
+      as_ln_s='cp -pR'
   elif ln conf$$.file conf$$ 2>/dev/null; then
     as_ln_s=ln
   else
-    as_ln_s='cp -p'
+    as_ln_s='cp -pR'
   fi
 else
-  as_ln_s='cp -p'
+  as_ln_s='cp -pR'
 fi
 rm -f conf$$ conf$$.exe conf$$.dir/conf$$.file conf$$.file
 rmdir conf$$.dir 2>/dev/null
 
+
+# as_fn_mkdir_p
+# -------------
+# Create "$as_dir" as a directory, including parents if necessary.
+as_fn_mkdir_p ()
+{
+
+  case $as_dir in #(
+  -*) as_dir=./$as_dir;;
+  esac
+  test -d "$as_dir" || eval $as_mkdir_p || {
+    as_dirs=
+    while :; do
+      case $as_dir in #(
+      *\'*) as_qdir=`$as_echo "$as_dir" | sed "s/'/'\\\\\\\\''/g"`;; #'(
+      *) as_qdir=$as_dir;;
+      esac
+      as_dirs="'$as_qdir' $as_dirs"
+      as_dir=`$as_dirname -- "$as_dir" ||
+$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$as_dir" : 'X\(//\)[^/]' \| \
+	 X"$as_dir" : 'X\(//\)$' \| \
+	 X"$as_dir" : 'X\(/\)' \| . 2>/dev/null ||
+$as_echo X"$as_dir" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)[^/].*/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+      test -d "$as_dir" && break
+    done
+    test -z "$as_dirs" || eval "mkdir $as_dirs"
+  } || test -d "$as_dir" || as_fn_error $? "cannot create directory $as_dir"
+
+
+} # as_fn_mkdir_p
 if mkdir -p . 2>/dev/null; then
-  as_mkdir_p=:
+  as_mkdir_p='mkdir -p "$as_dir"'
 else
   test -d ./-p && rmdir ./-p
   as_mkdir_p=false
 fi
 
-if test -x / >/dev/null 2>&1; then
-  as_test_x='test -x'
-else
-  if ls -dL / >/dev/null 2>&1; then
-    as_ls_L_option=L
-  else
-    as_ls_L_option=
-  fi
-  as_test_x='
-    eval sh -c '\''
-      if test -d "$1"; then
-	test -d "$1/.";
-      else
-	case $1 in
-	-*)set "./$1";;
-	esac;
-	case `ls -ld'$as_ls_L_option' "$1" 2>/dev/null` in
-	???[sx]*):;;*)false;;esac;fi
-    '\'' sh
-  '
-fi
-as_executable_p=$as_test_x
+
+# as_fn_executable_p FILE
+# -----------------------
+# Test if FILE is an executable regular file.
+as_fn_executable_p ()
+{
+  test -f "$1" && test -x "$1"
+} # as_fn_executable_p
+as_test_x='test -x'
+as_executable_p=as_fn_executable_p
 
 # Sed expression to map a string onto a valid CPP name.
 as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"
@@ -27680,13 +12680,19 @@ as_tr_sh="eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'"
 
 
 exec 6>&1
+## ----------------------------------- ##
+## Main body of $CONFIG_STATUS script. ##
+## ----------------------------------- ##
+_ASEOF
+test $as_write_fail = 0 && chmod +x $CONFIG_STATUS || ac_write_fail=1
 
-# Save the log message, to keep $[0] and so on meaningful, and to
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+# Save the log message, to keep $0 and so on meaningful, and to
 # report actual input values of CONFIG_FILES etc. instead of their
 # values after options handling.
 ac_log="
 This file was extended by $as_me, which was
-generated by GNU Autoconf 2.63.  Invocation command line was
+generated by GNU Autoconf 2.69.  Invocation command line was
 
   CONFIG_FILES    = $CONFIG_FILES
   CONFIG_HEADERS  = $CONFIG_HEADERS
@@ -27717,13 +12723,15 @@ _ACEOF
 
 cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
 ac_cs_usage="\
-\`$as_me' instantiates files from templates according to the
-current configuration.
+\`$as_me' instantiates files and other configuration actions
+from templates according to the current configuration.  Unless the files
+and actions are specified as TAGs, all are instantiated by default.
 
-Usage: $0 [OPTION]... [FILE]...
+Usage: $0 [OPTION]... [TAG]...
 
   -h, --help       print this help, then exit
   -V, --version    print version number and configuration settings, then exit
+      --config     print configuration, then exit
   -q, --quiet, --silent
                    do not print progress messages
   -d, --debug      don't remove temporary files
@@ -27739,16 +12747,17 @@ $config_files
 Configuration headers:
 $config_headers
 
-Report bugs to <bug-autoconf@gnu.org>."
+Report bugs to the package provider."
 
 _ACEOF
 cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+ac_cs_config="`$as_echo "$ac_configure_args" | sed 's/^ //; s/[\\""\`\$]/\\\\&/g'`"
 ac_cs_version="\\
 config.status
-configured by $0, generated by GNU Autoconf 2.63,
-  with options \\"`$as_echo "$ac_configure_args" | sed 's/^ //; s/[\\""\`\$]/\\\\&/g'`\\"
+configured by $0, generated by GNU Autoconf 2.69,
+  with options \\"\$ac_cs_config\\"
 
-Copyright (C) 2008 Free Software Foundation, Inc.
+Copyright (C) 2012 Free Software Foundation, Inc.
 This config.status script is free software; the Free Software Foundation
 gives unlimited permission to copy, distribute and modify it."
 
@@ -27763,11 +12772,16 @@ ac_need_defaults=:
 while test $# != 0
 do
   case $1 in
-  --*=*)
+  --*=?*)
     ac_option=`expr "X$1" : 'X\([^=]*\)='`
     ac_optarg=`expr "X$1" : 'X[^=]*=\(.*\)'`
     ac_shift=:
     ;;
+  --*=)
+    ac_option=`expr "X$1" : 'X\([^=]*\)='`
+    ac_optarg=
+    ac_shift=:
+    ;;
   *)
     ac_option=$1
     ac_optarg=$2
@@ -27781,27 +12795,29 @@ do
     ac_cs_recheck=: ;;
   --version | --versio | --versi | --vers | --ver | --ve | --v | -V )
     $as_echo "$ac_cs_version"; exit ;;
+  --config | --confi | --conf | --con | --co | --c )
+    $as_echo "$ac_cs_config"; exit ;;
   --debug | --debu | --deb | --de | --d | -d )
     debug=: ;;
   --file | --fil | --fi | --f )
     $ac_shift
     case $ac_optarg in
     *\'*) ac_optarg=`$as_echo "$ac_optarg" | sed "s/'/'\\\\\\\\''/g"` ;;
+    '') as_fn_error $? "missing file argument" ;;
     esac
-    CONFIG_FILES="$CONFIG_FILES '$ac_optarg'"
+    as_fn_append CONFIG_FILES " '$ac_optarg'"
     ac_need_defaults=false;;
   --header | --heade | --head | --hea )
     $ac_shift
     case $ac_optarg in
     *\'*) ac_optarg=`$as_echo "$ac_optarg" | sed "s/'/'\\\\\\\\''/g"` ;;
     esac
-    CONFIG_HEADERS="$CONFIG_HEADERS '$ac_optarg'"
+    as_fn_append CONFIG_HEADERS " '$ac_optarg'"
     ac_need_defaults=false;;
   --he | --h)
     # Conflict between --help and --header
-    { $as_echo "$as_me: error: ambiguous option: $1
-Try \`$0 --help' for more information." >&2
-   { (exit 1); exit 1; }; };;
+    as_fn_error $? "ambiguous option: \`$1'
+Try \`$0 --help' for more information.";;
   --help | --hel | -h )
     $as_echo "$ac_cs_usage"; exit ;;
   -q | -quiet | --quiet | --quie | --qui | --qu | --q \
@@ -27809,11 +12825,10 @@ Try \`$0 --help' for more information." >&2
     ac_cs_silent=: ;;
 
   # This is an error.
-  -*) { $as_echo "$as_me: error: unrecognized option: $1
-Try \`$0 --help' for more information." >&2
-   { (exit 1); exit 1; }; } ;;
+  -*) as_fn_error $? "unrecognized option: \`$1'
+Try \`$0 --help' for more information." ;;
 
-  *) ac_config_targets="$ac_config_targets $1"
+  *) as_fn_append ac_config_targets " $1"
      ac_need_defaults=false ;;
 
   esac
@@ -27830,7 +12845,7 @@ fi
 _ACEOF
 cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
 if \$ac_cs_recheck; then
-  set X '$SHELL' '$0' $ac_configure_args \$ac_configure_extra_args --no-create --no-recursion
+  set X $SHELL '$0' $ac_configure_args \$ac_configure_extra_args --no-create --no-recursion
   shift
   \$as_echo "running CONFIG_SHELL=$SHELL \$*" >&6
   CONFIG_SHELL='$SHELL'
@@ -27864,9 +12879,7 @@ do
     "base.make") CONFIG_FILES="$CONFIG_FILES base.make" ;;
     "Headers/GNUstepBase/GSConfig.h") CONFIG_FILES="$CONFIG_FILES Headers/GNUstepBase/GSConfig.h" ;;
 
-  *) { { $as_echo "$as_me:$LINENO: error: invalid argument: $ac_config_target" >&5
-$as_echo "$as_me: error: invalid argument: $ac_config_target" >&2;}
-   { (exit 1); exit 1; }; };;
+  *) as_fn_error $? "invalid argument: \`$ac_config_target'" "$LINENO" 5;;
   esac
 done
 
@@ -27888,26 +12901,24 @@ fi
 # after its creation but before its name has been assigned to `$tmp'.
 $debug ||
 {
-  tmp=
+  tmp= ac_tmp=
   trap 'exit_status=$?
-  { test -z "$tmp" || test ! -d "$tmp" || rm -fr "$tmp"; } && exit $exit_status
+  : "${ac_tmp:=$tmp}"
+  { test ! -d "$ac_tmp" || rm -fr "$ac_tmp"; } && exit $exit_status
 ' 0
-  trap '{ (exit 1); exit 1; }' 1 2 13 15
+  trap 'as_fn_exit 1' 1 2 13 15
 }
 # Create a (secure) tmp directory for tmp files.
 
 {
   tmp=`(umask 077 && mktemp -d "./confXXXXXX") 2>/dev/null` &&
-  test -n "$tmp" && test -d "$tmp"
+  test -d "$tmp"
 }  ||
 {
   tmp=./conf$$-$RANDOM
   (umask 077 && mkdir "$tmp")
-} ||
-{
-   $as_echo "$as_me: cannot create a temporary directory in ." >&2
-   { (exit 1); exit 1; }
-}
+} || as_fn_error $? "cannot create a temporary directory in ." "$LINENO" 5
+ac_tmp=$tmp
 
 # Set up the scripts for CONFIG_FILES section.
 # No need to generate them if there are no CONFIG_FILES.
@@ -27915,7 +12926,13 @@ $debug ||
 if test -n "$CONFIG_FILES"; then
 
 
-ac_cr=''
+ac_cr=`echo X | tr X '\015'`
+# On cygwin, bash can eat \r inside `` if the user requested igncr.
+# But we know of no other shell where ac_cr would be empty at this
+# point, so we can use a bashism as a fallback.
+if test "x$ac_cr" = x; then
+  eval ac_cr=\$\'\\r\'
+fi
 ac_cs_awk_cr=`$AWK 'BEGIN { print "a\rb" }' </dev/null 2>/dev/null`
 if test "$ac_cs_awk_cr" = "a${ac_cr}b"; then
   ac_cs_awk_cr='\\r'
@@ -27923,7 +12940,7 @@ else
   ac_cs_awk_cr=$ac_cr
 fi
 
-echo 'BEGIN {' >"$tmp/subs1.awk" &&
+echo 'BEGIN {' >"$ac_tmp/subs1.awk" &&
 _ACEOF
 
 
@@ -27932,24 +12949,18 @@ _ACEOF
   echo "$ac_subst_vars" | sed 's/.*/&!$&$ac_delim/' &&
   echo "_ACEOF"
 } >conf$$subs.sh ||
-  { { $as_echo "$as_me:$LINENO: error: could not make $CONFIG_STATUS" >&5
-$as_echo "$as_me: error: could not make $CONFIG_STATUS" >&2;}
-   { (exit 1); exit 1; }; }
-ac_delim_num=`echo "$ac_subst_vars" | grep -c '$'`
+  as_fn_error $? "could not make $CONFIG_STATUS" "$LINENO" 5
+ac_delim_num=`echo "$ac_subst_vars" | grep -c '^'`
 ac_delim='%!_!# '
 for ac_last_try in false false false false false :; do
   . ./conf$$subs.sh ||
-    { { $as_echo "$as_me:$LINENO: error: could not make $CONFIG_STATUS" >&5
-$as_echo "$as_me: error: could not make $CONFIG_STATUS" >&2;}
-   { (exit 1); exit 1; }; }
+    as_fn_error $? "could not make $CONFIG_STATUS" "$LINENO" 5
 
   ac_delim_n=`sed -n "s/.*$ac_delim\$/X/p" conf$$subs.awk | grep -c X`
   if test $ac_delim_n = $ac_delim_num; then
     break
   elif $ac_last_try; then
-    { { $as_echo "$as_me:$LINENO: error: could not make $CONFIG_STATUS" >&5
-$as_echo "$as_me: error: could not make $CONFIG_STATUS" >&2;}
-   { (exit 1); exit 1; }; }
+    as_fn_error $? "could not make $CONFIG_STATUS" "$LINENO" 5
   else
     ac_delim="$ac_delim!$ac_delim _$ac_delim!! "
   fi
@@ -27957,7 +12968,7 @@ done
 rm -f conf$$subs.sh
 
 cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
-cat >>"\$tmp/subs1.awk" <<\\_ACAWK &&
+cat >>"\$ac_tmp/subs1.awk" <<\\_ACAWK &&
 _ACEOF
 sed -n '
 h
@@ -27971,7 +12982,7 @@ s/'"$ac_delim"'$//
 t delim
 :nl
 h
-s/\(.\{148\}\).*/\1/
+s/\(.\{148\}\)..*/\1/
 t more1
 s/["\\]/\\&/g; s/^/"/; s/$/\\n"\\/
 p
@@ -27985,7 +12996,7 @@ s/.\{148\}//
 t nl
 :delim
 h
-s/\(.\{148\}\).*/\1/
+s/\(.\{148\}\)..*/\1/
 t more2
 s/["\\]/\\&/g; s/^/"/; s/$/"/
 p
@@ -28005,7 +13016,7 @@ t delim
 rm -f conf$$subs.awk
 cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
 _ACAWK
-cat >>"\$tmp/subs1.awk" <<_ACAWK &&
+cat >>"\$ac_tmp/subs1.awk" <<_ACAWK &&
   for (key in S) S_is_set[key] = 1
   FS = ""
 
@@ -28037,23 +13048,29 @@ if sed "s/$ac_cr//" < /dev/null > /dev/null 2>&1; then
   sed "s/$ac_cr\$//; s/$ac_cr/$ac_cs_awk_cr/g"
 else
   cat
-fi < "$tmp/subs1.awk" > "$tmp/subs.awk" \
-  || { { $as_echo "$as_me:$LINENO: error: could not setup config files machinery" >&5
-$as_echo "$as_me: error: could not setup config files machinery" >&2;}
-   { (exit 1); exit 1; }; }
+fi < "$ac_tmp/subs1.awk" > "$ac_tmp/subs.awk" \
+  || as_fn_error $? "could not setup config files machinery" "$LINENO" 5
 _ACEOF
 
-# VPATH may cause trouble with some makes, so we remove $(srcdir),
-# ${srcdir} and @srcdir@ from VPATH if srcdir is ".", strip leading and
+# VPATH may cause trouble with some makes, so we remove sole $(srcdir),
+# ${srcdir} and @srcdir@ entries from VPATH if srcdir is ".", strip leading and
 # trailing colons and then remove the whole line if VPATH becomes empty
 # (actually we leave an empty line to preserve line numbers).
 if test "x$srcdir" = x.; then
-  ac_vpsub='/^[	 ]*VPATH[	 ]*=/{
-s/:*\$(srcdir):*/:/
-s/:*\${srcdir}:*/:/
-s/:*@srcdir@:*/:/
-s/^\([^=]*=[	 ]*\):*/\1/
+  ac_vpsub='/^[	 ]*VPATH[	 ]*=[	 ]*/{
+h
+s///
+s/^/:/
+s/[	 ]*$/:/
+s/:\$(srcdir):/:/g
+s/:\${srcdir}:/:/g
+s/:@srcdir@:/:/g
+s/^:*//
 s/:*$//
+x
+s/\(=[	 ]*\).*/\1/
+G
+s/\n//
 s/^[^=]*=[	 ]*$//
 }'
 fi
@@ -28065,7 +13082,7 @@ fi # test -n "$CONFIG_FILES"
 # No need to generate them if there are no CONFIG_HEADERS.
 # This happens for instance with `./config.status Makefile'.
 if test -n "$CONFIG_HEADERS"; then
-cat >"$tmp/defines.awk" <<\_ACAWK ||
+cat >"$ac_tmp/defines.awk" <<\_ACAWK ||
 BEGIN {
 _ACEOF
 
@@ -28077,13 +13094,11 @@ _ACEOF
 # handling of long lines.
 ac_delim='%!_!# '
 for ac_last_try in false false :; do
-  ac_t=`sed -n "/$ac_delim/p" confdefs.h`
-  if test -z "$ac_t"; then
+  ac_tt=`sed -n "/$ac_delim/p" confdefs.h`
+  if test -z "$ac_tt"; then
     break
   elif $ac_last_try; then
-    { { $as_echo "$as_me:$LINENO: error: could not make $CONFIG_HEADERS" >&5
-$as_echo "$as_me: error: could not make $CONFIG_HEADERS" >&2;}
-   { (exit 1); exit 1; }; }
+    as_fn_error $? "could not make $CONFIG_HEADERS" "$LINENO" 5
   else
     ac_delim="$ac_delim!$ac_delim _$ac_delim!! "
   fi
@@ -28168,9 +13183,7 @@ cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
 _ACAWK
 _ACEOF
 cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
-  { { $as_echo "$as_me:$LINENO: error: could not setup config headers machinery" >&5
-$as_echo "$as_me: error: could not setup config headers machinery" >&2;}
-   { (exit 1); exit 1; }; }
+  as_fn_error $? "could not setup config headers machinery" "$LINENO" 5
 fi # test -n "$CONFIG_HEADERS"
 
 
@@ -28183,9 +13196,7 @@ do
   esac
   case $ac_mode$ac_tag in
   :[FHL]*:*);;
-  :L* | :C*:*) { { $as_echo "$as_me:$LINENO: error: invalid tag $ac_tag" >&5
-$as_echo "$as_me: error: invalid tag $ac_tag" >&2;}
-   { (exit 1); exit 1; }; };;
+  :L* | :C*:*) as_fn_error $? "invalid tag \`$ac_tag'" "$LINENO" 5;;
   :[FH]-) ac_tag=-:-;;
   :[FH]*) ac_tag=$ac_tag:$ac_tag.in;;
   esac
@@ -28204,7 +13215,7 @@ $as_echo "$as_me: error: invalid tag $ac_tag" >&2;}
     for ac_f
     do
       case $ac_f in
-      -) ac_f="$tmp/stdin";;
+      -) ac_f="$ac_tmp/stdin";;
       *) # Look for the file first in the build tree, then in the source tree
 	 # (if the path is not absolute).  The absolute path cannot be DOS-style,
 	 # because $ac_f cannot contain `:'.
@@ -28213,12 +13224,10 @@ $as_echo "$as_me: error: invalid tag $ac_tag" >&2;}
 	   [\\/$]*) false;;
 	   *) test -f "$srcdir/$ac_f" && ac_f="$srcdir/$ac_f";;
 	   esac ||
-	   { { $as_echo "$as_me:$LINENO: error: cannot find input file: $ac_f" >&5
-$as_echo "$as_me: error: cannot find input file: $ac_f" >&2;}
-   { (exit 1); exit 1; }; };;
+	   as_fn_error 1 "cannot find input file: \`$ac_f'" "$LINENO" 5;;
       esac
       case $ac_f in *\'*) ac_f=`$as_echo "$ac_f" | sed "s/'/'\\\\\\\\''/g"`;; esac
-      ac_file_inputs="$ac_file_inputs '$ac_f'"
+      as_fn_append ac_file_inputs " '$ac_f'"
     done
 
     # Let's still pretend it is `configure' which instantiates (i.e., don't
@@ -28229,7 +13238,7 @@ $as_echo "$as_me: error: cannot find input file: $ac_f" >&2;}
 	`' by configure.'
     if test x"$ac_file" != x-; then
       configure_input="$ac_file.  $configure_input"
-      { $as_echo "$as_me:$LINENO: creating $ac_file" >&5
+      { $as_echo "$as_me:${as_lineno-$LINENO}: creating $ac_file" >&5
 $as_echo "$as_me: creating $ac_file" >&6;}
     fi
     # Neutralize special characters interpreted by sed in replacement strings.
@@ -28241,10 +13250,8 @@ $as_echo "$as_me: creating $ac_file" >&6;}
     esac
 
     case $ac_tag in
-    *:-:* | *:-) cat >"$tmp/stdin" \
-      || { { $as_echo "$as_me:$LINENO: error: could not create $ac_file" >&5
-$as_echo "$as_me: error: could not create $ac_file" >&2;}
-   { (exit 1); exit 1; }; } ;;
+    *:-:* | *:-) cat >"$ac_tmp/stdin" \
+      || as_fn_error $? "could not create $ac_file" "$LINENO" 5 ;;
     esac
     ;;
   esac
@@ -28272,47 +13279,7 @@ $as_echo X"$ac_file" |
 	    q
 	  }
 	  s/.*/./; q'`
-  { as_dir="$ac_dir"
-  case $as_dir in #(
-  -*) as_dir=./$as_dir;;
-  esac
-  test -d "$as_dir" || { $as_mkdir_p && mkdir -p "$as_dir"; } || {
-    as_dirs=
-    while :; do
-      case $as_dir in #(
-      *\'*) as_qdir=`$as_echo "$as_dir" | sed "s/'/'\\\\\\\\''/g"`;; #'(
-      *) as_qdir=$as_dir;;
-      esac
-      as_dirs="'$as_qdir' $as_dirs"
-      as_dir=`$as_dirname -- "$as_dir" ||
-$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
-	 X"$as_dir" : 'X\(//\)[^/]' \| \
-	 X"$as_dir" : 'X\(//\)$' \| \
-	 X"$as_dir" : 'X\(/\)' \| . 2>/dev/null ||
-$as_echo X"$as_dir" |
-    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\/\)[^/].*/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\/\)$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\).*/{
-	    s//\1/
-	    q
-	  }
-	  s/.*/./; q'`
-      test -d "$as_dir" && break
-    done
-    test -z "$as_dirs" || eval "mkdir $as_dirs"
-  } || test -d "$as_dir" || { { $as_echo "$as_me:$LINENO: error: cannot create directory $as_dir" >&5
-$as_echo "$as_me: error: cannot create directory $as_dir" >&2;}
-   { (exit 1); exit 1; }; }; }
+  as_dir="$ac_dir"; as_fn_mkdir_p
   ac_builddir=.
 
 case "$ac_dir" in
@@ -28360,7 +13327,6 @@ cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
 # If the template does not know about datarootdir, expand it.
 # FIXME: This hack should be removed a few years after 2.60.
 ac_datarootdir_hack=; ac_datarootdir_seen=
-
 ac_sed_dataroot='
 /datarootdir/ {
   p
@@ -28370,12 +13336,11 @@ ac_sed_dataroot='
 /@docdir@/p
 /@infodir@/p
 /@localedir@/p
-/@mandir@/p
-'
+/@mandir@/p'
 case `eval "sed -n \"\$ac_sed_dataroot\" $ac_file_inputs"` in
 *datarootdir*) ac_datarootdir_seen=yes;;
 *@datadir@*|*@docdir@*|*@infodir@*|*@localedir@*|*@mandir@*)
-  { $as_echo "$as_me:$LINENO: WARNING: $ac_file_inputs seems to ignore the --datarootdir setting" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $ac_file_inputs seems to ignore the --datarootdir setting" >&5
 $as_echo "$as_me: WARNING: $ac_file_inputs seems to ignore the --datarootdir setting" >&2;}
 _ACEOF
 cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
@@ -28385,7 +13350,7 @@ cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
   s&@infodir@&$infodir&g
   s&@localedir@&$localedir&g
   s&@mandir@&$mandir&g
-    s&\\\${datarootdir}&$datarootdir&g' ;;
+  s&\\\${datarootdir}&$datarootdir&g' ;;
 esac
 _ACEOF
 
@@ -28411,27 +13376,24 @@ s&@abs_builddir@&$ac_abs_builddir&;t t
 s&@abs_top_builddir@&$ac_abs_top_builddir&;t t
 $ac_datarootdir_hack
 "
-eval sed \"\$ac_sed_extra\" "$ac_file_inputs" | $AWK -f "$tmp/subs.awk" >$tmp/out \
-  || { { $as_echo "$as_me:$LINENO: error: could not create $ac_file" >&5
-$as_echo "$as_me: error: could not create $ac_file" >&2;}
-   { (exit 1); exit 1; }; }
+eval sed \"\$ac_sed_extra\" "$ac_file_inputs" | $AWK -f "$ac_tmp/subs.awk" \
+  >$ac_tmp/out || as_fn_error $? "could not create $ac_file" "$LINENO" 5
 
 test -z "$ac_datarootdir_hack$ac_datarootdir_seen" &&
-  { ac_out=`sed -n '/\${datarootdir}/p' "$tmp/out"`; test -n "$ac_out"; } &&
-  { ac_out=`sed -n '/^[	 ]*datarootdir[	 ]*:*=/p' "$tmp/out"`; test -z "$ac_out"; } &&
-  { $as_echo "$as_me:$LINENO: WARNING: $ac_file contains a reference to the variable \`datarootdir'
-which seems to be undefined.  Please make sure it is defined." >&5
+  { ac_out=`sed -n '/\${datarootdir}/p' "$ac_tmp/out"`; test -n "$ac_out"; } &&
+  { ac_out=`sed -n '/^[	 ]*datarootdir[	 ]*:*=/p' \
+      "$ac_tmp/out"`; test -z "$ac_out"; } &&
+  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $ac_file contains a reference to the variable \`datarootdir'
+which seems to be undefined.  Please make sure it is defined" >&5
 $as_echo "$as_me: WARNING: $ac_file contains a reference to the variable \`datarootdir'
-which seems to be undefined.  Please make sure it is defined." >&2;}
+which seems to be undefined.  Please make sure it is defined" >&2;}
 
-  rm -f "$tmp/stdin"
+  rm -f "$ac_tmp/stdin"
   case $ac_file in
-  -) cat "$tmp/out" && rm -f "$tmp/out";;
-  *) rm -f "$ac_file" && mv "$tmp/out" "$ac_file";;
+  -) cat "$ac_tmp/out" && rm -f "$ac_tmp/out";;
+  *) rm -f "$ac_file" && mv "$ac_tmp/out" "$ac_file";;
   esac \
-  || { { $as_echo "$as_me:$LINENO: error: could not create $ac_file" >&5
-$as_echo "$as_me: error: could not create $ac_file" >&2;}
-   { (exit 1); exit 1; }; }
+  || as_fn_error $? "could not create $ac_file" "$LINENO" 5
  ;;
   :H)
   #
@@ -28440,27 +13402,21 @@ $as_echo "$as_me: error: could not create $ac_file" >&2;}
   if test x"$ac_file" != x-; then
     {
       $as_echo "/* $configure_input  */" \
-      && eval '$AWK -f "$tmp/defines.awk"' "$ac_file_inputs"
-    } >"$tmp/config.h" \
-      || { { $as_echo "$as_me:$LINENO: error: could not create $ac_file" >&5
-$as_echo "$as_me: error: could not create $ac_file" >&2;}
-   { (exit 1); exit 1; }; }
-    if diff "$ac_file" "$tmp/config.h" >/dev/null 2>&1; then
-      { $as_echo "$as_me:$LINENO: $ac_file is unchanged" >&5
+      && eval '$AWK -f "$ac_tmp/defines.awk"' "$ac_file_inputs"
+    } >"$ac_tmp/config.h" \
+      || as_fn_error $? "could not create $ac_file" "$LINENO" 5
+    if diff "$ac_file" "$ac_tmp/config.h" >/dev/null 2>&1; then
+      { $as_echo "$as_me:${as_lineno-$LINENO}: $ac_file is unchanged" >&5
 $as_echo "$as_me: $ac_file is unchanged" >&6;}
     else
       rm -f "$ac_file"
-      mv "$tmp/config.h" "$ac_file" \
-	|| { { $as_echo "$as_me:$LINENO: error: could not create $ac_file" >&5
-$as_echo "$as_me: error: could not create $ac_file" >&2;}
-   { (exit 1); exit 1; }; }
+      mv "$ac_tmp/config.h" "$ac_file" \
+	|| as_fn_error $? "could not create $ac_file" "$LINENO" 5
     fi
   else
     $as_echo "/* $configure_input  */" \
-      && eval '$AWK -f "$tmp/defines.awk"' "$ac_file_inputs" \
-      || { { $as_echo "$as_me:$LINENO: error: could not create -" >&5
-$as_echo "$as_me: error: could not create -" >&2;}
-   { (exit 1); exit 1; }; }
+      && eval '$AWK -f "$ac_tmp/defines.awk"' "$ac_file_inputs" \
+      || as_fn_error $? "could not create -" "$LINENO" 5
   fi
  ;;
 
@@ -28470,15 +13426,12 @@ $as_echo "$as_me: error: could not create -" >&2;}
 done # for ac_tag
 
 
-{ (exit 0); exit 0; }
+as_fn_exit 0
 _ACEOF
-chmod +x $CONFIG_STATUS
 ac_clean_files=$ac_clean_files_save
 
 test $ac_write_fail = 0 ||
-  { { $as_echo "$as_me:$LINENO: error: write failure creating $CONFIG_STATUS" >&5
-$as_echo "$as_me: error: write failure creating $CONFIG_STATUS" >&2;}
-   { (exit 1); exit 1; }; }
+  as_fn_error $? "write failure creating $CONFIG_STATUS" "$LINENO" 5
 
 
 # configure is writing to config.log, and then calls config.status.
@@ -28499,7 +13452,7 @@ if test "$no_create" != yes; then
   exec 5>>config.log
   # Use ||, not &&, to avoid exiting from the if with $? = 1, which
   # would make configure fail if this is the last instruction.
-  $ac_cs_success || { (exit 1); exit 1; }
+  $ac_cs_success || as_fn_exit 1
 fi
 
 #
@@ -28543,7 +13496,7 @@ if test "$no_recursion" != yes; then
       case $ac_arg in
       *\'*) ac_arg=`$as_echo "$ac_arg" | sed "s/'/'\\\\\\\\''/g"` ;;
       esac
-      ac_sub_configure_args="$ac_sub_configure_args '$ac_arg'" ;;
+      as_fn_append ac_sub_configure_args " '$ac_arg'" ;;
     esac
   done
 
@@ -28572,49 +13525,9 @@ if test "$no_recursion" != yes; then
     test -d "$srcdir/$ac_dir" || continue
 
     ac_msg="=== configuring in $ac_dir (`pwd`/$ac_dir)"
-    $as_echo "$as_me:$LINENO: $ac_msg" >&5
+    $as_echo "$as_me:${as_lineno-$LINENO}: $ac_msg" >&5
     $as_echo "$ac_msg" >&6
-    { as_dir="$ac_dir"
-  case $as_dir in #(
-  -*) as_dir=./$as_dir;;
-  esac
-  test -d "$as_dir" || { $as_mkdir_p && mkdir -p "$as_dir"; } || {
-    as_dirs=
-    while :; do
-      case $as_dir in #(
-      *\'*) as_qdir=`$as_echo "$as_dir" | sed "s/'/'\\\\\\\\''/g"`;; #'(
-      *) as_qdir=$as_dir;;
-      esac
-      as_dirs="'$as_qdir' $as_dirs"
-      as_dir=`$as_dirname -- "$as_dir" ||
-$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
-	 X"$as_dir" : 'X\(//\)[^/]' \| \
-	 X"$as_dir" : 'X\(//\)$' \| \
-	 X"$as_dir" : 'X\(/\)' \| . 2>/dev/null ||
-$as_echo X"$as_dir" |
-    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\/\)[^/].*/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\/\)$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\).*/{
-	    s//\1/
-	    q
-	  }
-	  s/.*/./; q'`
-      test -d "$as_dir" && break
-    done
-    test -z "$as_dirs" || eval "mkdir $as_dirs"
-  } || test -d "$as_dir" || { { $as_echo "$as_me:$LINENO: error: cannot create directory $as_dir" >&5
-$as_echo "$as_me: error: cannot create directory $as_dir" >&2;}
-   { (exit 1); exit 1; }; }; }
+    as_dir="$ac_dir"; as_fn_mkdir_p
     ac_builddir=.
 
 case "$ac_dir" in
@@ -28661,7 +13574,7 @@ ac_abs_srcdir=$ac_abs_top_srcdir$ac_dir_suffix
       # This should be Cygnus configure.
       ac_sub_configure=$ac_aux_dir/configure
     else
-      { $as_echo "$as_me:$LINENO: WARNING: no configuration information is in $ac_dir" >&5
+      { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: no configuration information is in $ac_dir" >&5
 $as_echo "$as_me: WARNING: no configuration information is in $ac_dir" >&2;}
       ac_sub_configure=
     fi
@@ -28675,21 +13588,19 @@ $as_echo "$as_me: WARNING: no configuration information is in $ac_dir" >&2;}
 	ac_sub_cache_file=$ac_top_build_prefix$cache_file ;;
       esac
 
-      { $as_echo "$as_me:$LINENO: running $SHELL $ac_sub_configure $ac_sub_configure_args --cache-file=$ac_sub_cache_file --srcdir=$ac_srcdir" >&5
+      { $as_echo "$as_me:${as_lineno-$LINENO}: running $SHELL $ac_sub_configure $ac_sub_configure_args --cache-file=$ac_sub_cache_file --srcdir=$ac_srcdir" >&5
 $as_echo "$as_me: running $SHELL $ac_sub_configure $ac_sub_configure_args --cache-file=$ac_sub_cache_file --srcdir=$ac_srcdir" >&6;}
       # The eval makes quoting arguments work.
       eval "\$SHELL \"\$ac_sub_configure\" $ac_sub_configure_args \
 	   --cache-file=\"\$ac_sub_cache_file\" --srcdir=\"\$ac_srcdir\"" ||
-	{ { $as_echo "$as_me:$LINENO: error: $ac_sub_configure failed for $ac_dir" >&5
-$as_echo "$as_me: error: $ac_sub_configure failed for $ac_dir" >&2;}
-   { (exit 1); exit 1; }; }
+	as_fn_error $? "$ac_sub_configure failed for $ac_dir" "$LINENO" 5
     fi
 
     cd "$ac_popdir"
   done
 fi
 if test -n "$ac_unrecognized_opts" && test "$enable_option_checking" != no; then
-  { $as_echo "$as_me:$LINENO: WARNING: unrecognized options: $ac_unrecognized_opts" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: unrecognized options: $ac_unrecognized_opts" >&5
 $as_echo "$as_me: WARNING: unrecognized options: $ac_unrecognized_opts" >&2;}
 fi
 
diff --git a/configure.ac b/configure.ac
index f97c4b1..5ea6092 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1222,6 +1222,14 @@ if test "$LIBOBJC" = ""; then
   exit 1
 fi
 
+FOUNDATION_LIB=`echo $LIBRARY_COMBO | tr '-' ' ' | awk '{print $2}'`
+AC_MSG_CHECKING(the Foundation library)
+if test "$FOUNDATION_LIB" = "nx" -o "$FOUNDATION_LIB" = "apple"; then
+  AC_MSG_RESULT(NeXT)
+else
+  AC_MSG_RESULT(GNU)
+fi
+
 #--------------------------------------------------------------------
 # Miscellaneous flags
 #--------------------------------------------------------------------
@@ -1767,9 +1775,16 @@ fi
 # Unless we are building for the apple runtime (ie only building base
 # additions library and not implementing a constant string class).
 #---------------------------------------------------------------------
-if test "$OBJC_RUNTIME_LIB" = "nx" -o "$OBJC_RUNTIME_LIB" = "apple"; then
+AC_MSG_CHECKING(if the compiler generates constant CFStrings)
+case "$target_os" in
+    darwin*)    IS_DARWIN="yes";;
+    *)          IS_DARWIN="no";;
+esac
+AC_MSG_RESULT($IS_DARWIN)
+
+if test "$IS_DARWIN" = "yes"; then
   NX_CONST_STRING_OBJCFLAGS=""
-  NX_CONST_STRING_CLASS=NXConstantString
+  NX_CONST_STRING_CLASS=NSCFConstantString
 else
   strclass_CPPFLAGS="$CPPFLAGS"
   CPPFLAGS="$CPPFLAGS -fconstant-string-class=FooConstantString"
@@ -2607,13 +2622,17 @@ if test "$exceptions" = "yes"; then
   do_broken_libffcall=yes
   do_enable_libffcall=no
 
-  if test "$have_unexpected" = "no"; then
-    echo
-    echo "Your gnustep-make is configured to use native objc exceptions, but"
-    echo "the objc runtime does not appear to support setting an uncaught"
-    echo "exception handler.  This means that any uncaught exception will"
-    echo "cause a program to abort immediately."
-    echo "Consider reconfiguring gnustep-make or updating libobjc to fix this."
+  if test "$have_set_uncaught_exception_handler" = "no"; then
+    if test "$have_set_unexpected" = "no"; then
+      if test "$have_unexpected" = "no"; then
+        echo
+        echo "Your gnustep-make is configured to use native objc exceptions, but"
+        echo "the objc runtime does not appear to support setting an uncaught"
+        echo "exception handler.  This means that any uncaught exception will"
+        echo "cause a program to abort immediately."
+        echo "Consider reconfiguring gnustep-make or updating libobjc to fix this."
+      fi
+    fi
   fi
 fi
 
@@ -2753,37 +2772,39 @@ if test $enable_ffcall = yes -a $ffi_ok = yes; then
   AC_MSG_RESULT($have_working_trampoline)
 fi
 
-if test $ffi_ok = no; then
-  AC_MSG_RESULT(none)
-  echo
-  if test $have_forward_hook = no; then
-    echo "You do not have an up-to-date libobjc library installed"
-  elif test "$have_working_trampoline" = no; then
-    echo "You have ffcall, but it does not work properly. Most likely because"
-    echo "your system's security policy is blocking some parts of ffcall"
-    echo "we recommend installing libffi instead."
-  else
-    echo "You do not have either ffcall or libffi installed/enabled, or configure needs"
-    echo "--with-ffi-include and/or --with-ffi-library flags so GNUstep can find them,"
-    echo "or you have ffcall but gnustep-make is configured to use native exceptions"
-    echo "(native exceptions are not compatible with ffcall)."
-  fi
-  echo "GNUstep requires libffi (or ffcall) and proper libobjc hooks to do"
-  echo "invocations and DO."
-  echo "(This does not apply on apple-apple-apple systems where DO is"
-  echo "not compatible with other GNUstep systems.)"
-  if test $enable_invocations = yes; then
-    echo
-    echo "You most likely do not want to build base without invocation support."
-    echo "Many things (including Distributed Objects and undo/redo), won't work"
-    echo "at all without invocations."
-    echo "If you really want to build -base without invocation support,"
-    echo "add --disable-invocations to the configure arguments."
-    echo "For more information, read the GNUstep build guide, ffcall section:"
-    echo "http://gnustep.made-it.com/BuildGuide/index.html"
-    AC_MSG_ERROR([Incomplete support for ffi functionality.])
-  fi
-  AC_MSG_WARN([Incomplete support for ffi funtionality.])
+AC_MSG_RESULT($ffi_ok)
+if test "$OBJC_RUNTIME_LIB" != "nx" -a "$OBJC_RUNTIME_LIB" != "apple"; then
+    if test $ffi_ok = no; then
+      echo
+      if test $have_forward_hook = no; then
+        echo "You do not have an up-to-date libobjc library installed"
+      elif test "$have_working_trampoline" = no; then
+        echo "You have ffcall, but it does not work properly. Most likely because"
+        echo "your system's security policy is blocking some parts of ffcall"
+        echo "we recommend installing libffi instead."
+      else
+        echo "You do not have either ffcall or libffi installed/enabled, or configure needs"
+        echo "--with-ffi-include and/or --with-ffi-library flags so GNUstep can find them,"
+        echo "or you have ffcall but gnustep-make is configured to use native exceptions"
+        echo "(native exceptions are not compatible with ffcall)."
+      fi
+      echo "GNUstep requires libffi (or ffcall) and proper libobjc hooks to do"
+      echo "invocations and DO."
+      echo "(This does not apply on apple-apple-apple systems where DO is"
+      echo "not compatible with other GNUstep systems.)"
+      if test $enable_invocations = yes; then
+        echo
+        echo "You most likely do not want to build base without invocation support."
+        echo "Many things (including Distributed Objects and undo/redo), won't work"
+        echo "at all without invocations."
+        echo "If you really want to build -base without invocation support,"
+        echo "add --disable-invocations to the configure arguments."
+        echo "For more information, read the GNUstep build guide, ffcall section:"
+        echo "http://gnustep.made-it.com/BuildGuide/index.html"
+        AC_MSG_ERROR([Incomplete support for ffi functionality.])
+      fi
+      AC_MSG_WARN([Incomplete support for ffi funtionality.])
+    fi
 fi
 AC_SUBST(WITH_FFI)
 
@@ -3035,11 +3056,16 @@ AC_SUBST(HAVE_LIBXML)
 # Check recent libgnutls for SSL streams.
 # See DEPENDENCIES POLICY at the start of this file.
 #--------------------------------------------------------------------
-AC_ARG_ENABLE(tls,
-  [  --disable-tls			Disable use of GNUTLS],,
-  enable_tls=yes)
 
-if test $enable_tls = yes; then
+# GNUTLS is linked to Apple's CoreFoundation on OSX, which renders it unusable there
+case "$target_os" in
+    darwin*) AC_ARG_ENABLE(gnutls, [  --enable-gnutls           Enable use of GNUTLS], enable_gnutls="$enableval", enable_gnutls=no)   ;;
+    *)       AC_ARG_ENABLE(gnutls, [  --disable-gnutls          Disable use of GNUTLS], enable_gnutls="$enableval", enable_gnutls=yes) ;;
+esac
+
+AC_MSG_CHECKING(whether we should try to use GNUTLS for SSL/TLS support)
+if test "$enable_gnutls" = yes; then
+  AC_MSG_RESULT(yes)
   HAVE_GNUTLS=0
   # Save CFLAGS and LIBS as AM_PATH_TLS clobbers these variables regardless
   # of the success of the macro.
@@ -3096,7 +3122,7 @@ if test $enable_tls = yes; then
     fi
   fi
 else
-  AC_MSG_WARN([Disabled support for TLS funtionality.])
+  AC_MSG_RESULT(no)
   HAVE_GNUTLS=0
 fi
 if test $HAVE_GNUTLS = 1; then
@@ -3105,6 +3131,31 @@ fi
 AC_SUBST(HAVE_GNUTLS)
 
 #--------------------------------------------------------------------
+# If there's no GNUTLS support, try using OpenSSL instead.
+#--------------------------------------------------------------------
+
+AC_MSG_CHECKING(whether we should try to use OpenSSL instead of GNUTLS)
+if test $HAVE_GNUTLS = 0; then
+  AC_MSG_RESULT(yes)
+  
+  # Configure flags from sub-configure runs, so they show up in our help file.
+  AC_ARG_ENABLE(openssl,
+    [  --disable-openssl		Disable support for openssl in URL classes],,
+    enable_openssl=yes)
+  HAVE_GNUTLS=0
+  AC_ARG_WITH(openssl-include,
+    [  --with-openssl-include=PATH  include path for openssl headers],
+    openssl_incdir="$withval", openssl_incdir="no")
+  AC_ARG_WITH(openssl-library,
+    [  --with-openssl-library=PATH  library path for openssl libraries],
+    openssl_libdir="$withval", openssl_libdir="no")
+  
+  AC_CONFIG_SUBDIRS(SSL)
+else
+  AC_MSG_RESULT(no)
+fi
+
+#--------------------------------------------------------------------
 # Check for NSNetServices
 # See DEPENDENCIES POLICY at the start of this file.
 #--------------------------------------------------------------------
@@ -3124,6 +3175,11 @@ if test $enable_zeroconf = yes; then
       if test "$have_mdns" = "yes"; then
         MDNS_LIBS="-ldns_sd"
         HAVE_MDNS=1
+      else
+        AC_CHECK_FUNC(DNSServiceBrowse, have_mdns=yes, have_mdns=no)
+        if test "$have_mdns" = "yes"; then
+          HAVE_MDNS=1
+        fi
       fi
     fi
   fi
@@ -3374,29 +3430,6 @@ fi
 
 AC_SUBST(GNUSTEP_INSTALL_GDOMAP_AS_SETUID)
 
-# If there's no TLS support ... try to get some limited functionality
-# by using OpenSSL instead.
-
-if test "$HAVE_TLS" = "0"; then
-
-#--------------------------------------------------------------------
-# Configure flags from sub-configure runs, so they show up in our
-# help file.
-#--------------------------------------------------------------------
-AC_ARG_ENABLE(openssl,
-  [  --disable-openssl		Disable support for openssl in URL classes],,
-  enable_openssl=yes)
-  HAVE_GNUTLS=0
-AC_ARG_WITH(openssl-include,
-  [  --with-openssl-include=PATH  include path for openssl headers],
-  openssl_incdir="$withval", openssl_incdir="no")
-AC_ARG_WITH(openssl-library,
-  [  --with-openssl-library=PATH  library path for openssl libraries],
-  openssl_libdir="$withval", openssl_libdir="no")
-
-AC_CONFIG_SUBDIRS(SSL)
-fi
-
 #--------------------------------------------------------------------
 # Record the version
 #--------------------------------------------------------------------
