diff --git a/.gitignore b/.gitignore
new file mode 100644
index 0000000..7849682
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1,11 @@
+*.xcodeproj/
+!*.xcodeproj/project.pbxproj
+.DS_Store
+
+# files produces by ./configure
+
+back.make
+config.h
+config.log
+config.make
+config.status
diff --git a/Backend.xcodeproj/project.pbxproj b/Backend.xcodeproj/project.pbxproj
new file mode 100644
index 0000000..01908c7
--- /dev/null
+++ b/Backend.xcodeproj/project.pbxproj
@@ -0,0 +1,994 @@
+// !$*UTF8*$!
+{
+	archiveVersion = 1;
+	classes = {
+	};
+	objectVersion = 46;
+	objects = {
+
+/* Begin PBXBuildFile section */
+		18FC95FD170223D300359B1C /* GSBackend.m in Sources */ = {isa = PBXBuildFile; fileRef = 18FC94F01702236100359B1C /* GSBackend.m */; };
+		18FC95FE170223EE00359B1C /* GSContext.m in Sources */ = {isa = PBXBuildFile; fileRef = 18FC951F1702236100359B1C /* GSContext.m */; };
+		18FC95FF170223EE00359B1C /* GSFunction.m in Sources */ = {isa = PBXBuildFile; fileRef = 18FC95201702236100359B1C /* GSFunction.m */; };
+		18FC9600170223EE00359B1C /* GSGState.m in Sources */ = {isa = PBXBuildFile; fileRef = 18FC95211702236100359B1C /* GSGState.m */; };
+		18FC9601170223EE00359B1C /* GSStreamContext.m in Sources */ = {isa = PBXBuildFile; fileRef = 18FC95221702236100359B1C /* GSStreamContext.m */; };
+		18FC9602170223EE00359B1C /* GSStreamGState.m in Sources */ = {isa = PBXBuildFile; fileRef = 18FC95231702236100359B1C /* GSStreamGState.m */; };
+		18FC9603170223EE00359B1C /* externs.m in Sources */ = {isa = PBXBuildFile; fileRef = 18FC95241702236100359B1C /* externs.m */; };
+		18FC9604170223EE00359B1C /* gscolors.c in Sources */ = {isa = PBXBuildFile; fileRef = 18FC95251702236100359B1C /* gscolors.c */; };
+		18FC9605170223FE00359B1C /* XGDragView.m in Sources */ = {isa = PBXBuildFile; fileRef = 18FC953F1702236100359B1C /* XGDragView.m */; };
+		18FC9606170223FE00359B1C /* XGGLContext.m in Sources */ = {isa = PBXBuildFile; fileRef = 18FC95401702236100359B1C /* XGGLContext.m */; };
+		18FC9607170223FE00359B1C /* XGGLFormat.m in Sources */ = {isa = PBXBuildFile; fileRef = 18FC95411702236100359B1C /* XGGLFormat.m */; };
+		18FC9608170223FE00359B1C /* XGServer.m in Sources */ = {isa = PBXBuildFile; fileRef = 18FC95421702236100359B1C /* XGServer.m */; };
+		18FC9609170223FE00359B1C /* XGServerEvent.m in Sources */ = {isa = PBXBuildFile; fileRef = 18FC95431702236100359B1C /* XGServerEvent.m */; };
+		18FC960A170223FE00359B1C /* XGServerWindow.m in Sources */ = {isa = PBXBuildFile; fileRef = 18FC95441702236100359B1C /* XGServerWindow.m */; };
+		18FC960B170223FE00359B1C /* XIMInputServer.m in Sources */ = {isa = PBXBuildFile; fileRef = 18FC95451702236100359B1C /* XIMInputServer.m */; };
+		18FC960C170223FE00359B1C /* XWindowBuffer.m in Sources */ = {isa = PBXBuildFile; fileRef = 18FC95461702236100359B1C /* XWindowBuffer.m */; };
+		18FC960D170223FE00359B1C /* context.c in Sources */ = {isa = PBXBuildFile; fileRef = 18FC95471702236100359B1C /* context.c */; };
+		18FC960E170223FE00359B1C /* convert.c in Sources */ = {isa = PBXBuildFile; fileRef = 18FC95481702236100359B1C /* convert.c */; };
+		18FC960F170223FE00359B1C /* raster.c in Sources */ = {isa = PBXBuildFile; fileRef = 18FC95491702236100359B1C /* raster.c */; };
+		18FC9610170223FE00359B1C /* scale.c in Sources */ = {isa = PBXBuildFile; fileRef = 18FC954A1702236100359B1C /* scale.c */; };
+		18FC9612170223FE00359B1C /* xdnd.c in Sources */ = {isa = PBXBuildFile; fileRef = 18FC954C1702236100359B1C /* xdnd.c */; };
+		18FC9613170223FE00359B1C /* xutil.c in Sources */ = {isa = PBXBuildFile; fileRef = 18FC954D1702236100359B1C /* xutil.c */; };
+		18FC96201702242600359B1C /* GSXftFontInfo.m in Sources */ = {isa = PBXBuildFile; fileRef = 18FC95621702236100359B1C /* GSXftFontInfo.m */; };
+		18FC96211702242600359B1C /* XGBitmap.m in Sources */ = {isa = PBXBuildFile; fileRef = 18FC95631702236100359B1C /* XGBitmap.m */; };
+		18FC96221702242600359B1C /* XGCommonFont.m in Sources */ = {isa = PBXBuildFile; fileRef = 18FC95641702236100359B1C /* XGCommonFont.m */; };
+		18FC96231702242600359B1C /* XGContext.m in Sources */ = {isa = PBXBuildFile; fileRef = 18FC95651702236100359B1C /* XGContext.m */; };
+		18FC96241702242600359B1C /* XGFont.m in Sources */ = {isa = PBXBuildFile; fileRef = 18FC95661702236100359B1C /* XGFont.m */; };
+		18FC96251702242600359B1C /* XGFontManager.m in Sources */ = {isa = PBXBuildFile; fileRef = 18FC95671702236100359B1C /* XGFontManager.m */; };
+		18FC96261702242600359B1C /* XGFontSetFontInfo.m in Sources */ = {isa = PBXBuildFile; fileRef = 18FC95681702236100359B1C /* XGFontSetFontInfo.m */; };
+		18FC96271702242600359B1C /* XGGState.m in Sources */ = {isa = PBXBuildFile; fileRef = 18FC95691702236100359B1C /* XGGState.m */; };
+		18FC96281702242600359B1C /* XGGeometry.m in Sources */ = {isa = PBXBuildFile; fileRef = 18FC956A1702236100359B1C /* XGGeometry.m */; };
+		18FC96291702242600359B1C /* linking.m in Sources */ = {isa = PBXBuildFile; fileRef = 18FC956B1702236100359B1C /* linking.m */; };
+		18FC962F170226DA00359B1C /* libXft.2.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 18FC962E170226DA00359B1C /* libXft.2.dylib */; };
+		18FC9631170226F000359B1C /* libfreetype.6.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 18FC9630170226F000359B1C /* libfreetype.6.dylib */; };
+		18FC96331702270F00359B1C /* libz.1.2.7.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 18FC96321702270F00359B1C /* libz.1.2.7.dylib */; };
+		18FC96351702272700359B1C /* libbz2.1.0.6.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 18FC96341702272700359B1C /* libbz2.1.0.6.dylib */; };
+		18FC96371702273900359B1C /* libfontconfig.1.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 18FC96361702273900359B1C /* libfontconfig.1.dylib */; };
+		18FC96391702274900359B1C /* libXext.6.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 18FC96381702274900359B1C /* libXext.6.dylib */; };
+		18FC963B1702275800359B1C /* libXcursor.1.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 18FC963A1702275800359B1C /* libXcursor.1.dylib */; };
+		18FC963D1702276B00359B1C /* libXfixes.3.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 18FC963C1702276B00359B1C /* libXfixes.3.dylib */; };
+		18FC963F1702277A00359B1C /* libXmu.6.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 18FC963E1702277A00359B1C /* libXmu.6.dylib */; };
+		18FC96411702278900359B1C /* libXt.6.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 18FC96401702278900359B1C /* libXt.6.dylib */; };
+		18FC96431702279F00359B1C /* libX11.6.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 18FC96421702279F00359B1C /* libX11.6.dylib */; };
+		18FC9645170227B600359B1C /* libgnustep-gui.0.23.1.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 18FC9644170227B600359B1C /* libgnustep-gui.0.23.1.dylib */; };
+		18FC9647170227CD00359B1C /* libgnustep-base.1.24.4.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 18FC9646170227CD00359B1C /* libgnustep-base.1.24.4.dylib */; };
+		18FC9649170227D900359B1C /* libobjc.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 18FC9648170227D900359B1C /* libobjc.dylib */; };
+/* End PBXBuildFile section */
+
+/* Begin PBXFileReference section */
+		18FC94C91702225C00359B1C /* Backend.bundle */ = {isa = PBXFileReference; explicitFileType = wrapper.cfbundle; includeInIndex = 0; path = Backend.bundle; sourceTree = BUILT_PRODUCTS_DIR; };
+		18FC94CC1702225C00359B1C /* Cocoa.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = Cocoa.framework; path = System/Library/Frameworks/Cocoa.framework; sourceTree = SDKROOT; };
+		18FC94CF1702225C00359B1C /* AppKit.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = AppKit.framework; path = System/Library/Frameworks/AppKit.framework; sourceTree = SDKROOT; };
+		18FC94D01702225C00359B1C /* CoreData.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = CoreData.framework; path = System/Library/Frameworks/CoreData.framework; sourceTree = SDKROOT; };
+		18FC94D11702225C00359B1C /* Foundation.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = Foundation.framework; path = System/Library/Frameworks/Foundation.framework; sourceTree = SDKROOT; };
+		18FC94E61702232800359B1C /* Backend-Info.plist */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.plist.xml; name = "Backend-Info.plist"; path = "Support/Backend/Backend-Info.plist"; sourceTree = SOURCE_ROOT; };
+		18FC94E71702232800359B1C /* Backend-Prefix.pch */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = "Backend-Prefix.pch"; path = "Support/Backend/Backend-Prefix.pch"; sourceTree = SOURCE_ROOT; };
+		18FC94EA1702236100359B1C /* .cvsignore */ = {isa = PBXFileReference; lastKnownFileType = text; path = .cvsignore; sourceTree = "<group>"; };
+		18FC94EC1702236100359B1C /* English */ = {isa = PBXFileReference; lastKnownFileType = text.plist.strings; name = English; path = English.lproj/nfontFaceNames.strings; sourceTree = "<group>"; };
+		18FC94ED1702236100359B1C /* GNUmakefile */ = {isa = PBXFileReference; lastKnownFileType = text; path = GNUmakefile; sourceTree = "<group>"; };
+		18FC94EE1702236100359B1C /* GNUmakefile.postamble */ = {isa = PBXFileReference; lastKnownFileType = text; path = GNUmakefile.postamble; sourceTree = "<group>"; };
+		18FC94EF1702236100359B1C /* GNUmakefile.preamble */ = {isa = PBXFileReference; lastKnownFileType = text; path = GNUmakefile.preamble; sourceTree = "<group>"; };
+		18FC94F01702236100359B1C /* GSBackend.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = GSBackend.m; sourceTree = "<group>"; };
+		18FC94F11702236100359B1C /* Swedish */ = {isa = PBXFileReference; lastKnownFileType = text.plist.strings; name = Swedish; path = Swedish.lproj/nfontFaceNames.strings; sourceTree = "<group>"; };
+		18FC94F31702236100359B1C /* .cvsignore */ = {isa = PBXFileReference; lastKnownFileType = text; path = .cvsignore; sourceTree = "<group>"; };
+		18FC94F41702236100359B1C /* ARTContext.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = ARTContext.m; sourceTree = "<group>"; };
+		18FC94F51702236100359B1C /* ARTGState.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = ARTGState.h; sourceTree = "<group>"; };
+		18FC94F61702236100359B1C /* ARTGState.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = ARTGState.m; sourceTree = "<group>"; };
+		18FC94F71702236100359B1C /* FTFaceInfo.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = FTFaceInfo.h; sourceTree = "<group>"; };
+		18FC94F81702236100359B1C /* FTFaceInfo.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = FTFaceInfo.m; sourceTree = "<group>"; };
+		18FC94F91702236100359B1C /* FTFontEnumerator.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = FTFontEnumerator.h; sourceTree = "<group>"; };
+		18FC94FA1702236100359B1C /* FTFontEnumerator.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = FTFontEnumerator.m; sourceTree = "<group>"; };
+		18FC94FB1702236100359B1C /* GNUmakefile */ = {isa = PBXFileReference; lastKnownFileType = text; path = GNUmakefile; sourceTree = "<group>"; };
+		18FC94FC1702236100359B1C /* GNUmakefile.preamble */ = {isa = PBXFileReference; lastKnownFileType = text; path = GNUmakefile.preamble; sourceTree = "<group>"; };
+		18FC94FD1702236100359B1C /* ReadRect.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = ReadRect.m; sourceTree = "<group>"; };
+		18FC94FE1702236100359B1C /* blit-main.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = "blit-main.m"; sourceTree = "<group>"; };
+		18FC94FF1702236100359B1C /* blit.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = blit.h; sourceTree = "<group>"; };
+		18FC95001702236100359B1C /* blit.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = blit.m; sourceTree = "<group>"; };
+		18FC95011702236100359B1C /* blit_scrapheap.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = blit_scrapheap.m; sourceTree = "<group>"; };
+		18FC95021702236100359B1C /* composite.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = composite.m; sourceTree = "<group>"; };
+		18FC95031702236100359B1C /* ftfont-old.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = "ftfont-old.m"; sourceTree = "<group>"; };
+		18FC95041702236100359B1C /* ftfont.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = ftfont.h; sourceTree = "<group>"; };
+		18FC95051702236100359B1C /* ftfont.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = ftfont.m; sourceTree = "<group>"; };
+		18FC95061702236100359B1C /* image.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = image.m; sourceTree = "<group>"; };
+		18FC95071702236100359B1C /* path.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = path.m; sourceTree = "<group>"; };
+		18FC95081702236100359B1C /* shfill.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = shfill.m; sourceTree = "<group>"; };
+		18FC950A1702236100359B1C /* CairoContext.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = CairoContext.m; sourceTree = "<group>"; };
+		18FC950B1702236100359B1C /* CairoFaceInfo.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = CairoFaceInfo.m; sourceTree = "<group>"; };
+		18FC950C1702236100359B1C /* CairoFontEnumerator.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = CairoFontEnumerator.m; sourceTree = "<group>"; };
+		18FC950D1702236100359B1C /* CairoFontInfo.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = CairoFontInfo.m; sourceTree = "<group>"; };
+		18FC950E1702236100359B1C /* CairoGState.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = CairoGState.m; sourceTree = "<group>"; };
+		18FC950F1702236100359B1C /* CairoPDFSurface.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = CairoPDFSurface.m; sourceTree = "<group>"; };
+		18FC95101702236100359B1C /* CairoPSSurface.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = CairoPSSurface.m; sourceTree = "<group>"; };
+		18FC95111702236100359B1C /* CairoSurface.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = CairoSurface.m; sourceTree = "<group>"; };
+		18FC95121702236100359B1C /* GNUmakefile */ = {isa = PBXFileReference; lastKnownFileType = text; path = GNUmakefile; sourceTree = "<group>"; };
+		18FC95131702236100359B1C /* GNUmakefile.preamble */ = {isa = PBXFileReference; lastKnownFileType = text; path = GNUmakefile.preamble; sourceTree = "<group>"; };
+		18FC95141702236100359B1C /* Win32CairoGState.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = Win32CairoGState.m; sourceTree = "<group>"; };
+		18FC95151702236100359B1C /* Win32CairoGlitzSurface.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = Win32CairoGlitzSurface.m; sourceTree = "<group>"; };
+		18FC95161702236100359B1C /* Win32CairoSurface.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = Win32CairoSurface.m; sourceTree = "<group>"; };
+		18FC95171702236100359B1C /* XGCairoGlitzSurface.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = XGCairoGlitzSurface.m; sourceTree = "<group>"; };
+		18FC95181702236100359B1C /* XGCairoModernSurface.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = XGCairoModernSurface.m; sourceTree = "<group>"; };
+		18FC95191702236100359B1C /* XGCairoSurface.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = XGCairoSurface.m; sourceTree = "<group>"; };
+		18FC951A1702236100359B1C /* XGCairoXImageSurface.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = XGCairoXImageSurface.m; sourceTree = "<group>"; };
+		18FC951C1702236100359B1C /* .cvsignore */ = {isa = PBXFileReference; lastKnownFileType = text; path = .cvsignore; sourceTree = "<group>"; };
+		18FC951D1702236100359B1C /* GNUmakefile */ = {isa = PBXFileReference; lastKnownFileType = text; path = GNUmakefile; sourceTree = "<group>"; };
+		18FC951E1702236100359B1C /* GNUmakefile.preamble */ = {isa = PBXFileReference; lastKnownFileType = text; path = GNUmakefile.preamble; sourceTree = "<group>"; };
+		18FC951F1702236100359B1C /* GSContext.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = GSContext.m; sourceTree = "<group>"; };
+		18FC95201702236100359B1C /* GSFunction.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = GSFunction.m; sourceTree = "<group>"; };
+		18FC95211702236100359B1C /* GSGState.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = GSGState.m; sourceTree = "<group>"; };
+		18FC95221702236100359B1C /* GSStreamContext.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = GSStreamContext.m; sourceTree = "<group>"; };
+		18FC95231702236100359B1C /* GSStreamGState.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = GSStreamGState.m; sourceTree = "<group>"; };
+		18FC95241702236100359B1C /* externs.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = externs.m; sourceTree = "<group>"; };
+		18FC95251702236100359B1C /* gscolors.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; path = gscolors.c; sourceTree = "<group>"; };
+		18FC95271702236100359B1C /* .cvsignore */ = {isa = PBXFileReference; lastKnownFileType = text; path = .cvsignore; sourceTree = "<group>"; };
+		18FC95281702236100359B1C /* GNUmakefile */ = {isa = PBXFileReference; lastKnownFileType = text; path = GNUmakefile; sourceTree = "<group>"; };
+		18FC95291702236100359B1C /* GNUmakefile.preamble */ = {isa = PBXFileReference; lastKnownFileType = text; path = GNUmakefile.preamble; sourceTree = "<group>"; };
+		18FC952A1702236100359B1C /* WIN32Server.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = WIN32Server.m; sourceTree = "<group>"; };
+		18FC952B1702236100359B1C /* w32_GLcontext.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = w32_GLcontext.m; sourceTree = "<group>"; };
+		18FC952C1702236100359B1C /* w32_GLformat.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = w32_GLformat.m; sourceTree = "<group>"; };
+		18FC952D1702236100359B1C /* w32_activate.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = w32_activate.m; sourceTree = "<group>"; };
+		18FC952E1702236100359B1C /* w32_create.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = w32_create.m; sourceTree = "<group>"; };
+		18FC952F1702236100359B1C /* w32_general.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = w32_general.m; sourceTree = "<group>"; };
+		18FC95301702236100359B1C /* w32_movesize.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = w32_movesize.m; sourceTree = "<group>"; };
+		18FC95311702236100359B1C /* w32_text_focus.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = w32_text_focus.m; sourceTree = "<group>"; };
+		18FC95321702236100359B1C /* w32_windowdisplay.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = w32_windowdisplay.m; sourceTree = "<group>"; };
+		18FC95341702236100359B1C /* .cvsignore */ = {isa = PBXFileReference; lastKnownFileType = text; path = .cvsignore; sourceTree = "<group>"; };
+		18FC95351702236100359B1C /* GNUmakefile */ = {isa = PBXFileReference; lastKnownFileType = text; path = GNUmakefile; sourceTree = "<group>"; };
+		18FC95361702236100359B1C /* GNUmakefile.preamble */ = {isa = PBXFileReference; lastKnownFileType = text; path = GNUmakefile.preamble; sourceTree = "<group>"; };
+		18FC95371702236100359B1C /* WIN32Context.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = WIN32Context.m; sourceTree = "<group>"; };
+		18FC95381702236100359B1C /* WIN32FontEnumerator.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = WIN32FontEnumerator.m; sourceTree = "<group>"; };
+		18FC95391702236100359B1C /* WIN32FontInfo.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = WIN32FontInfo.m; sourceTree = "<group>"; };
+		18FC953A1702236100359B1C /* WIN32GState.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = WIN32GState.m; sourceTree = "<group>"; };
+		18FC953C1702236100359B1C /* .cvsignore */ = {isa = PBXFileReference; lastKnownFileType = text; path = .cvsignore; sourceTree = "<group>"; };
+		18FC953D1702236100359B1C /* GNUmakefile */ = {isa = PBXFileReference; lastKnownFileType = text; path = GNUmakefile; sourceTree = "<group>"; };
+		18FC953E1702236100359B1C /* GNUmakefile.preamble */ = {isa = PBXFileReference; lastKnownFileType = text; path = GNUmakefile.preamble; sourceTree = "<group>"; };
+		18FC953F1702236100359B1C /* XGDragView.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = XGDragView.m; sourceTree = "<group>"; };
+		18FC95401702236100359B1C /* XGGLContext.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = XGGLContext.m; sourceTree = "<group>"; };
+		18FC95411702236100359B1C /* XGGLFormat.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = XGGLFormat.m; sourceTree = "<group>"; };
+		18FC95421702236100359B1C /* XGServer.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = XGServer.m; sourceTree = "<group>"; };
+		18FC95431702236100359B1C /* XGServerEvent.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = XGServerEvent.m; sourceTree = "<group>"; };
+		18FC95441702236100359B1C /* XGServerWindow.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = XGServerWindow.m; sourceTree = "<group>"; };
+		18FC95451702236100359B1C /* XIMInputServer.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = XIMInputServer.m; sourceTree = "<group>"; };
+		18FC95461702236100359B1C /* XWindowBuffer.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = XWindowBuffer.m; sourceTree = "<group>"; };
+		18FC95471702236100359B1C /* context.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; path = context.c; sourceTree = "<group>"; };
+		18FC95481702236100359B1C /* convert.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; path = convert.c; sourceTree = "<group>"; };
+		18FC95491702236100359B1C /* raster.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; path = raster.c; sourceTree = "<group>"; };
+		18FC954A1702236100359B1C /* scale.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; path = scale.c; sourceTree = "<group>"; };
+		18FC954B1702236100359B1C /* wrasterP.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = wrasterP.h; sourceTree = "<group>"; };
+		18FC954C1702236100359B1C /* xdnd.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; path = xdnd.c; sourceTree = "<group>"; };
+		18FC954D1702236100359B1C /* xutil.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; path = xutil.c; sourceTree = "<group>"; };
+		18FC954F1702236100359B1C /* .cvsignore */ = {isa = PBXFileReference; lastKnownFileType = text; path = .cvsignore; sourceTree = "<group>"; };
+		18FC95501702236100359B1C /* AFMFileFontInfo.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = AFMFileFontInfo.h; sourceTree = "<group>"; };
+		18FC95511702236100359B1C /* AFMFileFontInfo.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = AFMFileFontInfo.m; sourceTree = "<group>"; };
+		18FC95521702236100359B1C /* GNUmakefile */ = {isa = PBXFileReference; lastKnownFileType = text; path = GNUmakefile; sourceTree = "<group>"; };
+		18FC95531702236100359B1C /* GNUmakefile.preamble */ = {isa = PBXFileReference; lastKnownFileType = text; path = GNUmakefile.preamble; sourceTree = "<group>"; };
+		18FC95541702236100359B1C /* NSDPSContext.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSDPSContext.m; sourceTree = "<group>"; };
+		18FC95551702236100359B1C /* NSDPSContextOps.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = NSDPSContextOps.m; sourceTree = "<group>"; };
+		18FC95561702236100359B1C /* PXKEPSImageRep.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = PXKEPSImageRep.m; sourceTree = "<group>"; };
+		18FC95571702236100359B1C /* PXKFontManager.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = PXKFontManager.m; sourceTree = "<group>"; };
+		18FC95581702236100359B1C /* drawingfuncs.psw */ = {isa = PBXFileReference; lastKnownFileType = text; path = drawingfuncs.psw; sourceTree = "<group>"; };
+		18FC95591702236100359B1C /* extensions.psw */ = {isa = PBXFileReference; lastKnownFileType = text; path = extensions.psw; sourceTree = "<group>"; };
+		18FC955A1702236100359B1C /* fonts.psw */ = {isa = PBXFileReference; lastKnownFileType = text; path = fonts.psw; sourceTree = "<group>"; };
+		18FC955B1702236100359B1C /* general.psw */ = {isa = PBXFileReference; lastKnownFileType = text; path = general.psw; sourceTree = "<group>"; };
+		18FC955C1702236100359B1C /* parseAFM.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; path = parseAFM.c; sourceTree = "<group>"; };
+		18FC955D1702236100359B1C /* parseAFM.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = parseAFM.h; sourceTree = "<group>"; };
+		18FC955F1702236100359B1C /* .cvsignore */ = {isa = PBXFileReference; lastKnownFileType = text; path = .cvsignore; sourceTree = "<group>"; };
+		18FC95601702236100359B1C /* GNUmakefile */ = {isa = PBXFileReference; lastKnownFileType = text; path = GNUmakefile; sourceTree = "<group>"; };
+		18FC95611702236100359B1C /* GNUmakefile.preamble */ = {isa = PBXFileReference; lastKnownFileType = text; path = GNUmakefile.preamble; sourceTree = "<group>"; };
+		18FC95621702236100359B1C /* GSXftFontInfo.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = GSXftFontInfo.m; sourceTree = "<group>"; };
+		18FC95631702236100359B1C /* XGBitmap.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = XGBitmap.m; sourceTree = "<group>"; };
+		18FC95641702236100359B1C /* XGCommonFont.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = XGCommonFont.m; sourceTree = "<group>"; };
+		18FC95651702236100359B1C /* XGContext.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = XGContext.m; sourceTree = "<group>"; };
+		18FC95661702236100359B1C /* XGFont.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = XGFont.m; sourceTree = "<group>"; };
+		18FC95671702236100359B1C /* XGFontManager.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = XGFontManager.m; sourceTree = "<group>"; };
+		18FC95681702236100359B1C /* XGFontSetFontInfo.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = XGFontSetFontInfo.m; sourceTree = "<group>"; };
+		18FC95691702236100359B1C /* XGGState.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = XGGState.m; sourceTree = "<group>"; };
+		18FC956A1702236100359B1C /* XGGeometry.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = XGGeometry.m; sourceTree = "<group>"; };
+		18FC956B1702236100359B1C /* linking.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = linking.m; sourceTree = "<group>"; };
+		18FC956D1702236900359B1C /* .cvsignore */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; path = .cvsignore; sourceTree = "<group>"; };
+		18FC956E1702236900359B1C /* GNUmakefile */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; path = GNUmakefile; sourceTree = "<group>"; };
+		18FC956F1702236900359B1C /* GNUmakefile.postamble */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; path = GNUmakefile.postamble; sourceTree = "<group>"; };
+		18FC95701702236900359B1C /* GNUmakefile.preamble */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; path = GNUmakefile.preamble; sourceTree = "<group>"; };
+		18FC95711702236900359B1C /* font_cacher.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = font_cacher.m; sourceTree = "<group>"; };
+		18FC95721702236900359B1C /* gpbs.1 */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.man; path = gpbs.1; sourceTree = "<group>"; };
+		18FC95731702236900359B1C /* gpbs.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = gpbs.m; sourceTree = "<group>"; };
+		18FC95741702236900359B1C /* win32pbs.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = win32pbs.m; sourceTree = "<group>"; };
+		18FC95751702236900359B1C /* xpbs.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = xpbs.m; sourceTree = "<group>"; };
+		18FC95811702237300359B1C /* ARTContext.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ARTContext.h; sourceTree = "<group>"; };
+		18FC95831702237300359B1C /* CairoContext.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = CairoContext.h; sourceTree = "<group>"; };
+		18FC95841702237300359B1C /* CairoFaceInfo.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = CairoFaceInfo.h; sourceTree = "<group>"; };
+		18FC95851702237300359B1C /* CairoFontEnumerator.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = CairoFontEnumerator.h; sourceTree = "<group>"; };
+		18FC95861702237300359B1C /* CairoFontInfo.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = CairoFontInfo.h; sourceTree = "<group>"; };
+		18FC95871702237300359B1C /* CairoGState.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = CairoGState.h; sourceTree = "<group>"; };
+		18FC95881702237300359B1C /* CairoPDFSurface.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = CairoPDFSurface.h; sourceTree = "<group>"; };
+		18FC95891702237300359B1C /* CairoPSSurface.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = CairoPSSurface.h; sourceTree = "<group>"; };
+		18FC958A1702237300359B1C /* CairoSurface.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = CairoSurface.h; sourceTree = "<group>"; };
+		18FC958B1702237300359B1C /* Win32CairoGState.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Win32CairoGState.h; sourceTree = "<group>"; };
+		18FC958C1702237300359B1C /* Win32CairoGlitzSurface.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Win32CairoGlitzSurface.h; sourceTree = "<group>"; };
+		18FC958D1702237300359B1C /* Win32CairoSurface.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Win32CairoSurface.h; sourceTree = "<group>"; };
+		18FC958E1702237300359B1C /* XGCairoGlitzSurface.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = XGCairoGlitzSurface.h; sourceTree = "<group>"; };
+		18FC958F1702237300359B1C /* XGCairoModernSurface.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = XGCairoModernSurface.h; sourceTree = "<group>"; };
+		18FC95901702237300359B1C /* XGCairoSurface.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = XGCairoSurface.h; sourceTree = "<group>"; };
+		18FC95911702237300359B1C /* XGCairoXImageSurface.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = XGCairoXImageSurface.h; sourceTree = "<group>"; };
+		18FC95931702237300359B1C /* GSContext.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = GSContext.h; sourceTree = "<group>"; };
+		18FC95941702237300359B1C /* GSFunction.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = GSFunction.h; sourceTree = "<group>"; };
+		18FC95951702237300359B1C /* GSGState.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = GSGState.h; sourceTree = "<group>"; };
+		18FC95961702237300359B1C /* GSGStateOps.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = GSGStateOps.h; sourceTree = "<group>"; };
+		18FC95971702237300359B1C /* GSStreamContext.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = GSStreamContext.h; sourceTree = "<group>"; };
+		18FC95981702237300359B1C /* GSStreamGState.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = GSStreamGState.h; sourceTree = "<group>"; };
+		18FC95991702237300359B1C /* gscolors.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = gscolors.h; sourceTree = "<group>"; };
+		18FC959B1702237300359B1C /* WIN32Geometry.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = WIN32Geometry.h; sourceTree = "<group>"; };
+		18FC959C1702237300359B1C /* WIN32OpenGL.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = WIN32OpenGL.h; sourceTree = "<group>"; };
+		18FC959D1702237300359B1C /* WIN32Server.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = WIN32Server.h; sourceTree = "<group>"; };
+		18FC959F1702237300359B1C /* WIN32Context.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = WIN32Context.h; sourceTree = "<group>"; };
+		18FC95A01702237300359B1C /* WIN32FontEnumerator.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = WIN32FontEnumerator.h; sourceTree = "<group>"; };
+		18FC95A11702237300359B1C /* WIN32FontInfo.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = WIN32FontInfo.h; sourceTree = "<group>"; };
+		18FC95A21702237300359B1C /* WIN32GState.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = WIN32GState.h; sourceTree = "<group>"; };
+		18FC95A41702237300359B1C /* StdCmap.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = StdCmap.h; sourceTree = "<group>"; };
+		18FC95A51702237300359B1C /* XGDragView.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = XGDragView.h; sourceTree = "<group>"; };
+		18FC95A61702237300359B1C /* XGGeneric.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = XGGeneric.h; sourceTree = "<group>"; };
+		18FC95A71702237300359B1C /* XGInputServer.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = XGInputServer.h; sourceTree = "<group>"; };
+		18FC95A81702237300359B1C /* XGOpenGL.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = XGOpenGL.h; sourceTree = "<group>"; };
+		18FC95A91702237300359B1C /* XGServer.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = XGServer.h; sourceTree = "<group>"; };
+		18FC95AA1702237300359B1C /* XGServerWindow.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = XGServerWindow.h; sourceTree = "<group>"; };
+		18FC95AB1702237300359B1C /* XWindowBuffer.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = XWindowBuffer.h; sourceTree = "<group>"; };
+		18FC95AC1702237300359B1C /* wraster.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = wraster.h; sourceTree = "<group>"; };
+		18FC95AD1702237300359B1C /* xdnd.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = xdnd.h; sourceTree = "<group>"; };
+		18FC95AF1702237300359B1C /* NSDPSContext.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSDPSContext.h; sourceTree = "<group>"; };
+		18FC95B11702237300359B1C /* GSXftFontInfo.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = GSXftFontInfo.h; sourceTree = "<group>"; };
+		18FC95B21702237300359B1C /* XGContext.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = XGContext.h; sourceTree = "<group>"; };
+		18FC95B31702237300359B1C /* XGFontSetFontInfo.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = XGFontSetFontInfo.h; sourceTree = "<group>"; };
+		18FC95B41702237300359B1C /* XGGState.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = XGGState.h; sourceTree = "<group>"; };
+		18FC95B51702237300359B1C /* XGGeometry.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = XGGeometry.h; sourceTree = "<group>"; };
+		18FC95B61702237300359B1C /* XGPrivate.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = XGPrivate.h; sourceTree = "<group>"; };
+		18FC95B81702237D00359B1C /* GNUmakefile */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; path = GNUmakefile; sourceTree = "<group>"; };
+		18FC95B91702237D00359B1C /* GNUmakefile.postamble */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; path = GNUmakefile.postamble; sourceTree = "<group>"; };
+		18FC95BB1702237D00359B1C /* FontInfo.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist; path = FontInfo.plist; sourceTree = "<group>"; };
+		18FC95BC1702237D00359B1C /* n019003l.afm */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; path = n019003l.afm; sourceTree = "<group>"; };
+		18FC95BD1702237D00359B1C /* n019003l.pfb */ = {isa = PBXFileReference; lastKnownFileType = file; path = n019003l.pfb; sourceTree = "<group>"; };
+		18FC95BE1702237D00359B1C /* n019003l.pfm */ = {isa = PBXFileReference; lastKnownFileType = file; path = n019003l.pfm; sourceTree = "<group>"; };
+		18FC95BF1702237D00359B1C /* n019004l.afm */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; path = n019004l.afm; sourceTree = "<group>"; };
+		18FC95C01702237D00359B1C /* n019004l.pfb */ = {isa = PBXFileReference; lastKnownFileType = file; path = n019004l.pfb; sourceTree = "<group>"; };
+		18FC95C11702237D00359B1C /* n019004l.pfm */ = {isa = PBXFileReference; lastKnownFileType = file; path = n019004l.pfm; sourceTree = "<group>"; };
+		18FC95C21702237D00359B1C /* n019023l.afm */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; path = n019023l.afm; sourceTree = "<group>"; };
+		18FC95C31702237D00359B1C /* n019023l.pfb */ = {isa = PBXFileReference; lastKnownFileType = file; path = n019023l.pfb; sourceTree = "<group>"; };
+		18FC95C41702237D00359B1C /* n019023l.pfm */ = {isa = PBXFileReference; lastKnownFileType = file; path = n019023l.pfm; sourceTree = "<group>"; };
+		18FC95C51702237D00359B1C /* n019024l.afm */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; path = n019024l.afm; sourceTree = "<group>"; };
+		18FC95C61702237D00359B1C /* n019024l.pfb */ = {isa = PBXFileReference; lastKnownFileType = file; path = n019024l.pfb; sourceTree = "<group>"; };
+		18FC95C71702237D00359B1C /* n019024l.pfm */ = {isa = PBXFileReference; lastKnownFileType = file; path = n019024l.pfm; sourceTree = "<group>"; };
+		18FC95C81702237D00359B1C /* n019043l.afm */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; path = n019043l.afm; sourceTree = "<group>"; };
+		18FC95C91702237D00359B1C /* n019043l.pfb */ = {isa = PBXFileReference; lastKnownFileType = file; path = n019043l.pfb; sourceTree = "<group>"; };
+		18FC95CA1702237D00359B1C /* n019043l.pfm */ = {isa = PBXFileReference; lastKnownFileType = file; path = n019043l.pfm; sourceTree = "<group>"; };
+		18FC95CB1702237D00359B1C /* n019044l.afm */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; path = n019044l.afm; sourceTree = "<group>"; };
+		18FC95CC1702237D00359B1C /* n019044l.pfb */ = {isa = PBXFileReference; lastKnownFileType = file; path = n019044l.pfb; sourceTree = "<group>"; };
+		18FC95CD1702237D00359B1C /* n019044l.pfm */ = {isa = PBXFileReference; lastKnownFileType = file; path = n019044l.pfm; sourceTree = "<group>"; };
+		18FC95CE1702237D00359B1C /* n019063l.afm */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; path = n019063l.afm; sourceTree = "<group>"; };
+		18FC95CF1702237D00359B1C /* n019063l.pfb */ = {isa = PBXFileReference; lastKnownFileType = file; path = n019063l.pfb; sourceTree = "<group>"; };
+		18FC95D01702237D00359B1C /* n019063l.pfm */ = {isa = PBXFileReference; lastKnownFileType = file; path = n019063l.pfm; sourceTree = "<group>"; };
+		18FC95D11702237D00359B1C /* n019064l.afm */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; path = n019064l.afm; sourceTree = "<group>"; };
+		18FC95D21702237D00359B1C /* n019064l.pfb */ = {isa = PBXFileReference; lastKnownFileType = file; path = n019064l.pfb; sourceTree = "<group>"; };
+		18FC95D31702237D00359B1C /* n019064l.pfm */ = {isa = PBXFileReference; lastKnownFileType = file; path = n019064l.pfm; sourceTree = "<group>"; };
+		18FC95EF1702239000359B1C /* configure */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.script.sh; path = configure; sourceTree = SOURCE_ROOT; };
+		18FC95F01702239000359B1C /* configure.ac */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; path = configure.ac; sourceTree = SOURCE_ROOT; };
+		18FC95F3170223B500359B1C /* back.make.in */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; path = back.make.in; sourceTree = SOURCE_ROOT; };
+		18FC95F4170223B500359B1C /* config.h.in */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; path = config.h.in; sourceTree = SOURCE_ROOT; };
+		18FC95F5170223B500359B1C /* config.make.in */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; path = config.make.in; sourceTree = SOURCE_ROOT; };
+		18FC95F6170223B500359B1C /* GNUmakefile */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; path = GNUmakefile; sourceTree = SOURCE_ROOT; };
+		18FC95F7170223B500359B1C /* GNUmakefile.postamble */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; path = GNUmakefile.postamble; sourceTree = SOURCE_ROOT; };
+		18FC962E170226DA00359B1C /* libXft.2.dylib */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.dylib"; name = libXft.2.dylib; path = ../../../../opt/local/lib/libXft.2.dylib; sourceTree = "<group>"; };
+		18FC9630170226F000359B1C /* libfreetype.6.dylib */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.dylib"; name = libfreetype.6.dylib; path = ../../../../opt/local/lib/libfreetype.6.dylib; sourceTree = "<group>"; };
+		18FC96321702270F00359B1C /* libz.1.2.7.dylib */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.dylib"; name = libz.1.2.7.dylib; path = ../../../../opt/local/lib/libz.1.2.7.dylib; sourceTree = "<group>"; };
+		18FC96341702272700359B1C /* libbz2.1.0.6.dylib */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.dylib"; name = libbz2.1.0.6.dylib; path = ../../../../opt/local/lib/libbz2.1.0.6.dylib; sourceTree = "<group>"; };
+		18FC96361702273900359B1C /* libfontconfig.1.dylib */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.dylib"; name = libfontconfig.1.dylib; path = ../../../../opt/local/lib/libfontconfig.1.dylib; sourceTree = "<group>"; };
+		18FC96381702274900359B1C /* libXext.6.dylib */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.dylib"; name = libXext.6.dylib; path = ../../../../opt/local/lib/libXext.6.dylib; sourceTree = "<group>"; };
+		18FC963A1702275800359B1C /* libXcursor.1.dylib */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.dylib"; name = libXcursor.1.dylib; path = ../../../../opt/local/lib/libXcursor.1.dylib; sourceTree = "<group>"; };
+		18FC963C1702276B00359B1C /* libXfixes.3.dylib */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.dylib"; name = libXfixes.3.dylib; path = ../../../../opt/local/lib/libXfixes.3.dylib; sourceTree = "<group>"; };
+		18FC963E1702277A00359B1C /* libXmu.6.dylib */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.dylib"; name = libXmu.6.dylib; path = ../../../../opt/local/lib/libXmu.6.dylib; sourceTree = "<group>"; };
+		18FC96401702278900359B1C /* libXt.6.dylib */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.dylib"; name = libXt.6.dylib; path = ../../../../opt/local/lib/libXt.6.dylib; sourceTree = "<group>"; };
+		18FC96421702279F00359B1C /* libX11.6.dylib */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.dylib"; name = libX11.6.dylib; path = ../../../../opt/local/lib/libX11.6.dylib; sourceTree = "<group>"; };
+		18FC9644170227B600359B1C /* libgnustep-gui.0.23.1.dylib */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.dylib"; name = "libgnustep-gui.0.23.1.dylib"; path = "../../../../usr/GNUstep/Local/Library/Libraries/libgnustep-gui.0.23.1.dylib"; sourceTree = "<group>"; };
+		18FC9646170227CD00359B1C /* libgnustep-base.1.24.4.dylib */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.dylib"; name = "libgnustep-base.1.24.4.dylib"; path = "../../../../usr/GNUstep/Local/Library/Libraries/libgnustep-base.1.24.4.dylib"; sourceTree = "<group>"; };
+		18FC9648170227D900359B1C /* libobjc.dylib */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.dylib"; name = libobjc.dylib; path = usr/lib/libobjc.dylib; sourceTree = SDKROOT; };
+/* End PBXFileReference section */
+
+/* Begin PBXFrameworksBuildPhase section */
+		18FC94C61702225C00359B1C /* Frameworks */ = {
+			isa = PBXFrameworksBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				18FC9649170227D900359B1C /* libobjc.dylib in Frameworks */,
+				18FC9647170227CD00359B1C /* libgnustep-base.1.24.4.dylib in Frameworks */,
+				18FC9645170227B600359B1C /* libgnustep-gui.0.23.1.dylib in Frameworks */,
+				18FC96431702279F00359B1C /* libX11.6.dylib in Frameworks */,
+				18FC96411702278900359B1C /* libXt.6.dylib in Frameworks */,
+				18FC963F1702277A00359B1C /* libXmu.6.dylib in Frameworks */,
+				18FC963D1702276B00359B1C /* libXfixes.3.dylib in Frameworks */,
+				18FC963B1702275800359B1C /* libXcursor.1.dylib in Frameworks */,
+				18FC96391702274900359B1C /* libXext.6.dylib in Frameworks */,
+				18FC96371702273900359B1C /* libfontconfig.1.dylib in Frameworks */,
+				18FC96351702272700359B1C /* libbz2.1.0.6.dylib in Frameworks */,
+				18FC96331702270F00359B1C /* libz.1.2.7.dylib in Frameworks */,
+				18FC9631170226F000359B1C /* libfreetype.6.dylib in Frameworks */,
+				18FC962F170226DA00359B1C /* libXft.2.dylib in Frameworks */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+/* End PBXFrameworksBuildPhase section */
+
+/* Begin PBXGroup section */
+		18FC94BE1702225C00359B1C = {
+			isa = PBXGroup;
+			children = (
+				18FC9648170227D900359B1C /* libobjc.dylib */,
+				18FC9646170227CD00359B1C /* libgnustep-base.1.24.4.dylib */,
+				18FC9644170227B600359B1C /* libgnustep-gui.0.23.1.dylib */,
+				18FC96421702279F00359B1C /* libX11.6.dylib */,
+				18FC96401702278900359B1C /* libXt.6.dylib */,
+				18FC963E1702277A00359B1C /* libXmu.6.dylib */,
+				18FC963C1702276B00359B1C /* libXfixes.3.dylib */,
+				18FC963A1702275800359B1C /* libXcursor.1.dylib */,
+				18FC96381702274900359B1C /* libXext.6.dylib */,
+				18FC96361702273900359B1C /* libfontconfig.1.dylib */,
+				18FC96341702272700359B1C /* libbz2.1.0.6.dylib */,
+				18FC96321702270F00359B1C /* libz.1.2.7.dylib */,
+				18FC9630170226F000359B1C /* libfreetype.6.dylib */,
+				18FC962E170226DA00359B1C /* libXft.2.dylib */,
+				18FC94D21702225C00359B1C /* Backend */,
+				18FC94CB1702225C00359B1C /* Frameworks */,
+				18FC94CA1702225C00359B1C /* Products */,
+			);
+			sourceTree = "<group>";
+		};
+		18FC94CA1702225C00359B1C /* Products */ = {
+			isa = PBXGroup;
+			children = (
+				18FC94C91702225C00359B1C /* Backend.bundle */,
+			);
+			name = Products;
+			sourceTree = "<group>";
+		};
+		18FC94CB1702225C00359B1C /* Frameworks */ = {
+			isa = PBXGroup;
+			children = (
+				18FC94CC1702225C00359B1C /* Cocoa.framework */,
+				18FC94CE1702225C00359B1C /* Other Frameworks */,
+			);
+			name = Frameworks;
+			sourceTree = "<group>";
+		};
+		18FC94CE1702225C00359B1C /* Other Frameworks */ = {
+			isa = PBXGroup;
+			children = (
+				18FC94CF1702225C00359B1C /* AppKit.framework */,
+				18FC94D01702225C00359B1C /* CoreData.framework */,
+				18FC94D11702225C00359B1C /* Foundation.framework */,
+			);
+			name = "Other Frameworks";
+			sourceTree = "<group>";
+		};
+		18FC94D21702225C00359B1C /* Backend */ = {
+			isa = PBXGroup;
+			children = (
+				18FC95B71702237D00359B1C /* Fonts */,
+				18FC957F1702237300359B1C /* Headers */,
+				18FC94E91702236100359B1C /* Source */,
+				18FC956C1702236900359B1C /* Tools */,
+				18FC94D31702225C00359B1C /* Supporting Files */,
+			);
+			path = Backend;
+			sourceTree = "<group>";
+		};
+		18FC94D31702225C00359B1C /* Supporting Files */ = {
+			isa = PBXGroup;
+			children = (
+				18FC95F3170223B500359B1C /* back.make.in */,
+				18FC95F4170223B500359B1C /* config.h.in */,
+				18FC95F5170223B500359B1C /* config.make.in */,
+				18FC95F6170223B500359B1C /* GNUmakefile */,
+				18FC95F7170223B500359B1C /* GNUmakefile.postamble */,
+				18FC95EF1702239000359B1C /* configure */,
+				18FC95F01702239000359B1C /* configure.ac */,
+				18FC94E61702232800359B1C /* Backend-Info.plist */,
+				18FC94E71702232800359B1C /* Backend-Prefix.pch */,
+			);
+			name = "Supporting Files";
+			sourceTree = "<group>";
+		};
+		18FC94E91702236100359B1C /* Source */ = {
+			isa = PBXGroup;
+			children = (
+				18FC94EA1702236100359B1C /* .cvsignore */,
+				18FC94EB1702236100359B1C /* nfontFaceNames.strings */,
+				18FC94ED1702236100359B1C /* GNUmakefile */,
+				18FC94EE1702236100359B1C /* GNUmakefile.postamble */,
+				18FC94EF1702236100359B1C /* GNUmakefile.preamble */,
+				18FC94F01702236100359B1C /* GSBackend.m */,
+				18FC94F21702236100359B1C /* art */,
+				18FC95091702236100359B1C /* cairo */,
+				18FC951B1702236100359B1C /* gsc */,
+				18FC95261702236100359B1C /* win32 */,
+				18FC95331702236100359B1C /* winlib */,
+				18FC953B1702236100359B1C /* x11 */,
+				18FC954E1702236100359B1C /* xdps */,
+				18FC955E1702236100359B1C /* xlib */,
+			);
+			path = Source;
+			sourceTree = SOURCE_ROOT;
+		};
+		18FC94F21702236100359B1C /* art */ = {
+			isa = PBXGroup;
+			children = (
+				18FC94F31702236100359B1C /* .cvsignore */,
+				18FC94F41702236100359B1C /* ARTContext.m */,
+				18FC94F51702236100359B1C /* ARTGState.h */,
+				18FC94F61702236100359B1C /* ARTGState.m */,
+				18FC94F71702236100359B1C /* FTFaceInfo.h */,
+				18FC94F81702236100359B1C /* FTFaceInfo.m */,
+				18FC94F91702236100359B1C /* FTFontEnumerator.h */,
+				18FC94FA1702236100359B1C /* FTFontEnumerator.m */,
+				18FC94FB1702236100359B1C /* GNUmakefile */,
+				18FC94FC1702236100359B1C /* GNUmakefile.preamble */,
+				18FC94FD1702236100359B1C /* ReadRect.m */,
+				18FC94FE1702236100359B1C /* blit-main.m */,
+				18FC94FF1702236100359B1C /* blit.h */,
+				18FC95001702236100359B1C /* blit.m */,
+				18FC95011702236100359B1C /* blit_scrapheap.m */,
+				18FC95021702236100359B1C /* composite.m */,
+				18FC95031702236100359B1C /* ftfont-old.m */,
+				18FC95041702236100359B1C /* ftfont.h */,
+				18FC95051702236100359B1C /* ftfont.m */,
+				18FC95061702236100359B1C /* image.m */,
+				18FC95071702236100359B1C /* path.m */,
+				18FC95081702236100359B1C /* shfill.m */,
+			);
+			path = art;
+			sourceTree = "<group>";
+		};
+		18FC95091702236100359B1C /* cairo */ = {
+			isa = PBXGroup;
+			children = (
+				18FC950A1702236100359B1C /* CairoContext.m */,
+				18FC950B1702236100359B1C /* CairoFaceInfo.m */,
+				18FC950C1702236100359B1C /* CairoFontEnumerator.m */,
+				18FC950D1702236100359B1C /* CairoFontInfo.m */,
+				18FC950E1702236100359B1C /* CairoGState.m */,
+				18FC950F1702236100359B1C /* CairoPDFSurface.m */,
+				18FC95101702236100359B1C /* CairoPSSurface.m */,
+				18FC95111702236100359B1C /* CairoSurface.m */,
+				18FC95121702236100359B1C /* GNUmakefile */,
+				18FC95131702236100359B1C /* GNUmakefile.preamble */,
+				18FC95141702236100359B1C /* Win32CairoGState.m */,
+				18FC95151702236100359B1C /* Win32CairoGlitzSurface.m */,
+				18FC95161702236100359B1C /* Win32CairoSurface.m */,
+				18FC95171702236100359B1C /* XGCairoGlitzSurface.m */,
+				18FC95181702236100359B1C /* XGCairoModernSurface.m */,
+				18FC95191702236100359B1C /* XGCairoSurface.m */,
+				18FC951A1702236100359B1C /* XGCairoXImageSurface.m */,
+			);
+			path = cairo;
+			sourceTree = "<group>";
+		};
+		18FC951B1702236100359B1C /* gsc */ = {
+			isa = PBXGroup;
+			children = (
+				18FC951C1702236100359B1C /* .cvsignore */,
+				18FC951D1702236100359B1C /* GNUmakefile */,
+				18FC951E1702236100359B1C /* GNUmakefile.preamble */,
+				18FC951F1702236100359B1C /* GSContext.m */,
+				18FC95201702236100359B1C /* GSFunction.m */,
+				18FC95211702236100359B1C /* GSGState.m */,
+				18FC95221702236100359B1C /* GSStreamContext.m */,
+				18FC95231702236100359B1C /* GSStreamGState.m */,
+				18FC95241702236100359B1C /* externs.m */,
+				18FC95251702236100359B1C /* gscolors.c */,
+			);
+			path = gsc;
+			sourceTree = "<group>";
+		};
+		18FC95261702236100359B1C /* win32 */ = {
+			isa = PBXGroup;
+			children = (
+				18FC95271702236100359B1C /* .cvsignore */,
+				18FC95281702236100359B1C /* GNUmakefile */,
+				18FC95291702236100359B1C /* GNUmakefile.preamble */,
+				18FC952A1702236100359B1C /* WIN32Server.m */,
+				18FC952B1702236100359B1C /* w32_GLcontext.m */,
+				18FC952C1702236100359B1C /* w32_GLformat.m */,
+				18FC952D1702236100359B1C /* w32_activate.m */,
+				18FC952E1702236100359B1C /* w32_create.m */,
+				18FC952F1702236100359B1C /* w32_general.m */,
+				18FC95301702236100359B1C /* w32_movesize.m */,
+				18FC95311702236100359B1C /* w32_text_focus.m */,
+				18FC95321702236100359B1C /* w32_windowdisplay.m */,
+			);
+			path = win32;
+			sourceTree = "<group>";
+		};
+		18FC95331702236100359B1C /* winlib */ = {
+			isa = PBXGroup;
+			children = (
+				18FC95341702236100359B1C /* .cvsignore */,
+				18FC95351702236100359B1C /* GNUmakefile */,
+				18FC95361702236100359B1C /* GNUmakefile.preamble */,
+				18FC95371702236100359B1C /* WIN32Context.m */,
+				18FC95381702236100359B1C /* WIN32FontEnumerator.m */,
+				18FC95391702236100359B1C /* WIN32FontInfo.m */,
+				18FC953A1702236100359B1C /* WIN32GState.m */,
+			);
+			path = winlib;
+			sourceTree = "<group>";
+		};
+		18FC953B1702236100359B1C /* x11 */ = {
+			isa = PBXGroup;
+			children = (
+				18FC953C1702236100359B1C /* .cvsignore */,
+				18FC953D1702236100359B1C /* GNUmakefile */,
+				18FC953E1702236100359B1C /* GNUmakefile.preamble */,
+				18FC953F1702236100359B1C /* XGDragView.m */,
+				18FC95401702236100359B1C /* XGGLContext.m */,
+				18FC95411702236100359B1C /* XGGLFormat.m */,
+				18FC95421702236100359B1C /* XGServer.m */,
+				18FC95431702236100359B1C /* XGServerEvent.m */,
+				18FC95441702236100359B1C /* XGServerWindow.m */,
+				18FC95451702236100359B1C /* XIMInputServer.m */,
+				18FC95461702236100359B1C /* XWindowBuffer.m */,
+				18FC95471702236100359B1C /* context.c */,
+				18FC95481702236100359B1C /* convert.c */,
+				18FC95491702236100359B1C /* raster.c */,
+				18FC954A1702236100359B1C /* scale.c */,
+				18FC954B1702236100359B1C /* wrasterP.h */,
+				18FC954C1702236100359B1C /* xdnd.c */,
+				18FC954D1702236100359B1C /* xutil.c */,
+			);
+			path = x11;
+			sourceTree = "<group>";
+		};
+		18FC954E1702236100359B1C /* xdps */ = {
+			isa = PBXGroup;
+			children = (
+				18FC954F1702236100359B1C /* .cvsignore */,
+				18FC95501702236100359B1C /* AFMFileFontInfo.h */,
+				18FC95511702236100359B1C /* AFMFileFontInfo.m */,
+				18FC95521702236100359B1C /* GNUmakefile */,
+				18FC95531702236100359B1C /* GNUmakefile.preamble */,
+				18FC95541702236100359B1C /* NSDPSContext.m */,
+				18FC95551702236100359B1C /* NSDPSContextOps.m */,
+				18FC95561702236100359B1C /* PXKEPSImageRep.m */,
+				18FC95571702236100359B1C /* PXKFontManager.m */,
+				18FC95581702236100359B1C /* drawingfuncs.psw */,
+				18FC95591702236100359B1C /* extensions.psw */,
+				18FC955A1702236100359B1C /* fonts.psw */,
+				18FC955B1702236100359B1C /* general.psw */,
+				18FC955C1702236100359B1C /* parseAFM.c */,
+				18FC955D1702236100359B1C /* parseAFM.h */,
+			);
+			path = xdps;
+			sourceTree = "<group>";
+		};
+		18FC955E1702236100359B1C /* xlib */ = {
+			isa = PBXGroup;
+			children = (
+				18FC955F1702236100359B1C /* .cvsignore */,
+				18FC95601702236100359B1C /* GNUmakefile */,
+				18FC95611702236100359B1C /* GNUmakefile.preamble */,
+				18FC95621702236100359B1C /* GSXftFontInfo.m */,
+				18FC95631702236100359B1C /* XGBitmap.m */,
+				18FC95641702236100359B1C /* XGCommonFont.m */,
+				18FC95651702236100359B1C /* XGContext.m */,
+				18FC95661702236100359B1C /* XGFont.m */,
+				18FC95671702236100359B1C /* XGFontManager.m */,
+				18FC95681702236100359B1C /* XGFontSetFontInfo.m */,
+				18FC95691702236100359B1C /* XGGState.m */,
+				18FC956A1702236100359B1C /* XGGeometry.m */,
+				18FC956B1702236100359B1C /* linking.m */,
+			);
+			path = xlib;
+			sourceTree = "<group>";
+		};
+		18FC956C1702236900359B1C /* Tools */ = {
+			isa = PBXGroup;
+			children = (
+				18FC956D1702236900359B1C /* .cvsignore */,
+				18FC956E1702236900359B1C /* GNUmakefile */,
+				18FC956F1702236900359B1C /* GNUmakefile.postamble */,
+				18FC95701702236900359B1C /* GNUmakefile.preamble */,
+				18FC95711702236900359B1C /* font_cacher.m */,
+				18FC95721702236900359B1C /* gpbs.1 */,
+				18FC95731702236900359B1C /* gpbs.m */,
+				18FC95741702236900359B1C /* win32pbs.m */,
+				18FC95751702236900359B1C /* xpbs.m */,
+			);
+			path = Tools;
+			sourceTree = SOURCE_ROOT;
+		};
+		18FC957F1702237300359B1C /* Headers */ = {
+			isa = PBXGroup;
+			children = (
+				18FC95801702237300359B1C /* art */,
+				18FC95821702237300359B1C /* cairo */,
+				18FC95921702237300359B1C /* gsc */,
+				18FC959A1702237300359B1C /* win32 */,
+				18FC959E1702237300359B1C /* winlib */,
+				18FC95A31702237300359B1C /* x11 */,
+				18FC95AE1702237300359B1C /* xdps */,
+				18FC95B01702237300359B1C /* xlib */,
+			);
+			path = Headers;
+			sourceTree = SOURCE_ROOT;
+		};
+		18FC95801702237300359B1C /* art */ = {
+			isa = PBXGroup;
+			children = (
+				18FC95811702237300359B1C /* ARTContext.h */,
+			);
+			path = art;
+			sourceTree = "<group>";
+		};
+		18FC95821702237300359B1C /* cairo */ = {
+			isa = PBXGroup;
+			children = (
+				18FC95831702237300359B1C /* CairoContext.h */,
+				18FC95841702237300359B1C /* CairoFaceInfo.h */,
+				18FC95851702237300359B1C /* CairoFontEnumerator.h */,
+				18FC95861702237300359B1C /* CairoFontInfo.h */,
+				18FC95871702237300359B1C /* CairoGState.h */,
+				18FC95881702237300359B1C /* CairoPDFSurface.h */,
+				18FC95891702237300359B1C /* CairoPSSurface.h */,
+				18FC958A1702237300359B1C /* CairoSurface.h */,
+				18FC958B1702237300359B1C /* Win32CairoGState.h */,
+				18FC958C1702237300359B1C /* Win32CairoGlitzSurface.h */,
+				18FC958D1702237300359B1C /* Win32CairoSurface.h */,
+				18FC958E1702237300359B1C /* XGCairoGlitzSurface.h */,
+				18FC958F1702237300359B1C /* XGCairoModernSurface.h */,
+				18FC95901702237300359B1C /* XGCairoSurface.h */,
+				18FC95911702237300359B1C /* XGCairoXImageSurface.h */,
+			);
+			path = cairo;
+			sourceTree = "<group>";
+		};
+		18FC95921702237300359B1C /* gsc */ = {
+			isa = PBXGroup;
+			children = (
+				18FC95931702237300359B1C /* GSContext.h */,
+				18FC95941702237300359B1C /* GSFunction.h */,
+				18FC95951702237300359B1C /* GSGState.h */,
+				18FC95961702237300359B1C /* GSGStateOps.h */,
+				18FC95971702237300359B1C /* GSStreamContext.h */,
+				18FC95981702237300359B1C /* GSStreamGState.h */,
+				18FC95991702237300359B1C /* gscolors.h */,
+			);
+			path = gsc;
+			sourceTree = "<group>";
+		};
+		18FC959A1702237300359B1C /* win32 */ = {
+			isa = PBXGroup;
+			children = (
+				18FC959B1702237300359B1C /* WIN32Geometry.h */,
+				18FC959C1702237300359B1C /* WIN32OpenGL.h */,
+				18FC959D1702237300359B1C /* WIN32Server.h */,
+			);
+			path = win32;
+			sourceTree = "<group>";
+		};
+		18FC959E1702237300359B1C /* winlib */ = {
+			isa = PBXGroup;
+			children = (
+				18FC959F1702237300359B1C /* WIN32Context.h */,
+				18FC95A01702237300359B1C /* WIN32FontEnumerator.h */,
+				18FC95A11702237300359B1C /* WIN32FontInfo.h */,
+				18FC95A21702237300359B1C /* WIN32GState.h */,
+			);
+			path = winlib;
+			sourceTree = "<group>";
+		};
+		18FC95A31702237300359B1C /* x11 */ = {
+			isa = PBXGroup;
+			children = (
+				18FC95A41702237300359B1C /* StdCmap.h */,
+				18FC95A51702237300359B1C /* XGDragView.h */,
+				18FC95A61702237300359B1C /* XGGeneric.h */,
+				18FC95A71702237300359B1C /* XGInputServer.h */,
+				18FC95A81702237300359B1C /* XGOpenGL.h */,
+				18FC95A91702237300359B1C /* XGServer.h */,
+				18FC95AA1702237300359B1C /* XGServerWindow.h */,
+				18FC95AB1702237300359B1C /* XWindowBuffer.h */,
+				18FC95AC1702237300359B1C /* wraster.h */,
+				18FC95AD1702237300359B1C /* xdnd.h */,
+			);
+			path = x11;
+			sourceTree = "<group>";
+		};
+		18FC95AE1702237300359B1C /* xdps */ = {
+			isa = PBXGroup;
+			children = (
+				18FC95AF1702237300359B1C /* NSDPSContext.h */,
+			);
+			path = xdps;
+			sourceTree = "<group>";
+		};
+		18FC95B01702237300359B1C /* xlib */ = {
+			isa = PBXGroup;
+			children = (
+				18FC95B11702237300359B1C /* GSXftFontInfo.h */,
+				18FC95B21702237300359B1C /* XGContext.h */,
+				18FC95B31702237300359B1C /* XGFontSetFontInfo.h */,
+				18FC95B41702237300359B1C /* XGGState.h */,
+				18FC95B51702237300359B1C /* XGGeometry.h */,
+				18FC95B61702237300359B1C /* XGPrivate.h */,
+			);
+			path = xlib;
+			sourceTree = "<group>";
+		};
+		18FC95B71702237D00359B1C /* Fonts */ = {
+			isa = PBXGroup;
+			children = (
+				18FC95B81702237D00359B1C /* GNUmakefile */,
+				18FC95B91702237D00359B1C /* GNUmakefile.postamble */,
+				18FC95BA1702237D00359B1C /* Helvetica.nfont */,
+			);
+			path = Fonts;
+			sourceTree = SOURCE_ROOT;
+		};
+		18FC95BA1702237D00359B1C /* Helvetica.nfont */ = {
+			isa = PBXGroup;
+			children = (
+				18FC95BB1702237D00359B1C /* FontInfo.plist */,
+				18FC95BC1702237D00359B1C /* n019003l.afm */,
+				18FC95BD1702237D00359B1C /* n019003l.pfb */,
+				18FC95BE1702237D00359B1C /* n019003l.pfm */,
+				18FC95BF1702237D00359B1C /* n019004l.afm */,
+				18FC95C01702237D00359B1C /* n019004l.pfb */,
+				18FC95C11702237D00359B1C /* n019004l.pfm */,
+				18FC95C21702237D00359B1C /* n019023l.afm */,
+				18FC95C31702237D00359B1C /* n019023l.pfb */,
+				18FC95C41702237D00359B1C /* n019023l.pfm */,
+				18FC95C51702237D00359B1C /* n019024l.afm */,
+				18FC95C61702237D00359B1C /* n019024l.pfb */,
+				18FC95C71702237D00359B1C /* n019024l.pfm */,
+				18FC95C81702237D00359B1C /* n019043l.afm */,
+				18FC95C91702237D00359B1C /* n019043l.pfb */,
+				18FC95CA1702237D00359B1C /* n019043l.pfm */,
+				18FC95CB1702237D00359B1C /* n019044l.afm */,
+				18FC95CC1702237D00359B1C /* n019044l.pfb */,
+				18FC95CD1702237D00359B1C /* n019044l.pfm */,
+				18FC95CE1702237D00359B1C /* n019063l.afm */,
+				18FC95CF1702237D00359B1C /* n019063l.pfb */,
+				18FC95D01702237D00359B1C /* n019063l.pfm */,
+				18FC95D11702237D00359B1C /* n019064l.afm */,
+				18FC95D21702237D00359B1C /* n019064l.pfb */,
+				18FC95D31702237D00359B1C /* n019064l.pfm */,
+			);
+			path = Helvetica.nfont;
+			sourceTree = "<group>";
+		};
+/* End PBXGroup section */
+
+/* Begin PBXNativeTarget section */
+		18FC94C81702225C00359B1C /* Backend */ = {
+			isa = PBXNativeTarget;
+			buildConfigurationList = 18FC94DB1702225C00359B1C /* Build configuration list for PBXNativeTarget "Backend" */;
+			buildPhases = (
+				18FC94C51702225C00359B1C /* Sources */,
+				18FC94C61702225C00359B1C /* Frameworks */,
+				18FC94C71702225C00359B1C /* Resources */,
+			);
+			buildRules = (
+			);
+			dependencies = (
+			);
+			name = Backend;
+			productName = Backend;
+			productReference = 18FC94C91702225C00359B1C /* Backend.bundle */;
+			productType = "com.apple.product-type.bundle";
+		};
+/* End PBXNativeTarget section */
+
+/* Begin PBXProject section */
+		18FC94C01702225C00359B1C /* Project object */ = {
+			isa = PBXProject;
+			attributes = {
+				LastUpgradeCheck = 0420;
+			};
+			buildConfigurationList = 18FC94C31702225C00359B1C /* Build configuration list for PBXProject "Backend" */;
+			compatibilityVersion = "Xcode 3.2";
+			developmentRegion = English;
+			hasScannedForEncodings = 0;
+			knownRegions = (
+				en,
+				English,
+				Swedish,
+			);
+			mainGroup = 18FC94BE1702225C00359B1C;
+			productRefGroup = 18FC94CA1702225C00359B1C /* Products */;
+			projectDirPath = "";
+			projectRoot = "";
+			targets = (
+				18FC94C81702225C00359B1C /* Backend */,
+			);
+		};
+/* End PBXProject section */
+
+/* Begin PBXResourcesBuildPhase section */
+		18FC94C71702225C00359B1C /* Resources */ = {
+			isa = PBXResourcesBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+/* End PBXResourcesBuildPhase section */
+
+/* Begin PBXSourcesBuildPhase section */
+		18FC94C51702225C00359B1C /* Sources */ = {
+			isa = PBXSourcesBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				18FC95FD170223D300359B1C /* GSBackend.m in Sources */,
+				18FC95FE170223EE00359B1C /* GSContext.m in Sources */,
+				18FC95FF170223EE00359B1C /* GSFunction.m in Sources */,
+				18FC9600170223EE00359B1C /* GSGState.m in Sources */,
+				18FC9601170223EE00359B1C /* GSStreamContext.m in Sources */,
+				18FC9602170223EE00359B1C /* GSStreamGState.m in Sources */,
+				18FC9603170223EE00359B1C /* externs.m in Sources */,
+				18FC9604170223EE00359B1C /* gscolors.c in Sources */,
+				18FC9605170223FE00359B1C /* XGDragView.m in Sources */,
+				18FC9606170223FE00359B1C /* XGGLContext.m in Sources */,
+				18FC9607170223FE00359B1C /* XGGLFormat.m in Sources */,
+				18FC9608170223FE00359B1C /* XGServer.m in Sources */,
+				18FC9609170223FE00359B1C /* XGServerEvent.m in Sources */,
+				18FC960A170223FE00359B1C /* XGServerWindow.m in Sources */,
+				18FC960B170223FE00359B1C /* XIMInputServer.m in Sources */,
+				18FC960C170223FE00359B1C /* XWindowBuffer.m in Sources */,
+				18FC960D170223FE00359B1C /* context.c in Sources */,
+				18FC960E170223FE00359B1C /* convert.c in Sources */,
+				18FC960F170223FE00359B1C /* raster.c in Sources */,
+				18FC9610170223FE00359B1C /* scale.c in Sources */,
+				18FC9612170223FE00359B1C /* xdnd.c in Sources */,
+				18FC9613170223FE00359B1C /* xutil.c in Sources */,
+				18FC96201702242600359B1C /* GSXftFontInfo.m in Sources */,
+				18FC96211702242600359B1C /* XGBitmap.m in Sources */,
+				18FC96221702242600359B1C /* XGCommonFont.m in Sources */,
+				18FC96231702242600359B1C /* XGContext.m in Sources */,
+				18FC96241702242600359B1C /* XGFont.m in Sources */,
+				18FC96251702242600359B1C /* XGFontManager.m in Sources */,
+				18FC96261702242600359B1C /* XGFontSetFontInfo.m in Sources */,
+				18FC96271702242600359B1C /* XGGState.m in Sources */,
+				18FC96281702242600359B1C /* XGGeometry.m in Sources */,
+				18FC96291702242600359B1C /* linking.m in Sources */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+/* End PBXSourcesBuildPhase section */
+
+/* Begin PBXVariantGroup section */
+		18FC94EB1702236100359B1C /* nfontFaceNames.strings */ = {
+			isa = PBXVariantGroup;
+			children = (
+				18FC94EC1702236100359B1C /* English */,
+				18FC94F11702236100359B1C /* Swedish */,
+			);
+			name = nfontFaceNames.strings;
+			sourceTree = "<group>";
+		};
+/* End PBXVariantGroup section */
+
+/* Begin XCBuildConfiguration section */
+		18FC94D91702225C00359B1C /* Debug */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				ALWAYS_SEARCH_USER_PATHS = NO;
+				ARCHS = "$(ARCHS_STANDARD_64_BIT)";
+				COPY_PHASE_STRIP = NO;
+				GCC_C_LANGUAGE_STANDARD = gnu99;
+				GCC_DYNAMIC_NO_PIC = NO;
+				GCC_ENABLE_OBJC_EXCEPTIONS = YES;
+				GCC_OPTIMIZATION_LEVEL = 0;
+				GCC_PREPROCESSOR_DEFINITIONS = (
+					"DEBUG=1",
+					"$(inherited)",
+				);
+				GCC_SYMBOLS_PRIVATE_EXTERN = NO;
+				GCC_VERSION = com.apple.compilers.llvm.clang.1_0;
+				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
+				GCC_WARN_ABOUT_MISSING_PROTOTYPES = YES;
+				GCC_WARN_ABOUT_RETURN_TYPE = YES;
+				GCC_WARN_UNUSED_VARIABLE = YES;
+				MACOSX_DEPLOYMENT_TARGET = 10.6;
+				ONLY_ACTIVE_ARCH = YES;
+				SDKROOT = macosx;
+			};
+			name = Debug;
+		};
+		18FC94DA1702225C00359B1C /* Release */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				ALWAYS_SEARCH_USER_PATHS = NO;
+				ARCHS = "$(ARCHS_STANDARD_64_BIT)";
+				COPY_PHASE_STRIP = YES;
+				DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
+				GCC_C_LANGUAGE_STANDARD = gnu99;
+				GCC_ENABLE_OBJC_EXCEPTIONS = YES;
+				GCC_VERSION = com.apple.compilers.llvm.clang.1_0;
+				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
+				GCC_WARN_ABOUT_MISSING_PROTOTYPES = YES;
+				GCC_WARN_ABOUT_RETURN_TYPE = YES;
+				GCC_WARN_UNUSED_VARIABLE = YES;
+				MACOSX_DEPLOYMENT_TARGET = 10.6;
+				SDKROOT = macosx;
+			};
+			name = Release;
+		};
+		18FC94DC1702225C00359B1C /* Debug */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				ALWAYS_SEARCH_USER_PATHS = YES;
+				GCC_PRECOMPILE_PREFIX_HEADER = NO;
+				GCC_PREFIX_HEADER = "Support/Backend/Backend-Prefix.pch";
+				HEADER_SEARCH_PATHS = (
+					/opt/local/include,
+					/usr/GNUstep/Local/Library/Headers,
+					"$(SRCROOT)/Headers",
+					"$(SRCROOT)/Source",
+					"$(SRCROOT)",
+				);
+				INFOPLIST_FILE = "Support/Backend/Backend-Info.plist";
+				INSTALL_PATH = "$(LOCAL_LIBRARY_DIR)/Bundles";
+				LIBRARY_SEARCH_PATHS = (
+					/opt/local/lib,
+					/usr/GNUstep/Local/Library/Libraries,
+				);
+				PRODUCT_NAME = "$(TARGET_NAME)";
+				USER_HEADER_SEARCH_PATHS = /opt/local/include/freetype2;
+				WRAPPER_EXTENSION = bundle;
+			};
+			name = Debug;
+		};
+		18FC94DD1702225C00359B1C /* Release */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				ALWAYS_SEARCH_USER_PATHS = YES;
+				GCC_PRECOMPILE_PREFIX_HEADER = NO;
+				GCC_PREFIX_HEADER = "Support/Backend/Backend-Prefix.pch";
+				HEADER_SEARCH_PATHS = (
+					/opt/local/include,
+					/usr/GNUstep/Local/Library/Headers,
+					"$(SRCROOT)/Headers",
+					"$(SRCROOT)/Source",
+					"$(SRCROOT)",
+				);
+				INFOPLIST_FILE = "Support/Backend/Backend-Info.plist";
+				INSTALL_PATH = "$(LOCAL_LIBRARY_DIR)/Bundles";
+				LIBRARY_SEARCH_PATHS = (
+					/opt/local/lib,
+					/usr/GNUstep/Local/Library/Libraries,
+				);
+				PRODUCT_NAME = "$(TARGET_NAME)";
+				USER_HEADER_SEARCH_PATHS = /opt/local/include/freetype2;
+				WRAPPER_EXTENSION = bundle;
+			};
+			name = Release;
+		};
+/* End XCBuildConfiguration section */
+
+/* Begin XCConfigurationList section */
+		18FC94C31702225C00359B1C /* Build configuration list for PBXProject "Backend" */ = {
+			isa = XCConfigurationList;
+			buildConfigurations = (
+				18FC94D91702225C00359B1C /* Debug */,
+				18FC94DA1702225C00359B1C /* Release */,
+			);
+			defaultConfigurationIsVisible = 0;
+			defaultConfigurationName = Release;
+		};
+		18FC94DB1702225C00359B1C /* Build configuration list for PBXNativeTarget "Backend" */ = {
+			isa = XCConfigurationList;
+			buildConfigurations = (
+				18FC94DC1702225C00359B1C /* Debug */,
+				18FC94DD1702225C00359B1C /* Release */,
+			);
+			defaultConfigurationIsVisible = 0;
+			defaultConfigurationName = Release;
+		};
+/* End XCConfigurationList section */
+	};
+	rootObject = 18FC94C01702225C00359B1C /* Project object */;
+}
diff --git a/Headers/cairo/CairoFontInfo.h b/Headers/cairo/CairoFontInfo.h
index 9f84240..3f44cd6 100644
--- a/Headers/cairo/CairoFontInfo.h
+++ b/Headers/cairo/CairoFontInfo.h
@@ -40,14 +40,14 @@
 	BOOL _screenFont;
 	CGFloat lineHeight;
 
-	unsigned int _cacheSize;
+	NSUInteger _cacheSize;
 	unsigned int *_cachedGlyphs;
 	NSSize *_cachedSizes;
 }
 
-- (void) setCacheSize:(unsigned int)size;
+- (void) setCacheSize:(NSUInteger)size;
 - (void) drawGlyphs: (const NSGlyph*)glyphs
-	     length: (int)length 
+	     length: (NSUInteger)length 
 	         on: (cairo_t*)ct;
 @end
 
diff --git a/Headers/gsc/GSFunction.h b/Headers/gsc/GSFunction.h
index 5a7a22c..3e7059f 100644
--- a/Headers/gsc/GSFunction.h
+++ b/Headers/gsc/GSFunction.h
@@ -34,7 +34,7 @@
 @interface GSFunction : NSObject
 {
   /* General information about the function. */
-  int num_in, num_out;
+  NSInteger num_in, num_out;
 
   double *domain; /* num_in * 2 */
   double *range; /* num_out * 2 */
diff --git a/Headers/gsc/GSGStateOps.h b/Headers/gsc/GSGStateOps.h
index e796986..6976616 100644
--- a/Headers/gsc/GSGStateOps.h
+++ b/Headers/gsc/GSGStateOps.h
@@ -72,9 +72,9 @@
 - (void) GSSetTextCTM: (NSAffineTransform *)ctm;
 - (void) GSSetTextDrawingMode: (GSTextDrawingMode)mode;
 - (void) GSSetTextPosition: (NSPoint)loc;
-- (void) GSShowText: (const char *)string : (size_t) length;
-- (void) GSShowGlyphs: (const NSGlyph *)glyphs : (size_t) length;
-- (void) GSShowGlyphsWithAdvances: (const NSGlyph *)glyphs : (const NSSize *)advances : (size_t) length;
+- (void) GSShowText: (const char *)string : (NSUInteger) length;
+- (void) GSShowGlyphs: (const NSGlyph *)glyphs : (NSUInteger) length;
+- (void) GSShowGlyphsWithAdvances: (const NSGlyph *)glyphs : (const NSSize *)advances : (NSUInteger) length;
 
 /* ----------------------------------------------------------------------- */
 /* Gstate operations */
diff --git a/Headers/x11/XGDragView.h b/Headers/x11/XGDragView.h
index afebf5d..354633c 100644
--- a/Headers/x11/XGDragView.h
+++ b/Headers/x11/XGDragView.h
@@ -40,7 +40,7 @@
 
 void 		GSEnsureDndIsInitialized (void);
 DndClass 	xdnd (void);
-Atom		GSActionForDragOperation(unsigned int op);
+Atom		GSActionForDragOperation(NSDragOperation op);
 NSDragOperation	GSDragOperationForAction(Atom xaction);
 
 
diff --git a/Headers/x11/XGServer.h b/Headers/x11/XGServer.h
index bd6d2e1..fe24bf9 100644
--- a/Headers/x11/XGServer.h
+++ b/Headers/x11/XGServer.h
@@ -55,7 +55,7 @@ typedef enum {
 @interface XGServer : GSDisplayServer
 {
   Display           *dpy;
-  int               defScreen;
+  NSInteger         defScreen;
   NSMapTable        *screenList;
   Window	    grabWindow;
   struct XGGeneric  generic;
@@ -66,15 +66,15 @@ typedef enum {
 - (Display*) xDisplay;
 - (Window) xAppRootWindow;
 
-- (void *) xrContextForScreen: (int)screen_number;
-- (Visual *) visualForScreen: (int)screen_number;
-- (int) depthForScreen: (int)screen_number;
+- (void *) xrContextForScreen: (NSInteger)screenNumber;
+- (Visual *) visualForScreen: (NSInteger)screenNumber;
+- (int) depthForScreen: (NSInteger)screenNumber;
 
-- (XGDrawMechanism) drawMechanismForScreen: (int)screen_number;
-- (void) getForScreen: (int)screen_number pixelFormat: (int *)bpp_number 
-                masks: (int *)red_mask : (int *)green_mask : (int *)blue_mask;
-- (Window) xDisplayRootWindowForScreen: (int)screen_number;
-- (XColor) xColorFromColor: (XColor)color forScreen: (int)screen_number;
+- (XGDrawMechanism) drawMechanismForScreen: (NSInteger)screenNumber;
+- (void) getForScreen: (NSInteger)screenNumber pixelFormat: (NSInteger *)bitsPerPixel
+                masks: (NSUInteger *)red_mask : (NSUInteger *)green_mask : (NSUInteger *)blue_mask;
+- (Window) xDisplayRootWindowForScreen: (NSInteger)screenNumber;
+- (XColor) xColorFromColor: (XColor)color forScreen: (NSInteger)screenNumber;
 
 + (void) waitAllContexts;
 @end
diff --git a/Headers/x11/XGServerWindow.h b/Headers/x11/XGServerWindow.h
index 0ce9efd..b882a37 100644
--- a/Headers/x11/XGServerWindow.h
+++ b/Headers/x11/XGServerWindow.h
@@ -85,14 +85,14 @@ typedef struct _gswindow_device_t {
   Window                ident;         /* Window handle */
   Window                root;          /* Handle of root window */
   Window		parent;        /* Handle of parent window */
-  int                   screen;        /* Screeen this window is on */
+  NSInteger             screen;        /* Screeen this window is on */
   GC                    gc;            /* GC for drawing */
   long                  number;        /* Globally unique identifier */
   unsigned int          depth;         /* Window depth */
   unsigned int          border;        /* Border size */
   int			map_state;     /* X map state */
   int                   visibility;    /* X visibility */
-  int                   wm_state;      /* X WM state */
+  NSInteger             wm_state;      /* X WM state */
   NSBackingStoreType    type;          /* Backing type */
   NSRect                xframe;        /* Window frame */
 
@@ -118,8 +118,8 @@ typedef struct _gswindow_device_t {
   int                   gdriverProtocol; /* Managed by gdriver */
   BOOL			ignore_take_focus;
 #ifdef HAVE_LIBXEXT
-  uint32_t              net_wm_sync_request_counter_value_low;
-  uint32_t              net_wm_sync_request_counter_value_high;
+  Atom                  net_wm_sync_request_counter_value_low;
+  Atom                  net_wm_sync_request_counter_value_high;
   XSyncCounter          net_wm_sync_request_counter;
 #endif
 } gswindow_device_t;
@@ -129,20 +129,20 @@ typedef struct _gswindow_device_t {
 @interface XGServer (DPSWindow)
 + (gswindow_device_t *) _windowForXWindow: (Window)xWindow;
 + (gswindow_device_t *) _windowForXParent: (Window)xWindow;
-+ (gswindow_device_t *) _windowWithTag: (int)windowNumber;
-- (void) _addExposedRectangle: (XRectangle)rectangle : (int)win : (BOOL) ignoreBacking;
-- (void) _processExposedRectangles: (int)win;
++ (gswindow_device_t *) _windowWithTag: (NSInteger)windowNumber;
+- (void) _addExposedRectangle: (XRectangle)rectangle : (NSInteger)win : (BOOL) ignoreBacking;
+- (void) _processExposedRectangles: (NSInteger)win;
 - (void) _initializeCursorForXWindow: (Window) win;
 - (void) _destroyServerWindows;
 
 /* This needs to go in GSDisplayServer */
 - (void) _DPSsetcursor: (Cursor)c : (BOOL)set;
 
-- (int) _wm_state: (Window) win;
+- (NSInteger) _wm_state: (Window) win;
 - (BOOL) _ewmh_isHidden: (Window) win;
 @end
 
 extern Pixmap
 xgps_cursor_mask(Display *xdpy, Drawable draw, const unsigned char *data,
-		 int w, int h, int colors);
+		 NSInteger w, NSInteger h, NSInteger colors);
 #endif
diff --git a/Headers/x11/wraster.h b/Headers/x11/wraster.h
index a5d8a53..0c5ff88 100644
--- a/Headers/x11/wraster.h
+++ b/Headers/x11/wraster.h
@@ -79,11 +79,17 @@ extern "C" {
 /* standard colormap usage */
 #define RC_StandardColormap	(1<<7)
 
-    
-    
 
-    
-    
+#if __LP64__
+    typedef long RInteger;
+    typedef unsigned long RUInteger;
+#else
+    typedef int RInteger;
+    typedef unsigned int RUInteger;
+#endif
+
+
+
 /* std colormap usage/creation modes */
 enum {
     RUseStdColormap,		       /* default. fallbacks to RIgnore.. if 
@@ -97,7 +103,7 @@ enum {
 typedef struct RContextAttributes {
     int flags;
     int render_mode;
-    int colors_per_channel;	       /* for PseudoColor */
+    RInteger colors_per_channel;	       /* for PseudoColor */
     float rgamma;		       /* gamma correction for red, */
     float ggamma;		       /* green, */
     float bgamma;		       /* and blue */
@@ -115,7 +121,7 @@ typedef struct RContextAttributes {
  */
 typedef struct RContext {
     Display *dpy;
-    int screen_number;
+    RInteger screen_number;
     Colormap cmap;
     
     RContextAttributes *attribs;
@@ -140,7 +146,7 @@ typedef struct RContext {
     XStandardColormap *std_rgb_map;    /* standard RGB colormap */
     XStandardColormap *std_gray_map;   /* standard grayscale colormap */
     
-    int ncolors;		       /* total number of colors we can use */
+    RUInteger ncolors;		       /* total number of colors we can use */
     XColor *colors;		       /* internal colormap */
     unsigned long *pixels;	       /* RContext->colors[].pixel */
 
@@ -304,7 +310,7 @@ char *RGetImageFileFormat(char *file);
 /*
  * Xlib contexts
  */
-RContext *RCreateContext(Display *dpy, int screen_number,
+RContext *RCreateContext(Display *dpy, RInteger screen_number,
 			 RContextAttributes *attribs);
 
 void RDestroyContext(RContext *context);
diff --git a/Headers/x11/xdnd.h b/Headers/x11/xdnd.h
index 20d94e4..1c2a161 100644
--- a/Headers/x11/xdnd.h
+++ b/Headers/x11/xdnd.h
@@ -98,7 +98,7 @@ struct _DndClass {
 #define XDND_DROP_STAGE_CONVERTING	3
 #define XDND_DROP_STAGE_ENTERED		4
     int stage;
-    int dragging_version;
+    Atom dragging_version;
     int internal_drag;
     int want_position;
     int ready_to_drop;
@@ -118,7 +118,7 @@ struct _DndClass {
 
 void xdnd_init (DndClass * dnd, Display * display);
 void xdnd_set_dnd_aware (DndClass * dnd, Window window, Atom * typelist);
-int xdnd_is_dnd_aware (DndClass * dnd, Window window, int *version, Atom * typelist);
+int xdnd_is_dnd_aware (DndClass * dnd, Window window, Atom *version, Atom * typelist);
 void xdnd_set_type_list (DndClass * dnd, Window window, Atom * typelist);
 void xdnd_get_type_list (DndClass * dnd, Window window, Atom ** typelist);
 void xdnd_send_enter (DndClass * dnd, Window window, Window from, Atom * typelist);
@@ -130,6 +130,6 @@ void xdnd_send_drop (DndClass * dnd, Window window, Window from, unsigned long e
 void xdnd_send_finished (DndClass * dnd, Window window, Window from, int error);
 int xdnd_convert_selection (DndClass * dnd, Window window, Window requester, Atom type);
 int xdnd_set_selection_owner (DndClass * dnd, Window window, Atom type);
-void xdnd_selection_send (DndClass * dnd, XSelectionRequestEvent * request, unsigned char *data, int length);
+void xdnd_selection_send (DndClass * dnd, XSelectionRequestEvent * request, unsigned char *data, long length);
 
 #endif 	/* !_X_DND_H */
diff --git a/Headers/xlib/XGPrivate.h b/Headers/xlib/XGPrivate.h
index 768893e..c271d7f 100644
--- a/Headers/xlib/XGPrivate.h
+++ b/Headers/xlib/XGPrivate.h
@@ -39,7 +39,7 @@
 #include <GNUstepGUI/GSFontInfo.h>
 
 /* Font function (defined in XGFontManager) */
-extern NSString	*XGXFontName(NSString *fontName, float size);
+extern NSString	*XGXFontName(NSString *fontName, CGFloat size);
 
 /* Font functions (defined in XGCommonFont) */
 extern NSString *XGFontCacheName(Display *dpy);
@@ -70,16 +70,16 @@ extern unsigned long XGFontPropULong(Display *dpy, XFontStruct *font_struct,
 - (void) drawString:  (NSString*)string
 	  onDisplay: (Display*) xdpy drawable: (Drawable) draw
 	       with: (GC) xgcntxt at: (XPoint) xp;
-- (void) draw: (const char*) s length: (int) len 
+- (void) draw: (const char*) s length: (NSUInteger) len 
     onDisplay: (Display*) xdpy drawable: (Drawable) draw
 	 with: (GC) xgcntxt at: (XPoint) xp;
-- (float) widthOf: (const char*) s length: (int) len;
+- (CGFloat) widthOf: (const char*) s length: (NSUInteger) len;
 - (void) setActiveFor: (Display*) xdpy gc: (GC) xgcntxt;
 
-- (void) drawGlyphs: (const NSGlyph *) glyphs length: (int) len
+- (void) drawGlyphs: (const NSGlyph *) glyphs length: (NSUInteger) len
 	  onDisplay: (Display*) xdpy drawable: (Drawable) draw
 	       with: (GC) xgcntxt at: (XPoint) xp;
-- (float) widthOfGlyphs: (const NSGlyph *) glyphs length: (int) len;
+- (CGFloat) widthOfGlyphs: (const NSGlyph *) glyphs length: (NSUInteger) len;
 
 @end
 
@@ -94,10 +94,10 @@ extern int _pixmap_combine_alpha(RContext *context,
 
 extern int _bitmap_combine_alpha(RContext *context,
 		unsigned char * data_planes[5],
-		int width, int height,
-		int bits_per_sample, int samples_per_pixel,
-		int bits_per_pixel, int bytes_per_row,
-		int colour_space, BOOL one_is_black,
+		NSInteger width, NSInteger height,
+		NSInteger bits_per_sample, NSInteger samples_per_pixel,
+		NSInteger bits_per_pixel, NSInteger bytes_per_row,
+		NSInteger colour_space, BOOL one_is_black,
 		BOOL is_planar, BOOL has_alpha, BOOL fast_min,
 		RXImage *dest_im, RXImage *dest_alpha,
 		XRectangle srect, XRectangle drect,
diff --git a/Source/art/ARTContext.m b/Source/art/ARTContext.m
index 5c66380..d3de1c8 100644
--- a/Source/art/ARTContext.m
+++ b/Source/art/ARTContext.m
@@ -60,8 +60,8 @@
 
 - (void) setupDrawInfo: (void*)device
 {
-  int bpp;
-  int red_mask, green_mask, blue_mask;
+  NSInteger bpp;
+  NSUInteger red_mask, green_mask, blue_mask;
 #ifdef RDS
   RDSServer *s = (RDSServer *)server;
   
@@ -73,7 +73,7 @@
   [(XGServer *)server getForScreen: gs_win->screen pixelFormat: &bpp 
                 masks: &red_mask : &green_mask : &blue_mask];
 #endif
-  artcontext_setup_draw_info(&DI, red_mask, green_mask, blue_mask, bpp);
+  artcontext_setup_draw_info(&DI, (unsigned)red_mask, (unsigned)green_mask, (unsigned)blue_mask, (int)bpp);
 }
 
 - (void) flushGraphics
@@ -105,7 +105,7 @@
 - (BOOL) isCompatibleBitmap: (NSBitmapImageRep*)bitmap
 {
   NSString *colorSpaceName;
-  int numColors;
+  NSInteger numColors;
 
   if ([bitmap bitmapFormat] != 0)
     {
diff --git a/Source/art/ARTGState.m b/Source/art/ARTGState.m
index 5e54673..cb8f323 100644
--- a/Source/art/ARTGState.m
+++ b/Source/art/ARTGState.m
@@ -23,11 +23,12 @@
 */
 #include <math.h>
 
-#include <AppKit/NSAffineTransform.h>
-#include <AppKit/NSBezierPath.h>
-#include <AppKit/NSColor.h>
+#import <AppKit/NSAffineTransform.h>
+#import <AppKit/NSBezierPath.h>
+#import <AppKit/NSColor.h>
+#import <Foundation/NSException.h>
 
-#include "ARTGState.h"
+#import "ARTGState.h"
 
 #include "blit.h"
 #include "ftfont.h"
@@ -356,7 +357,7 @@ draw_info_t ART_DI;
 }
 
 
-- (void) GSShowGlyphsWithAdvances: (const NSGlyph *)glyphs : (const NSSize *)advances : (size_t) length
+- (void) GSShowGlyphsWithAdvances: (const NSGlyph *)glyphs : (const NSSize *)advances : (NSUInteger) length
 {
   // FIXME: Currently advances is ignored
   NSPoint p;
@@ -465,6 +466,7 @@ draw_info_t ART_DI;
 
 - (void) DPSsetdash: (const CGFloat*)pat : (NSInteger)size : (CGFloat)offs
 {
+  NSParameterAssert(size <= INT_MAX);
   NSInteger i;
 
   if (dash.n_dash)
@@ -478,7 +480,7 @@ draw_info_t ART_DI;
   if (size>0)
     {
       dash.offset = offs;
-      dash.n_dash = size;
+      dash.n_dash = (int)size;
       dash.dash = malloc(sizeof(double)*size);
       if (!dash.dash)
         {
diff --git a/Source/art/FTFaceInfo.h b/Source/art/FTFaceInfo.h
index 577bb34..d44049c 100644
--- a/Source/art/FTFaceInfo.h
+++ b/Source/art/FTFaceInfo.h
@@ -45,7 +45,7 @@
     int pixel_size;
     NSArray *files;
   } *sizes;
-  int num_sizes;
+  NSUInteger num_sizes;
 
   int weight;
   unsigned int traits;
diff --git a/Source/art/FTFontEnumerator.m b/Source/art/FTFontEnumerator.m
index a401411..00e7875 100644
--- a/Source/art/FTFontEnumerator.m
+++ b/Source/art/FTFontEnumerator.m
@@ -69,7 +69,7 @@ static BOOL anti_alias_by_default;
 
 
 
-static int traits_from_string(NSString *s, unsigned int *traits, unsigned int *weight)
+static NSUInteger traits_from_string(NSString *s, unsigned int *traits, unsigned int *weight)
 {
 static struct
 {
@@ -116,7 +116,7 @@ static struct
 {@"Condensed"      ,NSCondensedFontMask       ,-1},
 {nil,0,-1}
 };
-  int i;
+  NSUInteger i;
 
   *traits = 0;
 //  printf("do '%@'\n", s);
@@ -150,7 +150,7 @@ static struct
 
 static NSArray *fix_path(NSString *path, NSArray *files)
 {
-  int i, c = [files count];
+  NSUInteger i, c = [files count];
   NSMutableArray *nfiles;
 
   if (!files)
@@ -232,7 +232,7 @@ static void add_face(NSString *family, int family_weight,
   else if (!from_nfont)
     { /* try to guess something for .font packages */
       unsigned int dummy;
-      int split = traits_from_string(family,&dummy,&dummy);
+      NSUInteger split = traits_from_string(family,&dummy,&dummy);
       rawFaceName = faceName = [family substringFromIndex: split];
       family = [family substringToIndex: split];
       faceName = [NSLocalizedStringFromTableInBundle(faceName,@"nfontFaceNames",
@@ -257,7 +257,7 @@ static void add_face(NSString *family, int family_weight,
     NSDictionary *sizes;
     NSEnumerator *e;
     NSString *size;
-    int i;
+    NSUInteger i;
 
     sizes = [d objectForKey: @"ScreenFonts"];
 
@@ -291,7 +291,7 @@ static void add_face(NSString *family, int family_weight,
 
   if ([d objectForKey: @"RenderHints_hack"])
     fi->render_hints_hack
-      = strtol([[d objectForKey: @"RenderHints_hack"] cString], NULL, 0);
+      = (unsigned)strtol([[d objectForKey: @"RenderHints_hack"] cString], NULL, 0);
   else
     {
       if (anti_alias_by_default)
@@ -329,7 +329,7 @@ static void add_face(NSString *family, int family_weight,
 
 static void load_font_configuration(void)
 {
-  int i, j, k, c;
+  NSUInteger i, j, k, c;
   NSArray *paths;
   NSString *path, *font_path;
   NSFileManager *fm = [NSFileManager defaultManager];
@@ -445,8 +445,8 @@ static void load_font_configuration(void)
       [families_pending removeAllObjects];
     }
 
-  NSDebugLLog(@"ftfont", @"got %i fonts in %i families",
-    [fcfg_allFontNames count], [fcfg_allFontFamilies count]);
+  NSDebugLLog(@"ftfont", @"got %lu fonts in %lu families",
+    (unsigned long)[fcfg_allFontNames count], (unsigned long)[fcfg_allFontFamilies count]);
 
   if (![fcfg_allFontNames count])
     {
diff --git a/Source/art/ReadRect.m b/Source/art/ReadRect.m
index 3d7dbe0..f50a78f 100644
--- a/Source/art/ReadRect.m
+++ b/Source/art/ReadRect.m
@@ -109,7 +109,7 @@
   [matrix release];
 
   if (!w || !h)
-    return [[md autorelease] makeImmutableCopyOnFail: YES];
+    return [[[md autorelease] copy] autorelease];
 
   /* The rectangle isn't degenerate, so we need to actually copy some data. */
   {
@@ -135,10 +135,10 @@
 	c.dst += w * 4;
       }
 
-    [md setObject: [[d autorelease] makeImmutableCopyOnFail: YES]  forKey: @"Data"];
+    [md setObject: [[[d autorelease] copy] autorelease]  forKey: @"Data"];
   }
 
-  return [[md autorelease] makeImmutableCopyOnFail: YES];
+  return [[[md autorelease] copy] autorelease];
 }
 
 @end
diff --git a/Source/art/composite.m b/Source/art/composite.m
index 7ec67db..da314b5 100644
--- a/Source/art/composite.m
+++ b/Source/art/composite.m
@@ -41,9 +41,9 @@
 windows are known to be totally opaque, we can optimize in many ways
 (see big table at the end of blit.m). Will set dst_need_alpha and blit_func
 if necessary. Returns new operation, or -1 it it's a noop. */
-- (int) _composite_func: (BOOL)src_opaque : (BOOL)src_transparent
-	: (BOOL)dst_opaque : (BOOL *)dst_needs_alpha
-	: (int)op : (void (**)(composite_run_t *c, int num))blit_func_r
+- (NSInteger) _composite_func: (BOOL)src_opaque : (BOOL)src_transparent
+                             : (BOOL)dst_opaque : (BOOL *)dst_needs_alpha
+                             : (NSCompositingOperation)op : (void (**)(composite_run_t *c, int num))blit_func_r
 {
   void (*blit_func)(composite_run_t *c, int num);
 
@@ -429,7 +429,7 @@ static BOOL _rect_advance(rect_trace_t *t, int *x0, int *x1)
   ARTGState *ags = (ARTGState *)source;
   unsigned char *dst, *dst_alpha, *src, *src_alpha;
 
-  int op;
+  NSInteger op;
   void (*blit_func)(composite_run_t *c, int num) = NULL;
 
   NSPoint sp, dp;
@@ -608,12 +608,12 @@ static BOOL _rect_advance(rect_trace_t *t, int *x0, int *x1)
 
   if (!blit_func)
     {
-      NSLog(@"unimplemented: compositeGState: %p fromRect: (%g %g)+(%g %g) toPoint: (%g %g)  op: %i",
+      NSLog(@"unimplemented: compositeGState: %p fromRect: (%g %g)+(%g %g) toPoint: (%g %g)  op: %ld",
 	    source,
 	    aRect.origin.x, aRect.origin.y,
 	    aRect.size.width, aRect.size.height,
 	    aPoint.x, aPoint.y,
-	    op);
+	    (long)op);
       return;
     }
 
@@ -1505,10 +1505,10 @@ static BOOL _rect_advance(rect_trace_t *t, int *x0, int *x1)
     }
   else
     {
-      NSLog(@"unimplemented compositerect: (%g %g)+(%g %g)  op: %i",
+      NSLog(@"unimplemented compositerect: (%g %g)+(%g %g)  op: %ld",
 	    aRect.origin.x, aRect.origin.y,
 	    aRect.size.width, aRect.size.height,
-	    op);
+	    (long)op);
     }
   UPDATE_UNBUFFERED
 }
diff --git a/Source/art/ftfont.h b/Source/art/ftfont.h
index 7e3650a..6fc7cd4 100644
--- a/Source/art/ftfont.h
+++ b/Source/art/ftfont.h
@@ -27,6 +27,8 @@
 
 @class NSAffineTransform;
 
+struct draw_info_s;
+
 @protocol FTFontInfo
 -(void) drawString: (const char *)s
 	at: (int)x : (int)y
@@ -40,7 +42,7 @@
         widthChar: (int) wch
 	drawinfo: (struct draw_info_s *)di;
 
--(void) drawGlyphs: (const NSGlyph *)glyphs : (int)length
+-(void) drawGlyphs: (const NSGlyph *)glyphs : (NSUInteger)length
 	at: (int)x : (int)y
 	to: (int)x0 : (int)y0 : (int)x1 : (int)y1
 	: (unsigned char *)buf : (int)bpl
@@ -49,7 +51,7 @@
 	transform: (NSAffineTransform *)transform
 	drawinfo: (struct draw_info_s *)di;
 
--(void) drawGlyphs: (const NSGlyph *)glyphs : (int)length
+-(void) drawGlyphs: (const NSGlyph *)glyphs : (NSUInteger)length
 	at: (int)x : (int)y
 	to: (int)x0 : (int)y0 : (int)x1 : (int)y1
 	: (unsigned char *)buf : (int)bpl
diff --git a/Source/art/ftfont.m b/Source/art/ftfont.m
index d5e1b73..2a13d2b 100644
--- a/Source/art/ftfont.m
+++ b/Source/art/ftfont.m
@@ -84,7 +84,7 @@ from the back-art-subpixel-text defaults key
 1: subpixel, rgb
 2: subpixel, bgr
 */
-static int subpixel_text;
+static NSInteger subpixel_text;
 
 
 
@@ -136,7 +136,7 @@ static FT_Error ft_get_face(FTC_FaceID fid, FT_Library lib,
 {
   FT_Error err;
   NSArray *rfi = (NSArray *)fid;
-  int i, c = [rfi count];
+  NSUInteger i, c = [rfi count];
   const char *face_name = [[rfi objectAtIndex: 0] fileSystemRepresentation];
 
   NSDebugLLog(@"ftfont", @"ft_get_face: %@ '%s'", rfi, face_name);
@@ -416,7 +416,7 @@ static FT_Error ft_get_face(FTC_FaceID fid, FT_Library lib,
   return lineHeight;
 }
 
-- (unsigned) numberOfGlyphs
+- (NSUInteger) numberOfGlyphs
 {
   if (coveredCharacterSet == nil)
     {
@@ -610,7 +610,7 @@ static FT_Error ft_get_face(FTC_FaceID fid, FT_Library lib,
             {
               NSLog(@"FTC_SBitCache_Lookup() failed with error %08x "
                 @"(%08x, %08x, %ix%i, %08x)",
-                error, glyph, imageType.face_id, imageType.width,
+                error, glyph, (unsigned)imageType.face_id, imageType.width,
                 imageType.height, imageType.flags);
               continue;
             }
@@ -946,7 +946,7 @@ static FT_Error ft_get_face(FTC_FaceID fid, FT_Library lib,
 }
 
 
-- (void) drawGlyphs: (const NSGlyph *)glyphs : (int)length
+- (void) drawGlyphs: (const NSGlyph *)glyphs : (NSUInteger)length
         at: (int)x : (int)y
         to: (int)x0 : (int)y0 : (int)x1 : (int)y1
         : (unsigned char *)buf : (int)bpl
@@ -1040,7 +1040,7 @@ static FT_Error ft_get_face(FTC_FaceID fid, FT_Library lib,
             {
               NSLog(@"FTC_SBitCache_Lookup() failed with error %08x "
                 @"(%08x, %08x, %ix%i, %08x)",
-                error, glyph, imageType.face_id,
+                error, glyph, (unsigned)imageType.face_id,
                 imageType.width, imageType.height,
                 imageType.flags);
               continue;
@@ -1266,7 +1266,7 @@ static FT_Error ft_get_face(FTC_FaceID fid, FT_Library lib,
     }
 }
 
-- (void) drawGlyphs: (const NSGlyph *)glyphs : (int)length
+- (void) drawGlyphs: (const NSGlyph *)glyphs : (NSUInteger)length
         at: (int)x : (int)y
         to: (int)x0 : (int)y0 : (int)x1 : (int)y1
         : (unsigned char *)buf : (int)bpl
@@ -1360,7 +1360,7 @@ static FT_Error ft_get_face(FTC_FaceID fid, FT_Library lib,
             {
               if (glyph != 0xffffffff)
                 NSLog(@"FTC_SBitCache_Lookup() failed with error %08x (%08x, %08x, %ix%i, %08x)",
-                  error, glyph, imageType.face_id, imageType.width, imageType.height,
+                  error, glyph, (unsigned)imageType.face_id, imageType.width, imageType.height,
                   imageType.flags
                 );
               continue;
@@ -1628,7 +1628,7 @@ static FT_Error ft_get_face(FTC_FaceID fid, FT_Library lib,
       if ((error = FTC_SBitCache_Lookup(ftc_sbitcache, &imageType, glyph, &sbit, NULL)))
         {
           NSLog(@"FTC_SBitCache_Lookup() failed with error %08x (%08x, %08x, %ix%i, %08x)",
-            error, glyph, imageType.face_id,
+            error, glyph, (unsigned)imageType.face_id,
             imageType.width, imageType.height,
             imageType.flags
         );
@@ -1756,8 +1756,8 @@ static FT_Error ft_get_face(FTC_FaceID fid, FT_Library lib,
 - (CGFloat) widthOfString: (NSString*)string
 {
   unichar ch;
-  int i, c = [string length];
-  int total;
+  NSUInteger i, c = [string length];
+  NSInteger total;
 
   unsigned int glyph;
 
@@ -2020,12 +2020,12 @@ static int bezierpath_cubic_to(const FT_Vector *c1, const FT_Vector *c2,
 }
 
 static FT_Outline_Funcs bezierpath_funcs = {
-  move_to:bezierpath_move_to,
-  line_to:bezierpath_line_to,
-  conic_to:bezierpath_conic_to,
-  cubic_to:bezierpath_cubic_to,
-  shift:10,
-  delta:0,
+  .move_to = bezierpath_move_to,
+  .line_to = bezierpath_line_to,
+  .conic_to = bezierpath_conic_to,
+  .cubic_to = bezierpath_cubic_to,
+  .shift = 10,
+  .delta = 0,
 };
 
 
@@ -2112,7 +2112,7 @@ add code to avoid loading bitmaps for glyphs */
 }
 
 - (void) appendBezierPathWithGlyphs: (NSGlyph *)glyphs
-                              count: (int)count
+                              count: (NSInteger)count
                        toBezierPath: (NSBezierPath *)path
 {
   int i;
@@ -2212,7 +2212,8 @@ static int filters[3][7]=
               [NSString stringWithFormat: @"back-art-subpixel-filter-%i",i]];
         if (s)
           {
-            int j, c, sum, v;
+            NSUInteger j, c;
+            int sum, v;
             a = [s componentsSeparatedByString: @" "];
             c = [a count];
             if (!c)
diff --git a/Source/art/path.m b/Source/art/path.m
index a9e34ae..3ef7299 100644
--- a/Source/art/path.m
+++ b/Source/art/path.m
@@ -515,7 +515,7 @@ within one pixel.) */
 {
   ArtBpath *bpath, *bp2;
   ArtVpath *vp;
-  int i, j, c, cur_start, cur_line;
+  NSInteger i, j, c, cur_start, cur_line;
   NSPoint points[3];
   NSBezierPathElement t;
   double matrix[6];
@@ -731,8 +731,8 @@ static void clip_svp_callback(void *data, int y, int start,
   ci.index = malloc(sizeof(unsigned int) * (clip_sy + 1));
   if (!ci.index)
     {
-      NSLog(@"Warning: out of memory calculating clipping spans (%i bytes)",
-	    sizeof(unsigned int) * (clip_sy + 1));
+      NSLog(@"Warning: out of memory calculating clipping spans (%lu bytes)",
+	    (unsigned long)(sizeof(unsigned int) * (clip_sy + 1)));
       return;
     }
   ci.span_size = ci.num_span = 0;
diff --git a/Source/art/shfill.m b/Source/art/shfill.m
index 3312a7d..de6408a 100644
--- a/Source/art/shfill.m
+++ b/Source/art/shfill.m
@@ -224,7 +224,7 @@ static BOOL _rect_advance(rect_trace_t * t, int *x0, int *x1)
 typedef struct function_s
 {
   /* General information about the function. */
-  int num_in, num_out;
+  NSInteger num_in, num_out;
   void (* eval)(struct function_s *f, double *in, double *out);
 
   double * domain; /* num_in * 2 */
@@ -502,8 +502,8 @@ static BOOL function_setup(NSDictionary * d, function_t *f)
     f->encode = NULL;
     free(f->decode);
     f->decode = NULL;
-    NSDebugLLog(@"GSArt -shfill", @"Need %i bytes of data, DataSource only has %i bytes.", 
-      j, [data length]);
+    NSDebugLLog(@"GSArt -shfill", @"Need %i bytes of data, DataSource only has %lu bytes.", 
+      j, (unsigned long)[data length]);
     return NO;
   }
 
diff --git a/Source/cairo/CairoFontInfo.m b/Source/cairo/CairoFontInfo.m
index 329aca3..75e24b3 100644
--- a/Source/cairo/CairoFontInfo.m
+++ b/Source/cairo/CairoFontInfo.m
@@ -37,7 +37,7 @@
 
 @implementation CairoFontInfo 
 
-- (void) setCacheSize: (unsigned int)size
+- (void) setCacheSize: (NSUInteger)size
 {
   _cacheSize = size;
   if (_cachedSizes)
@@ -227,8 +227,8 @@ BOOL _cairo_extents_for_NSGlyph(cairo_scaled_font_t *scaled_font, NSGlyph glyph,
   unichar ustr[2];
   char str[4];
   unsigned char *b;
-  unsigned int size = 4;
-  int length = 1;
+  NSUInteger size = 4;
+  NSUInteger length = 1;
 
   ustr[0] = glyph;
   ustr[1] = 0;
@@ -252,7 +252,7 @@ BOOL _cairo_extents_for_NSGlyph(cairo_scaled_font_t *scaled_font, NSGlyph glyph,
 
   if (_cachedSizes)
     {
-      int entry = glyph % _cacheSize;
+      NSUInteger entry = glyph % _cacheSize;
 
       if (_cachedGlyphs[entry] == glyph)
         {
@@ -319,7 +319,7 @@ BOOL _cairo_extents_for_NSGlyph(cairo_scaled_font_t *scaled_font, NSGlyph glyph,
 }
 
 - (void) appendBezierPathWithGlyphs: (NSGlyph *)glyphs 
-                              count: (int)length 
+                              count: (NSInteger)length 
                        toBezierPath: (NSBezierPath *)path
 {
   cairo_format_t format = CAIRO_FORMAT_ARGB32;
@@ -328,11 +328,11 @@ BOOL _cairo_extents_for_NSGlyph(cairo_scaled_font_t *scaled_font, NSGlyph glyph,
   int ix = 400;
   int iy = 400;
   unsigned char *cdata;
-  int i;
+  NSUInteger i;
   unichar ustr[length+1];
   char str[3*length+1];
   unsigned char *b;
-  unsigned int size = 3*length+1;
+  NSUInteger size = 3*length+1;
   cairo_status_t status;
   cairo_matrix_t font_matrix;
 
@@ -469,15 +469,15 @@ BOOL _cairo_extents_for_NSGlyph(cairo_scaled_font_t *scaled_font, NSGlyph glyph,
 }
 
 - (void) drawGlyphs: (const NSGlyph*)glyphs
-             length: (int)length 
+             length: (NSUInteger)length 
                  on: (cairo_t*)ct
 {
   cairo_matrix_t font_matrix;
   unichar ustr[length+1];
   char str[3*length+1];
   unsigned char *b;
-  int i;
-  unsigned int size = 3*length+1;
+  NSUInteger i;
+  NSUInteger size = 3*length+1;
 
   for (i = 0; i < length; i++)
     {
diff --git a/Source/cairo/CairoGState.m b/Source/cairo/CairoGState.m
index 3447877..d18992f 100644
--- a/Source/cairo/CairoGState.m
+++ b/Source/cairo/CairoGState.m
@@ -424,7 +424,7 @@ static inline CGFloat floatToUserSpace(NSAffineTransform *ctm, double d)
     }
 }
 
-- (void) GSShowText: (const char *)string : (size_t)length
+- (void) GSShowText: (const char *)string : (NSUInteger)length
 {
   if (_ct)
     {
@@ -444,7 +444,7 @@ static inline CGFloat floatToUserSpace(NSAffineTransform *ctm, double d)
     }
 }
 
-- (void) GSShowGlyphsWithAdvances: (const NSGlyph *)glyphs : (const NSSize *)advances : (size_t) length
+- (void) GSShowGlyphsWithAdvances: (const NSGlyph *)glyphs : (const NSSize *)advances : (NSUInteger) length
 {
   // FIXME: this method should just be a call to cairo_show_glyphs
   // FIXME: Currently advances is ignored
@@ -618,7 +618,7 @@ static inline CGFloat floatToUserSpace(NSAffineTransform *ctm, double d)
   if (_ct)
     {
       double doffset = doubleFromUserSpace(ctm, foffset);
-      int i;
+      NSInteger i;
       GS_BEGINITEMBUF(dpat, size, double);
 
       i = size;
@@ -628,7 +628,7 @@ static inline CGFloat floatToUserSpace(NSAffineTransform *ctm, double d)
           // FIXME: When using the correct values, some dashes look wrong
           dpat[i] = doubleFromUserSpace(ctm, pat[i]) * 1.4;
         }
-      cairo_set_dash(_ct, dpat, size, doffset);
+      cairo_set_dash(_ct, dpat, (int)size, doffset);
       GS_ENDITEMBUF();
     }
 }
@@ -1014,10 +1014,10 @@ _set_op(cairo_t *ct, NSCompositingOperation op)
   NSAffineTransformStruct tstruct;
   cairo_surface_t *surface;
   unsigned char	*tmp = NULL;
-  int i = 0;
-  int j;
-  int index;
-  unsigned int pixels = pixelsHigh * pixelsWide;
+  NSInteger i = 0;
+  NSInteger j;
+  NSInteger index;
+  NSUInteger pixels = pixelsHigh * pixelsWide;
   unsigned char *rowData;
   cairo_matrix_t local_matrix;
   cairo_status_t status;
@@ -1128,9 +1128,9 @@ _set_op(cairo_t *ct, NSCompositingOperation op)
 
   surface = cairo_image_surface_create_for_data((void*)tmp,
 						format,
-						pixelsWide,
-						pixelsHigh,
-						pixelsWide * 4);
+						(int)pixelsWide,
+						(int)pixelsHigh,
+						(int)pixelsWide * 4);
   status = cairo_surface_status(surface);
   if (status != CAIRO_STATUS_SUCCESS)
     {
@@ -1537,8 +1537,8 @@ doesn't support to use the receiver cairo target as the source. */
   if (_ct)
     {
       cairo_status_t status;
-      int i;
-      int stops = [gradient numberOfColorStops];
+      NSInteger i;
+      NSInteger stops = [gradient numberOfColorStops];
       NSPoint startP = [ctm transformPoint: startCenter];
       NSPoint endP = [ctm transformPoint: endCenter];
       cairo_pattern_t *cpattern = cairo_pattern_create_radial(startP.x, startP.y, 
@@ -1587,8 +1587,8 @@ doesn't support to use the receiver cairo target as the source. */
   if (_ct)
     {
       cairo_status_t status;
-      int i;
-      int stops = [gradient numberOfColorStops];
+      NSInteger i;
+      NSInteger stops = [gradient numberOfColorStops];
       NSPoint startP = [ctm transformPoint: startPoint];
       NSPoint endP = [ctm transformPoint: endPoint];
       cairo_pattern_t *cpattern = cairo_pattern_create_linear(startP.x, startP.y,
diff --git a/Source/cairo/XGCairoSurface.m b/Source/cairo/XGCairoSurface.m
index 665024f..a58e3df 100644
--- a/Source/cairo/XGCairoSurface.m
+++ b/Source/cairo/XGCairoSurface.m
@@ -121,7 +121,7 @@
 						   bitsPerPixel: 32] autorelease];
 
       src = cairo_xlib_surface_create(dpy, win, attrs.visual, attrs.width, attrs.height);
-      dest = cairo_image_surface_create_for_data([bmp bitmapData], CAIRO_FORMAT_ARGB32, width, height, [bmp bytesPerRow]);
+      dest = cairo_image_surface_create_for_data([bmp bitmapData], CAIRO_FORMAT_ARGB32, (int)width, (int)height, (int)[bmp bytesPerRow]);
       
       {
 	cairo_t *cr = cairo_create(dest);
diff --git a/Source/gsc/GSContext.m b/Source/gsc/GSContext.m
index e010151..473f2ee 100644
--- a/Source/gsc/GSContext.m
+++ b/Source/gsc/GSContext.m
@@ -109,11 +109,11 @@ static NSMapTable *gtable;
 - (void)DPSexecuserobject: (NSInteger)index;
 - (void)DPSundefineuserobject: (NSInteger)index;
 - (void)DPSclear;
-- (void)DPScopy: (int)n;
-- (void)DPScount: (int *)n;
+- (void)DPScopy: (NSInteger)n;
+- (void)DPScount: (NSInteger *)n;
 - (void)DPSdup;
 - (void)DPSexch;
-- (void)DPSindex: (int)i;
+- (void)DPSindex: (NSInteger)i;
 - (void)DPSpop;
 @end
 
@@ -154,18 +154,18 @@ static NSMapTable *gtable;
     }
 }
 
-+ (void) insertObject: (id)obj forKey: (int)index
++ (void) insertObject: (id)obj forKey: (NSInteger)index
 {
   NSMapInsert(gtable, (void *)(uintptr_t)index, obj);
 }
 
 
-+ (id) getObjectForKey: (int)index
++ (id) getObjectForKey: (NSInteger)index
 {
   return NSMapGet(gtable, (void *)(uintptr_t)index);
 }
 
-+ (void) removeObjectForKey: (int)index
++ (void) removeObjectForKey: (NSInteger)index
 {
   NSMapRemove(gtable, (void *)(uintptr_t)index);
 }
@@ -432,17 +432,17 @@ static NSMapTable *gtable;
   [gstate GSSetTextPosition: loc];
 }
 
-- (void) GSShowText: (const char *)string : (size_t) length
+- (void) GSShowText: (const char *)string : (NSUInteger) length
 {
   [gstate GSShowText: string : length];
 }
 
-- (void) GSShowGlyphs: (const NSGlyph *)glyphs : (size_t) length
+- (void) GSShowGlyphs: (const NSGlyph *)glyphs : (NSUInteger) length
 {
   [gstate GSShowGlyphs: glyphs : length];
 }
 
-- (void) GSShowGlyphsWithAdvances: (const NSGlyph *)glyphs : (const NSSize *)advances : (size_t) length
+- (void) GSShowGlyphsWithAdvances: (const NSGlyph *)glyphs : (const NSSize *)advances : (NSUInteger) length
 {
   [gstate GSShowGlyphsWithAdvances: glyphs : advances : length];
 }
@@ -1019,10 +1019,10 @@ static NSMapTable *gtable;
   GSIArrayInitWithZoneAndCapacity((GSIArray)opstack, [self zone], 2);
 }
 
-- (void)DPScopy: (int)n 
+- (void)DPScopy: (NSInteger)n 
 {
-  unsigned count = GSIArrayCount((GSIArray)opstack);
-  int i;
+  NSUInteger count = GSIArrayCount((GSIArray)opstack);
+  NSUInteger i;
 
   for (i = 0; i < n; i++)
     {
@@ -1032,7 +1032,7 @@ static NSMapTable *gtable;
     }
 }
 
-- (void)DPScount: (int *)n 
+- (void)DPScount: (NSInteger *)n 
 {
   CHECK_NULL_OUTPUT(n);
   *n = GSIArrayCount((GSIArray)opstack);
@@ -1047,7 +1047,7 @@ static NSMapTable *gtable;
 
 - (void)DPSexch 
 {
-  unsigned count = GSIArrayCount((GSIArray)opstack);
+  NSUInteger count = GSIArrayCount((GSIArray)opstack);
 
   if (count < 2)
     {
@@ -1061,7 +1061,7 @@ static NSMapTable *gtable;
 
 - (void)DPSindex: (int)i 
 {
-  unsigned count = GSIArrayCount((GSIArray)opstack);
+  NSUInteger count = GSIArrayCount((GSIArray)opstack);
   NSObject *obj = (GSIArrayItemAtIndex((GSIArray)opstack, count - i)).obj;
 
   ctxt_push(obj, opstack);
diff --git a/Source/gsc/GSGState.m b/Source/gsc/GSGState.m
index 7d2f08a..0eb88a8 100644
--- a/Source/gsc/GSGState.m
+++ b/Source/gsc/GSGState.m
@@ -411,7 +411,7 @@ typedef enum {
 {
   NSPoint point = [path currentPoint];
   unichar *uch;
-  unsigned int ulen;
+  NSUInteger ulen;
   int i;
 
   /* 
@@ -643,12 +643,12 @@ typedef enum {
   [textCtm translateToPoint: loc];
 }
 
-- (void) GSShowText: (const char *)string : (size_t) length
+- (void) GSShowText: (const char *)string : (NSUInteger) length
 {
   [self subclassResponsibility: _cmd];
 }
 
-- (void) GSShowGlyphs: (const NSGlyph *)glyphs : (size_t) length
+- (void) GSShowGlyphs: (const NSGlyph *)glyphs : (NSUInteger) length
 {
   int i;
   NSSize advances[length];
@@ -661,7 +661,7 @@ typedef enum {
   [self GSShowGlyphsWithAdvances: glyphs : advances : length];
 }
 
-- (void) GSShowGlyphsWithAdvances: (const NSGlyph *)glyphs : (const NSSize *)advances : (size_t) length
+- (void) GSShowGlyphsWithAdvances: (const NSGlyph *)glyphs : (const NSSize *)advances : (NSUInteger) length
 {
   [self subclassResponsibility: _cmd];
 }
diff --git a/Source/gsc/GSStreamContext.m b/Source/gsc/GSStreamContext.m
index eb1cc1e..4568e92 100644
--- a/Source/gsc/GSStreamContext.m
+++ b/Source/gsc/GSStreamContext.m
@@ -283,14 +283,14 @@ fpfloat(FILE *stream, float f)
   [self notImplemented: _cmd];
 }
 
-- (void) GSShowText: (const char *)string : (size_t)length
+- (void) GSShowText: (const char *)string : (NSUInteger)length
 {
   fprintf(gstream, "(");
   [self output:string length: length];
   fprintf(gstream, ") show\n");
 }
 
-- (void) GSShowGlyphs: (const NSGlyph *)glyphs : (size_t)length
+- (void) GSShowGlyphs: (const NSGlyph *)glyphs : (NSUInteger)length
 {
   GSFontInfo *font = gstate->font;
   if ([font respondsToSelector: @selector(nameOfGlyph:)])
@@ -321,7 +321,7 @@ fpfloat(FILE *stream, float f)
 
 - (void) GSShowGlyphsWithAdvances: (const NSGlyph *)glyphs
                                  : (const NSSize *)advances
-                                 : (size_t)length
+                                 : (NSUInteger)length
 {
   // FIXME: Currently advances is ignored
   [self GSShowGlyphs: glyphs : length];
@@ -873,10 +873,10 @@ fpfloat(FILE *stream, float f)
 
 
 static void
-writeHex(FILE *gstream, const unsigned char *data, int count)
+writeHex(FILE *gstream, const unsigned char *data, NSInteger count)
 {
-static const char *hexdigits = "0123456789abcdef";
-  int i;
+  static const char *hexdigits = "0123456789abcdef";
+  NSInteger i;
   for (i = 0; i < count; i++)
     {
       fputc(hexdigits[(int)(data[i] / 16)], gstream);
diff --git a/Source/gsc/gscolors.c b/Source/gsc/gscolors.c
index 24f4bbd..46e86f0 100644
--- a/Source/gsc/gscolors.c
+++ b/Source/gsc/gscolors.c
@@ -41,14 +41,14 @@ gsMakeColor(device_color_t *dst, device_colorspace_t space, float a, float b, fl
   dst->field[3] = d;
 }
 
-void
+static void
 gsGrayToRGB(device_color_t  *color)
 {
   gsMakeColor(color, rgb_colorspace, color->field[0], color->field[0],
 	      color->field[0], 0);
 }
 
-void
+static void
 gsHSBToRGB(device_color_t  *color)
 {
   int i;
@@ -111,7 +111,7 @@ gsHSBToRGB(device_color_t  *color)
 }
 
 /* FIXME */   
-void
+static void
 gsCMYKToRGB(device_color_t  *color)
 {
   float c, m, y, k;
diff --git a/Source/win32/WIN32Server.m b/Source/win32/WIN32Server.m
index f9b48e5..471c012 100644
--- a/Source/win32/WIN32Server.m
+++ b/Source/win32/WIN32Server.m
@@ -236,7 +236,7 @@ BOOL CALLBACK LoadDisplayMonitorInfo(HMONITOR hMonitor,
 }
 
 
-- (NSEvent*) getEventMatchingMask: (unsigned)mask
+- (NSEvent*) getEventMatchingMask: (NSUInteger)mask
                        beforeDate: (NSDate*)limit
                            inMode: (NSString*)mode
                           dequeue: (BOOL)flag
@@ -248,7 +248,7 @@ BOOL CALLBACK LoadDisplayMonitorInfo(HMONITOR hMonitor,
                 dequeue: flag];
 }
 
-- (void) discardEventsMatchingMask: (unsigned)mask
+- (void) discardEventsMatchingMask: (NSUInteger)mask
                        beforeEvent: (NSEvent*)limit
 {
 //  [self callback: nil];
@@ -395,7 +395,7 @@ BOOL CALLBACK LoadDisplayMonitorInfo(HMONITOR hMonitor,
   [super dealloc];
 }
 
-- (void) restrictWindow: (int)win toImage: (NSImage*)image
+- (void) restrictWindow: (NSInteger)win toImage: (NSImage*)image
 {
   //TODO [self subclassResponsibility: _cmd];
 }
@@ -412,7 +412,7 @@ LRESULT CALLBACK windowEnumCallback(HWND hwnd, LPARAM lParam)
 		  
           if (PtInRect(&r,findWindowAtPoint) && IsWindowVisible(hwnd))
             {
-				NSWindow *window = GSWindowWithNumber((int)hwnd);
+				NSWindow *window = GSWindowWithNumber(hwnd);
 				if (![window ignoresMouseEvents])
 					foundWindowHwnd = hwnd;
             }
@@ -420,9 +420,9 @@ LRESULT CALLBACK windowEnumCallback(HWND hwnd, LPARAM lParam)
 	return true;
 }
 
-- (int) findWindowAt: (NSPoint)screenLocation 
-           windowRef: (int*)windowRef 
-           excluding: (int)win
+- (NSInteger) findWindowAt: (NSPoint)screenLocation 
+                 windowRef: (NSInteger*)windowRef 
+                 excluding: (NSInteger)win
 {
   HWND hwnd;
   POINT p;
@@ -443,16 +443,16 @@ LRESULT CALLBACK windowEnumCallback(HWND hwnd, LPARAM lParam)
 	EnumWindows((WNDENUMPROC)windowEnumCallback, win);
 	hwnd = foundWindowHwnd;
 
-  *windowRef = (int)hwnd;	// Any windows
+  *windowRef = (NSInteger)hwnd;	// Any windows
 
-  return (int)hwnd;
+  return (NSInteger)hwnd;
 }
 
 // FIXME: The following methods wont work for multiple screens.
 // However, GetDeviceCaps docs say that on a system with multiple screens,
 // LOGPIXELSX/Y will be the same for all screens, so the following is OK.
 /* Screen information */
-- (NSSize) resolutionForScreen: (int)screen
+- (NSSize) resolutionForScreen: (NSInteger)screen
 {
   int windowsXRes, windowsYRes;
   NSSize gnustepRes;
@@ -470,7 +470,7 @@ LRESULT CALLBACK windowEnumCallback(HWND hwnd, LPARAM lParam)
   return gnustepRes;
 }
 
-- (NSRect) boundsForScreen: (int)screen
+- (NSRect) boundsForScreen: (NSInteger)screen
 {
   if (screen < [monitorInfo count])
     {
@@ -479,7 +479,7 @@ LRESULT CALLBACK windowEnumCallback(HWND hwnd, LPARAM lParam)
   return NSZeroRect;
 }
 
-- (NSWindowDepth) windowDepthForScreen: (int)screen
+- (NSWindowDepth) windowDepthForScreen: (NSInteger)screen
 {
   HDC hdc  = 0;
   int bits = 0;
@@ -504,7 +504,7 @@ LRESULT CALLBACK windowEnumCallback(HWND hwnd, LPARAM lParam)
   return (_GSRGBBitValue | bits);
 }
 
-- (const NSWindowDepth *) availableDepthsForScreen: (int)screen
+- (const NSWindowDepth *) availableDepthsForScreen: (NSInteger)screen
 {
   int		 ndepths = 1;
   NSZone	*defaultZone = NSDefaultMallocZone();
@@ -537,7 +537,7 @@ LRESULT CALLBACK windowEnumCallback(HWND hwnd, LPARAM lParam)
 
 /**
    As the number of the window is actually is handle we return this.  */
-- (void *) windowDevice: (int)win
+- (void *) windowDevice: (NSInteger)win
 {
   return (void *)win;
 }
@@ -560,7 +560,7 @@ LRESULT CALLBACK windowEnumCallback(HWND hwnd, LPARAM lParam)
 
   NSMenu(style) =  NSTitledWindowMask | NSClosableWindowMask =3;
 */
-- (DWORD) windowStyleForGSStyle: (unsigned int) style
+- (DWORD) windowStyleForGSStyle: (NSUInteger) style
 {
   DWORD wstyle = 0;
         
@@ -597,7 +597,7 @@ LRESULT CALLBACK windowEnumCallback(HWND hwnd, LPARAM lParam)
    return wstyle | WS_CLIPCHILDREN;
 }
 
-- (DWORD) exwindowStyleForGSStyle: (unsigned int) style
+- (DWORD) exwindowStyleForGSStyle: (NSUInteger) style
 {
   DWORD estyle = 0;
 
@@ -1031,9 +1031,9 @@ LRESULT CALLBACK windowEnumCallback(HWND hwnd, LPARAM lParam)
   GetKeyboardState(keyState);
   
   // key events should go to the key window if we have one (Windows' focus window isn't always appropriate)
-  int windowNumber = [[NSApp keyWindow] windowNumber];
+  NSInteger windowNumber = [[NSApp keyWindow] windowNumber];
   if (windowNumber == 0)
-    windowNumber = (int)hwnd;
+    windowNumber = (NSInteger)hwnd;
   
   /* FIXME: How do you guarentee a context is associated with an event? */
   NSGraphicsContext *gcontext      = GSCurrentContext();
@@ -1485,8 +1485,8 @@ LRESULT CALLBACK windowEnumCallback(HWND hwnd, LPARAM lParam)
 
 */
 
-- (int) window: (NSRect)frame : (NSBackingStoreType)type : (unsigned int)style
-              : (int) screen
+- (NSInteger) window: (NSRect)frame : (NSBackingStoreType)type : (NSUInteger)style
+                    : (NSInteger) screen
 {
   HWND hwnd; 
   RECT r;
@@ -1550,12 +1550,12 @@ LRESULT CALLBACK windowEnumCallback(HWND hwnd, LPARAM lParam)
 
       SetLayeredWindowAttributes(hwnd, 0, 255, LWA_ALPHA);
 
-      [self _setWindowOwnedByServer: (int)hwnd];
+      [self _setWindowOwnedByServer: (NSInteger)hwnd];
     }
-  return (int)hwnd;
+  return (NSInteger)hwnd;
 }
 
-- (void) termwindow: (int) winNum
+- (void) termwindow: (NSInteger) winNum
 {
   NSDebugLLog(@"WCTrace", @"termwindow: %d", winNum);
   if (!DestroyWindow((HWND)winNum)) {
@@ -1563,7 +1563,7 @@ LRESULT CALLBACK windowEnumCallback(HWND hwnd, LPARAM lParam)
   }
 }
 
-- (void) stylewindow: (unsigned int)style : (int) winNum
+- (void) stylewindow: (NSUInteger)style : (NSInteger) winNum
 {
   DWORD wstyle = [self windowStyleForGSStyle: style];
   DWORD estyle = [self exwindowStyleForGSStyle: style];
@@ -1576,12 +1576,12 @@ LRESULT CALLBACK windowEnumCallback(HWND hwnd, LPARAM lParam)
   SetWindowLong((HWND)winNum, GWL_EXSTYLE, estyle);
 }
 
-- (void) setbackgroundcolor: (NSColor *)color : (int)win
+- (void) setbackgroundcolor: (NSColor *)color : (NSInteger)win
 {
 }
 
 /** Changes window's the backing store to type */
-- (void) windowbacking: (NSBackingStoreType)type : (int) winNum
+- (void) windowbacking: (NSBackingStoreType)type : (NSInteger) winNum
 {
   WIN_INTERN *win = (WIN_INTERN *)GetWindowLong((HWND)winNum, GWL_USERDATA);
 
@@ -1627,14 +1627,14 @@ LRESULT CALLBACK windowEnumCallback(HWND hwnd, LPARAM lParam)
   win->type = type;
 }
 
-- (void) titlewindow: (NSString*)window_title : (int) winNum
+- (void) titlewindow: (NSString*)window_title : (NSInteger) winNum
 {
   NSDebugLLog(@"WTrace", @"titlewindow: %@ : %d", window_title, winNum);
   SetWindowTextW((HWND)winNum, (const unichar*)
     [window_title cStringUsingEncoding: NSUnicodeStringEncoding]);
 }
 
-- (void) miniwindow: (int) winNum
+- (void) miniwindow: (NSInteger) winNum
 {
   NSDebugLLog(@"WTrace", @"miniwindow: %d", winNum);
   ShowWindow((HWND)winNum, SW_MINIMIZE);
@@ -1646,7 +1646,7 @@ LRESULT CALLBACK windowEnumCallback(HWND hwnd, LPARAM lParam)
   return NO;
 }
 
-- (void) setWindowdevice: (int)winNum forContext: (NSGraphicsContext *)ctxt
+- (void) setWindowdevice: (NSInteger)winNum forContext: (NSGraphicsContext *)ctxt
 {
   RECT rect;
   float h, l, r, t, b;
@@ -1662,7 +1662,7 @@ LRESULT CALLBACK windowEnumCallback(HWND hwnd, LPARAM lParam)
   DPSinitclip(ctxt);
 }
 
-- (void) orderwindow: (int) op : (int) otherWin : (int) winNum
+- (void) orderwindow: (NSInteger) op : (NSInteger) otherWin : (NSInteger) winNum
 {
   int		flag = 0;
   int		foreground = 0;
@@ -1891,7 +1891,7 @@ LRESULT CALLBACK windowEnumCallback(HWND hwnd, LPARAM lParam)
     }
 }
 
-- (void) movewindow: (NSPoint)loc : (int)winNum
+- (void) movewindow: (NSPoint)loc : (NSInteger)winNum
 {
   POINT p;
 
@@ -1903,7 +1903,7 @@ LRESULT CALLBACK windowEnumCallback(HWND hwnd, LPARAM lParam)
                SWP_NOZORDER | SWP_NOSIZE | SWP_NOACTIVATE | SWP_NOSENDCHANGING);
 }
 
-- (void) placewindow: (NSRect)frame : (int) winNum
+- (void) placewindow: (NSRect)frame : (NSInteger) winNum
 {
   RECT r;
   RECT r2;
@@ -1946,13 +1946,13 @@ LRESULT CALLBACK windowEnumCallback(HWND hwnd, LPARAM lParam)
 #endif
 }
 
-- (BOOL) findwindow: (NSPoint)loc : (int) op : (int) otherWin 
-		   : (NSPoint *)floc : (int*) winFound
+- (BOOL) findwindow: (NSPoint)loc : (NSInteger)op : (NSInteger)otherWin 
+		   : (NSPoint *)floc : (NSInteger *)winFound
 {
   return NO;
 }
 
-- (NSRect) windowbounds: (int) winNum
+- (NSRect) windowbounds: (NSInteger) winNum
 {
   RECT r;
 
@@ -1960,7 +1960,7 @@ LRESULT CALLBACK windowEnumCallback(HWND hwnd, LPARAM lParam)
   return MSScreenRectToGS(r);
 }
 
-- (void) setwindowlevel: (int) level : (int) winNum
+- (void) setwindowlevel: (NSInteger) level : (NSInteger) winNum
 {
   NSDebugLLog(@"WTrace", @"setwindowlevel: %d : %d", level, winNum);
   if (GetWindowLong((HWND)winNum, OFF_LEVEL) != level)
@@ -1973,7 +1973,7 @@ LRESULT CALLBACK windowEnumCallback(HWND hwnd, LPARAM lParam)
     }
 }
 
-- (int) windowlevel: (int) winNum
+- (NSInteger) windowlevel: (NSInteger) winNum
 {
   return GetWindowLong((HWND)winNum, OFF_LEVEL);
 }
@@ -2005,9 +2005,9 @@ LRESULT CALLBACK windowEnumCallback(HWND hwnd, LPARAM lParam)
       /* Only add windows we own.
        * FIXME We should improve the API to support all windows on server.
        */
-      if (GSWindowWithNumber((int)w) != nil)
+      if (GSWindowWithNumber(w) != nil)
 	{
-	  [list addObject: [NSNumber numberWithInt: (int)w]];
+	  [list addObject: [NSNumber numberWithInteger: (NSInteger)w]];
 	}
       w = GetNextWindow(w, GW_HWNDNEXT);
     }
@@ -2015,13 +2015,13 @@ LRESULT CALLBACK windowEnumCallback(HWND hwnd, LPARAM lParam)
   return list;
 }
 
-- (int) windowdepth: (int) winNum
+- (NSInteger) windowdepth: (NSInteger) winNum
 {
   return 0;
 }
 
 /** Set the maximum size of the window */
-- (void) setmaxsize: (NSSize)size : (int) winNum
+- (void) setmaxsize: (NSSize)size : (NSInteger) winNum
 {
   WIN_INTERN *win = (WIN_INTERN *)GetWindowLong((HWND)winNum, GWL_USERDATA);
   POINT p;
@@ -2044,7 +2044,7 @@ LRESULT CALLBACK windowEnumCallback(HWND hwnd, LPARAM lParam)
 }
 
 /** Set the minimum size of the window */
-- (void) setminsize: (NSSize)size : (int) winNum
+- (void) setminsize: (NSSize)size : (NSInteger) winNum
 {
   WIN_INTERN *win = (WIN_INTERN *)GetWindowLong((HWND)winNum, GWL_USERDATA);
   POINT p;
@@ -2055,11 +2055,11 @@ LRESULT CALLBACK windowEnumCallback(HWND hwnd, LPARAM lParam)
 }
 
 /** Set the resize incremenet of the window */
-- (void) setresizeincrements: (NSSize)size : (int) winNum
+- (void) setresizeincrements: (NSSize)size : (NSInteger) winNum
 {
 }
 /** Causes buffered graphics to be flushed to the screen */
-- (void) flushwindowrect: (NSRect)rect : (int)winNum
+- (void) flushwindowrect: (NSRect)rect : (NSInteger)winNum
 {
   HWND hwnd = (HWND)winNum;
   WIN_INTERN *win = (WIN_INTERN *)GetWindowLong(hwnd, GWL_USERDATA);
@@ -2099,8 +2099,8 @@ LRESULT CALLBACK windowEnumCallback(HWND hwnd, LPARAM lParam)
     }
 }
 
-- (void) styleoffsets: (float *) l : (float *) r : (float *) t : (float *) b
-		     : (unsigned int) style 
+- (void) styleoffsets: (CGFloat *) l : (CGFloat *) r : (CGFloat *) t : (CGFloat *) b
+		     : (NSUInteger) style 
 {
   if ([self handlesWindowDecorations])
     {
@@ -2127,11 +2127,11 @@ LRESULT CALLBACK windowEnumCallback(HWND hwnd, LPARAM lParam)
     }
 }
 
-- (void) docedited: (int) edited : (int) winNum
+- (void) docedited: (NSInteger) edited : (NSInteger) winNum
 {
 }
 
-- (void) setinputstate: (int)state : (int)winNum
+- (void) setinputstate: (NSInteger)state : (NSInteger)winNum
 {
   if ([self handlesWindowDecorations] == NO)
     {
@@ -2147,7 +2147,7 @@ LRESULT CALLBACK windowEnumCallback(HWND hwnd, LPARAM lParam)
 
 /** Forces focus to the window so that all key events are sent to this
     window */
-- (void) setinputfocus: (int) winNum
+- (void) setinputfocus: (NSInteger) winNum
 {
   NSDebugLLog(@"WTrace", @"setinputfocus: %d", winNum);
   NSDebugLLog(@"Focus", @"Setting input focus to %d", winNum);
@@ -2165,7 +2165,7 @@ LRESULT CALLBACK windowEnumCallback(HWND hwnd, LPARAM lParam)
   SetFocus((HWND)winNum);
 }
 
-- (void) setalpha: (float)alpha: (int) win
+- (void) setalpha: (CGFloat)alpha: (NSInteger) win
 {
   if (alpha > 0.99)
     {
@@ -2201,12 +2201,12 @@ LRESULT CALLBACK windowEnumCallback(HWND hwnd, LPARAM lParam)
   return MSScreenPointToGS(p.x, p.y);
 }
 
-- (NSPoint) mouseLocationOnScreen: (int)screen window: (int *)win
+- (NSPoint) mouseLocationOnScreen: (NSInteger)screen window: (NSInteger *)win
 {
   return [self mouselocation];
 }
 
-- (BOOL) capturemouse: (int) winNum
+- (BOOL) capturemouse: (NSInteger) winNum
 {
   NSDebugLLog(@"WTrace", @"capturemouse: %d", winNum);
   SetCapture((HWND)winNum);
@@ -2230,7 +2230,7 @@ LRESULT CALLBACK windowEnumCallback(HWND hwnd, LPARAM lParam)
   ShowCursor(YES);
 }
 
-- (void) standardcursor: (int)style : (void **)cid
+- (void) standardcursor: (NSInteger)style : (void **)cid
 {
   HCURSOR hCursor = 0;
 
@@ -2301,8 +2301,8 @@ LRESULT CALLBACK windowEnumCallback(HWND hwnd, LPARAM lParam)
   //DestroyCursor((HCURSOR)cid);
 }
 
-- (void) setParentWindow: (int)parentWin 
-          forChildWindow: (int)childWin
+- (void) setParentWindow: (NSInteger)parentWin 
+          forChildWindow: (NSInteger)childWin
 {
   //SetParent((HWND)childWin, (HWND)parentWin);
 }
@@ -2546,9 +2546,9 @@ process_key_event(WIN32Server *svr, HWND hwnd, WPARAM wParam, LPARAM lParam, NSE
     ukeys = [ukeys uppercaseString];
   
   // key events should go to the key window if we have one (Windows' focus window isn't always appropriate)
-  int windowNumber = [[NSApp keyWindow] windowNumber];
+  NSInteger windowNumber = [[NSApp keyWindow] windowNumber];
   if (windowNumber == 0)
-    windowNumber  = (int)hwnd;
+    windowNumber = (NSInteger)hwnd;
 	
   event = [NSEvent keyEventWithType: eventType
 			   location: eventLocation
@@ -2781,7 +2781,7 @@ process_mouse_event(WIN32Server *svr, HWND hwnd, WPARAM wParam, LPARAM lParam,
 			     location: eventLocation
 			modifierFlags: eventFlags
 			    timestamp: time
-			 windowNumber: (int)hwnd
+			 windowNumber: (NSInteger)hwnd
 			      context: gcontext
 			  eventNumber: tick
 			   clickCount: clickCount
diff --git a/Source/winlib/WIN32GState.m b/Source/winlib/WIN32GState.m
index d686d7d..7ac965d 100644
--- a/Source/winlib/WIN32GState.m
+++ b/Source/winlib/WIN32GState.m
@@ -1219,7 +1219,7 @@ HBITMAP GSCreateBitmap(HDC hDC, NSInteger pixelsWide, NSInteger pixelsHigh,
 }
 
 
-- (void) GSShowGlyphsWithAdvances: (const NSGlyph *)glyphs : (const NSSize *)advances : (size_t) length
+- (void) GSShowGlyphsWithAdvances: (const NSGlyph *)glyphs : (const NSSize *)advances : (NSUInteger) length
 {
   // FIXME: Currently advances is ignored
   NSPoint current = [path currentPoint];
diff --git a/Source/x11/XGDragView.m b/Source/x11/XGDragView.m
index 4854c92..e98a9e6 100644
--- a/Source/x11/XGDragView.m
+++ b/Source/x11/XGDragView.m
@@ -92,7 +92,7 @@ DndClass xdnd (void)
 
 
 Atom 
-GSActionForDragOperation(unsigned int op)
+GSActionForDragOperation(NSDragOperation op)
 {
   Atom xaction;
 
@@ -140,9 +140,9 @@ static inline
 Atom *
 mimeTypeForPasteboardType(Display *xDisplay, NSZone *zone, NSArray *types)
 {
-  Atom	*typelist;
-  int	count = [types count];
-  int	i;
+  Atom *typelist;
+  NSUInteger count = [types count];
+  NSUInteger i;
 
   typelist = NSZoneMalloc(zone, (count+1) * sizeof(Atom));
   for (i = 0; i < count; i++)
@@ -266,7 +266,7 @@ static	XGDragView	*sharedDragView = nil;
                     action: (NSDragOperation)action
                   position: (NSPoint)eventLocation
                  timestamp: (NSTimeInterval)time
-                  toWindow: (int)dWindowNumber
+                  toWindow: (NSInteger)dWindowNumber
 {
   switch (subtype)
     {
@@ -307,7 +307,7 @@ static	XGDragView	*sharedDragView = nil;
 
 
 - (NSWindow*) windowAcceptingDnDunder: (NSPoint)p
-			    windowRef: (int*)mouseWindowRef
+			    windowRef: (NSInteger *)mouseWindowRef
 {
   gswindow_device_t	*dwindev;
 
@@ -412,7 +412,7 @@ static	XGDragView	*sharedDragView = nil;
 
 - (void) _resetDragTypesForWindow: (NSWindow *)win
 {
-  int			winNum;
+  NSInteger             winNum;
   Atom			*typelist;
   gswindow_device_t	*window;
   NSCountedSet		*drag_set = [self dragTypesForWindow: win];
@@ -433,8 +433,8 @@ static	XGDragView	*sharedDragView = nil;
 
 - (BOOL) addDragTypes: (NSArray*)types toWindow: (NSWindow *)win
 {
-  BOOL	did_add;
-  int	winNum;
+  BOOL did_add;
+  NSInteger winNum;
 
   did_add = [super addDragTypes: types toWindow: win];
   /* Check if window device exists */
@@ -448,8 +448,8 @@ static	XGDragView	*sharedDragView = nil;
 
 - (BOOL) removeDragTypes: (NSArray*)types fromWindow: (NSWindow *)win
 {
-  BOOL	did_change;
-  int	winNum;
+  BOOL did_change;
+  NSInteger winNum;
 
   did_change = [super removeDragTypes: types fromWindow: win];
   /* Check if window device exists. */
diff --git a/Source/x11/XGServer.m b/Source/x11/XGServer.m
index 6d3987d..636cc4d 100644
--- a/Source/x11/XGServer.m
+++ b/Source/x11/XGServer.m
@@ -75,7 +75,7 @@ terminate(int sig)
 extern int XGErrorHandler(Display *display, XErrorEvent *err);
 
 static NSString *
-_parse_display_name(NSString *name, int *dn, int *sn)
+_parse_display_name(NSString *name, NSInteger *dn, NSInteger *sn)
 {
   int d, s;
   NSString *host;
@@ -136,7 +136,7 @@ _parse_display_name(NSString *name, int *dn, int *sn)
   XGDrawMechanism drawMechanism;
 }
 
-- initForDisplay: (Display *)dpy screen: (int)screen_number;
+- initForDisplay: (Display *)dpy screen: (NSInteger)screenNumber;
 - (XGDrawMechanism) drawMechanism;
 - (RContext *) context;
 @end
@@ -145,7 +145,7 @@ _parse_display_name(NSString *name, int *dn, int *sn)
 
 - (RContextAttributes *) _getXDefaults
 {
-  int dummy;
+  NSInteger dummy;
   RContextAttributes *attribs;
 
   NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];
@@ -168,7 +168,7 @@ _parse_display_name(NSString *name, int *dn, int *sn)
   return attribs;
 }
 
-- initForDisplay: (Display *)dpy screen: (int)screen_number
+- initForDisplay: (Display *)dpy screen: (NSInteger)screenNumber
 {
   RContextAttributes *attribs;
   XColor testColor;
@@ -177,7 +177,7 @@ _parse_display_name(NSString *name, int *dn, int *sn)
    /* Get the visual information */
   attribs = NULL;
   //attribs = [self _getXDefaults];
-  rcontext = RCreateContext(dpy, screen_number, attribs);
+  rcontext = RCreateContext(dpy, screenNumber, attribs);
 
   /*
    * If we have shared memory available, only use it when the XGPS-Shm
@@ -285,8 +285,8 @@ _parse_display_name(NSString *name, int *dn, int *sn)
         @"to work ... and submit a patch.");
       drawMechanism = XGDM_PORTABLE;
     }
-  NSDebugLLog(@"XGTrace", @"Draw mech %d for screen %d", drawMechanism,
-        screen_number);
+  NSDebugLLog(@"XGTrace", @"Draw mech %d for screen %ld", drawMechanism,
+        (long)screenNumber);
   return self;
 }
 
@@ -379,11 +379,11 @@ _parse_display_name(NSString *name, int *dn, int *sn)
 
 - (id) _initXContext
 {
-  int screen_number, display_number;
-  NSString *display_name;
+  NSInteger screenNumber, displayNumber;
+  NSString *displayName;
 
-  display_name = [server_info objectForKey: GSDisplayName];
-  if (display_name == nil)
+  displayName = [server_info objectForKey: GSDisplayName];
+  if (displayName == nil)
     {
       NSString *host = [[NSUserDefaults standardUserDefaults]
                            stringForKey: @"NSHost"];
@@ -398,7 +398,7 @@ _parse_display_name(NSString *name, int *dn, int *sn)
             sn = @"0";
           if (host == nil)
             host = @"";
-          display_name = [NSString stringWithFormat: @"%@:%@.%@", host, dn,sn];
+          displayName = [NSString stringWithFormat: @"%@:%@.%@", host, dn,sn];
         }
       else if ((host != nil) && ([host isEqual: @""] == NO))
         {
@@ -407,35 +407,35 @@ _parse_display_name(NSString *name, int *dn, int *sn)
            * to generate a display name for X from the host name and the
            * default display and screen numbers (zero).
            */
-          display_name = [NSString stringWithFormat: @"%@:0.0", host];
+          displayName = [NSString stringWithFormat: @"%@:0.0", host];
         }
     }
 
-  if (display_name)
+  if (displayName)
     {
-      dpy = XOpenDisplay([display_name cString]);
+      dpy = XOpenDisplay([displayName cString]);
     }
   else
     { 
       dpy = XOpenDisplay(NULL);
-      display_name = [NSString stringWithCString: XDisplayName(NULL)];
+      displayName = [NSString stringWithCString: XDisplayName(NULL)];
     }
 
   if (dpy == NULL)
     {
-      char *dname = XDisplayName([display_name cString]);
+      char *dname = XDisplayName([displayName cString]);
       [NSException raise: NSWindowServerCommunicationException
                   format: @"Unable to connect to X Server `%s'", dname];
     }
 
   /* Parse display information */
-  _parse_display_name(display_name, &display_number, &screen_number);
-  NSDebugLog(@"Opened display %@, display %d screen %d", 
-             display_name, display_number, screen_number);
-  [server_info setObject: display_name forKey: GSDisplayName];
-  [server_info setObject: [NSNumber numberWithInt: display_number]
+  _parse_display_name(displayName, &displayNumber, &screenNumber);
+  NSDebugLog(@"Opened display %@, display %ld screen %ld", 
+             displayName, (long)displayNumber, (long)screenNumber);
+  [server_info setObject: displayName forKey: GSDisplayName];
+  [server_info setObject: [NSNumber numberWithInteger: displayNumber]
                   forKey: GSDisplayNumber];
-  [server_info setObject: [NSNumber numberWithInt: screen_number] 
+  [server_info setObject: [NSNumber numberWithInteger: screenNumber] 
                   forKey: GSScreenNumber];
 
   /* Setup screen*/
@@ -443,7 +443,7 @@ _parse_display_name(NSString *name, int *dn, int *sn)
     screenList = NSCreateMapTable(NSIntMapKeyCallBacks,
                                  NSObjectMapValueCallBacks, 20);
 
-  defScreen = screen_number;
+  defScreen = screenNumber;
 
   XSetErrorHandler(XGErrorHandler);
 
@@ -502,23 +502,23 @@ _parse_display_name(NSString *name, int *dn, int *sn)
   return dpy;
 }
 
-- (XGScreenContext *) _screenContextForScreen: (int)screen_number
+- (XGScreenContext *) _screenContextForScreen: (NSInteger)screenNumber
 {
   int count = ScreenCount(dpy);
   XGScreenContext *screen;
 
-  if (screen_number >= count)
+  if (screenNumber >= count)
     {
       [NSException raise: NSInvalidArgumentException
                    format: @"Request for invalid screen"];
     }
 
-  screen = NSMapGet(screenList, (void *)(uintptr_t)screen_number);
+  screen = NSMapGet(screenList, (void *)(uintptr_t)screenNumber);
   if (screen == NULL)
     {
       screen = [[XGScreenContext alloc] 
-                   initForDisplay: dpy screen: screen_number];
-      NSMapInsert(screenList, (void *)(uintptr_t)screen_number, (void *)screen);
+                   initForDisplay: dpy screen: screenNumber];
+      NSMapInsert(screenList, (void *)(uintptr_t)screenNumber, (void *)screen);
       RELEASE(screen);
     }
 
@@ -529,19 +529,19 @@ _parse_display_name(NSString *name, int *dn, int *sn)
    Returns a pointer to a structure which describes aspects of the
    X windows display 
 */
-- (void *) xrContextForScreen: (int)screen_number
+- (void *) xrContextForScreen: (NSInteger)screenNumber
 {
-  return [[self _screenContextForScreen: screen_number] context];
+  return [[self _screenContextForScreen: screenNumber] context];
 }
 
-- (Visual *) visualForScreen: (int)screen_number
+- (Visual *) visualForScreen: (NSInteger)screenNumber
 {
-    return [[self _screenContextForScreen: screen_number] context]->visual;
+    return [[self _screenContextForScreen: screenNumber] context]->visual;
 }
 
-- (int) depthForScreen: (int)screen_number
+- (int) depthForScreen: (NSInteger)screenNumber
 {
-    return [[self _screenContextForScreen: screen_number] context]->depth;
+    return [[self _screenContextForScreen: screenNumber] context]->depth;
 }
 
 /**
@@ -549,13 +549,13 @@ _parse_display_name(NSString *name, int *dn, int *sn)
    the screen and how pixels should be drawn to the screen for maximum
    speed.
 */
-- (XGDrawMechanism) drawMechanismForScreen: (int)screen_number
+- (XGDrawMechanism) drawMechanismForScreen: (NSInteger)screenNumber
 {
- return [[self _screenContextForScreen: screen_number] drawMechanism];
+ return [[self _screenContextForScreen: screenNumber] drawMechanism];
 }
 
 // Could use NSSwapInt() instead
-static unsigned int flip_bytes32(unsigned int i)
+static uint32_t flip_bytes32(uint32_t i)
 {
   return ((i >> 24) & 0xff)
       |((i >>  8) & 0xff00)
@@ -563,12 +563,13 @@ static unsigned int flip_bytes32(unsigned int i)
       |((i << 24) & 0xff000000);
 }
 
-static unsigned int flip_bytes16(unsigned int i)
+static uint16_t flip_bytes16(uint16_t i)
 {
   return ((i >> 8) & 0xff)
       |((i <<  8) & 0xff00);
 }
 
+/* True iff we're big-endian */
 static int byte_order(void)
 {
   union
@@ -583,8 +584,8 @@ static int byte_order(void)
 /**
  * Used by the art backend to determine the drawing mechanism.
  */
-- (void) getForScreen: (int)screen_number pixelFormat: (int *)bpp_number 
-                masks: (int *)red_mask : (int *)green_mask : (int *)blue_mask
+- (void) getForScreen: (NSInteger)screenNumber pixelFormat: (NSInteger *)bpp_number 
+                masks: (NSUInteger *)red_mask : (NSUInteger *)green_mask : (NSUInteger *)blue_mask
 {
   Visual *visual;
   XImage *i;
@@ -621,7 +622,7 @@ static int byte_order(void)
   RContext *context;
 
   // Better to get the used visual from the context.
-  context = [self xrContextForScreen: screen_number];
+  context = [self xrContextForScreen: screenNumber];
   visual = context->visual;
   bpp = context->depth;
 #endif 
@@ -646,15 +647,15 @@ static int byte_order(void)
         {
           if ((bpp == 32) || (bpp == 24))
             {
-              *red_mask = flip_bytes32(*red_mask);
-              *green_mask = flip_bytes32(*green_mask);
-              *blue_mask = flip_bytes32(*blue_mask);
+              *red_mask = flip_bytes32((uint32_t)*red_mask);
+              *green_mask = flip_bytes32((uint32_t)*green_mask);
+              *blue_mask = flip_bytes32((uint32_t)*blue_mask);
             }
           else if (bpp == 16)
             {
-              *red_mask = flip_bytes16(*red_mask);
-              *green_mask = flip_bytes16(*green_mask);
-              *blue_mask = flip_bytes16(*blue_mask);
+              *red_mask = flip_bytes16((uint16_t)*red_mask);
+              *green_mask = flip_bytes16((uint16_t)*green_mask);
+              *blue_mask = flip_bytes16((uint16_t)*blue_mask);
             }
         }
     }
@@ -663,20 +664,20 @@ static int byte_order(void)
 /**
    Returns the root window of the display 
 */
-- (Window) xDisplayRootWindowForScreen: (int)screen_number;
+- (Window) xDisplayRootWindowForScreen: (NSInteger)screenNumber;
 {
-  return RootWindow(dpy, screen_number);
+  return RootWindow(dpy, screenNumber);
 }
 
 /**
    Returns the closest color in the current colormap to the indicated
    X color
 */
-- (XColor) xColorFromColor: (XColor)color forScreen: (int)screen_number
+- (XColor) xColorFromColor: (XColor)color forScreen: (NSInteger)screenNumber
 {
   Status ret;
   RColor rcolor;
-  RContext *context = [self xrContextForScreen: screen_number];
+  RContext *context = [self xrContextForScreen: screenNumber];
   XAllocColor(dpy, context->cmap, &color);
   rcolor.red   = color.red / 256;
   rcolor.green = color.green / 256;
diff --git a/Source/x11/XGServerEvent.m b/Source/x11/XGServerEvent.m
index e324569..93efe3e 100644
--- a/Source/x11/XGServerEvent.m
+++ b/Source/x11/XGServerEvent.m
@@ -91,6 +91,7 @@ static BOOL _mod_ignore_shift = NO;
 
 static BOOL next_event_is_a_keyrepeat;
 
+void __objc_xgcontextevent_linking (void);
 void __objc_xgcontextevent_linking (void)
 {
 }
@@ -120,6 +121,8 @@ static void (*procEvent)(id, SEL, XEvent*) = 0;
 @end
 
 
+extern int
+XGErrorHandler(Display *display, XErrorEvent *err);
 int
 XGErrorHandler(Display *display, XErrorEvent *err)
 {
@@ -158,8 +161,8 @@ static int check_modifier (XEvent *xEvent, KeySym key_sym)
 }
 
 @interface XGServer (WindowOps)
-- (void) styleoffsets: (float *) l : (float *) r : (float *) t : (float *) b
-                     : (unsigned int) style : (Window) win;
+- (void) styleoffsets: (CGFloat *) l : (CGFloat *) r : (CGFloat *) t : (CGFloat *) b
+                     : (NSUInteger) style : (Window) win;
 - (NSRect) _XWinRectToOSWinRect: (NSRect)r for: (void*)windowNumber;
 @end
 
@@ -316,15 +319,15 @@ posixFileDescriptor: (NSPosixFileDescriptor*)fileDescriptor
 - (NSPoint) _XPointToOSPoint: (NSPoint)x for: (void*)window
 {
   gswindow_device_t *win = (gswindow_device_t*)window;
-  unsigned int style = win->win_attrs.window_style;
+  unsigned long style = win->win_attrs.window_style;
   NSPoint o;
-  float t, b, l, r;
+  CGFloat t, b, l, r;
 
   [self styleoffsets: &l : &r : &t : &b : style : win->ident];
   o.x = x.x + l;
   o.y = NSHeight(win->xframe) - x.y + b;
 
-  NSDebugLLog(@"Frame", @"X2OP %lu, %x, %@, %@", win->number, style,
+  NSDebugLLog(@"Frame", @"X2OP %ld, %lx, %@, %@", (long)win->number, (long)style,
     NSStringFromPoint(x), NSStringFromPoint(o));
   return o;
 }
@@ -1431,7 +1434,7 @@ posixFileDescriptor: (NSPosixFileDescriptor*)fileDescriptor
 	      }
 	    if (cWin != 0)
 	      {
-		int new_state;
+		NSInteger new_state;
 
 		/* Get the new window state */
 		if (xEvent.xproperty.state == PropertyNewValue)
@@ -1760,13 +1763,13 @@ posixFileDescriptor: (NSPosixFileDescriptor*)fileDescriptor
 - (NSEvent *)_handleTakeFocusAtom: (XEvent)xEvent 
                        forContext: (NSGraphicsContext *)gcontext
 {
-  int key_num;
+  NSInteger key_num;
   NSWindow *key_win;
   NSEvent *e = nil;
   key_win = [NSApp keyWindow];
   key_num = [key_win windowNumber];
-  NSDebugLLog(@"Focus", @"take focus:%lu (current=%lu key=%d)",
-              cWin->number, generic.currentFocusWindow, key_num);
+  NSDebugLLog(@"Focus", @"take focus:%lu (current=%lu key=%ld)",
+              cWin->number, generic.currentFocusWindow, (long)key_num);
 
   /* Sometimes window managers lose the setinputfocus on the key window
    * e.g. when ordering out a window with focus then ordering in the key window.   
@@ -1811,7 +1814,7 @@ posixFileDescriptor: (NSPosixFileDescriptor*)fileDescriptor
          to become key, so it tells the main menu (typically the first
          menu in the list), but since we already have a window that
          was key before, use that instead */
-      NSDebugLLog(@"Focus", @"Key window is already %d", key_num);
+      NSDebugLLog(@"Focus", @"Key window is already %ld", (long)key_num);
       [GSServerForWindow(key_win) setinputfocus: key_num];
     }
   else
@@ -2496,7 +2499,7 @@ process_modifier_flags(unsigned int state)
   return [self mouseLocationOnScreen: defScreen window: NULL];
 }
 
-- (NSPoint) mouseLocationOnScreen: (int)screen window: (int *)win
+- (NSPoint) mouseLocationOnScreen: (NSInteger)screen window: (NSInteger *)win;
 {
   Window rootWin;
   Window childWin;
@@ -2508,7 +2511,7 @@ process_modifier_flags(unsigned int state)
   BOOL ok;
   NSPoint p;
   int height;
-  int screen_number;
+  NSInteger screen_number;
   
   screen_number = (screen >= 0) ? screen : defScreen;
   ok = XQueryPointer (dpy, [self xDisplayRootWindowForScreen: screen_number],
@@ -2548,7 +2551,7 @@ process_modifier_flags(unsigned int state)
   return p;
 }
 
-- (NSEvent*) getEventMatchingMask: (unsigned)mask
+- (NSEvent*) getEventMatchingMask: (NSUInteger)mask
                        beforeDate: (NSDate*)limit
                            inMode: (NSString*)mode
                           dequeue: (BOOL)flag
@@ -2560,7 +2563,7 @@ process_modifier_flags(unsigned int state)
                              dequeue: flag];
 }
 
-- (void) discardEventsMatchingMask: (unsigned)mask
+- (void) discardEventsMatchingMask: (NSUInteger)mask
                        beforeEvent: (NSEvent*)limit
 {
   [self receivedEvent: 0 type: 0 extra: 0 forMode: nil];
diff --git a/Source/x11/XGServerWindow.m b/Source/x11/XGServerWindow.m
index 45b25d7..f4e34b5 100644
--- a/Source/x11/XGServerWindow.m
+++ b/Source/x11/XGServerWindow.m
@@ -93,6 +93,11 @@ static NSMapTable *windowtags = NULL;
 /* Track used window numbers */
 static int		last_win_num = 0;
 
+#if !HAVE_XCURSOR
+static Pixmap
+xgps_cursor_image(Display *xdpy, Drawable draw, const unsigned char *data, 
+		  NSInteger w, NSInteger h, NSInteger colors, XColor *fg, XColor *bg);
+#endif
 
 @interface NSCursor (BackendPrivate)
 - (void *)_cid;
@@ -152,7 +157,7 @@ static NSBitmapImageRep *getStandardBitmap(NSImage *image)
     }
 }
 
-
+void __objc_xgcontextwindow_linking (void);
 void __objc_xgcontextwindow_linking (void)
 {
 }
@@ -162,14 +167,14 @@ void __objc_xgcontextwindow_linking (void)
  */
 static unsigned char*
 PropGetCheckProperty(Display *dpy, Window window, Atom hint, Atom type,
-		     int format, int count, int *retCount)
+		     NSInteger format, NSInteger count, NSUInteger *retCount)
 {
   Atom type_ret;
   int fmt_ret;
   unsigned long nitems_ret;
   unsigned long bytes_after_ret;
   unsigned char *data;
-  int tmp;
+  NSInteger tmp;
 
   if (count <= 0)
     tmp = 0xffffff;
@@ -219,7 +224,7 @@ setNormalHints(Display *d, gswindow_device_t *w)
       /* Some silly window managers (*cough* metacity *cough*) ignore
 	 our "non-resizable" hints unless we set the min and max
 	 sizes equal to the current size, hence the ugly code here.  */
-      CARD32 oldFlags;
+      long oldFlags;
       int old_w0, old_h0, old_w1, old_h1;
       
       old_w0 = w->siz_hints.min_width;
@@ -301,8 +306,7 @@ typedef struct {
  * window hints.  This makes an X call, please make sure you do it
  * only once.
  */
-static void setWindowHintsForStyle (Display *dpy, Window window, 
-				 unsigned int styleMask)
+static void setWindowHintsForStyle (Display *dpy, Window window, NSUInteger styleMask)
 {
   MwmHints *hints;
   BOOL needToFreeHints = YES;
@@ -428,9 +432,9 @@ static void setWindowHintsForStyle (Display *dpy, Window window,
 @end
 
 @interface XGServer (WindowOps)
-- (gswindow_device_t *) _rootWindowForScreen: (int)screen;
-- (void) styleoffsets: (float *) l : (float *) r : (float *) t : (float *) b
-                     : (unsigned int) style : (Window) win;
+- (gswindow_device_t *) _rootWindowForScreen: (NSInteger)screen;
+- (void) styleoffsets: (CGFloat *) l : (CGFloat *) r : (CGFloat *) t : (CGFloat *) b
+                     : (NSUInteger) style : (Window) win;
 - (void) _setSupportedWMProtocols: (gswindow_device_t *) window;
 @end
 
@@ -468,7 +472,7 @@ static void setWindowHintsForStyle (Display *dpy, Window window,
   return NSMapGet(windowmaps, (void *)xWindow);
 }
 
-+ (gswindow_device_t *) _windowWithTag: (int)windowNumber
++ (gswindow_device_t *) _windowWithTag: (NSInteger)windowNumber
 {
   return WINDOW_WITH_TAG(windowNumber);
 }
@@ -483,9 +487,9 @@ static void setWindowHintsForStyle (Display *dpy, Window window,
 - (NSRect) _OSFrameToXFrame: (NSRect)o for: (void*)window
 {
   gswindow_device_t	*win = (gswindow_device_t*)window;
-  unsigned int		style = win->win_attrs.window_style;
+  unsigned long		style = win->win_attrs.window_style;
   NSRect	x;
-  float	t, b, l, r;
+  CGFloat	t, b, l, r;
 
   [self styleoffsets: &l : &r : &t : &b : style : win->ident];
 
@@ -494,7 +498,7 @@ static void setWindowHintsForStyle (Display *dpy, Window window,
   x.origin.x = o.origin.x + l;
   x.origin.y = o.origin.y + o.size.height - t;
   x.origin.y = DisplayHeight(dpy, win->screen) - x.origin.y;
-  NSDebugLLog(@"Frame", @"O2X %lu, %x, %@, %@", win->number, style,
+  NSDebugLLog(@"Frame", @"O2X %ld, %lx, %@, %@", (long)win->number, (long)style,
     NSStringFromRect(o), NSStringFromRect(x));
   return x;
 }
@@ -508,9 +512,9 @@ static void setWindowHintsForStyle (Display *dpy, Window window,
 - (NSRect) _OSFrameToXHints: (NSRect)o for: (void*)window
 {
   gswindow_device_t	*win = (gswindow_device_t*)window;
-  unsigned int		style = win->win_attrs.window_style;
+  unsigned long		style = win->win_attrs.window_style;
   NSRect	x;
-  float	t, b, l, r;
+  CGFloat	t, b, l, r;
 
   [self styleoffsets: &l : &r : &t : &b : style : win->ident];
 
@@ -519,7 +523,7 @@ static void setWindowHintsForStyle (Display *dpy, Window window,
   x.origin.x = o.origin.x;
   x.origin.y = o.origin.y + o.size.height;
   x.origin.y = DisplayHeight(dpy, win->screen) - x.origin.y;
-  NSDebugLLog(@"Frame", @"O2H %lu, %x, %@, %@", win->number, style,
+  NSDebugLLog(@"Frame", @"O2H %ld, %lx, %@, %@", (long)win->number, (long)style,
     NSStringFromRect(o), NSStringFromRect(x));
   return x;
 }
@@ -531,9 +535,9 @@ static void setWindowHintsForStyle (Display *dpy, Window window,
 - (NSRect) _XWinRectToOSWinRect: (NSRect)x for: (void*)window
 {
   gswindow_device_t	*win = (gswindow_device_t*)window;
-  unsigned int		style = win->win_attrs.window_style;
+  unsigned long		style = win->win_attrs.window_style;
   NSRect	o;
-  float	t, b, l, r;
+  CGFloat	t, b, l, r;
 
   [self styleoffsets: &l : &r : &t : &b : style : win->ident];
   o.size.width = x.size.width;
@@ -554,9 +558,9 @@ static void setWindowHintsForStyle (Display *dpy, Window window,
 - (NSRect) _XFrameToOSFrame: (NSRect)x for: (void*)window
 {
   gswindow_device_t	*win = (gswindow_device_t*)window;
-  unsigned int		style = win->win_attrs.window_style;
+  unsigned long		style = win->win_attrs.window_style;
   NSRect	o;
-  float	t, b, l, r;
+  CGFloat	t, b, l, r;
 
   [self styleoffsets: &l : &r : &t : &b : style : win->ident];
   o = x;
@@ -566,7 +570,7 @@ static void setWindowHintsForStyle (Display *dpy, Window window,
   o.size.width += l + r;
   o.size.height += t + b;
 
-  NSDebugLLog(@"Frame", @"X2O %lu, %x, %@, %@", win->number, style,
+  NSDebugLLog(@"Frame", @"X2O %ld, %lx, %@, %@", (long)win->number, (long)style,
     NSStringFromRect(x), NSStringFromRect(o));
   return o;
 }
@@ -578,9 +582,9 @@ static void setWindowHintsForStyle (Display *dpy, Window window,
 - (NSRect) _XFrameToXHints: (NSRect)o for: (void*)window
 {
   gswindow_device_t	*win = (gswindow_device_t*)window;
-  unsigned int		style = win->win_attrs.window_style;
+  unsigned long		style = win->win_attrs.window_style;
   NSRect	x;
-  float	t, b, l, r;
+  CGFloat	t, b, l, r;
 
   [self styleoffsets: &l : &r : &t : &b : style : win->ident];
 
@@ -592,7 +596,7 @@ static void setWindowHintsForStyle (Display *dpy, Window window,
   x.size.height = o.size.height;
   x.origin.x = o.origin.x - l;
   x.origin.y = o.origin.y - t;
-  NSDebugLLog(@"Frame", @"X2H %lu, %x, %@, %@", win->number, style,
+  NSDebugLLog(@"Frame", @"X2H %ld, %lx, %@, %@", (long)win->number, (long)style,
     NSStringFromRect(o), NSStringFromRect(x));
   return x;
 }
@@ -628,7 +632,7 @@ static void setWindowHintsForStyle (Display *dpy, Window window,
 - (BOOL) _checkWMSupports: (Atom)feature
 {
   Window root;
-  int	count;
+  NSUInteger count;
   Atom *data;
   Atom supported;
 
@@ -658,7 +662,7 @@ static void setWindowHintsForStyle (Display *dpy, Window window,
   return NO;
 }
 
-Bool
+static Bool
 _get_next_prop_new_event(Display *display, XEvent *event, char *arg)
 {
 	XID *data = (XID*)arg;
@@ -736,7 +740,7 @@ _get_next_prop_new_event(Display *display, XEvent *event, char *arg)
   return NO;
 }
 
-- (BOOL) _checkStyle: (unsigned)style
+- (BOOL) _checkStyle: (NSUInteger)style
 {
   gswindow_device_t	*window;
   gswindow_device_t	*root;
@@ -746,16 +750,16 @@ _get_next_prop_new_event(Display *display, XEvent *event, char *arg)
   XClassHint		classhint;
   RContext              *context;
   XEvent		xEvent;
-  int			count;
+  NSUInteger            count;
   unsigned long		*extents;
   Offsets		*o = generic.offsets + (style & 15);
-  int			repp = 0;
+  Window                repp = 0;
   int			repx = 0;
   int			repy = 0;
   BOOL                  onScreen;
   BOOL                  reparented = NO;
 
-  NSDebugLLog(@"Offset", @"Checking offsets for style %d\n", style);
+  NSDebugLLog(@"Offset", @"Checking offsets for style %ld\n", (long)style);
 
   onScreen = [[NSUserDefaults standardUserDefaults] boolForKey:
     @"GSBackChecksOffsetsOnScreen"];
@@ -1114,8 +1118,8 @@ _get_next_prop_new_event(Display *display, XEvent *event, char *arg)
           o->b = b;
           o->known = YES;
           NSDebugLLog(@"Offset",
-                      @"Style %d lrtb set to %d,%d,%d,%d\n",
-                      style, (int)o->l, (int)o->r, (int)o->t, (int)o->b);
+                      @"Style %ld lrtb set to %d,%d,%d,%d\n",
+                      (long)style, (int)o->l, (int)o->r, (int)o->t, (int)o->b);
         }
     }
 
@@ -1133,7 +1137,7 @@ _get_next_prop_new_event(Display *display, XEvent *event, char *arg)
     }
   if (o->known == NO)
     {
-      NSLog(@"Failed to determine offsets for style %d", style);
+      NSLog(@"Failed to determine offsets for style %lu", (unsigned long)style);
       return NO;
     }
   return YES;
@@ -1146,7 +1150,7 @@ _get_next_prop_new_event(Display *display, XEvent *event, char *arg)
   Window *win;
   Atom	*data;
   Atom	atom;
-  int	count;
+  NSUInteger count;
 
   root = DefaultRootWindow(dpy);
   wmflags = XGWM_UNKNOWN;
@@ -1321,7 +1325,7 @@ _get_next_prop_new_event(Display *display, XEvent *event, char *arg)
   return wmflags;
 }
 
-- (gswindow_device_t *) _rootWindowForScreen: (int)screen
+- (gswindow_device_t *) _rootWindowForScreen: (NSInteger)screen
 {
   int x, y;
   unsigned int width, height;
@@ -1496,8 +1500,8 @@ _get_next_prop_new_event(Display *display, XEvent *event, char *arg)
 {
   NSProcessInfo		*pInfo = [NSProcessInfo processInfo];
   NSArray		*args;
-  unsigned int		i;
-  unsigned int		argc;
+  NSUInteger		i;
+  NSUInteger		argc;
   char			**argv;
   XClassHint		classhint; 
   XTextProperty		windowName;
@@ -1635,7 +1639,7 @@ _get_next_prop_new_event(Display *display, XEvent *event, char *arg)
     {
       argv[i] = (char*)[[args objectAtIndex: i] UTF8String];
     }
-  XSetCommand(dpy, ROOT, argv, argc);
+  XSetCommand(dpy, ROOT, argv, (int)argc);
   free(argv);
 
   // Store the host name of the machine we a running on
@@ -1685,8 +1689,8 @@ _get_next_prop_new_event(Display *display, XEvent *event, char *arg)
   if (handlesWindowDecorations == YES)
     {
       static Atom	_offsets_name = None;
-      unsigned		i;
-      int		count;
+      NSUInteger        i;
+      NSUInteger        count;
       uint16_t		*offsets;
 
       /* Offsets for NSBorderlessWindowMask *should* always be zero.
@@ -1835,14 +1839,14 @@ _get_next_prop_new_event(Display *display, XEvent *event, char *arg)
 
 -(BOOL) _createNetIcon: (NSImage*)image 
 		result: (long**)pixeldata 
-		  size: (int*)size
+		  size: (NSUInteger *)size
 {
   NSBitmapImageRep *rep;
-  int i, j, w, h, samples;
+  NSInteger i, j, w, h, samples;
   unsigned char *data;
-  int index;
+  NSUInteger index;
   long *iconPropertyData;
-  int iconSize;
+  NSUInteger iconSize;
  
   rep = getStandardBitmap(image);
   if (rep == nil)
@@ -1927,7 +1931,7 @@ _get_next_prop_new_event(Display *display, XEvent *event, char *arg)
   static Atom icon_atom = None;
   static BOOL didCreateNetIcon = NO;
   static long *iconPropertyData = NULL;
-  static int iconSize;
+  static NSUInteger iconSize;
   NSImage *image;
 
   /* Initialize the atom if needed */
@@ -1953,15 +1957,16 @@ _get_next_prop_new_event(Display *display, XEvent *event, char *arg)
 
   if (iconPropertyData != 0)
     {
+      /* todo: add NSAssert to check if icon is not too large */
       XChangeProperty(dpy, window,
 		      icon_atom, XA_CARDINAL, 
 		      32, PropModeReplace,
-		      (unsigned char *)iconPropertyData, iconSize);
+		      (unsigned char *)iconPropertyData, (int)iconSize);
     }
 }
 
-- (int) window: (NSRect)frame : (NSBackingStoreType)type : (unsigned int)style
-	      : (int)screen
+- (NSInteger) window: (NSRect)frame : (NSBackingStoreType)type : (NSUInteger)style
+                    : (NSInteger)screen
 {
   gswindow_device_t	*window;
   gswindow_device_t	*root;
@@ -2168,8 +2173,8 @@ _get_next_prop_new_event(Display *display, XEvent *event, char *arg)
   return window->number;
 }
 
-- (int) nativeWindow: (void *)winref : (NSRect*)frame : (NSBackingStoreType*)type 
-		    : (unsigned int*)style : (int*)screen
+- (NSInteger) nativeWindow: (void *)winref : (NSRect*)frame : (NSBackingStoreType*)type 
+                          : (NSUInteger*)style : (NSInteger*)screen
 {
   gswindow_device_t	*window;
   gswindow_device_t	*root;
@@ -2284,7 +2289,7 @@ _get_next_prop_new_event(Display *display, XEvent *event, char *arg)
   return window->number;
 }
 
-- (void) termwindow: (int)win
+- (void) termwindow: (NSInteger)win
 {
   gswindow_device_t *window;
 
@@ -2298,7 +2303,7 @@ _get_next_prop_new_event(Display *display, XEvent *event, char *arg)
       return;
     }
 
-  NSDebugLLog(@"XGTrace", @"DPStermwindow: %d", win);
+  NSDebugLLog(@"XGTrace", @"DPStermwindow: %ld", (long)win);
   if (window->ic)
     {
       [inputServer ximCloseIC: window->ic];
@@ -2332,14 +2337,14 @@ _get_next_prop_new_event(Display *display, XEvent *event, char *arg)
  * Return the offsets between the window content-view and it's frame
  * depending on the window style.
  */
-- (void) styleoffsets: (float *) l : (float *) r : (float *) t : (float *) b 
-		     : (unsigned int) style
+- (void) styleoffsets: (CGFloat *) l : (CGFloat *) r : (CGFloat *) t : (CGFloat *) b 
+		     : (NSUInteger) style
 {
   [self styleoffsets: l : r : t : b : style : (Window) 0];
 }
 
-- (void) styleoffsets: (float *) l : (float *) r : (float *) t : (float *) b 
-		     : (unsigned int) style : (Window) win
+- (void) styleoffsets: (CGFloat *) l : (CGFloat *) r : (CGFloat *) t : (CGFloat *) b 
+		     : (NSUInteger) style : (Window) win
 {
   Offsets	*o;
 
@@ -2357,7 +2362,7 @@ _get_next_prop_new_event(Display *display, XEvent *event, char *arg)
   /* First check _NET_FRAME_EXTENTS */
   if (win  && ((generic.wm & XGWM_EWMH) != 0)) 
     {
-      int count;
+      NSUInteger count;
       unsigned long *extents;
 
       if (_net_frame_extents == None)
@@ -2465,7 +2470,7 @@ NSLog(@"styleoffsets ... guessing offsets\n");
     }
 }
 
-- (void) stylewindow: (unsigned int)style : (int) win
+- (void) stylewindow: (NSUInteger)style : (NSInteger)win
 {
   gswindow_device_t	*window;
 
@@ -2475,7 +2480,7 @@ NSLog(@"styleoffsets ... guessing offsets\n");
   if (!window)
     return;
 
-  NSDebugLLog(@"XGTrace", @"DPSstylewindow: %d : %d", style, win);
+  NSDebugLLog(@"XGTrace", @"DPSstylewindow: %lu : %ld", (unsigned long)style, (long)win);
   if (window->win_attrs.window_style != style
     || (window->win_attrs.flags & GSWindowStyleAttr) == 0)
     {
@@ -2508,7 +2513,7 @@ NSLog(@"styleoffsets ... guessing offsets\n");
     }
 }
 
-- (void) setbackgroundcolor: (NSColor *)color : (int)win
+- (void) setbackgroundcolor: (NSColor *)color : (NSInteger)win
 {
   XColor xf;
   gswindow_device_t *window;
@@ -2522,13 +2527,13 @@ NSLog(@"styleoffsets ... guessing offsets\n");
   xf.red   = 65535 * [color redComponent];
   xf.green = 65535 * [color greenComponent];
   xf.blue  = 65535 * [color blueComponent];
-  NSDebugLLog(@"XGTrace", @"setbackgroundcolor: %@ %d", color, win);
+  NSDebugLLog(@"XGTrace", @"setbackgroundcolor: %@ %ld", color, (long)win);
   xf = [self xColorFromColor: xf forScreen: window->screen];
   window->xwn_attrs.background_pixel = xf.pixel;
   XSetWindowBackground(dpy, window->ident, window->xwn_attrs.background_pixel);
 }
 
-- (void) windowbacking: (NSBackingStoreType)type : (int) win
+- (void) windowbacking: (NSBackingStoreType)type : (NSInteger) win
 {
   gswindow_device_t *window;
 
@@ -2536,7 +2541,7 @@ NSLog(@"styleoffsets ... guessing offsets\n");
   if (!window)
     return;
 
-  NSDebugLLog(@"XGTrace", @"DPSwindowbacking: %d : %d", (int)type, win);
+  NSDebugLLog(@"XGTrace", @"DPSwindowbacking: %ld : %ld", (long)type, (long)win);
 
   if ((window->gdriverProtocol & GDriverHandlesBacking))
     {
@@ -2553,7 +2558,7 @@ NSLog(@"styleoffsets ... guessing offsets\n");
   [self _createBuffer: window];
 }
 
-- (void) titlewindow: (NSString *)window_title : (int) win
+- (void) titlewindow: (NSString *)window_title : (NSInteger)win
 {
   gswindow_device_t *window;
 
@@ -2561,7 +2566,7 @@ NSLog(@"styleoffsets ... guessing offsets\n");
   if (!window)
     return;
 
-  NSDebugLLog(@"XGTrace", @"DPStitlewindow: %@ : %d", window_title, win);
+  NSDebugLLog(@"XGTrace", @"DPStitlewindow: %@ : %ld", window_title, (long)win);
   if (window_title && window->ident)
     {
       XTextProperty windowName;
@@ -2598,17 +2603,17 @@ NSLog(@"styleoffsets ... guessing offsets\n");
       char *name = (char *)[window_title UTF8String];
       XChangeProperty(dpy, window->ident, _net_wm_name, _utf8,
 		      8, PropModeReplace, 
-		      (unsigned char *)name, strlen(name));
+		      (unsigned char *)name, (int)strlen(name));
       XChangeProperty(dpy, window->ident, _net_wm_icon_name, _utf8,
 		      8, PropModeReplace, 
-		      (unsigned char *)name, strlen(name));
+		      (unsigned char *)name, (int)strlen(name));
       }
 
       XFree(windowName.value);
     }
 }
 
-- (void) docedited: (int)edited : (int) win
+- (void) docedited: (NSInteger)edited : (NSInteger)win
 {
   gswindow_device_t *window;
 
@@ -2616,7 +2621,7 @@ NSLog(@"styleoffsets ... guessing offsets\n");
   if (!window)
     return;
 
-  NSDebugLLog(@"XGTrace", @"DPSdocedited: %d : %d", edited, win);
+  NSDebugLLog(@"XGTrace", @"DPSdocedited: %ld : %ld", (long)edited, (long)win);
   window->win_attrs.flags |= GSExtraFlagsAttr;
   if (edited)
     {
@@ -2654,7 +2659,7 @@ NSLog(@"styleoffsets ... guessing offsets\n");
   return generic.flags.appOwnsMiniwindow;
 }
 
-- (void) miniwindow: (int) win
+- (void) miniwindow: (NSInteger) win
 {
   gswindow_device_t	*window;
   XEvent e;
@@ -2664,7 +2669,7 @@ NSLog(@"styleoffsets ... guessing offsets\n");
     {
       return;
     }
-  NSDebugLLog(@"XGTrace", @"DPSminiwindow: %d ", win);
+  NSDebugLLog(@"XGTrace", @"DPSminiwindow: %ld ", (long)win);
   /*
    * If we haven't already done so - set the icon window hint for this
    * window so that the GNUstep miniwindow is displayed (if supported).
@@ -2677,8 +2682,8 @@ NSLog(@"styleoffsets ... guessing offsets\n");
       nswin = GSWindowWithNumber(window->number);
       if (nswin != nil)
 	{
-	  int			iNum = [[nswin counterpart] windowNumber];
-	  gswindow_device_t	*iconw = WINDOW_WITH_TAG(iNum);
+	  NSInteger iNum = [[nswin counterpart] windowNumber];
+	  gswindow_device_t *iconw = WINDOW_WITH_TAG(iNum);
 
 	  if (iconw != 0)
 	    {
@@ -2707,26 +2712,26 @@ NSLog(@"styleoffsets ... guessing offsets\n");
      under metacity, which sets _NET_WM_STATE for shaded windows to both
      _NET_WM_STATE_SHADED and _NET_WM_STATE_HIDDEN. */
   if (generic.flags.appOwnsMiniwindow && !(generic.wm & XGWM_WINDOWMAKER))
-    XWithdrawWindow(dpy, window->ident, window->screen);
+    XWithdrawWindow(dpy, window->ident, (int)window->screen);
   else if (window->wm_state != IconicState)
-    XIconifyWindow(dpy, window->ident, window->screen);
+    XIconifyWindow(dpy, window->ident, (int)window->screen);
 }
 
 /**
    Make sure we have the most up-to-date window information and then
    make sure the context has our new information
 */
-- (void) setWindowdevice: (int)win forContext: (NSGraphicsContext *)ctxt
+- (void) setWindowdevice: (NSInteger)win forContext: (NSGraphicsContext *)ctxt
 {
   unsigned width, height;
   gswindow_device_t *window;
-  float	t, b, l, r;
+  CGFloat t, b, l, r;
 
-  NSDebugLLog(@"XGTrace", @"DPSwindowdevice: %d ", win);
+  NSDebugLLog(@"XGTrace", @"DPSwindowdevice: %ld ", (long)win);
   window = WINDOW_WITH_TAG(win);
   if (!window)
     {
-      NSLog(@"Invalidparam: Invalid window number %d", win);
+      NSLog(@"Invalidparam: Invalid window number %ld", (long)win);
       return;
     }
 
@@ -2780,7 +2785,7 @@ static BOOL didCreatePixmaps;
 {
   NSImage *image;
   NSBitmapImageRep *rep;
-  int i, j, w, h, samples, screen;
+  NSInteger i, j, w, h, samples, screen;
   unsigned char *data;
   XColor pixelColor;
   GC pixgc;
@@ -2800,7 +2805,7 @@ static BOOL didCreatePixmaps;
   screen = [[[self screenList] objectAtIndex: 0] intValue];
   xIconPixmap = XCreatePixmap(dpy,
                       [self xDisplayRootWindowForScreen: screen],
-                      [rep pixelsWide], [rep pixelsHigh],
+                      (unsigned)[rep pixelsWide], (unsigned)[rep pixelsHigh],
                       DefaultDepth(dpy, screen));
   pixgc = XCreateGC(dpy, xIconPixmap, 0, NULL);
 
@@ -2820,7 +2825,7 @@ static BOOL didCreatePixmaps;
 
 	  RGetClosestXColor(rcontext, &pixelRColor, &pixelColor);
 	  XSetForeground(dpy, pixgc, pixelColor. pixel);
-	  XDrawPoint(dpy, xIconPixmap, pixgc, j, i);
+	  XDrawPoint(dpy, xIconPixmap, pixgc, (int)j, (int)i);
 	  d += samples;
 	}
       data += [rep bytesPerRow];
@@ -2836,16 +2841,16 @@ static BOOL didCreatePixmaps;
   return 1;
 }   
 
-- (void) orderwindow: (int)op : (int)otherWin : (int)winNum
+- (void) orderwindow: (NSInteger)op : (NSInteger)otherWin : (NSInteger)winNum
 {
   gswindow_device_t	*window;
   gswindow_device_t	*other;
-  int		level;
+  NSInteger		level;
 
   window = WINDOW_WITH_TAG(winNum);
   if (winNum == 0 || window == NULL)
     {
-      NSLog(@"Invalidparam: Ordering invalid window %d", winNum);
+      NSLog(@"Invalidparam: Ordering invalid window %ld", (long)winNum);
       return;
     }
 
@@ -2926,7 +2931,7 @@ static BOOL didCreatePixmaps;
 	}
     }
 
-  NSDebugLLog(@"XGTrace", @"DPSorderwindow: %d : %d : %d",op,otherWin,winNum);
+  NSDebugLLog(@"XGTrace", @"DPSorderwindow: %ld : %ld : %ld", (long)op, (long)otherWin, (long)winNum);
   level = window->win_attrs.window_level;
   if (otherWin > 0)
     {
@@ -2983,14 +2988,14 @@ static BOOL didCreatePixmaps;
 	    XWindowChanges chg;
 	    chg.sibling = other->ident;
 	    chg.stack_mode = Below;
-	    XReconfigureWMWindow(dpy, window->ident, window->screen,
+	    XReconfigureWMWindow(dpy, window->ident, (int)window->screen,
 	      CWSibling|CWStackMode, &chg);
 	  }
 	else
 	  {
 	    XWindowChanges chg;
 	    chg.stack_mode = Below;
-	    XReconfigureWMWindow(dpy, window->ident, window->screen,
+	    XReconfigureWMWindow(dpy, window->ident, (int)window->screen,
 	      CWStackMode, &chg);
 	  }
 	XMapWindow(dpy, window->ident);
@@ -3002,21 +3007,21 @@ static BOOL didCreatePixmaps;
 	    XWindowChanges chg;
 	    chg.sibling = other->ident;
 	    chg.stack_mode = Above;
-	    XReconfigureWMWindow(dpy, window->ident, window->screen,
+	    XReconfigureWMWindow(dpy, window->ident, (int)window->screen,
 	      CWSibling|CWStackMode, &chg);
 	  }
 	else
 	  {
 	    XWindowChanges chg;
 	    chg.stack_mode = Above;
-	    XReconfigureWMWindow(dpy, window->ident, window->screen,
+	    XReconfigureWMWindow(dpy, window->ident, (int)window->screen,
 	      CWStackMode, &chg);
 	  }
 	XMapWindow(dpy, window->ident);
 	break;
 
       case NSWindowOut:
-        XWithdrawWindow (dpy, window->ident, window->screen);
+        XWithdrawWindow (dpy, window->ident, (int)window->screen);
 	break;
     }
   /*
@@ -3099,7 +3104,7 @@ static BOOL didCreatePixmaps;
 /* Restrict the displayed part of the window to the given image.
    This only yields usefull results if the window is borderless and 
    displays the image itself */
-- (void) restrictWindow: (int)win toImage: (NSImage*)image
+- (void) restrictWindow: (NSInteger)win toImage: (NSImage*)image
 {
   gswindow_device_t	*window;
   Pixmap pixmap = 0;
@@ -3107,7 +3112,7 @@ static BOOL didCreatePixmaps;
   window = WINDOW_WITH_TAG(win);
   if (win == 0 || window == NULL)
     {
-      NSLog(@"Invalidparam: Restricting invalid window %d", win);
+      NSLog(@"Invalidparam: Restricting invalid window %ld", (long)win);
       return;
     }
 
@@ -3141,14 +3146,14 @@ static BOOL didCreatePixmaps;
 
 /* This method is a fast implementation of move that only works 
    correctly for borderless windows. Use with caution. */
-- (void) movewindow: (NSPoint)loc : (int)win
+- (void) movewindow: (NSPoint)loc : (NSInteger)win
 {
   gswindow_device_t	*window;
 
   window = WINDOW_WITH_TAG(win);
   if (win == 0 || window == NULL)
     {
-      NSLog(@"Invalidparam: Moving invalid window %d", win);
+      NSLog(@"Invalidparam: Moving invalid window %ld", (long)win);
       return;
     }
 
@@ -3159,7 +3164,7 @@ static BOOL didCreatePixmaps;
   setNormalHints(dpy, window);
 }
 
-- (void) placewindow: (NSRect)rect : (int)win
+- (void) placewindow: (NSRect)rect : (NSInteger)win
 {
   NSEvent *e;
   NSRect xVal;
@@ -3173,12 +3178,11 @@ static BOOL didCreatePixmaps;
   window = WINDOW_WITH_TAG(win);
   if (win == 0 || window == NULL)
     {
-      NSLog(@"Invalidparam: Placing invalid window %d", win);
+      NSLog(@"Invalidparam: Placing invalid window %ld", (long)win);
       return;
     }
 
-  NSDebugLLog(@"XGTrace", @"DPSplacewindow: %@ : %d", NSStringFromRect(rect), 
-	      win);
+  NSDebugLLog(@"XGTrace", @"DPSplacewindow: %@ : %ld", NSStringFromRect(rect), (long)win);
   nswin  = GSWindowWithNumber(win);
   frame = [nswin frame];
   if (NSEqualRects(rect, frame) == YES)
@@ -3262,13 +3266,13 @@ static BOOL didCreatePixmaps;
     }
 }
 
-- (BOOL) findwindow: (NSPoint)loc : (int) op : (int) otherWin : (NSPoint *)floc 
-: (int*) winFound
+- (BOOL) findwindow: (NSPoint)loc : (NSInteger)op : (NSInteger)otherWin
+                   : (NSPoint *)floc : (NSInteger *)winFound
 {
   return NO;
 }
 
-- (NSRect) windowbounds: (int)win
+- (NSRect) windowbounds: (NSInteger)win
 {
   gswindow_device_t *window;
   int screenHeight;
@@ -3280,7 +3284,7 @@ static BOOL didCreatePixmaps;
   if (!window)
     return NSZeroRect;
 
-  NSDebugLLog(@"XGTrace", @"DPScurrentwindowbounds: %d", win);
+  NSDebugLLog(@"XGTrace", @"DPScurrentwindowbounds: %ld", (long)win);
 
   // get the current xframe of the window
   XGetGeometry(dpy, window->ident, &window->root,
@@ -3293,7 +3297,7 @@ static BOOL didCreatePixmaps;
   return rect;
 }
 
-- (void) setwindowlevel: (int)level : (int)win
+- (void) setwindowlevel: (NSInteger)level : (NSInteger)win
 {
   gswindow_device_t *window;
 
@@ -3301,7 +3305,7 @@ static BOOL didCreatePixmaps;
   if (!window)
     return;
 
-  NSDebugLLog(@"XGTrace", @"DPSsetwindowlevel: %d : %d", level, win);
+  NSDebugLLog(@"XGTrace", @"DPSsetwindowlevel: %ld : %ld", (long)level, (long)win);
   if ((int)(window->win_attrs.window_level) != level
     || (window->win_attrs.flags & GSWindowLevelAttr) == 0)
     {
@@ -3470,7 +3474,7 @@ static BOOL didCreatePixmaps;
     }
 }
 
-- (int) windowlevel: (int)win
+- (NSInteger) windowlevel: (NSInteger)win
 {
   gswindow_device_t *window;
 
@@ -3489,7 +3493,7 @@ static BOOL didCreatePixmaps;
   Window *windowOrder;
   gswindow_device_t *tmp;
   NSMutableArray *ret;
-  int c;
+  NSUInteger c;
   static Atom client_stack_atom = None;
  
   if (!client_stack_atom)
@@ -3514,7 +3518,7 @@ static BOOL didCreatePixmaps;
        * interested in the ones which are ours. */
       if (tmp)
         {
-          [ret addObject:[NSNumber numberWithInt:tmp->number]];
+          [ret addObject:[NSNumber numberWithLong:tmp->number]];
         }
     }
   
@@ -3522,7 +3526,7 @@ static BOOL didCreatePixmaps;
   return ret;
 }
 
-- (int) windowdepth: (int)win
+- (NSInteger) windowdepth: (NSInteger)win
 {
   gswindow_device_t *window;
 
@@ -3533,7 +3537,7 @@ static BOOL didCreatePixmaps;
   return window->depth;
 }
 
-- (void) setmaxsize: (NSSize)size : (int)win
+- (void) setmaxsize: (NSSize)size : (NSInteger)win
 {
   gswindow_device_t	*window;
   NSRect		r;
@@ -3551,7 +3555,7 @@ static BOOL didCreatePixmaps;
   setNormalHints(dpy, window);
 }
 
-- (void) setminsize: (NSSize)size : (int)win
+- (void) setminsize: (NSSize)size : (NSInteger)win
 {
   gswindow_device_t	*window;
   NSRect		r;
@@ -3569,7 +3573,7 @@ static BOOL didCreatePixmaps;
   setNormalHints(dpy, window);
 }
 
-- (void) setresizeincrements: (NSSize)size : (int)win
+- (void) setresizeincrements: (NSSize)size : (NSInteger)win
 {
   gswindow_device_t *window;
 
@@ -3585,7 +3589,7 @@ static BOOL didCreatePixmaps;
 }
 
 // process expose event
-- (void) _addExposedRectangle: (XRectangle)rectangle : (int)win : (BOOL) ignoreBacking
+- (void) _addExposedRectangle: (XRectangle)rectangle : (NSInteger)win : (BOOL) ignoreBacking
 {
   gswindow_device_t *window;
 
@@ -3647,23 +3651,23 @@ static BOOL didCreatePixmaps;
     }
 }
 
-- (void) flushwindowrect: (NSRect)rect : (int)win
+- (void) flushwindowrect: (NSRect)rect : (NSInteger)win
 {
   int xi, yi, width, height;
   XGCValues values;
   unsigned long valuemask;
   gswindow_device_t *window;
-  float	l, r, t, b;
+  CGFloat	l, r, t, b;
 
   window = WINDOW_WITH_TAG(win);
   if (win == 0 || window == NULL)
     {
-      NSLog(@"Invalidparam: Placing invalid window %d", win);
+      NSLog(@"Invalidparam: Placing invalid window %ld", (long)win);
       return;
     }
 
-  NSDebugLLog(@"XGFlush", @"DPSflushwindowrect: %@ : %d", 
-	      NSStringFromRect(rect), win);
+  NSDebugLLog(@"XGFlush", @"DPSflushwindowrect: %@ : %ld",
+	      NSStringFromRect(rect), (long)win);
   if (window->type == NSBackingStoreNonretained)
     {
       XFlush(dpy);
@@ -3710,8 +3714,8 @@ static BOOL didCreatePixmaps;
     {
       XSyncValue value;
       XSyncIntsToValue(&value,
-		       window->net_wm_sync_request_counter_value_low,
-		       window->net_wm_sync_request_counter_value_high);
+		       (unsigned)window->net_wm_sync_request_counter_value_low,
+		       (int)window->net_wm_sync_request_counter_value_high);
       XSyncSetCounter(dpy, window->net_wm_sync_request_counter, value);
       window->net_wm_sync_request_counter_value_low = 0;
       window->net_wm_sync_request_counter_value_high = 0;
@@ -3722,9 +3726,9 @@ static BOOL didCreatePixmaps;
 }
 
 // handle X expose events
-- (void) _processExposedRectangles: (int)win
+- (void) _processExposedRectangles: (NSInteger)win
 {
-  int n;
+  NSUInteger n;
   gswindow_device_t *window;
   NSWindow *gui_win;
 
@@ -3750,7 +3754,7 @@ static BOOL didCreatePixmaps;
     {
       NSView *v;
       NSValue *val[n];
-      int i;
+      NSUInteger i;
 
       v = [[gui_win contentView] superview];
 	
@@ -3769,7 +3773,7 @@ static BOOL didCreatePixmaps;
   XSetClipMask (dpy, window->gc, None);
 }
 
-- (BOOL) capturemouse: (int)win
+- (BOOL) capturemouse: (NSInteger)win
 {
   int ret;
   gswindow_device_t *window;
@@ -3783,11 +3787,11 @@ static BOOL didCreatePixmaps;
 		     GrabModeAsync, GrabModeAsync, None, None, [self lastTime]);
 
   if (ret != GrabSuccess)
-    NSDebugLLog(@"XGTrace", @"Failed to grab pointer %d\n", win);
+    NSDebugLLog(@"XGTrace", @"Failed to grab pointer %ld\n", (long)win);
   else
     {
       grab_window = window;
-      NSDebugLLog(@"XGTrace", @"Grabbed pointer %d\n", win);
+      NSDebugLLog(@"XGTrace", @"Grabbed pointer %ld\n", (long)win);
     }
   return (ret == GrabSuccess) ? YES : NO;
 }
@@ -3799,7 +3803,7 @@ static BOOL didCreatePixmaps;
   grab_window = NULL;
 }
 
-- (void) setMouseLocation: (NSPoint)mouseLocation onScreen: (int)aScreen
+- (void) setMouseLocation: (NSPoint)mouseLocation onScreen: (NSInteger)aScreen
 {
   int height;
   int destX, destY;
@@ -3812,17 +3816,17 @@ static BOOL didCreatePixmaps;
                0, 0, 0, 0, destX, destY);
 }
 
-- (void) setinputfocus: (int)win
+- (void) setinputfocus: (NSInteger)win
 {
   gswindow_device_t *window = WINDOW_WITH_TAG(win);
 
   if (win == 0 || window == 0)
     {
-      NSDebugLLog(@"Focus", @"Setting focus to unknown win %d", win);
+      NSDebugLLog(@"Focus", @"Setting focus to unknown win %ld", (long)win);
       return;
     }
 
-  NSDebugLLog(@"XGTrace", @"DPSsetinputfocus: %d", win);
+  NSDebugLLog(@"XGTrace", @"DPSsetinputfocus: %ld", (long)win);
   /*
    * If we have an outstanding request to set focus to this window,
    * we don't want to do it again.
@@ -3859,12 +3863,12 @@ static BOOL didCreatePixmaps;
  * Instruct window manager that the specified window is 'key', 'main', or
  * just a normal window.
  */
-- (void) setinputstate: (int)st : (int)win
+- (void) setinputstate: (NSInteger)st : (NSInteger)win
 {
   if (!handlesWindowDecorations)
     return;
 
-  NSDebugLLog(@"XGTrace", @"DPSsetinputstate: %d : %d", st, win);
+  NSDebugLLog(@"XGTrace", @"DPSsetinputstate: %ld : %ld", (long)st, (long)win);
   if ((generic.wm & XGWM_WINDOWMAKER) != 0)
     {
       gswindow_device_t *window = WINDOW_WITH_TAG(win);
@@ -3918,18 +3922,18 @@ static BOOL didCreatePixmaps;
 }
 
 /** Sets the transparancy value for the whole window */
-- (void) setalpha: (float)alpha : (int) win
+- (void) setalpha: (CGFloat)alpha : (NSInteger) win
 {
   gswindow_device_t *window = WINDOW_WITH_TAG(win);
   static Atom opacity_atom = None;
 
   if (win == 0 || window == 0)
     {
-      NSDebugLLog(@"XGTrace", @"Setting alpha to unknown win %d", win);
+      NSDebugLLog(@"XGTrace", @"Setting alpha to unknown win %ld", (long)win);
       return;
     }
 
-  NSDebugLLog(@"XGTrace", @"setalpha: %d", win);
+  NSDebugLLog(@"XGTrace", @"setalpha: %ld", (long)win);
   
   /* Initialize the atom if needed */
   if (opacity_atom == None)
@@ -3959,17 +3963,17 @@ static BOOL didCreatePixmaps;
     }
 }
 
-- (float) getAlpha: (int)win
+- (CGFloat) getAlpha: (NSInteger)win
 {
   gswindow_device_t *window = WINDOW_WITH_TAG(win);
   static Atom opacity_atom = None;
-  int c;
+  NSUInteger c;
   unsigned int *num;
   float alpha = 0.0;
 
   if (win == 0 || window == 0)
     {
-      NSDebugLLog(@"XGTrace", @"Setting alpha to unknown win %d", win);
+      NSDebugLLog(@"XGTrace", @"Setting alpha to unknown win %ld", (long)win);
       return alpha;
     }
 
@@ -3996,7 +4000,7 @@ static BOOL didCreatePixmaps;
   return dpy;
 }
 
-- (void *) windowDevice: (int)win
+- (void *) windowDevice: (NSInteger)win
 {
   Window ptrloc;
   gswindow_device_t *window;
@@ -4103,12 +4107,12 @@ static BOOL   cursor_hidden = NO;
 
 Pixmap
 xgps_cursor_mask(Display *xdpy, Drawable draw, const unsigned char *data,
-		  int w, int h, int colors)
+		 NSInteger w, NSInteger h, NSInteger colors)
 {
-  int j, i;
+  NSInteger j, i;
   unsigned char	ialpha;
   Pixmap pix;
-  int bitmapSize = ((w + 7) >> 3) * h; // (w/8) rounded up times height
+  NSInteger bitmapSize = ((w + 7) >> 3) * h; // (w/8) rounded up times height
   char *aData = calloc(1, bitmapSize);
   char *cData = aData;
 
@@ -4143,19 +4147,20 @@ xgps_cursor_mask(Display *xdpy, Drawable draw, const unsigned char *data,
 	}
     }
 
-  pix = XCreatePixmapFromBitmapData(xdpy, draw, (char *)aData, w, h, 
+  pix = XCreatePixmapFromBitmapData(xdpy, draw, (char *)aData, (unsigned)w, (unsigned)h, 
 				    1L, 0L, 1);
   free(aData);
   return pix;
 }
 
-Pixmap
+#if !HAVE_XCURSOR
+static Pixmap
 xgps_cursor_image(Display *xdpy, Drawable draw, const unsigned char *data, 
-		  int w, int h, int colors, XColor *fg, XColor *bg)
+		  NSInteger w, NSInteger h, NSInteger colors, XColor *fg, XColor *bg)
 {
-  int j, i, min, max;
+  NSInteger j, i, min, max;
   Pixmap pix;
-  int bitmapSize = ((w + 7) >> 3) * h; // w/8 rounded up multiplied by h
+  NSInteger bitmapSize = ((w + 7) >> 3) * h; // w/8 rounded up multiplied by h
   char *aData = calloc(1, bitmapSize);
   char *cData = aData;
 
@@ -4219,11 +4224,12 @@ xgps_cursor_image(Display *xdpy, Drawable draw, const unsigned char *data,
 	}
     }
   
-  pix = XCreatePixmapFromBitmapData(xdpy, draw, (char *)aData, w, h, 
+  pix = XCreatePixmapFromBitmapData(xdpy, draw, (char *)aData, (unsigned)w, (unsigned)h, 
 				    1L, 0L, 1);
   free(aData);
   return pix;
 }
+#endif
 
 - (void) hidecursor
 {
@@ -4247,7 +4253,7 @@ xgps_cursor_image(Display *xdpy, Drawable draw, const unsigned char *data,
   cursor_hidden = NO;
 }
 
-- (void) standardcursor: (int)style : (void **)cid
+- (void) standardcursor: (NSInteger)style : (void **)cid
 {
   Cursor cursor = None;
 
@@ -4297,8 +4303,8 @@ xgps_cursor_image(Display *xdpy, Drawable draw, const unsigned char *data,
 {
   Cursor cursor;
   NSBitmapImageRep *rep;
-  int w, h;
-  int colors;
+  NSInteger w, h;
+  NSInteger colors;
   const unsigned char *data;
 
   rep = getStandardBitmap(image);
@@ -4338,13 +4344,13 @@ xgps_cursor_image(Display *xdpy, Drawable draw, const unsigned char *data,
 
   {
     XcursorImage *xcursorImage;
-    xcursorImage = XcursorImageCreate(w, h);
+    xcursorImage = XcursorImageCreate((int)w, (int)h);
     xcursorImage->xhot = hotp.x;
     xcursorImage->yhot = hotp.y;
 
     // Copy the data from the image rep to the Xcursor structure
     {
-      int bytesPerRow;
+      NSInteger bytesPerRow;
       size_t row;
 
       bytesPerRow = [rep bytesPerRow];
@@ -4529,7 +4535,7 @@ _computeDepth(int class, int bpp)
  int count = ScreenCount(dpy);
  NSMutableArray *screens = [NSMutableArray arrayWithCapacity: count];
  if (count > 0)
-   [screens addObject: [NSNumber numberWithInt: defScreen]];
+   [screens addObject: [NSNumber numberWithInteger: defScreen]];
  for (i = 0; i < count; i++)
    {
      if (i != defScreen)
@@ -4538,12 +4544,12 @@ _computeDepth(int class, int bpp)
  return screens;
 }
 
-- (NSWindowDepth) windowDepthForScreen: (int) screen_num
+- (NSWindowDepth) windowDepthForScreen: (NSInteger) screen_num
 { 
   Screen	*screen;
   int		 class = 0, bpp = 0;
 
-  screen = XScreenOfDisplay(dpy, screen_num);
+  screen = XScreenOfDisplay(dpy, (int)screen_num);
   if (screen == NULL)
     {
       return 0;
@@ -4555,7 +4561,7 @@ _computeDepth(int class, int bpp)
   return _computeDepth(class, bpp);
 }
 
-- (const NSWindowDepth *) availableDepthsForScreen: (int) screen_num
+- (const NSWindowDepth *) availableDepthsForScreen: (NSInteger) screen_num
 {  
   Screen	*screen;
   int		 class = 0;
@@ -4569,7 +4575,7 @@ _computeDepth(int class, int bpp)
       return NULL;
     }
 
-  screen = XScreenOfDisplay(dpy, screen_num);
+  screen = XScreenOfDisplay(dpy, (int)screen_num);
   if (screen == NULL)
     {
       return NULL;
@@ -4589,7 +4595,7 @@ _computeDepth(int class, int bpp)
   return depths;
 }
 
-- (NSSize) resolutionForScreen: (int)screen_num
+- (NSSize) resolutionForScreen: (NSInteger)screen_num
 { 
   // NOTE:
   // -gui now trusts the return value of resolutionForScreen:,
@@ -4622,11 +4628,11 @@ _computeDepth(int class, int bpp)
   */
 }
 
-- (NSRect) boundsForScreen: (int)screen
+- (NSRect) boundsForScreen: (NSInteger)screen
 {
  if (screen < 0 || screen >= ScreenCount(dpy))
    {
-     NSLog(@"Invalidparam: no screen %d", screen);
+     NSLog(@"Invalidparam: no screen %ld", (long)screen);
      return NSZeroRect;
    }
  return NSMakeRect(0, 0, DisplayWidth(dpy, screen), 
@@ -4640,7 +4646,7 @@ _computeDepth(int class, int bpp)
   Atom rgba_image_atom;
   Window win;
   Window *pwin;
-  int count;
+  NSUInteger count;
   unsigned char *tile;
   NSImage *iconTileImage;
   NSBitmapImageRep *imageRep;
@@ -4724,10 +4730,10 @@ _computeDepth(int class, int bpp)
   return [super iconSize];
 }
 
-- (unsigned int) numberOfDesktops: (int)screen
+- (NSUInteger) numberOfDesktops: (NSInteger)screen
 {
   static Atom number_of_desktops = None;
-  int c;
+  NSUInteger c;
   unsigned int *num;
   unsigned int number = 0;
 
@@ -4746,11 +4752,11 @@ _computeDepth(int class, int bpp)
   return number;
 }
 
-- (NSArray *) namesOfDesktops: (int)screen
+- (NSArray *) namesOfDesktops: (NSInteger)screen
 {
   static Atom utf8_string = None;
   static Atom desktop_names = None;
-  int c;
+  NSUInteger c;
   char *names;
 
   if (utf8_string == None)
@@ -4779,10 +4785,10 @@ _computeDepth(int class, int bpp)
   return nil;
 }
 
-- (unsigned int) desktopNumberForScreen: (int)screen
+- (NSUInteger) desktopNumberForScreen: (NSInteger)screen
 {
   static Atom current_desktop = None;
-  int c;
+  NSUInteger c;
   unsigned int *num;
   unsigned int number = 0;
 
@@ -4801,7 +4807,7 @@ _computeDepth(int class, int bpp)
   return number;
 }
 
-- (void) setDesktopNumber: (unsigned int)workspace forScreen: (int)screen
+- (void) setDesktopNumber: (NSUInteger)workspace forScreen: (NSInteger)screen
 {
   static Atom current_desktop = None;
   Window root = RootWindow(dpy, screen);
@@ -4818,11 +4824,11 @@ _computeDepth(int class, int bpp)
         data3: 0];
 }
 
-- (unsigned int) desktopNumberForWindow: (int)win
+- (NSUInteger) desktopNumberForWindow: (NSInteger)win
 {
   gswindow_device_t	*window;
   static Atom wm_desktop = None;
-  int c;
+  NSUInteger c;
   unsigned int *num;
   unsigned int number = 0;
 
@@ -4845,7 +4851,7 @@ _computeDepth(int class, int bpp)
   return number;
 }
 
-- (void) setDesktopNumber: (unsigned int)workspace forWindow: (int)win
+- (void) setDesktopNumber: (NSUInteger)workspace forWindow: (NSInteger)win
 {
   gswindow_device_t	*window;
   static Atom wm_desktop = None;
@@ -4866,7 +4872,7 @@ _computeDepth(int class, int bpp)
         data3: 0];
 }
 
-- (void) setShadow: (BOOL)hasShadow : (int)win
+- (void) setShadow: (BOOL)hasShadow : (NSInteger)win
 {
   gswindow_device_t	*window;
   static Atom wm_window_shadow = None;
@@ -4904,11 +4910,11 @@ _computeDepth(int class, int bpp)
     }
 }
 
-- (BOOL) hasShadow: (int)win
+- (BOOL) hasShadow: (NSInteger)win
 {
   gswindow_device_t	*window;
   static Atom wm_window_shadow = None;
-  int c;
+  NSUInteger c;
   unsigned int *num;
   BOOL hasShadow = NO;
 
@@ -4936,7 +4942,7 @@ _computeDepth(int class, int bpp)
  * Check whether the window is miniaturized according to the ICCCM window
  * state property.
  */
-- (int) _wm_state: (Window)win
+- (NSInteger) _wm_state: (Window)win
 {
   long *data;
   long state;
@@ -4963,8 +4969,8 @@ _computeDepth(int class, int bpp)
 - (BOOL) _ewmh_isHidden: (Window)win
 {
   Atom *data;
-  int count;
-  int i;
+  NSUInteger count;
+  NSUInteger i;
 
   data = (Atom *)PropGetCheckProperty(dpy, win, 
                                       generic.netstates.net_wm_state_atom, 
@@ -4987,8 +4993,8 @@ _computeDepth(int class, int bpp)
   return NO;
 }
 
-- (void) setParentWindow: (int)parentWin 
-          forChildWindow: (int)childWin
+- (void) setParentWindow: (NSInteger)parentWin 
+          forChildWindow: (NSInteger)childWin
 {
   gswindow_device_t	*cwindow;
   gswindow_device_t	*pwindow;
diff --git a/Source/x11/context.c b/Source/x11/context.c
index e9f68ce..1bfa133 100644
--- a/Source/x11/context.c
+++ b/Source/x11/context.c
@@ -49,7 +49,7 @@
 extern void _wraster_change_filter(int type);
 
 
-static Bool bestContext(Display *dpy, int screen_number, RContext *context);
+static Bool bestContext(Display *dpy, RInteger screen_number, RContext *context);
 
 static RContextAttributes DEFAULT_CONTEXT_ATTRIBS = {
     RC_UseSharedMemory|RC_RenderMode|RC_ColorsPerChannel, /* flags */
@@ -107,7 +107,7 @@ RSupportedFileFormats(void)
 static Bool
 allocateStandardPseudoColor(RContext *ctx, XStandardColormap *stdcmap)
 {
-    int i;
+    RUInteger i;
 
     ctx->ncolors = stdcmap->red_max * stdcmap->red_mult
 	+ stdcmap->green_max * stdcmap->green_mult
@@ -160,7 +160,7 @@ allocateStandardPseudoColor(RContext *ctx, XStandardColormap *stdcmap)
 static Bool
 setupStandardColormap(RContext *ctx, Atom property)
 {
-    if (!XmuLookupStandardColormap(ctx->dpy, ctx->screen_number,
+    if (!XmuLookupStandardColormap(ctx->dpy, (int)ctx->screen_number,
 				   ctx->visual->visualid,
 				   ctx->depth, property,
 				   True, True)) {
@@ -185,9 +185,9 @@ allocatePseudoColor(RContext *ctx)
     XColor *colors;
     XColor avcolors[256];
     int avncolors;
-    int i, ncolors, r, g, b;
+    RInteger i, ncolors, r, g, b;
     int retries;
-    int cpc = ctx->attribs->colors_per_channel;
+    RInteger cpc = ctx->attribs->colors_per_channel;
     
     ncolors = cpc * cpc * cpc;
     
@@ -326,9 +326,9 @@ allocateGrayScale(RContext *ctx)
     XColor *colors;
     XColor avcolors[256];
     int avncolors;
-    int i, ncolors, r, g, b;
+    RInteger i, ncolors, r, g, b;
     int retries;
-    int cpc = ctx->attribs->colors_per_channel;
+    RInteger cpc = ctx->attribs->colors_per_channel;
 
     ncolors = cpc * cpc * cpc;
     
@@ -509,12 +509,12 @@ setupPseudoColorColormap(RContext *context)
 
 
 static char*
-mygetenv(char *var, int scr)
+mygetenv(char *var, RInteger scr)
 {
     char *p;
     char varname[64];
 
-    sprintf(varname, "%s%i", var, scr);
+    sprintf(varname, "%s%ld", var, (long)scr);
     p = getenv(varname);
     if (!p) {
 	p = getenv(var);
@@ -524,7 +524,7 @@ mygetenv(char *var, int scr)
 
 
 static void 
-gatherconfig(RContext *context, int screen_n)
+gatherconfig(RContext *context, RInteger screen_n)
 {
     char *ptr;
 
@@ -564,7 +564,7 @@ gatherconfig(RContext *context, int screen_n)
 
 
 static void
-getColormap(RContext *context, int screen_number)
+getColormap(RContext *context, RInteger screen_number)
 {
     Colormap cmap = None;
     XStandardColormap *cmaps;
@@ -616,7 +616,7 @@ count_offset(unsigned long mask)
 
 
 RContext*
-RCreateContext(Display *dpy, int screen_number, RContextAttributes *attribs)
+RCreateContext(Display *dpy, RInteger screen_number, RContextAttributes *attribs)
 {
     RContext *context;
     XGCValues gcv;
@@ -662,7 +662,7 @@ RCreateContext(Display *dpy, int screen_number, RContextAttributes *attribs)
 	XVisualInfo *vinfo, templ;
 	int nret;
 	    
-	templ.screen = screen_number;
+	templ.screen = (int)screen_number;
 	templ.visualid = context->attribs->visualid;
 	vinfo = XGetVisualInfo(context->dpy, VisualIDMask|VisualScreenMask,
 			       &templ, &nret);
@@ -816,7 +816,7 @@ RCreateContext(Display *dpy, int screen_number, RContextAttributes *attribs)
 
 
 static Bool
-bestContext(Display *dpy, int screen_number, RContext *context)
+bestContext(Display *dpy, RInteger screen_number, RContext *context)
 {
     XVisualInfo *vinfo=NULL, rvinfo;
     int best = -1, numvis, i;
@@ -824,7 +824,7 @@ bestContext(Display *dpy, int screen_number, RContext *context)
     XSetWindowAttributes attr;
     
     rvinfo.class  = TrueColor;
-    rvinfo.screen = screen_number;
+    rvinfo.screen = (int)screen_number;
 
     #ifdef XRENDER
 
diff --git a/Source/x11/convert.c b/Source/x11/convert.c
index 8a7d83f..67a6238 100644
--- a/Source/x11/convert.c
+++ b/Source/x11/convert.c
@@ -60,10 +60,10 @@ typedef struct RConversionTable {
 
 
 typedef struct RStdConversionTable {
-    unsigned int table[256];
+    unsigned long table[256];
 
-    unsigned short mult;
-    unsigned short max;
+    unsigned long mult;
+    unsigned long max;
 
     struct RStdConversionTable *next;
 } RStdConversionTable;
@@ -103,11 +103,11 @@ computeTable(unsigned short mask)
 }
 
 
-static unsigned int*
-computeStdTable(unsigned int mult, unsigned int max)
+static unsigned long*
+computeStdTable(unsigned long mult, unsigned long max)
 {
     RStdConversionTable *tmp = stdConversionTable;
-    unsigned int i;
+    unsigned long i;
 
     while (tmp) {
         if (tmp->mult == mult && tmp->max == max)
@@ -386,7 +386,7 @@ convertPseudoColor_to_8(RXImage *ximg, RImage *image,
 			   const unsigned short *btable,
 			   const int dr, const int dg, const int db,
 			   unsigned long *pixels,
-			   int cpc)
+			   RInteger cpc)
 {
     signed char *terr;
     int x, y, r, g, b;
@@ -395,7 +395,7 @@ convertPseudoColor_to_8(RXImage *ximg, RImage *image,
     unsigned char *ptr = image->data;
     unsigned char *optr = (unsigned char *)ximg->image->data;
     int channels = (image->format == RRGBAFormat ? 4 : 3);
-    int cpcpc = cpc*cpc;
+    RInteger cpcpc = cpc*cpc;
 
     /* convert and dither the image to XImage */
     for (y=0; y<image->height; y++) {
@@ -463,12 +463,12 @@ image2PseudoColor(RContext *ctx, RImage *image)
     register int x, y, r, g, b;
     unsigned char *ptr;
     unsigned long pixel;
-    const int cpc=ctx->attribs->colors_per_channel;
+    const RInteger cpc=ctx->attribs->colors_per_channel;
     const unsigned short rmask = cpc-1; /* different sizes could be used */
     const unsigned short gmask = rmask; /* for r,g,b */
     const unsigned short bmask = rmask;
     unsigned short *rtable, *gtable, *btable;
-    const int cpccpc = cpc*cpc;
+    const RInteger cpccpc = cpc*cpc;
     int channels = (image->format == RRGBAFormat ? 4 : 3);
 
     ximg = RCreateXImage(ctx, ctx->depth, image->width, image->height);
@@ -548,12 +548,13 @@ static RXImage*
 image2StandardPseudoColor(RContext *ctx, RImage *image)
 {
     RXImage *ximg;
-    register int x, y, r, g, b;
+    register int x, y;
+    register long r, g, b;
     unsigned char *ptr;
     unsigned long pixel;
     unsigned char *data;
-    unsigned int *rtable, *gtable, *btable;
-    unsigned int base_pixel = ctx->std_rgb_map->base_pixel;
+    unsigned long *rtable, *gtable, *btable;
+    unsigned long base_pixel = ctx->std_rgb_map->base_pixel;
     int channels = (image->format == RRGBAFormat ? 4 : 3);
 
 
@@ -698,7 +699,7 @@ image2GrayScale(RContext *ctx, RImage *image)
     RXImage *ximg;
     register int x, y, g;
     unsigned char *ptr;
-    const int cpc=ctx->attribs->colors_per_channel;
+    const RInteger cpc=ctx->attribs->colors_per_channel;
     unsigned short gmask;
     unsigned short *table;
     unsigned char *data;
@@ -1079,7 +1080,7 @@ RGetClosestXColor(RContext *context, RColor *color, XColor *retColor)
 	       || context->vclass == StaticColor) {
 
 	if (context->attribs->standard_colormap_mode != RIgnoreStdColormap) {
-	    unsigned int *rtable, *gtable, *btable;
+	    unsigned long *rtable, *gtable, *btable;
 
 	    rtable = computeStdTable(context->std_rgb_map->red_mult,
 				     context->std_rgb_map->red_max);
@@ -1105,13 +1106,13 @@ RGetClosestXColor(RContext *context, RColor *color, XColor *retColor)
 	    retColor->flags = DoRed|DoGreen|DoBlue;
 	    
 	} else {
-	    const int cpc=context->attribs->colors_per_channel;
+	    const RInteger cpc=context->attribs->colors_per_channel;
 	    const unsigned short rmask = cpc-1; /* different sizes could be used */
 	    const unsigned short gmask = rmask; /* for r,g,b */
 	    const unsigned short bmask = rmask;
 	    unsigned short *rtable, *gtable, *btable;
-	    const int cpccpc = cpc*cpc;
-	    int index;
+	    const RInteger cpccpc = cpc*cpc;
+	    RInteger index;
 
 	    rtable = computeTable(rmask);
 	    gtable = computeTable(gmask);
@@ -1128,7 +1129,7 @@ RGetClosestXColor(RContext *context, RColor *color, XColor *retColor)
 
     } else if (context->vclass == GrayScale || context->vclass == StaticGray) {
 
-	const int cpc = context->attribs->colors_per_channel;
+	const RInteger cpc = context->attribs->colors_per_channel;
 	unsigned short gmask;
 	unsigned short *table;
 	int index;
diff --git a/Source/x11/raster.c b/Source/x11/raster.c
index f53f281..42be5b6 100644
--- a/Source/x11/raster.c
+++ b/Source/x11/raster.c
@@ -297,7 +297,7 @@ RCombineImagesWithOpaqueness(RImage *image, RImage *src, int opaqueness)
 #undef COP
 }
 
-int
+static int
 calculateCombineArea(RImage *des, RImage *src, int *sx, int *sy,
                      unsigned *swidth, unsigned *sheight, int *dx, int *dy)
 {
diff --git a/Source/x11/scale.c b/Source/x11/scale.c
index d7a7f77..fa3e6fb 100644
--- a/Source/x11/scale.c
+++ b/Source/x11/scale.c
@@ -359,6 +359,8 @@ double t;
 static double (*filterf)() = Mitchell_filter;
 static double fwidth = Mitchell_support;
 
+extern void
+_wraster_change_filter(int type);
 void
 _wraster_change_filter(int type)
 {
diff --git a/Source/x11/xdnd.c b/Source/x11/xdnd.c
index 94abd51..e44b22f 100644
--- a/Source/x11/xdnd.c
+++ b/Source/x11/xdnd.c
@@ -40,18 +40,12 @@
 #ifdef DND_DEBUG
 #define dnd_debug(a,b...) printf("%s: %d: " a "\n", __FILE__, __LINE__ , ## b)
 #else
-
-#ifdef NeXT_RUNTIME
-#define dnd_debug //
-#else  /* !NeXT_RUNTIME */
 #define dnd_debug(a,b...)
-#endif /* NeXT_RUNTIME */
-
 #endif
 
 
 
-void
+static void
 xdnd_reset(DndClass * dnd)
 {
   dnd->stage = XDND_DROP_STAGE_IDLE;
@@ -122,7 +116,7 @@ xdnd_set_dnd_aware (DndClass * dnd, Window window, Atom * typelist)
 }
 
 int
-xdnd_is_dnd_aware(DndClass *dnd, Window window, int *version, Atom *typelist)
+xdnd_is_dnd_aware(DndClass *dnd, Window window, Atom *version, Atom *typelist)
 {
   Atom actual;
   int format;
@@ -329,7 +323,7 @@ xdnd_set_selection_owner(DndClass * dnd, Window window, Atom type)
 
 void
 xdnd_selection_send(DndClass * dnd, XSelectionRequestEvent * request, 
-  unsigned char *data, int length)
+                    unsigned char *data, long length)
 {
   XEvent xevent;
 
@@ -338,7 +332,7 @@ xdnd_selection_send(DndClass * dnd, XSelectionRequestEvent * request,
   dnd_debug (" length = %d", length);
 
   XChangeProperty (dnd->display, request->requestor, request->property,
-    request->target, 8, PropModeReplace, data, length);
+    request->target, 8, PropModeReplace, data, (int)length);
 
   xevent.xselection.type = SelectionNotify;
   xevent.xselection.property = request->property;
diff --git a/Source/x11/xutil.c b/Source/x11/xutil.c
index 0bee2ca..f0f624b 100644
--- a/Source/x11/xutil.c
+++ b/Source/x11/xutil.c
@@ -267,6 +267,8 @@ RPutXImage(RContext *context, Drawable d, GC gc, RXImage *ximage, int src_x,
 
 
 #ifdef XSHM
+extern Pixmap
+R_CreateXImageMappedPixmap(RContext *context, RXImage *rximage);
 Pixmap
 R_CreateXImageMappedPixmap(RContext *context, RXImage *rximage)
 {
diff --git a/Source/xlib/GSXftFontInfo.m b/Source/xlib/GSXftFontInfo.m
index 3dbad7c..5ea4521 100644
--- a/Source/xlib/GSXftFontInfo.m
+++ b/Source/xlib/GSXftFontInfo.m
@@ -341,9 +341,9 @@ Ones(unsigned int n)
                ucs4 != FC_CHARSET_DONE;
                ucs4 = FcCharSetNextPage(charset, map, &next))
             {
-              unsigned int i;
+              NSUInteger i;
               NSRange aRange;
-              unsigned int max;
+              NSUInteger max;
 
               aRange = NSMakeRange(ucs4, FC_CHARSET_MAP_SIZE * sizeof(FcChar32));
               max = NSMaxRange(aRange);
@@ -378,20 +378,20 @@ Ones(unsigned int n)
 - (CGFloat) widthOfString: (NSString*)string
 {
   XGlyphInfo extents;
-  int len = [string length];
+  NSUInteger len = [string length];
   XftChar16 str[len]; 
 
   [string getCharacters: (unichar*)str];
   XftTextExtents16 ([XGServer currentXDisplay],
 		    font_info,
 		    str, 
-		    len,
+		    (int)len,
 		    &extents);
 
   return extents.width;
 }
 
-- (CGFloat) widthOfGlyphs: (const NSGlyph *) glyphs length: (int) len
+- (CGFloat) widthOfGlyphs: (const NSGlyph *) glyphs length: (NSUInteger) len
 {
   XGlyphInfo extents;
   XftChar16 buf[len];
@@ -405,7 +405,7 @@ Ones(unsigned int n)
   XftTextExtents16 ([XGServer currentXDisplay],
 		    font_info,
 		    buf,
-		    len,
+		    (int)len,
 		    &extents);
 
   return extents.width;
@@ -492,7 +492,7 @@ Ones(unsigned int n)
 {
   NSData *d = [string dataUsingEncoding: mostCompatibleStringEncoding
 		      allowLossyConversion: YES];
-  int length = [d length];
+  NSUInteger length = [d length];
   const char *cstr = (const char*)[d bytes];
   XGGState *state = (XGGState *)[(XGContext *)GSCurrentContext() currentGState];
   XftDraw *xftdraw = [state xftDrawForDrawable: draw];
@@ -500,10 +500,10 @@ Ones(unsigned int n)
 
   /* do it */
   XftDrawString16(xftdraw, &xftcolor, font_info, 
-		  xp.x, xp.y, (XftChar16*)cstr, length);
+		  xp.x, xp.y, (XftChar16*)cstr, (int)length);
 }
 
-- (void) drawGlyphs: (const NSGlyph *) glyphs length: (int) len
+- (void) drawGlyphs: (const NSGlyph *) glyphs length: (NSUInteger) len
 	  onDisplay: (Display*) xdpy drawable: (Drawable) draw
 	       with: (GC) xgcntxt at: (XPoint) xp
 {
@@ -520,14 +520,14 @@ Ones(unsigned int n)
 
   /* do it */
   XftDrawString16(xftdraw, &xftcolor, font_info, 
-		  xp.x, xp.y, (XftChar16*)buf, len);
+		  xp.x, xp.y, (XftChar16*)buf, (int)len);
 }
 
 - (void) draw: (const char*) s length: (int) len 
     onDisplay: (Display*) xdpy drawable: (Drawable) draw
 	 with: (GC) xgcntxt at: (XPoint) xp
 {
-  int length = strlen(s);
+  NSUInteger length = strlen(s);
   XGGState *state = (XGGState *)[(XGContext *)GSCurrentContext() currentGState];
   XftDraw *xftdraw = [state xftDrawForDrawable: draw];
   XftColor xftcolor = [state xftColor];
@@ -537,13 +537,13 @@ Ones(unsigned int n)
   if (NSUTF8StringEncoding == mostCompatibleStringEncoding)
     {
       XftDrawStringUtf8(xftdraw, &xftcolor, font_info,
-                        xp.x, xp.y, (XftChar8 *)s, length);
+                        xp.x, xp.y, (XftChar8 *)s, (int)length);
     }
   else
 #endif
     {
       XftDrawString8(xftdraw, &xftcolor, font_info, 
-                   xp.x, xp.y, (XftChar8*)s, length);
+                   xp.x, xp.y, (XftChar8*)s, (int)length);
     }
 }
 
@@ -654,16 +654,16 @@ static int bezierpath_cubic_to(const FT_Vector *c1, const FT_Vector *c2,
 }
 
 static FT_Outline_Funcs bezierpath_funcs = {
-  move_to: bezierpath_move_to,
-  line_to: bezierpath_line_to,
-  conic_to: bezierpath_conic_to,
-  cubic_to: bezierpath_cubic_to,
-  shift: 10,
-//  delta: 0,
+  .move_to = bezierpath_move_to,
+  .line_to = bezierpath_line_to,
+  .conic_to = bezierpath_conic_to,
+  .cubic_to = bezierpath_cubic_to,
+  .shift = 10,
+//  .delta = 0,
 };
 
 - (void) appendBezierPathWithGlyphs: (NSGlyph *)glyphs
-                              count: (int)count
+                              count: (NSInteger)count
                        toBezierPath: (NSBezierPath *)path
 {
   int i;
diff --git a/Source/xlib/XGBitmap.m b/Source/xlib/XGBitmap.m
index 3914a02..988c654 100644
--- a/Source/xlib/XGBitmap.m
+++ b/Source/xlib/XGBitmap.m
@@ -98,7 +98,7 @@
 #define CSIZE 16384
 #define GS_QUERY_COLOR(color)					\
   do {								\
-    int centry = color.pixel % CSIZE;				\
+    unsigned long centry = color.pixel % CSIZE;                 \
     if (empty[centry] == NO && pixels[centry] == color.pixel)	\
       {								\
 	color = colors[centry];					\
@@ -399,8 +399,8 @@ struct _bitmap_decompose {
 static int
 _get_bit_value(unsigned char *base, long msb_off, int bit_width)
 {
-  long lsb_off, byte1, byte2;
-  int shift, value;
+  long lsb_off, byte1, byte2, shift;
+  int value;
 
   /*
    * Firstly we calculate the position of the msb and lsb in terms
@@ -699,10 +699,10 @@ _set_ranges(long src_len, long dst_len,
 int
 _bitmap_combine_alpha(RContext *context,
 		unsigned char * data_planes[5],
-		int width, int height,
-		int bits_per_sample, int samples_per_pixel,
-		int bits_per_pixel, int bytes_per_row,
-		int colour_space, BOOL one_is_black,
+		NSInteger width, NSInteger height,
+		NSInteger bits_per_sample, NSInteger samples_per_pixel,
+		NSInteger bits_per_pixel, NSInteger bytes_per_row,
+		NSInteger colour_space, BOOL one_is_black,
 		BOOL is_planar, BOOL has_alpha, BOOL fast_min,
 		RXImage *dest_im, RXImage *dest_alpha,
 		XRectangle srect, XRectangle drect,
@@ -717,7 +717,7 @@ _bitmap_combine_alpha(RContext *context,
 
   /* Sanity check on colourspace and number of colours */
   {
-    int num_of_colours = samples_per_pixel - (has_alpha ? 1 : 0);
+    NSInteger num_of_colours = samples_per_pixel - (has_alpha ? 1 : 0);
     switch(colour_space)
       {
         case hsb_colorspace:
@@ -726,7 +726,7 @@ _bitmap_combine_alpha(RContext *context,
         case rgb_colorspace:
           if (num_of_colours != 3)
             {
-              NSLog(@"Bad number of colour planes - %d", num_of_colours);
+              NSLog(@"Bad number of colour planes - %ld", (long)num_of_colours);
               NSLog(@"RGB colourspace requires three planes excluding alpha");
               return -1;
             }
@@ -734,7 +734,7 @@ _bitmap_combine_alpha(RContext *context,
         case cmyk_colorspace:
           if (num_of_colours != 4)
             {
-              NSLog(@"Bad number of colour planes - %d", num_of_colours);
+              NSLog(@"Bad number of colour planes - %ld", (long)num_of_colours);
               NSLog(@"CMYK colourspace requires four planes excluding alpha");
               return -1;
             }
@@ -742,7 +742,7 @@ _bitmap_combine_alpha(RContext *context,
         case gray_colorspace:
           if (num_of_colours != 1)
             {
-              NSLog(@"Bad number of colour planes - %d", num_of_colours);
+              NSLog(@"Bad number of colour planes - %ld", (long)num_of_colours);
               NSLog(@"Gray colourspace requires one plane excluding alpha");
               return -1;
             }
@@ -754,17 +754,18 @@ _bitmap_combine_alpha(RContext *context,
   }
 
   /* bitmap decomposition structure */
-  img.bps = bits_per_sample;
-  img.bpp = bits_per_pixel;
-  img.spp = samples_per_pixel;
-  img.bpr = bytes_per_row;
+  /* WARNING: NSIntegers are truncated to ints */
+  img.bps = (int)bits_per_sample;
+  img.bpp = (int)bits_per_pixel;
+  img.spp = (int)samples_per_pixel;
+  img.bpr = (int)bytes_per_row;
   img.image_w = width;
   img.image_h = height;
   img.screen_w = srect.width;
   img.screen_h = srect.height;
   img.has_alpha = has_alpha;
   img.one_is_black = one_is_black;
-  img.cspace = colour_space;
+  img.cspace = (int)colour_space;
   img.cur_image_row = 0;
   img.cur_screen_row = 0;
 
@@ -803,7 +804,7 @@ _bitmap_combine_alpha(RContext *context,
           img.pro_mul = 255;
           break;
         default:
-          NSLog(@"Bizzare number of bits per sample %d", bits_per_sample);
+          NSLog(@"Bizzare number of bits per sample %ld", bits_per_sample);
           return -1;
      }
 
diff --git a/Source/xlib/XGContext.m b/Source/xlib/XGContext.m
index 7436f90..aea6ac6 100644
--- a/Source/xlib/XGContext.m
+++ b/Source/xlib/XGContext.m
@@ -147,7 +147,7 @@
 - (BOOL) isCompatibleBitmap: (NSBitmapImageRep*)bitmap
 {
   NSString *colorSpaceName;
-  int numColors;
+  NSInteger numColors;
 
   if ([bitmap bitmapFormat] != 0)
     {
diff --git a/Source/xlib/XGFont.m b/Source/xlib/XGFont.m
index 6af8da3..48280a0 100644
--- a/Source/xlib/XGFont.m
+++ b/Source/xlib/XGFont.m
@@ -193,7 +193,7 @@ static BOOL XGInitAtoms(Display *dpy)
   XGCValues gcv;
   NSData *d = [string dataUsingEncoding: mostCompatibleStringEncoding
 		      allowLossyConversion: YES];
-  int length = [d length];
+  NSUInteger length = [d length];
   const char *cstr = (const char*)[d bytes];
 
   // Select this font, although it might already be current.
@@ -201,18 +201,18 @@ static BOOL XGInitAtoms(Display *dpy)
   XChangeGC(xdpy, xgcntxt, GCFont, &gcv);
 
   // FIXME: Use XDrawString16 for NSTwoByteGlyphPacking
-  XDrawString(xdpy, draw, xgcntxt, xp.x, xp.y, cstr, length);
+  XDrawString(xdpy, draw, xgcntxt, xp.x, xp.y, cstr, (int)length);
 }
 
-- (void) draw: (const char*) s length: (int) len 
+- (void) draw: (const char*) s length: (NSUInteger) len 
     onDisplay: (Display*) xdpy drawable: (Drawable) draw
 	 with: (GC) xgcntxt at: (XPoint) xp
 {
   // This font must already be active!
-  XDrawString(xdpy, draw, xgcntxt, xp.x, xp.y, s, len);
+  XDrawString(xdpy, draw, xgcntxt, xp.x, xp.y, s, (int)len);
 }
 
-- (void) drawGlyphs: (const NSGlyph *) glyphs length: (int) len
+- (void) drawGlyphs: (const NSGlyph *) glyphs length: (NSUInteger) len
 	  onDisplay: (Display*) xdpy drawable: (Drawable) draw
 	       with: (GC) xgcntxt at: (XPoint) xp
 {
@@ -225,26 +225,26 @@ static BOOL XGInitAtoms(Display *dpy)
       buf[i] = glyphs[i];
     }
 
-  XDrawString(xdpy, draw, xgcntxt, xp.x, xp.y, buf, len);
+  XDrawString(xdpy, draw, xgcntxt, xp.x, xp.y, buf, (int)len);
 }
 
 - (CGFloat) widthOfString: (NSString*)string
 {
   NSData *d = [string dataUsingEncoding: mostCompatibleStringEncoding
 		      allowLossyConversion: YES];
-  int length = [d length];
+  NSUInteger length = [d length];
   const char *cstr = (const char*)[d bytes];
 
   // FIXME: Use XTextWidth16 for NSTwoByteGlyphPacking
-  return XTextWidth(font_info, cstr, length);
+  return XTextWidth(font_info, cstr, (int)length);
 }
 
-- (CGFloat) widthOf: (const char*) s length: (int) len
+- (CGFloat) widthOf: (const char*) s length: (NSUInteger) len
 {
-  return XTextWidth(font_info, s, len);
+  return XTextWidth(font_info, s, (int)len);
 }
 
-- (CGFloat) widthOfGlyphs: (const NSGlyph *) glyphs length: (int) len
+- (CGFloat) widthOfGlyphs: (const NSGlyph *) glyphs length: (NSUInteger) len
 {
   char buf[len];
   int i;
@@ -254,7 +254,7 @@ static BOOL XGInitAtoms(Display *dpy)
       buf[i] = glyphs[i];
     }
 
-  return XTextWidth(font_info, buf, len);
+  return XTextWidth(font_info, buf, (int)len);
 }
 
 - (void) setActiveFor: (Display*) xdpy gc: (GC) xgcntxt
@@ -377,7 +377,7 @@ static BOOL XGInitAtoms(Display *dpy)
 	&& (mostCompatibleStringEncoding != NSUnicodeStringEncoding))
         {
 	  // FIXME: This only works for 8-Bit characters
-	  unsigned int  size = 1;
+	  NSUInteger  size = 1;
 	  unsigned char c = 0;
 	  unsigned char *dst = &c;
 	  unichar ch = glyph;
diff --git a/Source/xlib/XGFontManager.m b/Source/xlib/XGFontManager.m
index d571d08..d6b1d3f 100644
--- a/Source/xlib/XGFontManager.m
+++ b/Source/xlib/XGFontManager.m
@@ -52,7 +52,7 @@
 static NSMutableDictionary* creationDictionary;
 
 // Fills in the size into an creation string to make it an X font name
-NSString *XGXFontName(NSString *fontName, float size)
+NSString *XGXFontName(NSString *fontName, CGFloat size)
 {
   NSString *creationName = [creationDictionary objectForKey: fontName];
 
diff --git a/Source/xlib/XGGState.m b/Source/xlib/XGGState.m
index 33d7159..3f6eb76 100644
--- a/Source/xlib/XGGState.m
+++ b/Source/xlib/XGGState.m
@@ -56,7 +56,7 @@ static BOOL shouldDrawAlpha = YES;
     [self copyGraphicContext]
 
 
-u_long   
+static u_long
 xrRGBToPixel(RContext* context, device_color_t color)
 {
   XColor cc;
@@ -1061,7 +1061,7 @@ static Region emptyRegion;
 
 - (void) _paintPath: (ctxt_object_t) drawType
 {
-  unsigned count;
+  NSUInteger count;
   NSBezierPath *flatPath;
   XPoint ll, ur;
   
@@ -1251,8 +1251,8 @@ static Region emptyRegion;
 
 - (void)DPSshow: (const char *)s 
 {
-  int len;
-  int width;
+  NSUInteger len;
+  NSInteger width;
   NSSize scale;
   XPoint xp;
 
@@ -1299,7 +1299,7 @@ static Region emptyRegion;
 }
 
 
-- (void) GSShowGlyphsWithAdvances: (const NSGlyph *)glyphs : (const NSSize *)advances : (size_t) length
+- (void) GSShowGlyphsWithAdvances: (const NSGlyph *)glyphs : (const NSSize *)advances : (NSUInteger) length
 {
   // FIXME: Currently advances is ignored
   int width;
@@ -1412,7 +1412,7 @@ static Region emptyRegion;
   // We can only set the dash pattern, if xgcntxt exists.
   if (xgcntxt == 0)
     return;
-  XSetDashes(XDPY, xgcntxt, dash_offset, dash_list, size);
+  XSetDashes(XDPY, xgcntxt, dash_offset, dash_list, (int)size);
 }
 
 - (void)DPSsetlinecap: (int)linecap 
diff --git a/Source/xlib/linking.m b/Source/xlib/linking.m
index d425f24..957168f 100644
--- a/Source/xlib/linking.m
+++ b/Source/xlib/linking.m
@@ -31,6 +31,7 @@ extern void __objc_xgcontextwindow_linking (void);
 extern void __objc_xgcontextevent_linking (void);
 
 
+void __objc_xgps_linking(void);
 void __objc_xgps_linking(void)
 {
   //__objc_xgps_gsbackend_linking();
diff --git a/Support/Backend/Backend-Info.plist b/Support/Backend/Backend-Info.plist
new file mode 100644
index 0000000..1729d43
--- /dev/null
+++ b/Support/Backend/Backend-Info.plist
@@ -0,0 +1,30 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
+<plist version="1.0">
+<dict>
+	<key>CFBundleDevelopmentRegion</key>
+	<string>English</string>
+	<key>CFBundleExecutable</key>
+	<string>${EXECUTABLE_NAME}</string>
+	<key>CFBundleIconFile</key>
+	<string></string>
+	<key>CFBundleIdentifier</key>
+	<string>org.gnustep.${PRODUCT_NAME:rfc1034identifier}</string>
+	<key>CFBundleInfoDictionaryVersion</key>
+	<string>6.0</string>
+	<key>CFBundleName</key>
+	<string>${PRODUCT_NAME}</string>
+	<key>CFBundlePackageType</key>
+	<string>BNDL</string>
+	<key>CFBundleShortVersionString</key>
+	<string>1.0</string>
+	<key>CFBundleSignature</key>
+	<string>????</string>
+	<key>CFBundleVersion</key>
+	<string>1</string>
+	<key>NSHumanReadableCopyright</key>
+	<string>Copyright © 2013 __MyCompanyName__. All rights reserved.</string>
+	<key>NSPrincipalClass</key>
+	<string></string>
+</dict>
+</plist>
diff --git a/Support/Backend/Backend-Prefix.pch b/Support/Backend/Backend-Prefix.pch
new file mode 100644
index 0000000..dfcfb39
--- /dev/null
+++ b/Support/Backend/Backend-Prefix.pch
@@ -0,0 +1,7 @@
+//
+// Prefix header for all source files of the 'Backend' target in the 'Backend' project
+//
+
+#ifdef __OBJC__
+    #import <Cocoa/Cocoa.h>
+#endif
diff --git a/configure b/configure
index 228ae70..ae2df91 100755
--- a/configure
+++ b/configure
@@ -1,11 +1,9 @@
 #! /bin/sh
 # Guess values for system-dependent variables and create Makefiles.
-# Generated by GNU Autoconf 2.68.
+# Generated by GNU Autoconf 2.69.
 #
 #
-# Copyright (C) 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
-# 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010 Free Software
-# Foundation, Inc.
+# Copyright (C) 1992-1996, 1998-2012 Free Software Foundation, Inc.
 #
 #
 # This configure script is free software; the Free Software Foundation
@@ -134,6 +132,31 @@ export LANGUAGE
 # CDPATH.
 (unset CDPATH) >/dev/null 2>&1 && unset CDPATH
 
+# Use a proper internal environment variable to ensure we don't fall
+  # into an infinite loop, continuously re-executing ourselves.
+  if test x"${_as_can_reexec}" != xno && test "x$CONFIG_SHELL" != x; then
+    _as_can_reexec=no; export _as_can_reexec;
+    # We cannot yet assume a decent shell, so we have to provide a
+# neutralization value for shells without unset; and this also
+# works around shells that cannot unset nonexistent variables.
+# Preserve -v and -x to the replacement shell.
+BASH_ENV=/dev/null
+ENV=/dev/null
+(unset BASH_ENV) >/dev/null 2>&1 && unset BASH_ENV ENV
+case $- in # ((((
+  *v*x* | *x*v* ) as_opts=-vx ;;
+  *v* ) as_opts=-v ;;
+  *x* ) as_opts=-x ;;
+  * ) as_opts= ;;
+esac
+exec $CONFIG_SHELL $as_opts "$as_myself" ${1+"$@"}
+# Admittedly, this is quite paranoid, since all the known shells bail
+# out after a failed `exec'.
+$as_echo "$0: could not re-execute with $CONFIG_SHELL" >&2
+as_fn_exit 255
+  fi
+  # We don't want this to propagate to other subprocesses.
+          { _as_can_reexec=; unset _as_can_reexec;}
 if test "x$CONFIG_SHELL" = x; then
   as_bourne_compatible="if test -n \"\${ZSH_VERSION+set}\" && (emulate sh) >/dev/null 2>&1; then :
   emulate sh
@@ -167,7 +190,8 @@ if ( set x; as_fn_ret_success y && test x = \"\$1\" ); then :
 else
   exitcode=1; echo positional parameters were not saved.
 fi
-test x\$exitcode = x0 || exit 1"
+test x\$exitcode = x0 || exit 1
+test -x / || exit 1"
   as_suggested="  as_lineno_1=";as_suggested=$as_suggested$LINENO;as_suggested=$as_suggested" as_lineno_1a=\$LINENO
   as_lineno_2=";as_suggested=$as_suggested$LINENO;as_suggested=$as_suggested" as_lineno_2a=\$LINENO
   eval 'test \"x\$as_lineno_1'\$as_run'\" != \"x\$as_lineno_2'\$as_run'\" &&
@@ -212,21 +236,25 @@ IFS=$as_save_IFS
 
 
       if test "x$CONFIG_SHELL" != x; then :
-  # We cannot yet assume a decent shell, so we have to provide a
-	# neutralization value for shells without unset; and this also
-	# works around shells that cannot unset nonexistent variables.
-	# Preserve -v and -x to the replacement shell.
-	BASH_ENV=/dev/null
-	ENV=/dev/null
-	(unset BASH_ENV) >/dev/null 2>&1 && unset BASH_ENV ENV
-	export CONFIG_SHELL
-	case $- in # ((((
-	  *v*x* | *x*v* ) as_opts=-vx ;;
-	  *v* ) as_opts=-v ;;
-	  *x* ) as_opts=-x ;;
-	  * ) as_opts= ;;
-	esac
-	exec "$CONFIG_SHELL" $as_opts "$as_myself" ${1+"$@"}
+  export CONFIG_SHELL
+             # We cannot yet assume a decent shell, so we have to provide a
+# neutralization value for shells without unset; and this also
+# works around shells that cannot unset nonexistent variables.
+# Preserve -v and -x to the replacement shell.
+BASH_ENV=/dev/null
+ENV=/dev/null
+(unset BASH_ENV) >/dev/null 2>&1 && unset BASH_ENV ENV
+case $- in # ((((
+  *v*x* | *x*v* ) as_opts=-vx ;;
+  *v* ) as_opts=-v ;;
+  *x* ) as_opts=-x ;;
+  * ) as_opts= ;;
+esac
+exec $CONFIG_SHELL $as_opts "$as_myself" ${1+"$@"}
+# Admittedly, this is quite paranoid, since all the known shells bail
+# out after a failed `exec'.
+$as_echo "$0: could not re-execute with $CONFIG_SHELL" >&2
+exit 255
 fi
 
     if test x$as_have_required = xno; then :
@@ -328,6 +356,14 @@ $as_echo X"$as_dir" |
 
 
 } # as_fn_mkdir_p
+
+# as_fn_executable_p FILE
+# -----------------------
+# Test if FILE is an executable regular file.
+as_fn_executable_p ()
+{
+  test -f "$1" && test -x "$1"
+} # as_fn_executable_p
 # as_fn_append VAR VALUE
 # ----------------------
 # Append the text in VALUE to the end of the definition contained in VAR. Take
@@ -449,6 +485,10 @@ as_cr_alnum=$as_cr_Letters$as_cr_digits
   chmod +x "$as_me.lineno" ||
     { $as_echo "$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&2; as_fn_exit 1; }
 
+  # If we had to re-execute with $CONFIG_SHELL, we're ensured to have
+  # already done that, so ensure we don't try to do so again and fall
+  # in an infinite loop.  This has already happened in practice.
+  _as_can_reexec=no; export _as_can_reexec
   # Don't try to exec as it changes $[0], causing all sort of problems
   # (the dirname of $[0] is not the place where we might find the
   # original and so on.  Autoconf is especially sensitive to this).
@@ -483,16 +523,16 @@ if (echo >conf$$.file) 2>/dev/null; then
     # ... but there are two gotchas:
     # 1) On MSYS, both `ln -s file dir' and `ln file dir' fail.
     # 2) DJGPP < 2.04 has no symlinks; `ln -s' creates a wrapper executable.
-    # In both cases, we have to default to `cp -p'.
+    # In both cases, we have to default to `cp -pR'.
     ln -s conf$$.file conf$$.dir 2>/dev/null && test ! -f conf$$.exe ||
-      as_ln_s='cp -p'
+      as_ln_s='cp -pR'
   elif ln conf$$.file conf$$ 2>/dev/null; then
     as_ln_s=ln
   else
-    as_ln_s='cp -p'
+    as_ln_s='cp -pR'
   fi
 else
-  as_ln_s='cp -p'
+  as_ln_s='cp -pR'
 fi
 rm -f conf$$ conf$$.exe conf$$.dir/conf$$.file conf$$.file
 rmdir conf$$.dir 2>/dev/null
@@ -504,28 +544,8 @@ else
   as_mkdir_p=false
 fi
 
-if test -x / >/dev/null 2>&1; then
-  as_test_x='test -x'
-else
-  if ls -dL / >/dev/null 2>&1; then
-    as_ls_L_option=L
-  else
-    as_ls_L_option=
-  fi
-  as_test_x='
-    eval sh -c '\''
-      if test -d "$1"; then
-	test -d "$1/.";
-      else
-	case $1 in #(
-	-*)set "./$1";;
-	esac;
-	case `ls -ld'$as_ls_L_option' "$1" 2>/dev/null` in #((
-	???[sx]*):;;*)false;;esac;fi
-    '\'' sh
-  '
-fi
-as_executable_p=$as_test_x
+as_test_x='test -x'
+as_executable_p=as_fn_executable_p
 
 # Sed expression to map a string onto a valid CPP name.
 as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"
@@ -1181,8 +1201,6 @@ target=$target_alias
 if test "x$host_alias" != x; then
   if test "x$build_alias" = x; then
     cross_compiling=maybe
-    $as_echo "$as_me: WARNING: if you wanted to set the --build type, don't use --host.
-    If a cross compiler is detected then cross compile mode will be used" >&2
   elif test "x$build_alias" != "x$host_alias"; then
     cross_compiling=yes
   fi
@@ -1437,9 +1455,9 @@ test -n "$ac_init_help" && exit $ac_status
 if $ac_init_version; then
   cat <<\_ACEOF
 configure
-generated by GNU Autoconf 2.68
+generated by GNU Autoconf 2.69
 
-Copyright (C) 2010 Free Software Foundation, Inc.
+Copyright (C) 2012 Free Software Foundation, Inc.
 This configure script is free software; the Free Software Foundation
 gives unlimited permission to copy, distribute and modify it.
 _ACEOF
@@ -1712,7 +1730,7 @@ $as_echo "$ac_try_echo"; } >&5
 	 test ! -s conftest.err
        } && test -s conftest$ac_exeext && {
 	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
+	 test -x conftest$ac_exeext
        }; then :
   ac_retval=0
 else
@@ -1802,7 +1820,7 @@ This file contains any messages produced by compilers while
 running configure, to aid debugging if configure makes a mistake.
 
 It was created by $as_me, which was
-generated by GNU Autoconf 2.68.  Invocation command line was
+generated by GNU Autoconf 2.69.  Invocation command line was
 
   $ $0 $@
 
@@ -2221,7 +2239,7 @@ do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_prog_CC="${ac_tool_prefix}gcc"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -2261,7 +2279,7 @@ do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_prog_ac_ct_CC="gcc"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -2314,7 +2332,7 @@ do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_prog_CC="${ac_tool_prefix}cc"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -2355,7 +2373,7 @@ do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     if test "$as_dir/$ac_word$ac_exec_ext" = "/usr/ucb/cc"; then
        ac_prog_rejected=yes
        continue
@@ -2413,7 +2431,7 @@ do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_prog_CC="$ac_tool_prefix$ac_prog"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -2457,7 +2475,7 @@ do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_prog_ac_ct_CC="$ac_prog"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -2903,8 +2921,7 @@ cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #include <stdarg.h>
 #include <stdio.h>
-#include <sys/types.h>
-#include <sys/stat.h>
+struct stat;
 /* Most of the following tests are stolen from RCS 5.7's src/conf.sh.  */
 struct buf { int x; };
 FILE * (*rcsopen) (struct buf *, struct stat *, int);
@@ -3308,7 +3325,7 @@ do
     for ac_prog in grep ggrep; do
     for ac_exec_ext in '' $ac_executable_extensions; do
       ac_path_GREP="$as_dir/$ac_prog$ac_exec_ext"
-      { test -f "$ac_path_GREP" && $as_test_x "$ac_path_GREP"; } || continue
+      as_fn_executable_p "$ac_path_GREP" || continue
 # Check for GNU ac_path_GREP and select it if it is found.
   # Check for GNU $ac_path_GREP
 case `"$ac_path_GREP" --version 2>&1` in
@@ -3374,7 +3391,7 @@ do
     for ac_prog in egrep; do
     for ac_exec_ext in '' $ac_executable_extensions; do
       ac_path_EGREP="$as_dir/$ac_prog$ac_exec_ext"
-      { test -f "$ac_path_EGREP" && $as_test_x "$ac_path_EGREP"; } || continue
+      as_fn_executable_p "$ac_path_EGREP" || continue
 # Check for GNU ac_path_EGREP and select it if it is found.
   # Check for GNU $ac_path_EGREP
 case `"$ac_path_EGREP" --version 2>&1` in
@@ -4355,7 +4372,7 @@ do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_path_PKG_CONFIG="$as_dir/$ac_word$ac_exec_ext"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -4496,7 +4513,7 @@ do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_path_PKG_CONFIG="$as_dir/$ac_word$ac_exec_ext"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -4637,7 +4654,7 @@ do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_path_PKG_CONFIG="$as_dir/$ac_word$ac_exec_ext"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -4988,7 +5005,7 @@ do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_path_PKG_CONFIG="$as_dir/$ac_word$ac_exec_ext"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -5815,7 +5832,7 @@ do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_path_PKG_CONFIG="$as_dir/$ac_word$ac_exec_ext"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -5915,7 +5932,7 @@ do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_path_PKG_CONFIG="$as_dir/$ac_word$ac_exec_ext"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -6015,7 +6032,7 @@ do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_path_PKG_CONFIG="$as_dir/$ac_word$ac_exec_ext"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -6115,7 +6132,7 @@ do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_path_PKG_CONFIG="$as_dir/$ac_word$ac_exec_ext"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -6215,7 +6232,7 @@ do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_path_PKG_CONFIG="$as_dir/$ac_word$ac_exec_ext"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -6315,7 +6332,7 @@ do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_path_PKG_CONFIG="$as_dir/$ac_word$ac_exec_ext"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -6646,7 +6663,7 @@ do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_path_PKG_CONFIG="$as_dir/$ac_word$ac_exec_ext"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -6759,7 +6776,7 @@ do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_path_PKG_CONFIG="$as_dir/$ac_word$ac_exec_ext"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -6880,7 +6897,7 @@ do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_path_PKG_CONFIG="$as_dir/$ac_word$ac_exec_ext"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -7007,6 +7024,8 @@ BUILD_GRAPHICS=cairo
 case $target_os in
   *mingw32* ) BUILD_SERVER=win32
               BUILD_GRAPHICS=winlib;;
+# Cairo is linked to Apple's CoreFoundation on OSX, do not build it by default
+  darwin* )   BUILD_GRAPHICS=xlib;;
 esac
 
 # Check whether --enable-server was given.
@@ -7154,7 +7173,8 @@ $as_echo "$as_me: Switching to $BUILD_GRAPHICS" >&6;}
     CPPFLAGS="$LIBART_CFLAGS $FREETYPE_CFLAGS $CPPFLAGS"
   fi
 elif test x"$BUILD_GRAPHICS" = "xxlib"; then
- : # Nothing to do
+  LIBS="$FREETYPE_LIBS $FONTCONFIG_LIBS $LIBS"
+  CPPFLAGS="$FREETYPE_CFLAGS $FONTCONFIG_CFLAGS $CPPFLAGS"
 elif test x"$BUILD_GRAPHICS" = "xwinlib"; then
  : # Nothing to do
 else
@@ -7679,16 +7699,16 @@ if (echo >conf$$.file) 2>/dev/null; then
     # ... but there are two gotchas:
     # 1) On MSYS, both `ln -s file dir' and `ln file dir' fail.
     # 2) DJGPP < 2.04 has no symlinks; `ln -s' creates a wrapper executable.
-    # In both cases, we have to default to `cp -p'.
+    # In both cases, we have to default to `cp -pR'.
     ln -s conf$$.file conf$$.dir 2>/dev/null && test ! -f conf$$.exe ||
-      as_ln_s='cp -p'
+      as_ln_s='cp -pR'
   elif ln conf$$.file conf$$ 2>/dev/null; then
     as_ln_s=ln
   else
-    as_ln_s='cp -p'
+    as_ln_s='cp -pR'
   fi
 else
-  as_ln_s='cp -p'
+  as_ln_s='cp -pR'
 fi
 rm -f conf$$ conf$$.exe conf$$.dir/conf$$.file conf$$.file
 rmdir conf$$.dir 2>/dev/null
@@ -7748,28 +7768,16 @@ else
   as_mkdir_p=false
 fi
 
-if test -x / >/dev/null 2>&1; then
-  as_test_x='test -x'
-else
-  if ls -dL / >/dev/null 2>&1; then
-    as_ls_L_option=L
-  else
-    as_ls_L_option=
-  fi
-  as_test_x='
-    eval sh -c '\''
-      if test -d "$1"; then
-	test -d "$1/.";
-      else
-	case $1 in #(
-	-*)set "./$1";;
-	esac;
-	case `ls -ld'$as_ls_L_option' "$1" 2>/dev/null` in #((
-	???[sx]*):;;*)false;;esac;fi
-    '\'' sh
-  '
-fi
-as_executable_p=$as_test_x
+
+# as_fn_executable_p FILE
+# -----------------------
+# Test if FILE is an executable regular file.
+as_fn_executable_p ()
+{
+  test -f "$1" && test -x "$1"
+} # as_fn_executable_p
+as_test_x='test -x'
+as_executable_p=as_fn_executable_p
 
 # Sed expression to map a string onto a valid CPP name.
 as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"
@@ -7791,7 +7799,7 @@ cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
 # values after options handling.
 ac_log="
 This file was extended by $as_me, which was
-generated by GNU Autoconf 2.68.  Invocation command line was
+generated by GNU Autoconf 2.69.  Invocation command line was
 
   CONFIG_FILES    = $CONFIG_FILES
   CONFIG_HEADERS  = $CONFIG_HEADERS
@@ -7853,10 +7861,10 @@ cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
 ac_cs_config="`$as_echo "$ac_configure_args" | sed 's/^ //; s/[\\""\`\$]/\\\\&/g'`"
 ac_cs_version="\\
 config.status
-configured by $0, generated by GNU Autoconf 2.68,
+configured by $0, generated by GNU Autoconf 2.69,
   with options \\"\$ac_cs_config\\"
 
-Copyright (C) 2010 Free Software Foundation, Inc.
+Copyright (C) 2012 Free Software Foundation, Inc.
 This config.status script is free software; the Free Software Foundation
 gives unlimited permission to copy, distribute and modify it."
 
@@ -7944,7 +7952,7 @@ fi
 _ACEOF
 cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
 if \$ac_cs_recheck; then
-  set X '$SHELL' '$0' $ac_configure_args \$ac_configure_extra_args --no-create --no-recursion
+  set X $SHELL '$0' $ac_configure_args \$ac_configure_extra_args --no-create --no-recursion
   shift
   \$as_echo "running CONFIG_SHELL=$SHELL \$*" >&6
   CONFIG_SHELL='$SHELL'
diff --git a/configure.ac b/configure.ac
index a953cfe..0ec7136 100644
--- a/configure.ac
+++ b/configure.ac
@@ -523,6 +523,8 @@ BUILD_GRAPHICS=cairo
 case $target_os in
   *mingw32* ) BUILD_SERVER=win32
               BUILD_GRAPHICS=winlib;;
+# Cairo is linked to Apple's CoreFoundation on OSX, do not build it by default
+  darwin* )   BUILD_GRAPHICS=xlib;;
 esac
 
 AC_ARG_ENABLE(server, 
@@ -638,7 +640,8 @@ elif test x"$BUILD_GRAPHICS" = "xart"; then
     CPPFLAGS="$LIBART_CFLAGS $FREETYPE_CFLAGS $CPPFLAGS"
   fi
 elif test x"$BUILD_GRAPHICS" = "xxlib"; then
- : # Nothing to do
+  LIBS="$FREETYPE_LIBS $FONTCONFIG_LIBS $LIBS"
+  CPPFLAGS="$FREETYPE_CFLAGS $FONTCONFIG_CFLAGS $CPPFLAGS"
 elif test x"$BUILD_GRAPHICS" = "xwinlib"; then
  : # Nothing to do
 else
